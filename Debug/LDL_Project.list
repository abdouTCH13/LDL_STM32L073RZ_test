
LDL_Project.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000d808  080000c0  080000c0  000100c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000ea0  0800d8c8  0800d8c8  0001d8c8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0800e768  0800e768  00020068  2**0
                  CONTENTS
  4 .ARM          00000008  0800e768  0800e768  0001e768  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0800e770  0800e770  00020068  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0800e770  0800e770  0001e770  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0800e774  0800e774  0001e774  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000068  20000000  0800e778  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000558  20000068  0800e7e0  00020068  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  200005c0  0800e7e0  000205c0  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  00020068  2**0
                  CONTENTS, READONLY
 12 .debug_info   000231c3  00000000  00000000  00020090  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000043e2  00000000  00000000  00043253  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 000016b0  00000000  00000000  00047638  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00001570  00000000  00000000  00048ce8  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  00018d5d  00000000  00000000  0004a258  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   000152cc  00000000  00000000  00062fb5  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    00086102  00000000  00000000  00078281  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .comment      0000007b  00000000  00000000  000fe383  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00005948  00000000  00000000  000fe400  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	20000068 	.word	0x20000068
 80000e0:	00000000 	.word	0x00000000
 80000e4:	0800d8b0 	.word	0x0800d8b0

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	2000006c 	.word	0x2000006c
 8000104:	0800d8b0 	.word	0x0800d8b0

08000108 <__udivsi3>:
 8000108:	2200      	movs	r2, #0
 800010a:	0843      	lsrs	r3, r0, #1
 800010c:	428b      	cmp	r3, r1
 800010e:	d374      	bcc.n	80001fa <__udivsi3+0xf2>
 8000110:	0903      	lsrs	r3, r0, #4
 8000112:	428b      	cmp	r3, r1
 8000114:	d35f      	bcc.n	80001d6 <__udivsi3+0xce>
 8000116:	0a03      	lsrs	r3, r0, #8
 8000118:	428b      	cmp	r3, r1
 800011a:	d344      	bcc.n	80001a6 <__udivsi3+0x9e>
 800011c:	0b03      	lsrs	r3, r0, #12
 800011e:	428b      	cmp	r3, r1
 8000120:	d328      	bcc.n	8000174 <__udivsi3+0x6c>
 8000122:	0c03      	lsrs	r3, r0, #16
 8000124:	428b      	cmp	r3, r1
 8000126:	d30d      	bcc.n	8000144 <__udivsi3+0x3c>
 8000128:	22ff      	movs	r2, #255	; 0xff
 800012a:	0209      	lsls	r1, r1, #8
 800012c:	ba12      	rev	r2, r2
 800012e:	0c03      	lsrs	r3, r0, #16
 8000130:	428b      	cmp	r3, r1
 8000132:	d302      	bcc.n	800013a <__udivsi3+0x32>
 8000134:	1212      	asrs	r2, r2, #8
 8000136:	0209      	lsls	r1, r1, #8
 8000138:	d065      	beq.n	8000206 <__udivsi3+0xfe>
 800013a:	0b03      	lsrs	r3, r0, #12
 800013c:	428b      	cmp	r3, r1
 800013e:	d319      	bcc.n	8000174 <__udivsi3+0x6c>
 8000140:	e000      	b.n	8000144 <__udivsi3+0x3c>
 8000142:	0a09      	lsrs	r1, r1, #8
 8000144:	0bc3      	lsrs	r3, r0, #15
 8000146:	428b      	cmp	r3, r1
 8000148:	d301      	bcc.n	800014e <__udivsi3+0x46>
 800014a:	03cb      	lsls	r3, r1, #15
 800014c:	1ac0      	subs	r0, r0, r3
 800014e:	4152      	adcs	r2, r2
 8000150:	0b83      	lsrs	r3, r0, #14
 8000152:	428b      	cmp	r3, r1
 8000154:	d301      	bcc.n	800015a <__udivsi3+0x52>
 8000156:	038b      	lsls	r3, r1, #14
 8000158:	1ac0      	subs	r0, r0, r3
 800015a:	4152      	adcs	r2, r2
 800015c:	0b43      	lsrs	r3, r0, #13
 800015e:	428b      	cmp	r3, r1
 8000160:	d301      	bcc.n	8000166 <__udivsi3+0x5e>
 8000162:	034b      	lsls	r3, r1, #13
 8000164:	1ac0      	subs	r0, r0, r3
 8000166:	4152      	adcs	r2, r2
 8000168:	0b03      	lsrs	r3, r0, #12
 800016a:	428b      	cmp	r3, r1
 800016c:	d301      	bcc.n	8000172 <__udivsi3+0x6a>
 800016e:	030b      	lsls	r3, r1, #12
 8000170:	1ac0      	subs	r0, r0, r3
 8000172:	4152      	adcs	r2, r2
 8000174:	0ac3      	lsrs	r3, r0, #11
 8000176:	428b      	cmp	r3, r1
 8000178:	d301      	bcc.n	800017e <__udivsi3+0x76>
 800017a:	02cb      	lsls	r3, r1, #11
 800017c:	1ac0      	subs	r0, r0, r3
 800017e:	4152      	adcs	r2, r2
 8000180:	0a83      	lsrs	r3, r0, #10
 8000182:	428b      	cmp	r3, r1
 8000184:	d301      	bcc.n	800018a <__udivsi3+0x82>
 8000186:	028b      	lsls	r3, r1, #10
 8000188:	1ac0      	subs	r0, r0, r3
 800018a:	4152      	adcs	r2, r2
 800018c:	0a43      	lsrs	r3, r0, #9
 800018e:	428b      	cmp	r3, r1
 8000190:	d301      	bcc.n	8000196 <__udivsi3+0x8e>
 8000192:	024b      	lsls	r3, r1, #9
 8000194:	1ac0      	subs	r0, r0, r3
 8000196:	4152      	adcs	r2, r2
 8000198:	0a03      	lsrs	r3, r0, #8
 800019a:	428b      	cmp	r3, r1
 800019c:	d301      	bcc.n	80001a2 <__udivsi3+0x9a>
 800019e:	020b      	lsls	r3, r1, #8
 80001a0:	1ac0      	subs	r0, r0, r3
 80001a2:	4152      	adcs	r2, r2
 80001a4:	d2cd      	bcs.n	8000142 <__udivsi3+0x3a>
 80001a6:	09c3      	lsrs	r3, r0, #7
 80001a8:	428b      	cmp	r3, r1
 80001aa:	d301      	bcc.n	80001b0 <__udivsi3+0xa8>
 80001ac:	01cb      	lsls	r3, r1, #7
 80001ae:	1ac0      	subs	r0, r0, r3
 80001b0:	4152      	adcs	r2, r2
 80001b2:	0983      	lsrs	r3, r0, #6
 80001b4:	428b      	cmp	r3, r1
 80001b6:	d301      	bcc.n	80001bc <__udivsi3+0xb4>
 80001b8:	018b      	lsls	r3, r1, #6
 80001ba:	1ac0      	subs	r0, r0, r3
 80001bc:	4152      	adcs	r2, r2
 80001be:	0943      	lsrs	r3, r0, #5
 80001c0:	428b      	cmp	r3, r1
 80001c2:	d301      	bcc.n	80001c8 <__udivsi3+0xc0>
 80001c4:	014b      	lsls	r3, r1, #5
 80001c6:	1ac0      	subs	r0, r0, r3
 80001c8:	4152      	adcs	r2, r2
 80001ca:	0903      	lsrs	r3, r0, #4
 80001cc:	428b      	cmp	r3, r1
 80001ce:	d301      	bcc.n	80001d4 <__udivsi3+0xcc>
 80001d0:	010b      	lsls	r3, r1, #4
 80001d2:	1ac0      	subs	r0, r0, r3
 80001d4:	4152      	adcs	r2, r2
 80001d6:	08c3      	lsrs	r3, r0, #3
 80001d8:	428b      	cmp	r3, r1
 80001da:	d301      	bcc.n	80001e0 <__udivsi3+0xd8>
 80001dc:	00cb      	lsls	r3, r1, #3
 80001de:	1ac0      	subs	r0, r0, r3
 80001e0:	4152      	adcs	r2, r2
 80001e2:	0883      	lsrs	r3, r0, #2
 80001e4:	428b      	cmp	r3, r1
 80001e6:	d301      	bcc.n	80001ec <__udivsi3+0xe4>
 80001e8:	008b      	lsls	r3, r1, #2
 80001ea:	1ac0      	subs	r0, r0, r3
 80001ec:	4152      	adcs	r2, r2
 80001ee:	0843      	lsrs	r3, r0, #1
 80001f0:	428b      	cmp	r3, r1
 80001f2:	d301      	bcc.n	80001f8 <__udivsi3+0xf0>
 80001f4:	004b      	lsls	r3, r1, #1
 80001f6:	1ac0      	subs	r0, r0, r3
 80001f8:	4152      	adcs	r2, r2
 80001fa:	1a41      	subs	r1, r0, r1
 80001fc:	d200      	bcs.n	8000200 <__udivsi3+0xf8>
 80001fe:	4601      	mov	r1, r0
 8000200:	4152      	adcs	r2, r2
 8000202:	4610      	mov	r0, r2
 8000204:	4770      	bx	lr
 8000206:	e7ff      	b.n	8000208 <__udivsi3+0x100>
 8000208:	b501      	push	{r0, lr}
 800020a:	2000      	movs	r0, #0
 800020c:	f000 f8f0 	bl	80003f0 <__aeabi_idiv0>
 8000210:	bd02      	pop	{r1, pc}
 8000212:	46c0      	nop			; (mov r8, r8)

08000214 <__aeabi_uidivmod>:
 8000214:	2900      	cmp	r1, #0
 8000216:	d0f7      	beq.n	8000208 <__udivsi3+0x100>
 8000218:	e776      	b.n	8000108 <__udivsi3>
 800021a:	4770      	bx	lr

0800021c <__divsi3>:
 800021c:	4603      	mov	r3, r0
 800021e:	430b      	orrs	r3, r1
 8000220:	d47f      	bmi.n	8000322 <__divsi3+0x106>
 8000222:	2200      	movs	r2, #0
 8000224:	0843      	lsrs	r3, r0, #1
 8000226:	428b      	cmp	r3, r1
 8000228:	d374      	bcc.n	8000314 <__divsi3+0xf8>
 800022a:	0903      	lsrs	r3, r0, #4
 800022c:	428b      	cmp	r3, r1
 800022e:	d35f      	bcc.n	80002f0 <__divsi3+0xd4>
 8000230:	0a03      	lsrs	r3, r0, #8
 8000232:	428b      	cmp	r3, r1
 8000234:	d344      	bcc.n	80002c0 <__divsi3+0xa4>
 8000236:	0b03      	lsrs	r3, r0, #12
 8000238:	428b      	cmp	r3, r1
 800023a:	d328      	bcc.n	800028e <__divsi3+0x72>
 800023c:	0c03      	lsrs	r3, r0, #16
 800023e:	428b      	cmp	r3, r1
 8000240:	d30d      	bcc.n	800025e <__divsi3+0x42>
 8000242:	22ff      	movs	r2, #255	; 0xff
 8000244:	0209      	lsls	r1, r1, #8
 8000246:	ba12      	rev	r2, r2
 8000248:	0c03      	lsrs	r3, r0, #16
 800024a:	428b      	cmp	r3, r1
 800024c:	d302      	bcc.n	8000254 <__divsi3+0x38>
 800024e:	1212      	asrs	r2, r2, #8
 8000250:	0209      	lsls	r1, r1, #8
 8000252:	d065      	beq.n	8000320 <__divsi3+0x104>
 8000254:	0b03      	lsrs	r3, r0, #12
 8000256:	428b      	cmp	r3, r1
 8000258:	d319      	bcc.n	800028e <__divsi3+0x72>
 800025a:	e000      	b.n	800025e <__divsi3+0x42>
 800025c:	0a09      	lsrs	r1, r1, #8
 800025e:	0bc3      	lsrs	r3, r0, #15
 8000260:	428b      	cmp	r3, r1
 8000262:	d301      	bcc.n	8000268 <__divsi3+0x4c>
 8000264:	03cb      	lsls	r3, r1, #15
 8000266:	1ac0      	subs	r0, r0, r3
 8000268:	4152      	adcs	r2, r2
 800026a:	0b83      	lsrs	r3, r0, #14
 800026c:	428b      	cmp	r3, r1
 800026e:	d301      	bcc.n	8000274 <__divsi3+0x58>
 8000270:	038b      	lsls	r3, r1, #14
 8000272:	1ac0      	subs	r0, r0, r3
 8000274:	4152      	adcs	r2, r2
 8000276:	0b43      	lsrs	r3, r0, #13
 8000278:	428b      	cmp	r3, r1
 800027a:	d301      	bcc.n	8000280 <__divsi3+0x64>
 800027c:	034b      	lsls	r3, r1, #13
 800027e:	1ac0      	subs	r0, r0, r3
 8000280:	4152      	adcs	r2, r2
 8000282:	0b03      	lsrs	r3, r0, #12
 8000284:	428b      	cmp	r3, r1
 8000286:	d301      	bcc.n	800028c <__divsi3+0x70>
 8000288:	030b      	lsls	r3, r1, #12
 800028a:	1ac0      	subs	r0, r0, r3
 800028c:	4152      	adcs	r2, r2
 800028e:	0ac3      	lsrs	r3, r0, #11
 8000290:	428b      	cmp	r3, r1
 8000292:	d301      	bcc.n	8000298 <__divsi3+0x7c>
 8000294:	02cb      	lsls	r3, r1, #11
 8000296:	1ac0      	subs	r0, r0, r3
 8000298:	4152      	adcs	r2, r2
 800029a:	0a83      	lsrs	r3, r0, #10
 800029c:	428b      	cmp	r3, r1
 800029e:	d301      	bcc.n	80002a4 <__divsi3+0x88>
 80002a0:	028b      	lsls	r3, r1, #10
 80002a2:	1ac0      	subs	r0, r0, r3
 80002a4:	4152      	adcs	r2, r2
 80002a6:	0a43      	lsrs	r3, r0, #9
 80002a8:	428b      	cmp	r3, r1
 80002aa:	d301      	bcc.n	80002b0 <__divsi3+0x94>
 80002ac:	024b      	lsls	r3, r1, #9
 80002ae:	1ac0      	subs	r0, r0, r3
 80002b0:	4152      	adcs	r2, r2
 80002b2:	0a03      	lsrs	r3, r0, #8
 80002b4:	428b      	cmp	r3, r1
 80002b6:	d301      	bcc.n	80002bc <__divsi3+0xa0>
 80002b8:	020b      	lsls	r3, r1, #8
 80002ba:	1ac0      	subs	r0, r0, r3
 80002bc:	4152      	adcs	r2, r2
 80002be:	d2cd      	bcs.n	800025c <__divsi3+0x40>
 80002c0:	09c3      	lsrs	r3, r0, #7
 80002c2:	428b      	cmp	r3, r1
 80002c4:	d301      	bcc.n	80002ca <__divsi3+0xae>
 80002c6:	01cb      	lsls	r3, r1, #7
 80002c8:	1ac0      	subs	r0, r0, r3
 80002ca:	4152      	adcs	r2, r2
 80002cc:	0983      	lsrs	r3, r0, #6
 80002ce:	428b      	cmp	r3, r1
 80002d0:	d301      	bcc.n	80002d6 <__divsi3+0xba>
 80002d2:	018b      	lsls	r3, r1, #6
 80002d4:	1ac0      	subs	r0, r0, r3
 80002d6:	4152      	adcs	r2, r2
 80002d8:	0943      	lsrs	r3, r0, #5
 80002da:	428b      	cmp	r3, r1
 80002dc:	d301      	bcc.n	80002e2 <__divsi3+0xc6>
 80002de:	014b      	lsls	r3, r1, #5
 80002e0:	1ac0      	subs	r0, r0, r3
 80002e2:	4152      	adcs	r2, r2
 80002e4:	0903      	lsrs	r3, r0, #4
 80002e6:	428b      	cmp	r3, r1
 80002e8:	d301      	bcc.n	80002ee <__divsi3+0xd2>
 80002ea:	010b      	lsls	r3, r1, #4
 80002ec:	1ac0      	subs	r0, r0, r3
 80002ee:	4152      	adcs	r2, r2
 80002f0:	08c3      	lsrs	r3, r0, #3
 80002f2:	428b      	cmp	r3, r1
 80002f4:	d301      	bcc.n	80002fa <__divsi3+0xde>
 80002f6:	00cb      	lsls	r3, r1, #3
 80002f8:	1ac0      	subs	r0, r0, r3
 80002fa:	4152      	adcs	r2, r2
 80002fc:	0883      	lsrs	r3, r0, #2
 80002fe:	428b      	cmp	r3, r1
 8000300:	d301      	bcc.n	8000306 <__divsi3+0xea>
 8000302:	008b      	lsls	r3, r1, #2
 8000304:	1ac0      	subs	r0, r0, r3
 8000306:	4152      	adcs	r2, r2
 8000308:	0843      	lsrs	r3, r0, #1
 800030a:	428b      	cmp	r3, r1
 800030c:	d301      	bcc.n	8000312 <__divsi3+0xf6>
 800030e:	004b      	lsls	r3, r1, #1
 8000310:	1ac0      	subs	r0, r0, r3
 8000312:	4152      	adcs	r2, r2
 8000314:	1a41      	subs	r1, r0, r1
 8000316:	d200      	bcs.n	800031a <__divsi3+0xfe>
 8000318:	4601      	mov	r1, r0
 800031a:	4152      	adcs	r2, r2
 800031c:	4610      	mov	r0, r2
 800031e:	4770      	bx	lr
 8000320:	e05d      	b.n	80003de <__divsi3+0x1c2>
 8000322:	0fca      	lsrs	r2, r1, #31
 8000324:	d000      	beq.n	8000328 <__divsi3+0x10c>
 8000326:	4249      	negs	r1, r1
 8000328:	1003      	asrs	r3, r0, #32
 800032a:	d300      	bcc.n	800032e <__divsi3+0x112>
 800032c:	4240      	negs	r0, r0
 800032e:	4053      	eors	r3, r2
 8000330:	2200      	movs	r2, #0
 8000332:	469c      	mov	ip, r3
 8000334:	0903      	lsrs	r3, r0, #4
 8000336:	428b      	cmp	r3, r1
 8000338:	d32d      	bcc.n	8000396 <__divsi3+0x17a>
 800033a:	0a03      	lsrs	r3, r0, #8
 800033c:	428b      	cmp	r3, r1
 800033e:	d312      	bcc.n	8000366 <__divsi3+0x14a>
 8000340:	22fc      	movs	r2, #252	; 0xfc
 8000342:	0189      	lsls	r1, r1, #6
 8000344:	ba12      	rev	r2, r2
 8000346:	0a03      	lsrs	r3, r0, #8
 8000348:	428b      	cmp	r3, r1
 800034a:	d30c      	bcc.n	8000366 <__divsi3+0x14a>
 800034c:	0189      	lsls	r1, r1, #6
 800034e:	1192      	asrs	r2, r2, #6
 8000350:	428b      	cmp	r3, r1
 8000352:	d308      	bcc.n	8000366 <__divsi3+0x14a>
 8000354:	0189      	lsls	r1, r1, #6
 8000356:	1192      	asrs	r2, r2, #6
 8000358:	428b      	cmp	r3, r1
 800035a:	d304      	bcc.n	8000366 <__divsi3+0x14a>
 800035c:	0189      	lsls	r1, r1, #6
 800035e:	d03a      	beq.n	80003d6 <__divsi3+0x1ba>
 8000360:	1192      	asrs	r2, r2, #6
 8000362:	e000      	b.n	8000366 <__divsi3+0x14a>
 8000364:	0989      	lsrs	r1, r1, #6
 8000366:	09c3      	lsrs	r3, r0, #7
 8000368:	428b      	cmp	r3, r1
 800036a:	d301      	bcc.n	8000370 <__divsi3+0x154>
 800036c:	01cb      	lsls	r3, r1, #7
 800036e:	1ac0      	subs	r0, r0, r3
 8000370:	4152      	adcs	r2, r2
 8000372:	0983      	lsrs	r3, r0, #6
 8000374:	428b      	cmp	r3, r1
 8000376:	d301      	bcc.n	800037c <__divsi3+0x160>
 8000378:	018b      	lsls	r3, r1, #6
 800037a:	1ac0      	subs	r0, r0, r3
 800037c:	4152      	adcs	r2, r2
 800037e:	0943      	lsrs	r3, r0, #5
 8000380:	428b      	cmp	r3, r1
 8000382:	d301      	bcc.n	8000388 <__divsi3+0x16c>
 8000384:	014b      	lsls	r3, r1, #5
 8000386:	1ac0      	subs	r0, r0, r3
 8000388:	4152      	adcs	r2, r2
 800038a:	0903      	lsrs	r3, r0, #4
 800038c:	428b      	cmp	r3, r1
 800038e:	d301      	bcc.n	8000394 <__divsi3+0x178>
 8000390:	010b      	lsls	r3, r1, #4
 8000392:	1ac0      	subs	r0, r0, r3
 8000394:	4152      	adcs	r2, r2
 8000396:	08c3      	lsrs	r3, r0, #3
 8000398:	428b      	cmp	r3, r1
 800039a:	d301      	bcc.n	80003a0 <__divsi3+0x184>
 800039c:	00cb      	lsls	r3, r1, #3
 800039e:	1ac0      	subs	r0, r0, r3
 80003a0:	4152      	adcs	r2, r2
 80003a2:	0883      	lsrs	r3, r0, #2
 80003a4:	428b      	cmp	r3, r1
 80003a6:	d301      	bcc.n	80003ac <__divsi3+0x190>
 80003a8:	008b      	lsls	r3, r1, #2
 80003aa:	1ac0      	subs	r0, r0, r3
 80003ac:	4152      	adcs	r2, r2
 80003ae:	d2d9      	bcs.n	8000364 <__divsi3+0x148>
 80003b0:	0843      	lsrs	r3, r0, #1
 80003b2:	428b      	cmp	r3, r1
 80003b4:	d301      	bcc.n	80003ba <__divsi3+0x19e>
 80003b6:	004b      	lsls	r3, r1, #1
 80003b8:	1ac0      	subs	r0, r0, r3
 80003ba:	4152      	adcs	r2, r2
 80003bc:	1a41      	subs	r1, r0, r1
 80003be:	d200      	bcs.n	80003c2 <__divsi3+0x1a6>
 80003c0:	4601      	mov	r1, r0
 80003c2:	4663      	mov	r3, ip
 80003c4:	4152      	adcs	r2, r2
 80003c6:	105b      	asrs	r3, r3, #1
 80003c8:	4610      	mov	r0, r2
 80003ca:	d301      	bcc.n	80003d0 <__divsi3+0x1b4>
 80003cc:	4240      	negs	r0, r0
 80003ce:	2b00      	cmp	r3, #0
 80003d0:	d500      	bpl.n	80003d4 <__divsi3+0x1b8>
 80003d2:	4249      	negs	r1, r1
 80003d4:	4770      	bx	lr
 80003d6:	4663      	mov	r3, ip
 80003d8:	105b      	asrs	r3, r3, #1
 80003da:	d300      	bcc.n	80003de <__divsi3+0x1c2>
 80003dc:	4240      	negs	r0, r0
 80003de:	b501      	push	{r0, lr}
 80003e0:	2000      	movs	r0, #0
 80003e2:	f000 f805 	bl	80003f0 <__aeabi_idiv0>
 80003e6:	bd02      	pop	{r1, pc}

080003e8 <__aeabi_idivmod>:
 80003e8:	2900      	cmp	r1, #0
 80003ea:	d0f8      	beq.n	80003de <__divsi3+0x1c2>
 80003ec:	e716      	b.n	800021c <__divsi3>
 80003ee:	4770      	bx	lr

080003f0 <__aeabi_idiv0>:
 80003f0:	4770      	bx	lr
 80003f2:	46c0      	nop			; (mov r8, r8)

080003f4 <__aeabi_uldivmod>:
 80003f4:	2b00      	cmp	r3, #0
 80003f6:	d111      	bne.n	800041c <__aeabi_uldivmod+0x28>
 80003f8:	2a00      	cmp	r2, #0
 80003fa:	d10f      	bne.n	800041c <__aeabi_uldivmod+0x28>
 80003fc:	2900      	cmp	r1, #0
 80003fe:	d100      	bne.n	8000402 <__aeabi_uldivmod+0xe>
 8000400:	2800      	cmp	r0, #0
 8000402:	d002      	beq.n	800040a <__aeabi_uldivmod+0x16>
 8000404:	2100      	movs	r1, #0
 8000406:	43c9      	mvns	r1, r1
 8000408:	1c08      	adds	r0, r1, #0
 800040a:	b407      	push	{r0, r1, r2}
 800040c:	4802      	ldr	r0, [pc, #8]	; (8000418 <__aeabi_uldivmod+0x24>)
 800040e:	a102      	add	r1, pc, #8	; (adr r1, 8000418 <__aeabi_uldivmod+0x24>)
 8000410:	1840      	adds	r0, r0, r1
 8000412:	9002      	str	r0, [sp, #8]
 8000414:	bd03      	pop	{r0, r1, pc}
 8000416:	46c0      	nop			; (mov r8, r8)
 8000418:	ffffffd9 	.word	0xffffffd9
 800041c:	b403      	push	{r0, r1}
 800041e:	4668      	mov	r0, sp
 8000420:	b501      	push	{r0, lr}
 8000422:	9802      	ldr	r0, [sp, #8]
 8000424:	f000 f830 	bl	8000488 <__udivmoddi4>
 8000428:	9b01      	ldr	r3, [sp, #4]
 800042a:	469e      	mov	lr, r3
 800042c:	b002      	add	sp, #8
 800042e:	bc0c      	pop	{r2, r3}
 8000430:	4770      	bx	lr
 8000432:	46c0      	nop			; (mov r8, r8)

08000434 <__aeabi_lmul>:
 8000434:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000436:	46ce      	mov	lr, r9
 8000438:	4647      	mov	r7, r8
 800043a:	0415      	lsls	r5, r2, #16
 800043c:	0c2d      	lsrs	r5, r5, #16
 800043e:	002e      	movs	r6, r5
 8000440:	b580      	push	{r7, lr}
 8000442:	0407      	lsls	r7, r0, #16
 8000444:	0c14      	lsrs	r4, r2, #16
 8000446:	0c3f      	lsrs	r7, r7, #16
 8000448:	4699      	mov	r9, r3
 800044a:	0c03      	lsrs	r3, r0, #16
 800044c:	437e      	muls	r6, r7
 800044e:	435d      	muls	r5, r3
 8000450:	4367      	muls	r7, r4
 8000452:	4363      	muls	r3, r4
 8000454:	197f      	adds	r7, r7, r5
 8000456:	0c34      	lsrs	r4, r6, #16
 8000458:	19e4      	adds	r4, r4, r7
 800045a:	469c      	mov	ip, r3
 800045c:	42a5      	cmp	r5, r4
 800045e:	d903      	bls.n	8000468 <__aeabi_lmul+0x34>
 8000460:	2380      	movs	r3, #128	; 0x80
 8000462:	025b      	lsls	r3, r3, #9
 8000464:	4698      	mov	r8, r3
 8000466:	44c4      	add	ip, r8
 8000468:	464b      	mov	r3, r9
 800046a:	4343      	muls	r3, r0
 800046c:	4351      	muls	r1, r2
 800046e:	0c25      	lsrs	r5, r4, #16
 8000470:	0436      	lsls	r6, r6, #16
 8000472:	4465      	add	r5, ip
 8000474:	0c36      	lsrs	r6, r6, #16
 8000476:	0424      	lsls	r4, r4, #16
 8000478:	19a4      	adds	r4, r4, r6
 800047a:	195b      	adds	r3, r3, r5
 800047c:	1859      	adds	r1, r3, r1
 800047e:	0020      	movs	r0, r4
 8000480:	bc0c      	pop	{r2, r3}
 8000482:	4690      	mov	r8, r2
 8000484:	4699      	mov	r9, r3
 8000486:	bdf0      	pop	{r4, r5, r6, r7, pc}

08000488 <__udivmoddi4>:
 8000488:	b5f0      	push	{r4, r5, r6, r7, lr}
 800048a:	464f      	mov	r7, r9
 800048c:	4646      	mov	r6, r8
 800048e:	46d6      	mov	lr, sl
 8000490:	b5c0      	push	{r6, r7, lr}
 8000492:	0004      	movs	r4, r0
 8000494:	b082      	sub	sp, #8
 8000496:	000d      	movs	r5, r1
 8000498:	4691      	mov	r9, r2
 800049a:	4698      	mov	r8, r3
 800049c:	428b      	cmp	r3, r1
 800049e:	d82f      	bhi.n	8000500 <__udivmoddi4+0x78>
 80004a0:	d02c      	beq.n	80004fc <__udivmoddi4+0x74>
 80004a2:	4641      	mov	r1, r8
 80004a4:	4648      	mov	r0, r9
 80004a6:	f000 f8cf 	bl	8000648 <__clzdi2>
 80004aa:	0029      	movs	r1, r5
 80004ac:	0006      	movs	r6, r0
 80004ae:	0020      	movs	r0, r4
 80004b0:	f000 f8ca 	bl	8000648 <__clzdi2>
 80004b4:	1a33      	subs	r3, r6, r0
 80004b6:	469c      	mov	ip, r3
 80004b8:	3b20      	subs	r3, #32
 80004ba:	469a      	mov	sl, r3
 80004bc:	d500      	bpl.n	80004c0 <__udivmoddi4+0x38>
 80004be:	e076      	b.n	80005ae <__udivmoddi4+0x126>
 80004c0:	464b      	mov	r3, r9
 80004c2:	4652      	mov	r2, sl
 80004c4:	4093      	lsls	r3, r2
 80004c6:	001f      	movs	r7, r3
 80004c8:	464b      	mov	r3, r9
 80004ca:	4662      	mov	r2, ip
 80004cc:	4093      	lsls	r3, r2
 80004ce:	001e      	movs	r6, r3
 80004d0:	42af      	cmp	r7, r5
 80004d2:	d828      	bhi.n	8000526 <__udivmoddi4+0x9e>
 80004d4:	d025      	beq.n	8000522 <__udivmoddi4+0x9a>
 80004d6:	4653      	mov	r3, sl
 80004d8:	1ba4      	subs	r4, r4, r6
 80004da:	41bd      	sbcs	r5, r7
 80004dc:	2b00      	cmp	r3, #0
 80004de:	da00      	bge.n	80004e2 <__udivmoddi4+0x5a>
 80004e0:	e07b      	b.n	80005da <__udivmoddi4+0x152>
 80004e2:	2200      	movs	r2, #0
 80004e4:	2300      	movs	r3, #0
 80004e6:	9200      	str	r2, [sp, #0]
 80004e8:	9301      	str	r3, [sp, #4]
 80004ea:	2301      	movs	r3, #1
 80004ec:	4652      	mov	r2, sl
 80004ee:	4093      	lsls	r3, r2
 80004f0:	9301      	str	r3, [sp, #4]
 80004f2:	2301      	movs	r3, #1
 80004f4:	4662      	mov	r2, ip
 80004f6:	4093      	lsls	r3, r2
 80004f8:	9300      	str	r3, [sp, #0]
 80004fa:	e018      	b.n	800052e <__udivmoddi4+0xa6>
 80004fc:	4282      	cmp	r2, r0
 80004fe:	d9d0      	bls.n	80004a2 <__udivmoddi4+0x1a>
 8000500:	2200      	movs	r2, #0
 8000502:	2300      	movs	r3, #0
 8000504:	9200      	str	r2, [sp, #0]
 8000506:	9301      	str	r3, [sp, #4]
 8000508:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800050a:	2b00      	cmp	r3, #0
 800050c:	d001      	beq.n	8000512 <__udivmoddi4+0x8a>
 800050e:	601c      	str	r4, [r3, #0]
 8000510:	605d      	str	r5, [r3, #4]
 8000512:	9800      	ldr	r0, [sp, #0]
 8000514:	9901      	ldr	r1, [sp, #4]
 8000516:	b002      	add	sp, #8
 8000518:	bc1c      	pop	{r2, r3, r4}
 800051a:	4690      	mov	r8, r2
 800051c:	4699      	mov	r9, r3
 800051e:	46a2      	mov	sl, r4
 8000520:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000522:	42a3      	cmp	r3, r4
 8000524:	d9d7      	bls.n	80004d6 <__udivmoddi4+0x4e>
 8000526:	2200      	movs	r2, #0
 8000528:	2300      	movs	r3, #0
 800052a:	9200      	str	r2, [sp, #0]
 800052c:	9301      	str	r3, [sp, #4]
 800052e:	4663      	mov	r3, ip
 8000530:	2b00      	cmp	r3, #0
 8000532:	d0e9      	beq.n	8000508 <__udivmoddi4+0x80>
 8000534:	07fb      	lsls	r3, r7, #31
 8000536:	4698      	mov	r8, r3
 8000538:	4641      	mov	r1, r8
 800053a:	0872      	lsrs	r2, r6, #1
 800053c:	430a      	orrs	r2, r1
 800053e:	087b      	lsrs	r3, r7, #1
 8000540:	4666      	mov	r6, ip
 8000542:	e00e      	b.n	8000562 <__udivmoddi4+0xda>
 8000544:	42ab      	cmp	r3, r5
 8000546:	d101      	bne.n	800054c <__udivmoddi4+0xc4>
 8000548:	42a2      	cmp	r2, r4
 800054a:	d80c      	bhi.n	8000566 <__udivmoddi4+0xde>
 800054c:	1aa4      	subs	r4, r4, r2
 800054e:	419d      	sbcs	r5, r3
 8000550:	2001      	movs	r0, #1
 8000552:	1924      	adds	r4, r4, r4
 8000554:	416d      	adcs	r5, r5
 8000556:	2100      	movs	r1, #0
 8000558:	3e01      	subs	r6, #1
 800055a:	1824      	adds	r4, r4, r0
 800055c:	414d      	adcs	r5, r1
 800055e:	2e00      	cmp	r6, #0
 8000560:	d006      	beq.n	8000570 <__udivmoddi4+0xe8>
 8000562:	42ab      	cmp	r3, r5
 8000564:	d9ee      	bls.n	8000544 <__udivmoddi4+0xbc>
 8000566:	3e01      	subs	r6, #1
 8000568:	1924      	adds	r4, r4, r4
 800056a:	416d      	adcs	r5, r5
 800056c:	2e00      	cmp	r6, #0
 800056e:	d1f8      	bne.n	8000562 <__udivmoddi4+0xda>
 8000570:	9800      	ldr	r0, [sp, #0]
 8000572:	9901      	ldr	r1, [sp, #4]
 8000574:	4653      	mov	r3, sl
 8000576:	1900      	adds	r0, r0, r4
 8000578:	4169      	adcs	r1, r5
 800057a:	2b00      	cmp	r3, #0
 800057c:	db23      	blt.n	80005c6 <__udivmoddi4+0x13e>
 800057e:	002b      	movs	r3, r5
 8000580:	4652      	mov	r2, sl
 8000582:	40d3      	lsrs	r3, r2
 8000584:	002a      	movs	r2, r5
 8000586:	4664      	mov	r4, ip
 8000588:	40e2      	lsrs	r2, r4
 800058a:	001c      	movs	r4, r3
 800058c:	4653      	mov	r3, sl
 800058e:	0015      	movs	r5, r2
 8000590:	2b00      	cmp	r3, #0
 8000592:	db2d      	blt.n	80005f0 <__udivmoddi4+0x168>
 8000594:	0026      	movs	r6, r4
 8000596:	4657      	mov	r7, sl
 8000598:	40be      	lsls	r6, r7
 800059a:	0033      	movs	r3, r6
 800059c:	0026      	movs	r6, r4
 800059e:	4667      	mov	r7, ip
 80005a0:	40be      	lsls	r6, r7
 80005a2:	0032      	movs	r2, r6
 80005a4:	1a80      	subs	r0, r0, r2
 80005a6:	4199      	sbcs	r1, r3
 80005a8:	9000      	str	r0, [sp, #0]
 80005aa:	9101      	str	r1, [sp, #4]
 80005ac:	e7ac      	b.n	8000508 <__udivmoddi4+0x80>
 80005ae:	4662      	mov	r2, ip
 80005b0:	2320      	movs	r3, #32
 80005b2:	1a9b      	subs	r3, r3, r2
 80005b4:	464a      	mov	r2, r9
 80005b6:	40da      	lsrs	r2, r3
 80005b8:	4661      	mov	r1, ip
 80005ba:	0013      	movs	r3, r2
 80005bc:	4642      	mov	r2, r8
 80005be:	408a      	lsls	r2, r1
 80005c0:	0017      	movs	r7, r2
 80005c2:	431f      	orrs	r7, r3
 80005c4:	e780      	b.n	80004c8 <__udivmoddi4+0x40>
 80005c6:	4662      	mov	r2, ip
 80005c8:	2320      	movs	r3, #32
 80005ca:	1a9b      	subs	r3, r3, r2
 80005cc:	002a      	movs	r2, r5
 80005ce:	4666      	mov	r6, ip
 80005d0:	409a      	lsls	r2, r3
 80005d2:	0023      	movs	r3, r4
 80005d4:	40f3      	lsrs	r3, r6
 80005d6:	4313      	orrs	r3, r2
 80005d8:	e7d4      	b.n	8000584 <__udivmoddi4+0xfc>
 80005da:	4662      	mov	r2, ip
 80005dc:	2320      	movs	r3, #32
 80005de:	2100      	movs	r1, #0
 80005e0:	1a9b      	subs	r3, r3, r2
 80005e2:	2200      	movs	r2, #0
 80005e4:	9100      	str	r1, [sp, #0]
 80005e6:	9201      	str	r2, [sp, #4]
 80005e8:	2201      	movs	r2, #1
 80005ea:	40da      	lsrs	r2, r3
 80005ec:	9201      	str	r2, [sp, #4]
 80005ee:	e780      	b.n	80004f2 <__udivmoddi4+0x6a>
 80005f0:	2320      	movs	r3, #32
 80005f2:	4662      	mov	r2, ip
 80005f4:	0026      	movs	r6, r4
 80005f6:	1a9b      	subs	r3, r3, r2
 80005f8:	40de      	lsrs	r6, r3
 80005fa:	002f      	movs	r7, r5
 80005fc:	46b0      	mov	r8, r6
 80005fe:	4666      	mov	r6, ip
 8000600:	40b7      	lsls	r7, r6
 8000602:	4646      	mov	r6, r8
 8000604:	003b      	movs	r3, r7
 8000606:	4333      	orrs	r3, r6
 8000608:	e7c8      	b.n	800059c <__udivmoddi4+0x114>
 800060a:	46c0      	nop			; (mov r8, r8)

0800060c <__clzsi2>:
 800060c:	211c      	movs	r1, #28
 800060e:	2301      	movs	r3, #1
 8000610:	041b      	lsls	r3, r3, #16
 8000612:	4298      	cmp	r0, r3
 8000614:	d301      	bcc.n	800061a <__clzsi2+0xe>
 8000616:	0c00      	lsrs	r0, r0, #16
 8000618:	3910      	subs	r1, #16
 800061a:	0a1b      	lsrs	r3, r3, #8
 800061c:	4298      	cmp	r0, r3
 800061e:	d301      	bcc.n	8000624 <__clzsi2+0x18>
 8000620:	0a00      	lsrs	r0, r0, #8
 8000622:	3908      	subs	r1, #8
 8000624:	091b      	lsrs	r3, r3, #4
 8000626:	4298      	cmp	r0, r3
 8000628:	d301      	bcc.n	800062e <__clzsi2+0x22>
 800062a:	0900      	lsrs	r0, r0, #4
 800062c:	3904      	subs	r1, #4
 800062e:	a202      	add	r2, pc, #8	; (adr r2, 8000638 <__clzsi2+0x2c>)
 8000630:	5c10      	ldrb	r0, [r2, r0]
 8000632:	1840      	adds	r0, r0, r1
 8000634:	4770      	bx	lr
 8000636:	46c0      	nop			; (mov r8, r8)
 8000638:	02020304 	.word	0x02020304
 800063c:	01010101 	.word	0x01010101
	...

08000648 <__clzdi2>:
 8000648:	b510      	push	{r4, lr}
 800064a:	2900      	cmp	r1, #0
 800064c:	d103      	bne.n	8000656 <__clzdi2+0xe>
 800064e:	f7ff ffdd 	bl	800060c <__clzsi2>
 8000652:	3020      	adds	r0, #32
 8000654:	e002      	b.n	800065c <__clzdi2+0x14>
 8000656:	1c08      	adds	r0, r1, #0
 8000658:	f7ff ffd8 	bl	800060c <__clzsi2>
 800065c:	bd10      	pop	{r4, pc}
 800065e:	46c0      	nop			; (mov r8, r8)

08000660 <__io_putchar>:

void HAL_UART_MspInit(UART_HandleTypeDef *huart);

///////////////////////C file
PUTCHAR_PROTOTYPE
{
 8000660:	b580      	push	{r7, lr}
 8000662:	b082      	sub	sp, #8
 8000664:	af00      	add	r7, sp, #0
 8000666:	6078      	str	r0, [r7, #4]
  /* Place your implementation of fputc here */
  /* e.g. write a character to the USART2 and Loop until the end of transmission */
  HAL_UART_Transmit(&UartHandle, (uint8_t *)&ch, 1, 0xFFFF);
 8000668:	4b05      	ldr	r3, [pc, #20]	; (8000680 <__io_putchar+0x20>)
 800066a:	1d39      	adds	r1, r7, #4
 800066c:	4805      	ldr	r0, [pc, #20]	; (8000684 <__io_putchar+0x24>)
 800066e:	2201      	movs	r2, #1
 8000670:	f000 f8d8 	bl	8000824 <HAL_UART_Transmit>

  return ch;
 8000674:	687b      	ldr	r3, [r7, #4]
}
 8000676:	0018      	movs	r0, r3
 8000678:	46bd      	mov	sp, r7
 800067a:	b002      	add	sp, #8
 800067c:	bd80      	pop	{r7, pc}
 800067e:	46c0      	nop			; (mov r8, r8)
 8000680:	0000ffff 	.word	0x0000ffff
 8000684:	20000090 	.word	0x20000090

08000688 <initialize>:

void initialize(void)
{
 8000688:	b580      	push	{r7, lr}
 800068a:	af00      	add	r7, sp, #0
	  UartHandle.Instance        = USARTx;
 800068c:	4b11      	ldr	r3, [pc, #68]	; (80006d4 <initialize+0x4c>)
 800068e:	4a12      	ldr	r2, [pc, #72]	; (80006d8 <initialize+0x50>)
 8000690:	601a      	str	r2, [r3, #0]

	  UartHandle.Init.BaudRate   = 9600;
 8000692:	4b10      	ldr	r3, [pc, #64]	; (80006d4 <initialize+0x4c>)
 8000694:	2296      	movs	r2, #150	; 0x96
 8000696:	0192      	lsls	r2, r2, #6
 8000698:	605a      	str	r2, [r3, #4]
	  UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 800069a:	4b0e      	ldr	r3, [pc, #56]	; (80006d4 <initialize+0x4c>)
 800069c:	2200      	movs	r2, #0
 800069e:	609a      	str	r2, [r3, #8]
	  UartHandle.Init.StopBits   = UART_STOPBITS_1;
 80006a0:	4b0c      	ldr	r3, [pc, #48]	; (80006d4 <initialize+0x4c>)
 80006a2:	2200      	movs	r2, #0
 80006a4:	60da      	str	r2, [r3, #12]
	  UartHandle.Init.Parity     = UART_HWCONTROL_NONE;
 80006a6:	4b0b      	ldr	r3, [pc, #44]	; (80006d4 <initialize+0x4c>)
 80006a8:	2200      	movs	r2, #0
 80006aa:	611a      	str	r2, [r3, #16]
	  UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
 80006ac:	4b09      	ldr	r3, [pc, #36]	; (80006d4 <initialize+0x4c>)
 80006ae:	2200      	movs	r2, #0
 80006b0:	619a      	str	r2, [r3, #24]
	  UartHandle.Init.Mode       = UART_MODE_TX_RX;
 80006b2:	4b08      	ldr	r3, [pc, #32]	; (80006d4 <initialize+0x4c>)
 80006b4:	220c      	movs	r2, #12
 80006b6:	615a      	str	r2, [r3, #20]
	  if (HAL_UART_Init(&UartHandle) != HAL_OK)
 80006b8:	4b06      	ldr	r3, [pc, #24]	; (80006d4 <initialize+0x4c>)
 80006ba:	0018      	movs	r0, r3
 80006bc:	f000 f85e 	bl	800077c <HAL_UART_Init>
 80006c0:	1e03      	subs	r3, r0, #0
 80006c2:	d003      	beq.n	80006cc <initialize+0x44>
	  {
	    /* Initialization Error */
	    Error_Handler(__func__);
 80006c4:	4b05      	ldr	r3, [pc, #20]	; (80006dc <initialize+0x54>)
 80006c6:	0018      	movs	r0, r3
 80006c8:	f009 febc 	bl	800a444 <Error_Handler>
	  }

}
 80006cc:	46c0      	nop			; (mov r8, r8)
 80006ce:	46bd      	mov	sp, r7
 80006d0:	bd80      	pop	{r7, pc}
 80006d2:	46c0      	nop			; (mov r8, r8)
 80006d4:	20000090 	.word	0x20000090
 80006d8:	40004400 	.word	0x40004400
 80006dc:	0800e32c 	.word	0x0800e32c

080006e0 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 80006e0:	b590      	push	{r4, r7, lr}
 80006e2:	b08b      	sub	sp, #44	; 0x2c
 80006e4:	af00      	add	r7, sp, #0
 80006e6:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef  GPIO_InitStruct;


  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* Enable GPIO TX/RX clock */
  USARTx_TX_GPIO_CLK_ENABLE();
 80006e8:	4b23      	ldr	r3, [pc, #140]	; (8000778 <HAL_UART_MspInit+0x98>)
 80006ea:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80006ec:	4b22      	ldr	r3, [pc, #136]	; (8000778 <HAL_UART_MspInit+0x98>)
 80006ee:	2101      	movs	r1, #1
 80006f0:	430a      	orrs	r2, r1
 80006f2:	62da      	str	r2, [r3, #44]	; 0x2c
 80006f4:	4b20      	ldr	r3, [pc, #128]	; (8000778 <HAL_UART_MspInit+0x98>)
 80006f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80006f8:	2201      	movs	r2, #1
 80006fa:	4013      	ands	r3, r2
 80006fc:	613b      	str	r3, [r7, #16]
 80006fe:	693b      	ldr	r3, [r7, #16]
  USARTx_RX_GPIO_CLK_ENABLE();
 8000700:	4b1d      	ldr	r3, [pc, #116]	; (8000778 <HAL_UART_MspInit+0x98>)
 8000702:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000704:	4b1c      	ldr	r3, [pc, #112]	; (8000778 <HAL_UART_MspInit+0x98>)
 8000706:	2101      	movs	r1, #1
 8000708:	430a      	orrs	r2, r1
 800070a:	62da      	str	r2, [r3, #44]	; 0x2c
 800070c:	4b1a      	ldr	r3, [pc, #104]	; (8000778 <HAL_UART_MspInit+0x98>)
 800070e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000710:	2201      	movs	r2, #1
 8000712:	4013      	ands	r3, r2
 8000714:	60fb      	str	r3, [r7, #12]
 8000716:	68fb      	ldr	r3, [r7, #12]


  /* Enable USARTx clock */
  USARTx_CLK_ENABLE();
 8000718:	4b17      	ldr	r3, [pc, #92]	; (8000778 <HAL_UART_MspInit+0x98>)
 800071a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800071c:	4b16      	ldr	r3, [pc, #88]	; (8000778 <HAL_UART_MspInit+0x98>)
 800071e:	2180      	movs	r1, #128	; 0x80
 8000720:	0289      	lsls	r1, r1, #10
 8000722:	430a      	orrs	r2, r1
 8000724:	639a      	str	r2, [r3, #56]	; 0x38

  /*##-2- Configure peripheral GPIO ##########################################*/
  /* UART TX GPIO pin configuration  */
  GPIO_InitStruct.Pin       = USARTx_TX_PIN;
 8000726:	2414      	movs	r4, #20
 8000728:	193b      	adds	r3, r7, r4
 800072a:	2204      	movs	r2, #4
 800072c:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 800072e:	193b      	adds	r3, r7, r4
 8000730:	2202      	movs	r2, #2
 8000732:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
 8000734:	193b      	adds	r3, r7, r4
 8000736:	2201      	movs	r2, #1
 8000738:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
 800073a:	193b      	adds	r3, r7, r4
 800073c:	2203      	movs	r2, #3
 800073e:	60da      	str	r2, [r3, #12]
  GPIO_InitStruct.Alternate = USARTx_TX_AF;
 8000740:	193b      	adds	r3, r7, r4
 8000742:	2204      	movs	r2, #4
 8000744:	611a      	str	r2, [r3, #16]

  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);
 8000746:	193a      	adds	r2, r7, r4
 8000748:	23a0      	movs	r3, #160	; 0xa0
 800074a:	05db      	lsls	r3, r3, #23
 800074c:	0011      	movs	r1, r2
 800074e:	0018      	movs	r0, r3
 8000750:	f00a f9e2 	bl	800ab18 <HAL_GPIO_Init>

  /* UART RX GPIO pin configuration  */
  GPIO_InitStruct.Pin = USARTx_RX_PIN;
 8000754:	193b      	adds	r3, r7, r4
 8000756:	2208      	movs	r2, #8
 8000758:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Alternate = USARTx_RX_AF;
 800075a:	193b      	adds	r3, r7, r4
 800075c:	2204      	movs	r2, #4
 800075e:	611a      	str	r2, [r3, #16]

  HAL_GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStruct);
 8000760:	193a      	adds	r2, r7, r4
 8000762:	23a0      	movs	r3, #160	; 0xa0
 8000764:	05db      	lsls	r3, r3, #23
 8000766:	0011      	movs	r1, r2
 8000768:	0018      	movs	r0, r3
 800076a:	f00a f9d5 	bl	800ab18 <HAL_GPIO_Init>
}
 800076e:	46c0      	nop			; (mov r8, r8)
 8000770:	46bd      	mov	sp, r7
 8000772:	b00b      	add	sp, #44	; 0x2c
 8000774:	bd90      	pop	{r4, r7, pc}
 8000776:	46c0      	nop			; (mov r8, r8)
 8000778:	40021000 	.word	0x40021000

0800077c <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 800077c:	b580      	push	{r7, lr}
 800077e:	b082      	sub	sp, #8
 8000780:	af00      	add	r7, sp, #0
 8000782:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 8000784:	687b      	ldr	r3, [r7, #4]
 8000786:	2b00      	cmp	r3, #0
 8000788:	d101      	bne.n	800078e <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 800078a:	2301      	movs	r3, #1
 800078c:	e044      	b.n	8000818 <HAL_UART_Init+0x9c>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 800078e:	687b      	ldr	r3, [r7, #4]
 8000790:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8000792:	2b00      	cmp	r3, #0
 8000794:	d107      	bne.n	80007a6 <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8000796:	687b      	ldr	r3, [r7, #4]
 8000798:	2270      	movs	r2, #112	; 0x70
 800079a:	2100      	movs	r1, #0
 800079c:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 800079e:	687b      	ldr	r3, [r7, #4]
 80007a0:	0018      	movs	r0, r3
 80007a2:	f7ff ff9d 	bl	80006e0 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 80007a6:	687b      	ldr	r3, [r7, #4]
 80007a8:	2224      	movs	r2, #36	; 0x24
 80007aa:	675a      	str	r2, [r3, #116]	; 0x74

  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 80007ac:	687b      	ldr	r3, [r7, #4]
 80007ae:	681b      	ldr	r3, [r3, #0]
 80007b0:	681a      	ldr	r2, [r3, #0]
 80007b2:	687b      	ldr	r3, [r7, #4]
 80007b4:	681b      	ldr	r3, [r3, #0]
 80007b6:	2101      	movs	r1, #1
 80007b8:	438a      	bics	r2, r1
 80007ba:	601a      	str	r2, [r3, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 80007bc:	687b      	ldr	r3, [r7, #4]
 80007be:	0018      	movs	r0, r3
 80007c0:	f000 f8d8 	bl	8000974 <UART_SetConfig>
 80007c4:	0003      	movs	r3, r0
 80007c6:	2b01      	cmp	r3, #1
 80007c8:	d101      	bne.n	80007ce <HAL_UART_Init+0x52>
  {
    return HAL_ERROR;
 80007ca:	2301      	movs	r3, #1
 80007cc:	e024      	b.n	8000818 <HAL_UART_Init+0x9c>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 80007ce:	687b      	ldr	r3, [r7, #4]
 80007d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80007d2:	2b00      	cmp	r3, #0
 80007d4:	d003      	beq.n	80007de <HAL_UART_Init+0x62>
  {
    UART_AdvFeatureConfig(huart);
 80007d6:	687b      	ldr	r3, [r7, #4]
 80007d8:	0018      	movs	r0, r3
 80007da:	f000 fbff 	bl	8000fdc <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80007de:	687b      	ldr	r3, [r7, #4]
 80007e0:	681b      	ldr	r3, [r3, #0]
 80007e2:	685a      	ldr	r2, [r3, #4]
 80007e4:	687b      	ldr	r3, [r7, #4]
 80007e6:	681b      	ldr	r3, [r3, #0]
 80007e8:	490d      	ldr	r1, [pc, #52]	; (8000820 <HAL_UART_Init+0xa4>)
 80007ea:	400a      	ands	r2, r1
 80007ec:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80007ee:	687b      	ldr	r3, [r7, #4]
 80007f0:	681b      	ldr	r3, [r3, #0]
 80007f2:	689a      	ldr	r2, [r3, #8]
 80007f4:	687b      	ldr	r3, [r7, #4]
 80007f6:	681b      	ldr	r3, [r3, #0]
 80007f8:	212a      	movs	r1, #42	; 0x2a
 80007fa:	438a      	bics	r2, r1
 80007fc:	609a      	str	r2, [r3, #8]

  /* Enable the Peripheral */
  __HAL_UART_ENABLE(huart);
 80007fe:	687b      	ldr	r3, [r7, #4]
 8000800:	681b      	ldr	r3, [r3, #0]
 8000802:	681a      	ldr	r2, [r3, #0]
 8000804:	687b      	ldr	r3, [r7, #4]
 8000806:	681b      	ldr	r3, [r3, #0]
 8000808:	2101      	movs	r1, #1
 800080a:	430a      	orrs	r2, r1
 800080c:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 800080e:	687b      	ldr	r3, [r7, #4]
 8000810:	0018      	movs	r0, r3
 8000812:	f000 fc97 	bl	8001144 <UART_CheckIdleState>
 8000816:	0003      	movs	r3, r0
}
 8000818:	0018      	movs	r0, r3
 800081a:	46bd      	mov	sp, r7
 800081c:	b002      	add	sp, #8
 800081e:	bd80      	pop	{r7, pc}
 8000820:	ffffb7ff 	.word	0xffffb7ff

08000824 <HAL_UART_Transmit>:
  * @param Size    Amount of data to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8000824:	b580      	push	{r7, lr}
 8000826:	b08a      	sub	sp, #40	; 0x28
 8000828:	af02      	add	r7, sp, #8
 800082a:	60f8      	str	r0, [r7, #12]
 800082c:	60b9      	str	r1, [r7, #8]
 800082e:	603b      	str	r3, [r7, #0]
 8000830:	1dbb      	adds	r3, r7, #6
 8000832:	801a      	strh	r2, [r3, #0]
  uint8_t  *pdata8bits;
  uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 8000834:	68fb      	ldr	r3, [r7, #12]
 8000836:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8000838:	2b20      	cmp	r3, #32
 800083a:	d000      	beq.n	800083e <HAL_UART_Transmit+0x1a>
 800083c:	e094      	b.n	8000968 <HAL_UART_Transmit+0x144>
  {
    if ((pData == NULL) || (Size == 0U))
 800083e:	68bb      	ldr	r3, [r7, #8]
 8000840:	2b00      	cmp	r3, #0
 8000842:	d003      	beq.n	800084c <HAL_UART_Transmit+0x28>
 8000844:	1dbb      	adds	r3, r7, #6
 8000846:	881b      	ldrh	r3, [r3, #0]
 8000848:	2b00      	cmp	r3, #0
 800084a:	d101      	bne.n	8000850 <HAL_UART_Transmit+0x2c>
    {
      return  HAL_ERROR;
 800084c:	2301      	movs	r3, #1
 800084e:	e08c      	b.n	800096a <HAL_UART_Transmit+0x146>
    }

    /* In case of 9bits/No Parity transfer, pData buffer provided as input parameter
       should be aligned on a u16 frontier, as data to be filled into TDR will be
       handled through a u16 cast. */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8000850:	68fb      	ldr	r3, [r7, #12]
 8000852:	689a      	ldr	r2, [r3, #8]
 8000854:	2380      	movs	r3, #128	; 0x80
 8000856:	015b      	lsls	r3, r3, #5
 8000858:	429a      	cmp	r2, r3
 800085a:	d109      	bne.n	8000870 <HAL_UART_Transmit+0x4c>
 800085c:	68fb      	ldr	r3, [r7, #12]
 800085e:	691b      	ldr	r3, [r3, #16]
 8000860:	2b00      	cmp	r3, #0
 8000862:	d105      	bne.n	8000870 <HAL_UART_Transmit+0x4c>
    {
      if ((((uint32_t)pData) & 1) != 0)
 8000864:	68bb      	ldr	r3, [r7, #8]
 8000866:	2201      	movs	r2, #1
 8000868:	4013      	ands	r3, r2
 800086a:	d001      	beq.n	8000870 <HAL_UART_Transmit+0x4c>
      {
        return  HAL_ERROR;
 800086c:	2301      	movs	r3, #1
 800086e:	e07c      	b.n	800096a <HAL_UART_Transmit+0x146>
      }
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 8000870:	68fb      	ldr	r3, [r7, #12]
 8000872:	2270      	movs	r2, #112	; 0x70
 8000874:	5c9b      	ldrb	r3, [r3, r2]
 8000876:	2b01      	cmp	r3, #1
 8000878:	d101      	bne.n	800087e <HAL_UART_Transmit+0x5a>
 800087a:	2302      	movs	r3, #2
 800087c:	e075      	b.n	800096a <HAL_UART_Transmit+0x146>
 800087e:	68fb      	ldr	r3, [r7, #12]
 8000880:	2270      	movs	r2, #112	; 0x70
 8000882:	2101      	movs	r1, #1
 8000884:	5499      	strb	r1, [r3, r2]

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8000886:	68fb      	ldr	r3, [r7, #12]
 8000888:	2200      	movs	r2, #0
 800088a:	67da      	str	r2, [r3, #124]	; 0x7c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800088c:	68fb      	ldr	r3, [r7, #12]
 800088e:	2221      	movs	r2, #33	; 0x21
 8000890:	675a      	str	r2, [r3, #116]	; 0x74

    /* Init tickstart for timeout managment*/
    tickstart = HAL_GetTick();
 8000892:	f00a f85d 	bl	800a950 <HAL_GetTick>
 8000896:	0003      	movs	r3, r0
 8000898:	617b      	str	r3, [r7, #20]

    huart->TxXferSize  = Size;
 800089a:	68fb      	ldr	r3, [r7, #12]
 800089c:	1dba      	adds	r2, r7, #6
 800089e:	2150      	movs	r1, #80	; 0x50
 80008a0:	8812      	ldrh	r2, [r2, #0]
 80008a2:	525a      	strh	r2, [r3, r1]
    huart->TxXferCount = Size;
 80008a4:	68fb      	ldr	r3, [r7, #12]
 80008a6:	1dba      	adds	r2, r7, #6
 80008a8:	2152      	movs	r1, #82	; 0x52
 80008aa:	8812      	ldrh	r2, [r2, #0]
 80008ac:	525a      	strh	r2, [r3, r1]

        /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80008ae:	68fb      	ldr	r3, [r7, #12]
 80008b0:	689a      	ldr	r2, [r3, #8]
 80008b2:	2380      	movs	r3, #128	; 0x80
 80008b4:	015b      	lsls	r3, r3, #5
 80008b6:	429a      	cmp	r2, r3
 80008b8:	d108      	bne.n	80008cc <HAL_UART_Transmit+0xa8>
 80008ba:	68fb      	ldr	r3, [r7, #12]
 80008bc:	691b      	ldr	r3, [r3, #16]
 80008be:	2b00      	cmp	r3, #0
 80008c0:	d104      	bne.n	80008cc <HAL_UART_Transmit+0xa8>
    {
      pdata8bits  = NULL;
 80008c2:	2300      	movs	r3, #0
 80008c4:	61fb      	str	r3, [r7, #28]
      pdata16bits = (uint16_t *) pData;
 80008c6:	68bb      	ldr	r3, [r7, #8]
 80008c8:	61bb      	str	r3, [r7, #24]
 80008ca:	e003      	b.n	80008d4 <HAL_UART_Transmit+0xb0>
    }
    else
    {
      pdata8bits  = pData;
 80008cc:	68bb      	ldr	r3, [r7, #8]
 80008ce:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 80008d0:	2300      	movs	r3, #0
 80008d2:	61bb      	str	r3, [r7, #24]
    }

    while (huart->TxXferCount > 0U)
 80008d4:	e02c      	b.n	8000930 <HAL_UART_Transmit+0x10c>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 80008d6:	697a      	ldr	r2, [r7, #20]
 80008d8:	68f8      	ldr	r0, [r7, #12]
 80008da:	683b      	ldr	r3, [r7, #0]
 80008dc:	9300      	str	r3, [sp, #0]
 80008de:	0013      	movs	r3, r2
 80008e0:	2200      	movs	r2, #0
 80008e2:	2180      	movs	r1, #128	; 0x80
 80008e4:	f000 fc74 	bl	80011d0 <UART_WaitOnFlagUntilTimeout>
 80008e8:	1e03      	subs	r3, r0, #0
 80008ea:	d001      	beq.n	80008f0 <HAL_UART_Transmit+0xcc>
      {
        return HAL_TIMEOUT;
 80008ec:	2303      	movs	r3, #3
 80008ee:	e03c      	b.n	800096a <HAL_UART_Transmit+0x146>
      }
      if (pdata8bits == NULL)
 80008f0:	69fb      	ldr	r3, [r7, #28]
 80008f2:	2b00      	cmp	r3, #0
 80008f4:	d10b      	bne.n	800090e <HAL_UART_Transmit+0xea>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 80008f6:	69bb      	ldr	r3, [r7, #24]
 80008f8:	881b      	ldrh	r3, [r3, #0]
 80008fa:	001a      	movs	r2, r3
 80008fc:	68fb      	ldr	r3, [r7, #12]
 80008fe:	681b      	ldr	r3, [r3, #0]
 8000900:	05d2      	lsls	r2, r2, #23
 8000902:	0dd2      	lsrs	r2, r2, #23
 8000904:	629a      	str	r2, [r3, #40]	; 0x28
        pdata16bits++;
 8000906:	69bb      	ldr	r3, [r7, #24]
 8000908:	3302      	adds	r3, #2
 800090a:	61bb      	str	r3, [r7, #24]
 800090c:	e007      	b.n	800091e <HAL_UART_Transmit+0xfa>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800090e:	69fb      	ldr	r3, [r7, #28]
 8000910:	781a      	ldrb	r2, [r3, #0]
 8000912:	68fb      	ldr	r3, [r7, #12]
 8000914:	681b      	ldr	r3, [r3, #0]
 8000916:	629a      	str	r2, [r3, #40]	; 0x28
        pdata8bits++;
 8000918:	69fb      	ldr	r3, [r7, #28]
 800091a:	3301      	adds	r3, #1
 800091c:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 800091e:	68fb      	ldr	r3, [r7, #12]
 8000920:	2252      	movs	r2, #82	; 0x52
 8000922:	5a9b      	ldrh	r3, [r3, r2]
 8000924:	b29b      	uxth	r3, r3
 8000926:	3b01      	subs	r3, #1
 8000928:	b299      	uxth	r1, r3
 800092a:	68fb      	ldr	r3, [r7, #12]
 800092c:	2252      	movs	r2, #82	; 0x52
 800092e:	5299      	strh	r1, [r3, r2]
    while (huart->TxXferCount > 0U)
 8000930:	68fb      	ldr	r3, [r7, #12]
 8000932:	2252      	movs	r2, #82	; 0x52
 8000934:	5a9b      	ldrh	r3, [r3, r2]
 8000936:	b29b      	uxth	r3, r3
 8000938:	2b00      	cmp	r3, #0
 800093a:	d1cc      	bne.n	80008d6 <HAL_UART_Transmit+0xb2>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 800093c:	697a      	ldr	r2, [r7, #20]
 800093e:	68f8      	ldr	r0, [r7, #12]
 8000940:	683b      	ldr	r3, [r7, #0]
 8000942:	9300      	str	r3, [sp, #0]
 8000944:	0013      	movs	r3, r2
 8000946:	2200      	movs	r2, #0
 8000948:	2140      	movs	r1, #64	; 0x40
 800094a:	f000 fc41 	bl	80011d0 <UART_WaitOnFlagUntilTimeout>
 800094e:	1e03      	subs	r3, r0, #0
 8000950:	d001      	beq.n	8000956 <HAL_UART_Transmit+0x132>
    {
      return HAL_TIMEOUT;
 8000952:	2303      	movs	r3, #3
 8000954:	e009      	b.n	800096a <HAL_UART_Transmit+0x146>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 8000956:	68fb      	ldr	r3, [r7, #12]
 8000958:	2220      	movs	r2, #32
 800095a:	675a      	str	r2, [r3, #116]	; 0x74

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 800095c:	68fb      	ldr	r3, [r7, #12]
 800095e:	2270      	movs	r2, #112	; 0x70
 8000960:	2100      	movs	r1, #0
 8000962:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
 8000964:	2300      	movs	r3, #0
 8000966:	e000      	b.n	800096a <HAL_UART_Transmit+0x146>
  }
  else
  {
    return HAL_BUSY;
 8000968:	2302      	movs	r3, #2
  }
}
 800096a:	0018      	movs	r0, r3
 800096c:	46bd      	mov	sp, r7
 800096e:	b008      	add	sp, #32
 8000970:	bd80      	pop	{r7, pc}
	...

08000974 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8000974:	b5b0      	push	{r4, r5, r7, lr}
 8000976:	b08e      	sub	sp, #56	; 0x38
 8000978:	af00      	add	r7, sp, #0
 800097a:	61f8      	str	r0, [r7, #28]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
 800097c:	231b      	movs	r3, #27
 800097e:	2218      	movs	r2, #24
 8000980:	4694      	mov	ip, r2
 8000982:	44bc      	add	ip, r7
 8000984:	4463      	add	r3, ip
 8000986:	2210      	movs	r2, #16
 8000988:	701a      	strb	r2, [r3, #0]
  uint32_t usartdiv                   = 0x00000000U;
 800098a:	2300      	movs	r3, #0
 800098c:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_StatusTypeDef ret               = HAL_OK;
 800098e:	2313      	movs	r3, #19
 8000990:	2218      	movs	r2, #24
 8000992:	4694      	mov	ip, r2
 8000994:	44bc      	add	ip, r7
 8000996:	4463      	add	r3, ip
 8000998:	2200      	movs	r2, #0
 800099a:	701a      	strb	r2, [r3, #0]
  uint32_t lpuart_ker_ck_pres         = 0x00000000U;
 800099c:	2300      	movs	r3, #0
 800099e:	627b      	str	r3, [r7, #36]	; 0x24
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80009a0:	69fb      	ldr	r3, [r7, #28]
 80009a2:	689a      	ldr	r2, [r3, #8]
 80009a4:	69fb      	ldr	r3, [r7, #28]
 80009a6:	691b      	ldr	r3, [r3, #16]
 80009a8:	431a      	orrs	r2, r3
 80009aa:	69fb      	ldr	r3, [r7, #28]
 80009ac:	695b      	ldr	r3, [r3, #20]
 80009ae:	431a      	orrs	r2, r3
 80009b0:	69fb      	ldr	r3, [r7, #28]
 80009b2:	69db      	ldr	r3, [r3, #28]
 80009b4:	4313      	orrs	r3, r2
 80009b6:	637b      	str	r3, [r7, #52]	; 0x34
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80009b8:	69fb      	ldr	r3, [r7, #28]
 80009ba:	681b      	ldr	r3, [r3, #0]
 80009bc:	681b      	ldr	r3, [r3, #0]
 80009be:	4aca      	ldr	r2, [pc, #808]	; (8000ce8 <UART_SetConfig+0x374>)
 80009c0:	4013      	ands	r3, r2
 80009c2:	0019      	movs	r1, r3
 80009c4:	69fb      	ldr	r3, [r7, #28]
 80009c6:	681b      	ldr	r3, [r3, #0]
 80009c8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80009ca:	430a      	orrs	r2, r1
 80009cc:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80009ce:	69fb      	ldr	r3, [r7, #28]
 80009d0:	681b      	ldr	r3, [r3, #0]
 80009d2:	685b      	ldr	r3, [r3, #4]
 80009d4:	4ac5      	ldr	r2, [pc, #788]	; (8000cec <UART_SetConfig+0x378>)
 80009d6:	4013      	ands	r3, r2
 80009d8:	0019      	movs	r1, r3
 80009da:	69fb      	ldr	r3, [r7, #28]
 80009dc:	68da      	ldr	r2, [r3, #12]
 80009de:	69fb      	ldr	r3, [r7, #28]
 80009e0:	681b      	ldr	r3, [r3, #0]
 80009e2:	430a      	orrs	r2, r1
 80009e4:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 80009e6:	69fb      	ldr	r3, [r7, #28]
 80009e8:	699b      	ldr	r3, [r3, #24]
 80009ea:	637b      	str	r3, [r7, #52]	; 0x34

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80009ec:	69fb      	ldr	r3, [r7, #28]
 80009ee:	681b      	ldr	r3, [r3, #0]
 80009f0:	4abf      	ldr	r2, [pc, #764]	; (8000cf0 <UART_SetConfig+0x37c>)
 80009f2:	4293      	cmp	r3, r2
 80009f4:	d004      	beq.n	8000a00 <UART_SetConfig+0x8c>
  {
    tmpreg |= huart->Init.OneBitSampling;
 80009f6:	69fb      	ldr	r3, [r7, #28]
 80009f8:	6a1b      	ldr	r3, [r3, #32]
 80009fa:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80009fc:	4313      	orrs	r3, r2
 80009fe:	637b      	str	r3, [r7, #52]	; 0x34
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8000a00:	69fb      	ldr	r3, [r7, #28]
 8000a02:	681b      	ldr	r3, [r3, #0]
 8000a04:	689b      	ldr	r3, [r3, #8]
 8000a06:	4abb      	ldr	r2, [pc, #748]	; (8000cf4 <UART_SetConfig+0x380>)
 8000a08:	4013      	ands	r3, r2
 8000a0a:	0019      	movs	r1, r3
 8000a0c:	69fb      	ldr	r3, [r7, #28]
 8000a0e:	681b      	ldr	r3, [r3, #0]
 8000a10:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8000a12:	430a      	orrs	r2, r1
 8000a14:	609a      	str	r2, [r3, #8]


  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8000a16:	69fb      	ldr	r3, [r7, #28]
 8000a18:	681b      	ldr	r3, [r3, #0]
 8000a1a:	4ab7      	ldr	r2, [pc, #732]	; (8000cf8 <UART_SetConfig+0x384>)
 8000a1c:	4293      	cmp	r3, r2
 8000a1e:	d134      	bne.n	8000a8a <UART_SetConfig+0x116>
 8000a20:	4bb6      	ldr	r3, [pc, #728]	; (8000cfc <UART_SetConfig+0x388>)
 8000a22:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000a24:	2203      	movs	r2, #3
 8000a26:	4013      	ands	r3, r2
 8000a28:	2b01      	cmp	r3, #1
 8000a2a:	d015      	beq.n	8000a58 <UART_SetConfig+0xe4>
 8000a2c:	d304      	bcc.n	8000a38 <UART_SetConfig+0xc4>
 8000a2e:	2b02      	cmp	r3, #2
 8000a30:	d00a      	beq.n	8000a48 <UART_SetConfig+0xd4>
 8000a32:	2b03      	cmp	r3, #3
 8000a34:	d018      	beq.n	8000a68 <UART_SetConfig+0xf4>
 8000a36:	e01f      	b.n	8000a78 <UART_SetConfig+0x104>
 8000a38:	231b      	movs	r3, #27
 8000a3a:	2218      	movs	r2, #24
 8000a3c:	4694      	mov	ip, r2
 8000a3e:	44bc      	add	ip, r7
 8000a40:	4463      	add	r3, ip
 8000a42:	2201      	movs	r2, #1
 8000a44:	701a      	strb	r2, [r3, #0]
 8000a46:	e0c5      	b.n	8000bd4 <UART_SetConfig+0x260>
 8000a48:	231b      	movs	r3, #27
 8000a4a:	2218      	movs	r2, #24
 8000a4c:	4694      	mov	ip, r2
 8000a4e:	44bc      	add	ip, r7
 8000a50:	4463      	add	r3, ip
 8000a52:	2202      	movs	r2, #2
 8000a54:	701a      	strb	r2, [r3, #0]
 8000a56:	e0bd      	b.n	8000bd4 <UART_SetConfig+0x260>
 8000a58:	231b      	movs	r3, #27
 8000a5a:	2218      	movs	r2, #24
 8000a5c:	4694      	mov	ip, r2
 8000a5e:	44bc      	add	ip, r7
 8000a60:	4463      	add	r3, ip
 8000a62:	2204      	movs	r2, #4
 8000a64:	701a      	strb	r2, [r3, #0]
 8000a66:	e0b5      	b.n	8000bd4 <UART_SetConfig+0x260>
 8000a68:	231b      	movs	r3, #27
 8000a6a:	2218      	movs	r2, #24
 8000a6c:	4694      	mov	ip, r2
 8000a6e:	44bc      	add	ip, r7
 8000a70:	4463      	add	r3, ip
 8000a72:	2208      	movs	r2, #8
 8000a74:	701a      	strb	r2, [r3, #0]
 8000a76:	e0ad      	b.n	8000bd4 <UART_SetConfig+0x260>
 8000a78:	231b      	movs	r3, #27
 8000a7a:	2218      	movs	r2, #24
 8000a7c:	4694      	mov	ip, r2
 8000a7e:	44bc      	add	ip, r7
 8000a80:	4463      	add	r3, ip
 8000a82:	2210      	movs	r2, #16
 8000a84:	701a      	strb	r2, [r3, #0]
 8000a86:	46c0      	nop			; (mov r8, r8)
 8000a88:	e0a4      	b.n	8000bd4 <UART_SetConfig+0x260>
 8000a8a:	69fb      	ldr	r3, [r7, #28]
 8000a8c:	681b      	ldr	r3, [r3, #0]
 8000a8e:	4a9c      	ldr	r2, [pc, #624]	; (8000d00 <UART_SetConfig+0x38c>)
 8000a90:	4293      	cmp	r3, r2
 8000a92:	d137      	bne.n	8000b04 <UART_SetConfig+0x190>
 8000a94:	4b99      	ldr	r3, [pc, #612]	; (8000cfc <UART_SetConfig+0x388>)
 8000a96:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000a98:	220c      	movs	r2, #12
 8000a9a:	4013      	ands	r3, r2
 8000a9c:	2b04      	cmp	r3, #4
 8000a9e:	d018      	beq.n	8000ad2 <UART_SetConfig+0x15e>
 8000aa0:	d802      	bhi.n	8000aa8 <UART_SetConfig+0x134>
 8000aa2:	2b00      	cmp	r3, #0
 8000aa4:	d005      	beq.n	8000ab2 <UART_SetConfig+0x13e>
 8000aa6:	e024      	b.n	8000af2 <UART_SetConfig+0x17e>
 8000aa8:	2b08      	cmp	r3, #8
 8000aaa:	d00a      	beq.n	8000ac2 <UART_SetConfig+0x14e>
 8000aac:	2b0c      	cmp	r3, #12
 8000aae:	d018      	beq.n	8000ae2 <UART_SetConfig+0x16e>
 8000ab0:	e01f      	b.n	8000af2 <UART_SetConfig+0x17e>
 8000ab2:	231b      	movs	r3, #27
 8000ab4:	2218      	movs	r2, #24
 8000ab6:	4694      	mov	ip, r2
 8000ab8:	44bc      	add	ip, r7
 8000aba:	4463      	add	r3, ip
 8000abc:	2200      	movs	r2, #0
 8000abe:	701a      	strb	r2, [r3, #0]
 8000ac0:	e088      	b.n	8000bd4 <UART_SetConfig+0x260>
 8000ac2:	231b      	movs	r3, #27
 8000ac4:	2218      	movs	r2, #24
 8000ac6:	4694      	mov	ip, r2
 8000ac8:	44bc      	add	ip, r7
 8000aca:	4463      	add	r3, ip
 8000acc:	2202      	movs	r2, #2
 8000ace:	701a      	strb	r2, [r3, #0]
 8000ad0:	e080      	b.n	8000bd4 <UART_SetConfig+0x260>
 8000ad2:	231b      	movs	r3, #27
 8000ad4:	2218      	movs	r2, #24
 8000ad6:	4694      	mov	ip, r2
 8000ad8:	44bc      	add	ip, r7
 8000ada:	4463      	add	r3, ip
 8000adc:	2204      	movs	r2, #4
 8000ade:	701a      	strb	r2, [r3, #0]
 8000ae0:	e078      	b.n	8000bd4 <UART_SetConfig+0x260>
 8000ae2:	231b      	movs	r3, #27
 8000ae4:	2218      	movs	r2, #24
 8000ae6:	4694      	mov	ip, r2
 8000ae8:	44bc      	add	ip, r7
 8000aea:	4463      	add	r3, ip
 8000aec:	2208      	movs	r2, #8
 8000aee:	701a      	strb	r2, [r3, #0]
 8000af0:	e070      	b.n	8000bd4 <UART_SetConfig+0x260>
 8000af2:	231b      	movs	r3, #27
 8000af4:	2218      	movs	r2, #24
 8000af6:	4694      	mov	ip, r2
 8000af8:	44bc      	add	ip, r7
 8000afa:	4463      	add	r3, ip
 8000afc:	2210      	movs	r2, #16
 8000afe:	701a      	strb	r2, [r3, #0]
 8000b00:	46c0      	nop			; (mov r8, r8)
 8000b02:	e067      	b.n	8000bd4 <UART_SetConfig+0x260>
 8000b04:	69fb      	ldr	r3, [r7, #28]
 8000b06:	681b      	ldr	r3, [r3, #0]
 8000b08:	4a7e      	ldr	r2, [pc, #504]	; (8000d04 <UART_SetConfig+0x390>)
 8000b0a:	4293      	cmp	r3, r2
 8000b0c:	d107      	bne.n	8000b1e <UART_SetConfig+0x1aa>
 8000b0e:	231b      	movs	r3, #27
 8000b10:	2218      	movs	r2, #24
 8000b12:	4694      	mov	ip, r2
 8000b14:	44bc      	add	ip, r7
 8000b16:	4463      	add	r3, ip
 8000b18:	2200      	movs	r2, #0
 8000b1a:	701a      	strb	r2, [r3, #0]
 8000b1c:	e05a      	b.n	8000bd4 <UART_SetConfig+0x260>
 8000b1e:	69fb      	ldr	r3, [r7, #28]
 8000b20:	681b      	ldr	r3, [r3, #0]
 8000b22:	4a79      	ldr	r2, [pc, #484]	; (8000d08 <UART_SetConfig+0x394>)
 8000b24:	4293      	cmp	r3, r2
 8000b26:	d107      	bne.n	8000b38 <UART_SetConfig+0x1c4>
 8000b28:	231b      	movs	r3, #27
 8000b2a:	2218      	movs	r2, #24
 8000b2c:	4694      	mov	ip, r2
 8000b2e:	44bc      	add	ip, r7
 8000b30:	4463      	add	r3, ip
 8000b32:	2200      	movs	r2, #0
 8000b34:	701a      	strb	r2, [r3, #0]
 8000b36:	e04d      	b.n	8000bd4 <UART_SetConfig+0x260>
 8000b38:	69fb      	ldr	r3, [r7, #28]
 8000b3a:	681b      	ldr	r3, [r3, #0]
 8000b3c:	4a6c      	ldr	r2, [pc, #432]	; (8000cf0 <UART_SetConfig+0x37c>)
 8000b3e:	4293      	cmp	r3, r2
 8000b40:	d141      	bne.n	8000bc6 <UART_SetConfig+0x252>
 8000b42:	4b6e      	ldr	r3, [pc, #440]	; (8000cfc <UART_SetConfig+0x388>)
 8000b44:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000b46:	23c0      	movs	r3, #192	; 0xc0
 8000b48:	011b      	lsls	r3, r3, #4
 8000b4a:	4013      	ands	r3, r2
 8000b4c:	2280      	movs	r2, #128	; 0x80
 8000b4e:	00d2      	lsls	r2, r2, #3
 8000b50:	4293      	cmp	r3, r2
 8000b52:	d01f      	beq.n	8000b94 <UART_SetConfig+0x220>
 8000b54:	2280      	movs	r2, #128	; 0x80
 8000b56:	00d2      	lsls	r2, r2, #3
 8000b58:	4293      	cmp	r3, r2
 8000b5a:	d802      	bhi.n	8000b62 <UART_SetConfig+0x1ee>
 8000b5c:	2b00      	cmp	r3, #0
 8000b5e:	d009      	beq.n	8000b74 <UART_SetConfig+0x200>
 8000b60:	e028      	b.n	8000bb4 <UART_SetConfig+0x240>
 8000b62:	2280      	movs	r2, #128	; 0x80
 8000b64:	0112      	lsls	r2, r2, #4
 8000b66:	4293      	cmp	r3, r2
 8000b68:	d00c      	beq.n	8000b84 <UART_SetConfig+0x210>
 8000b6a:	22c0      	movs	r2, #192	; 0xc0
 8000b6c:	0112      	lsls	r2, r2, #4
 8000b6e:	4293      	cmp	r3, r2
 8000b70:	d018      	beq.n	8000ba4 <UART_SetConfig+0x230>
 8000b72:	e01f      	b.n	8000bb4 <UART_SetConfig+0x240>
 8000b74:	231b      	movs	r3, #27
 8000b76:	2218      	movs	r2, #24
 8000b78:	4694      	mov	ip, r2
 8000b7a:	44bc      	add	ip, r7
 8000b7c:	4463      	add	r3, ip
 8000b7e:	2200      	movs	r2, #0
 8000b80:	701a      	strb	r2, [r3, #0]
 8000b82:	e027      	b.n	8000bd4 <UART_SetConfig+0x260>
 8000b84:	231b      	movs	r3, #27
 8000b86:	2218      	movs	r2, #24
 8000b88:	4694      	mov	ip, r2
 8000b8a:	44bc      	add	ip, r7
 8000b8c:	4463      	add	r3, ip
 8000b8e:	2202      	movs	r2, #2
 8000b90:	701a      	strb	r2, [r3, #0]
 8000b92:	e01f      	b.n	8000bd4 <UART_SetConfig+0x260>
 8000b94:	231b      	movs	r3, #27
 8000b96:	2218      	movs	r2, #24
 8000b98:	4694      	mov	ip, r2
 8000b9a:	44bc      	add	ip, r7
 8000b9c:	4463      	add	r3, ip
 8000b9e:	2204      	movs	r2, #4
 8000ba0:	701a      	strb	r2, [r3, #0]
 8000ba2:	e017      	b.n	8000bd4 <UART_SetConfig+0x260>
 8000ba4:	231b      	movs	r3, #27
 8000ba6:	2218      	movs	r2, #24
 8000ba8:	4694      	mov	ip, r2
 8000baa:	44bc      	add	ip, r7
 8000bac:	4463      	add	r3, ip
 8000bae:	2208      	movs	r2, #8
 8000bb0:	701a      	strb	r2, [r3, #0]
 8000bb2:	e00f      	b.n	8000bd4 <UART_SetConfig+0x260>
 8000bb4:	231b      	movs	r3, #27
 8000bb6:	2218      	movs	r2, #24
 8000bb8:	4694      	mov	ip, r2
 8000bba:	44bc      	add	ip, r7
 8000bbc:	4463      	add	r3, ip
 8000bbe:	2210      	movs	r2, #16
 8000bc0:	701a      	strb	r2, [r3, #0]
 8000bc2:	46c0      	nop			; (mov r8, r8)
 8000bc4:	e006      	b.n	8000bd4 <UART_SetConfig+0x260>
 8000bc6:	231b      	movs	r3, #27
 8000bc8:	2218      	movs	r2, #24
 8000bca:	4694      	mov	ip, r2
 8000bcc:	44bc      	add	ip, r7
 8000bce:	4463      	add	r3, ip
 8000bd0:	2210      	movs	r2, #16
 8000bd2:	701a      	strb	r2, [r3, #0]

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 8000bd4:	69fb      	ldr	r3, [r7, #28]
 8000bd6:	681b      	ldr	r3, [r3, #0]
 8000bd8:	4a45      	ldr	r2, [pc, #276]	; (8000cf0 <UART_SetConfig+0x37c>)
 8000bda:	4293      	cmp	r3, r2
 8000bdc:	d000      	beq.n	8000be0 <UART_SetConfig+0x26c>
 8000bde:	e09d      	b.n	8000d1c <UART_SetConfig+0x3a8>
  {
    /* Retrieve frequency clock */
    switch (clocksource)
 8000be0:	231b      	movs	r3, #27
 8000be2:	2218      	movs	r2, #24
 8000be4:	4694      	mov	ip, r2
 8000be6:	44bc      	add	ip, r7
 8000be8:	4463      	add	r3, ip
 8000bea:	781b      	ldrb	r3, [r3, #0]
 8000bec:	2b02      	cmp	r3, #2
 8000bee:	d00d      	beq.n	8000c0c <UART_SetConfig+0x298>
 8000bf0:	dc02      	bgt.n	8000bf8 <UART_SetConfig+0x284>
 8000bf2:	2b00      	cmp	r3, #0
 8000bf4:	d005      	beq.n	8000c02 <UART_SetConfig+0x28e>
 8000bf6:	e01d      	b.n	8000c34 <UART_SetConfig+0x2c0>
 8000bf8:	2b04      	cmp	r3, #4
 8000bfa:	d012      	beq.n	8000c22 <UART_SetConfig+0x2ae>
 8000bfc:	2b08      	cmp	r3, #8
 8000bfe:	d015      	beq.n	8000c2c <UART_SetConfig+0x2b8>
 8000c00:	e018      	b.n	8000c34 <UART_SetConfig+0x2c0>
    {
      case UART_CLOCKSOURCE_PCLK1:
        lpuart_ker_ck_pres = HAL_RCC_GetPCLK1Freq();
 8000c02:	f00b f9c3 	bl	800bf8c <HAL_RCC_GetPCLK1Freq>
 8000c06:	0003      	movs	r3, r0
 8000c08:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 8000c0a:	e01b      	b.n	8000c44 <UART_SetConfig+0x2d0>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8000c0c:	4b3b      	ldr	r3, [pc, #236]	; (8000cfc <UART_SetConfig+0x388>)
 8000c0e:	681b      	ldr	r3, [r3, #0]
 8000c10:	2210      	movs	r2, #16
 8000c12:	4013      	ands	r3, r2
 8000c14:	d002      	beq.n	8000c1c <UART_SetConfig+0x2a8>
        {
          lpuart_ker_ck_pres = (uint32_t)(HSI_VALUE >> 2U);
 8000c16:	4b3d      	ldr	r3, [pc, #244]	; (8000d0c <UART_SetConfig+0x398>)
 8000c18:	627b      	str	r3, [r7, #36]	; 0x24
        }
        else
        {
          lpuart_ker_ck_pres = (uint32_t)HSI_VALUE;
        }
        break;
 8000c1a:	e013      	b.n	8000c44 <UART_SetConfig+0x2d0>
          lpuart_ker_ck_pres = (uint32_t)HSI_VALUE;
 8000c1c:	4b3c      	ldr	r3, [pc, #240]	; (8000d10 <UART_SetConfig+0x39c>)
 8000c1e:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 8000c20:	e010      	b.n	8000c44 <UART_SetConfig+0x2d0>
      case UART_CLOCKSOURCE_SYSCLK:
        lpuart_ker_ck_pres = HAL_RCC_GetSysClockFreq();
 8000c22:	f00b f925 	bl	800be70 <HAL_RCC_GetSysClockFreq>
 8000c26:	0003      	movs	r3, r0
 8000c28:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 8000c2a:	e00b      	b.n	8000c44 <UART_SetConfig+0x2d0>
      case UART_CLOCKSOURCE_LSE:
        lpuart_ker_ck_pres = (uint32_t)LSE_VALUE;
 8000c2c:	2380      	movs	r3, #128	; 0x80
 8000c2e:	021b      	lsls	r3, r3, #8
 8000c30:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 8000c32:	e007      	b.n	8000c44 <UART_SetConfig+0x2d0>
      case UART_CLOCKSOURCE_UNDEFINED:
      default:
        ret = HAL_ERROR;
 8000c34:	2313      	movs	r3, #19
 8000c36:	2218      	movs	r2, #24
 8000c38:	4694      	mov	ip, r2
 8000c3a:	44bc      	add	ip, r7
 8000c3c:	4463      	add	r3, ip
 8000c3e:	2201      	movs	r2, #1
 8000c40:	701a      	strb	r2, [r3, #0]
        break;
 8000c42:	46c0      	nop			; (mov r8, r8)
    }

    /* if proper clock source reported */
    if (lpuart_ker_ck_pres != 0U)
 8000c44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000c46:	2b00      	cmp	r3, #0
 8000c48:	d100      	bne.n	8000c4c <UART_SetConfig+0x2d8>
 8000c4a:	e1a6      	b.n	8000f9a <UART_SetConfig+0x626>
    {
      /* ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8000c4c:	69fb      	ldr	r3, [r7, #28]
 8000c4e:	685a      	ldr	r2, [r3, #4]
 8000c50:	0013      	movs	r3, r2
 8000c52:	005b      	lsls	r3, r3, #1
 8000c54:	189b      	adds	r3, r3, r2
 8000c56:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8000c58:	429a      	cmp	r2, r3
 8000c5a:	d305      	bcc.n	8000c68 <UART_SetConfig+0x2f4>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
 8000c5c:	69fb      	ldr	r3, [r7, #28]
 8000c5e:	685b      	ldr	r3, [r3, #4]
 8000c60:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8000c62:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8000c64:	429a      	cmp	r2, r3
 8000c66:	d907      	bls.n	8000c78 <UART_SetConfig+0x304>
      {
        ret = HAL_ERROR;
 8000c68:	2313      	movs	r3, #19
 8000c6a:	2218      	movs	r2, #24
 8000c6c:	4694      	mov	ip, r2
 8000c6e:	44bc      	add	ip, r7
 8000c70:	4463      	add	r3, ip
 8000c72:	2201      	movs	r2, #1
 8000c74:	701a      	strb	r2, [r3, #0]
 8000c76:	e190      	b.n	8000f9a <UART_SetConfig+0x626>
      }
      else
      {
        usartdiv = (uint32_t)(UART_DIV_LPUART(lpuart_ker_ck_pres, huart->Init.BaudRate));
 8000c78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000c7a:	613b      	str	r3, [r7, #16]
 8000c7c:	2300      	movs	r3, #0
 8000c7e:	617b      	str	r3, [r7, #20]
 8000c80:	6939      	ldr	r1, [r7, #16]
 8000c82:	697a      	ldr	r2, [r7, #20]
 8000c84:	000b      	movs	r3, r1
 8000c86:	0e1b      	lsrs	r3, r3, #24
 8000c88:	0010      	movs	r0, r2
 8000c8a:	0205      	lsls	r5, r0, #8
 8000c8c:	431d      	orrs	r5, r3
 8000c8e:	000b      	movs	r3, r1
 8000c90:	021c      	lsls	r4, r3, #8
 8000c92:	69fb      	ldr	r3, [r7, #28]
 8000c94:	685b      	ldr	r3, [r3, #4]
 8000c96:	085b      	lsrs	r3, r3, #1
 8000c98:	60bb      	str	r3, [r7, #8]
 8000c9a:	2300      	movs	r3, #0
 8000c9c:	60fb      	str	r3, [r7, #12]
 8000c9e:	68b8      	ldr	r0, [r7, #8]
 8000ca0:	68f9      	ldr	r1, [r7, #12]
 8000ca2:	1900      	adds	r0, r0, r4
 8000ca4:	4169      	adcs	r1, r5
 8000ca6:	69fb      	ldr	r3, [r7, #28]
 8000ca8:	685b      	ldr	r3, [r3, #4]
 8000caa:	603b      	str	r3, [r7, #0]
 8000cac:	2300      	movs	r3, #0
 8000cae:	607b      	str	r3, [r7, #4]
 8000cb0:	683a      	ldr	r2, [r7, #0]
 8000cb2:	687b      	ldr	r3, [r7, #4]
 8000cb4:	f7ff fb9e 	bl	80003f4 <__aeabi_uldivmod>
 8000cb8:	0003      	movs	r3, r0
 8000cba:	000c      	movs	r4, r1
 8000cbc:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* It is forbidden to write values lower than 0x300 in the LPUART_BRR register */
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8000cbe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000cc0:	4a14      	ldr	r2, [pc, #80]	; (8000d14 <UART_SetConfig+0x3a0>)
 8000cc2:	4293      	cmp	r3, r2
 8000cc4:	d908      	bls.n	8000cd8 <UART_SetConfig+0x364>
 8000cc6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000cc8:	4a13      	ldr	r2, [pc, #76]	; (8000d18 <UART_SetConfig+0x3a4>)
 8000cca:	4293      	cmp	r3, r2
 8000ccc:	d804      	bhi.n	8000cd8 <UART_SetConfig+0x364>
        {
          huart->Instance->BRR = usartdiv;
 8000cce:	69fb      	ldr	r3, [r7, #28]
 8000cd0:	681b      	ldr	r3, [r3, #0]
 8000cd2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8000cd4:	60da      	str	r2, [r3, #12]
 8000cd6:	e160      	b.n	8000f9a <UART_SetConfig+0x626>
        }
        else
        {
          ret = HAL_ERROR;
 8000cd8:	2313      	movs	r3, #19
 8000cda:	2218      	movs	r2, #24
 8000cdc:	4694      	mov	ip, r2
 8000cde:	44bc      	add	ip, r7
 8000ce0:	4463      	add	r3, ip
 8000ce2:	2201      	movs	r2, #1
 8000ce4:	701a      	strb	r2, [r3, #0]
 8000ce6:	e158      	b.n	8000f9a <UART_SetConfig+0x626>
 8000ce8:	efff69f3 	.word	0xefff69f3
 8000cec:	ffffcfff 	.word	0xffffcfff
 8000cf0:	40004800 	.word	0x40004800
 8000cf4:	fffff4ff 	.word	0xfffff4ff
 8000cf8:	40013800 	.word	0x40013800
 8000cfc:	40021000 	.word	0x40021000
 8000d00:	40004400 	.word	0x40004400
 8000d04:	40004c00 	.word	0x40004c00
 8000d08:	40005000 	.word	0x40005000
 8000d0c:	003d0900 	.word	0x003d0900
 8000d10:	00f42400 	.word	0x00f42400
 8000d14:	000002ff 	.word	0x000002ff
 8000d18:	000fffff 	.word	0x000fffff
        }
      } /*   if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) || (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (lpuart_ker_ck_pres != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8000d1c:	69fb      	ldr	r3, [r7, #28]
 8000d1e:	69da      	ldr	r2, [r3, #28]
 8000d20:	2380      	movs	r3, #128	; 0x80
 8000d22:	021b      	lsls	r3, r3, #8
 8000d24:	429a      	cmp	r2, r3
 8000d26:	d000      	beq.n	8000d2a <UART_SetConfig+0x3b6>
 8000d28:	e0a9      	b.n	8000e7e <UART_SetConfig+0x50a>
  {
    switch (clocksource)
 8000d2a:	231b      	movs	r3, #27
 8000d2c:	2218      	movs	r2, #24
 8000d2e:	4694      	mov	ip, r2
 8000d30:	44bc      	add	ip, r7
 8000d32:	4463      	add	r3, ip
 8000d34:	781b      	ldrb	r3, [r3, #0]
 8000d36:	2b08      	cmp	r3, #8
 8000d38:	d86d      	bhi.n	8000e16 <UART_SetConfig+0x4a2>
 8000d3a:	009a      	lsls	r2, r3, #2
 8000d3c:	4b9f      	ldr	r3, [pc, #636]	; (8000fbc <UART_SetConfig+0x648>)
 8000d3e:	18d3      	adds	r3, r2, r3
 8000d40:	681b      	ldr	r3, [r3, #0]
 8000d42:	469f      	mov	pc, r3
    {
      case UART_CLOCKSOURCE_PCLK1:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8000d44:	f00b f922 	bl	800bf8c <HAL_RCC_GetPCLK1Freq>
 8000d48:	0003      	movs	r3, r0
 8000d4a:	005a      	lsls	r2, r3, #1
 8000d4c:	69fb      	ldr	r3, [r7, #28]
 8000d4e:	685b      	ldr	r3, [r3, #4]
 8000d50:	085b      	lsrs	r3, r3, #1
 8000d52:	18d2      	adds	r2, r2, r3
 8000d54:	69fb      	ldr	r3, [r7, #28]
 8000d56:	685b      	ldr	r3, [r3, #4]
 8000d58:	0019      	movs	r1, r3
 8000d5a:	0010      	movs	r0, r2
 8000d5c:	f7ff f9d4 	bl	8000108 <__udivsi3>
 8000d60:	0003      	movs	r3, r0
 8000d62:	b29b      	uxth	r3, r3
 8000d64:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8000d66:	e05e      	b.n	8000e26 <UART_SetConfig+0x4b2>
      case UART_CLOCKSOURCE_PCLK2:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 8000d68:	f00b f926 	bl	800bfb8 <HAL_RCC_GetPCLK2Freq>
 8000d6c:	0003      	movs	r3, r0
 8000d6e:	005a      	lsls	r2, r3, #1
 8000d70:	69fb      	ldr	r3, [r7, #28]
 8000d72:	685b      	ldr	r3, [r3, #4]
 8000d74:	085b      	lsrs	r3, r3, #1
 8000d76:	18d2      	adds	r2, r2, r3
 8000d78:	69fb      	ldr	r3, [r7, #28]
 8000d7a:	685b      	ldr	r3, [r3, #4]
 8000d7c:	0019      	movs	r1, r3
 8000d7e:	0010      	movs	r0, r2
 8000d80:	f7ff f9c2 	bl	8000108 <__udivsi3>
 8000d84:	0003      	movs	r3, r0
 8000d86:	b29b      	uxth	r3, r3
 8000d88:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8000d8a:	e04c      	b.n	8000e26 <UART_SetConfig+0x4b2>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8000d8c:	4b8c      	ldr	r3, [pc, #560]	; (8000fc0 <UART_SetConfig+0x64c>)
 8000d8e:	681b      	ldr	r3, [r3, #0]
 8000d90:	2210      	movs	r2, #16
 8000d92:	4013      	ands	r3, r2
 8000d94:	d00e      	beq.n	8000db4 <UART_SetConfig+0x440>
        {
          usartdiv = (uint16_t)(UART_DIV_SAMPLING8((HSI_VALUE >> 2U), huart->Init.BaudRate));
 8000d96:	69fb      	ldr	r3, [r7, #28]
 8000d98:	685b      	ldr	r3, [r3, #4]
 8000d9a:	085b      	lsrs	r3, r3, #1
 8000d9c:	4a89      	ldr	r2, [pc, #548]	; (8000fc4 <UART_SetConfig+0x650>)
 8000d9e:	189a      	adds	r2, r3, r2
 8000da0:	69fb      	ldr	r3, [r7, #28]
 8000da2:	685b      	ldr	r3, [r3, #4]
 8000da4:	0019      	movs	r1, r3
 8000da6:	0010      	movs	r0, r2
 8000da8:	f7ff f9ae 	bl	8000108 <__udivsi3>
 8000dac:	0003      	movs	r3, r0
 8000dae:	b29b      	uxth	r3, r3
 8000db0:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
        }
        break;
 8000db2:	e038      	b.n	8000e26 <UART_SetConfig+0x4b2>
          usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 8000db4:	69fb      	ldr	r3, [r7, #28]
 8000db6:	685b      	ldr	r3, [r3, #4]
 8000db8:	085b      	lsrs	r3, r3, #1
 8000dba:	4a83      	ldr	r2, [pc, #524]	; (8000fc8 <UART_SetConfig+0x654>)
 8000dbc:	189a      	adds	r2, r3, r2
 8000dbe:	69fb      	ldr	r3, [r7, #28]
 8000dc0:	685b      	ldr	r3, [r3, #4]
 8000dc2:	0019      	movs	r1, r3
 8000dc4:	0010      	movs	r0, r2
 8000dc6:	f7ff f99f 	bl	8000108 <__udivsi3>
 8000dca:	0003      	movs	r3, r0
 8000dcc:	b29b      	uxth	r3, r3
 8000dce:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8000dd0:	e029      	b.n	8000e26 <UART_SetConfig+0x4b2>
      case UART_CLOCKSOURCE_SYSCLK:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8000dd2:	f00b f84d 	bl	800be70 <HAL_RCC_GetSysClockFreq>
 8000dd6:	0003      	movs	r3, r0
 8000dd8:	005a      	lsls	r2, r3, #1
 8000dda:	69fb      	ldr	r3, [r7, #28]
 8000ddc:	685b      	ldr	r3, [r3, #4]
 8000dde:	085b      	lsrs	r3, r3, #1
 8000de0:	18d2      	adds	r2, r2, r3
 8000de2:	69fb      	ldr	r3, [r7, #28]
 8000de4:	685b      	ldr	r3, [r3, #4]
 8000de6:	0019      	movs	r1, r3
 8000de8:	0010      	movs	r0, r2
 8000dea:	f7ff f98d 	bl	8000108 <__udivsi3>
 8000dee:	0003      	movs	r3, r0
 8000df0:	b29b      	uxth	r3, r3
 8000df2:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8000df4:	e017      	b.n	8000e26 <UART_SetConfig+0x4b2>
      case UART_CLOCKSOURCE_LSE:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 8000df6:	69fb      	ldr	r3, [r7, #28]
 8000df8:	685b      	ldr	r3, [r3, #4]
 8000dfa:	085b      	lsrs	r3, r3, #1
 8000dfc:	2280      	movs	r2, #128	; 0x80
 8000dfe:	0252      	lsls	r2, r2, #9
 8000e00:	189a      	adds	r2, r3, r2
 8000e02:	69fb      	ldr	r3, [r7, #28]
 8000e04:	685b      	ldr	r3, [r3, #4]
 8000e06:	0019      	movs	r1, r3
 8000e08:	0010      	movs	r0, r2
 8000e0a:	f7ff f97d 	bl	8000108 <__udivsi3>
 8000e0e:	0003      	movs	r3, r0
 8000e10:	b29b      	uxth	r3, r3
 8000e12:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8000e14:	e007      	b.n	8000e26 <UART_SetConfig+0x4b2>
      case UART_CLOCKSOURCE_UNDEFINED:
      default:
        ret = HAL_ERROR;
 8000e16:	2313      	movs	r3, #19
 8000e18:	2218      	movs	r2, #24
 8000e1a:	4694      	mov	ip, r2
 8000e1c:	44bc      	add	ip, r7
 8000e1e:	4463      	add	r3, ip
 8000e20:	2201      	movs	r2, #1
 8000e22:	701a      	strb	r2, [r3, #0]
        break;
 8000e24:	46c0      	nop			; (mov r8, r8)
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8000e26:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000e28:	2b0f      	cmp	r3, #15
 8000e2a:	d920      	bls.n	8000e6e <UART_SetConfig+0x4fa>
 8000e2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000e2e:	4a67      	ldr	r2, [pc, #412]	; (8000fcc <UART_SetConfig+0x658>)
 8000e30:	4293      	cmp	r3, r2
 8000e32:	d81c      	bhi.n	8000e6e <UART_SetConfig+0x4fa>
    {
      brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8000e34:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000e36:	b29a      	uxth	r2, r3
 8000e38:	200a      	movs	r0, #10
 8000e3a:	2418      	movs	r4, #24
 8000e3c:	193b      	adds	r3, r7, r4
 8000e3e:	181b      	adds	r3, r3, r0
 8000e40:	210f      	movs	r1, #15
 8000e42:	438a      	bics	r2, r1
 8000e44:	801a      	strh	r2, [r3, #0]
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8000e46:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000e48:	085b      	lsrs	r3, r3, #1
 8000e4a:	b29b      	uxth	r3, r3
 8000e4c:	2207      	movs	r2, #7
 8000e4e:	4013      	ands	r3, r2
 8000e50:	b299      	uxth	r1, r3
 8000e52:	193b      	adds	r3, r7, r4
 8000e54:	181b      	adds	r3, r3, r0
 8000e56:	193a      	adds	r2, r7, r4
 8000e58:	1812      	adds	r2, r2, r0
 8000e5a:	8812      	ldrh	r2, [r2, #0]
 8000e5c:	430a      	orrs	r2, r1
 8000e5e:	801a      	strh	r2, [r3, #0]
      huart->Instance->BRR = brrtemp;
 8000e60:	69fb      	ldr	r3, [r7, #28]
 8000e62:	681b      	ldr	r3, [r3, #0]
 8000e64:	193a      	adds	r2, r7, r4
 8000e66:	1812      	adds	r2, r2, r0
 8000e68:	8812      	ldrh	r2, [r2, #0]
 8000e6a:	60da      	str	r2, [r3, #12]
 8000e6c:	e095      	b.n	8000f9a <UART_SetConfig+0x626>
    }
    else
    {
      ret = HAL_ERROR;
 8000e6e:	2313      	movs	r3, #19
 8000e70:	2218      	movs	r2, #24
 8000e72:	4694      	mov	ip, r2
 8000e74:	44bc      	add	ip, r7
 8000e76:	4463      	add	r3, ip
 8000e78:	2201      	movs	r2, #1
 8000e7a:	701a      	strb	r2, [r3, #0]
 8000e7c:	e08d      	b.n	8000f9a <UART_SetConfig+0x626>
    }
  }
  else
  {
    switch (clocksource)
 8000e7e:	231b      	movs	r3, #27
 8000e80:	2218      	movs	r2, #24
 8000e82:	4694      	mov	ip, r2
 8000e84:	44bc      	add	ip, r7
 8000e86:	4463      	add	r3, ip
 8000e88:	781b      	ldrb	r3, [r3, #0]
 8000e8a:	2b08      	cmp	r3, #8
 8000e8c:	d86a      	bhi.n	8000f64 <UART_SetConfig+0x5f0>
 8000e8e:	009a      	lsls	r2, r3, #2
 8000e90:	4b4f      	ldr	r3, [pc, #316]	; (8000fd0 <UART_SetConfig+0x65c>)
 8000e92:	18d3      	adds	r3, r2, r3
 8000e94:	681b      	ldr	r3, [r3, #0]
 8000e96:	469f      	mov	pc, r3
    {
      case UART_CLOCKSOURCE_PCLK1:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8000e98:	f00b f878 	bl	800bf8c <HAL_RCC_GetPCLK1Freq>
 8000e9c:	0002      	movs	r2, r0
 8000e9e:	69fb      	ldr	r3, [r7, #28]
 8000ea0:	685b      	ldr	r3, [r3, #4]
 8000ea2:	085b      	lsrs	r3, r3, #1
 8000ea4:	18d2      	adds	r2, r2, r3
 8000ea6:	69fb      	ldr	r3, [r7, #28]
 8000ea8:	685b      	ldr	r3, [r3, #4]
 8000eaa:	0019      	movs	r1, r3
 8000eac:	0010      	movs	r0, r2
 8000eae:	f7ff f92b 	bl	8000108 <__udivsi3>
 8000eb2:	0003      	movs	r3, r0
 8000eb4:	b29b      	uxth	r3, r3
 8000eb6:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8000eb8:	e05c      	b.n	8000f74 <UART_SetConfig+0x600>
      case UART_CLOCKSOURCE_PCLK2:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 8000eba:	f00b f87d 	bl	800bfb8 <HAL_RCC_GetPCLK2Freq>
 8000ebe:	0002      	movs	r2, r0
 8000ec0:	69fb      	ldr	r3, [r7, #28]
 8000ec2:	685b      	ldr	r3, [r3, #4]
 8000ec4:	085b      	lsrs	r3, r3, #1
 8000ec6:	18d2      	adds	r2, r2, r3
 8000ec8:	69fb      	ldr	r3, [r7, #28]
 8000eca:	685b      	ldr	r3, [r3, #4]
 8000ecc:	0019      	movs	r1, r3
 8000ece:	0010      	movs	r0, r2
 8000ed0:	f7ff f91a 	bl	8000108 <__udivsi3>
 8000ed4:	0003      	movs	r3, r0
 8000ed6:	b29b      	uxth	r3, r3
 8000ed8:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8000eda:	e04b      	b.n	8000f74 <UART_SetConfig+0x600>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8000edc:	4b38      	ldr	r3, [pc, #224]	; (8000fc0 <UART_SetConfig+0x64c>)
 8000ede:	681b      	ldr	r3, [r3, #0]
 8000ee0:	2210      	movs	r2, #16
 8000ee2:	4013      	ands	r3, r2
 8000ee4:	d00e      	beq.n	8000f04 <UART_SetConfig+0x590>
        {
          usartdiv = (uint16_t)(UART_DIV_SAMPLING16((HSI_VALUE >> 2U), huart->Init.BaudRate));
 8000ee6:	69fb      	ldr	r3, [r7, #28]
 8000ee8:	685b      	ldr	r3, [r3, #4]
 8000eea:	085b      	lsrs	r3, r3, #1
 8000eec:	4a39      	ldr	r2, [pc, #228]	; (8000fd4 <UART_SetConfig+0x660>)
 8000eee:	189a      	adds	r2, r3, r2
 8000ef0:	69fb      	ldr	r3, [r7, #28]
 8000ef2:	685b      	ldr	r3, [r3, #4]
 8000ef4:	0019      	movs	r1, r3
 8000ef6:	0010      	movs	r0, r2
 8000ef8:	f7ff f906 	bl	8000108 <__udivsi3>
 8000efc:	0003      	movs	r3, r0
 8000efe:	b29b      	uxth	r3, r3
 8000f00:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
        }
        break;
 8000f02:	e037      	b.n	8000f74 <UART_SetConfig+0x600>
          usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 8000f04:	69fb      	ldr	r3, [r7, #28]
 8000f06:	685b      	ldr	r3, [r3, #4]
 8000f08:	085b      	lsrs	r3, r3, #1
 8000f0a:	4a33      	ldr	r2, [pc, #204]	; (8000fd8 <UART_SetConfig+0x664>)
 8000f0c:	189a      	adds	r2, r3, r2
 8000f0e:	69fb      	ldr	r3, [r7, #28]
 8000f10:	685b      	ldr	r3, [r3, #4]
 8000f12:	0019      	movs	r1, r3
 8000f14:	0010      	movs	r0, r2
 8000f16:	f7ff f8f7 	bl	8000108 <__udivsi3>
 8000f1a:	0003      	movs	r3, r0
 8000f1c:	b29b      	uxth	r3, r3
 8000f1e:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8000f20:	e028      	b.n	8000f74 <UART_SetConfig+0x600>
      case UART_CLOCKSOURCE_SYSCLK:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8000f22:	f00a ffa5 	bl	800be70 <HAL_RCC_GetSysClockFreq>
 8000f26:	0002      	movs	r2, r0
 8000f28:	69fb      	ldr	r3, [r7, #28]
 8000f2a:	685b      	ldr	r3, [r3, #4]
 8000f2c:	085b      	lsrs	r3, r3, #1
 8000f2e:	18d2      	adds	r2, r2, r3
 8000f30:	69fb      	ldr	r3, [r7, #28]
 8000f32:	685b      	ldr	r3, [r3, #4]
 8000f34:	0019      	movs	r1, r3
 8000f36:	0010      	movs	r0, r2
 8000f38:	f7ff f8e6 	bl	8000108 <__udivsi3>
 8000f3c:	0003      	movs	r3, r0
 8000f3e:	b29b      	uxth	r3, r3
 8000f40:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8000f42:	e017      	b.n	8000f74 <UART_SetConfig+0x600>
      case UART_CLOCKSOURCE_LSE:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 8000f44:	69fb      	ldr	r3, [r7, #28]
 8000f46:	685b      	ldr	r3, [r3, #4]
 8000f48:	085b      	lsrs	r3, r3, #1
 8000f4a:	2280      	movs	r2, #128	; 0x80
 8000f4c:	0212      	lsls	r2, r2, #8
 8000f4e:	189a      	adds	r2, r3, r2
 8000f50:	69fb      	ldr	r3, [r7, #28]
 8000f52:	685b      	ldr	r3, [r3, #4]
 8000f54:	0019      	movs	r1, r3
 8000f56:	0010      	movs	r0, r2
 8000f58:	f7ff f8d6 	bl	8000108 <__udivsi3>
 8000f5c:	0003      	movs	r3, r0
 8000f5e:	b29b      	uxth	r3, r3
 8000f60:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8000f62:	e007      	b.n	8000f74 <UART_SetConfig+0x600>
      case UART_CLOCKSOURCE_UNDEFINED:
      default:
        ret = HAL_ERROR;
 8000f64:	2313      	movs	r3, #19
 8000f66:	2218      	movs	r2, #24
 8000f68:	4694      	mov	ip, r2
 8000f6a:	44bc      	add	ip, r7
 8000f6c:	4463      	add	r3, ip
 8000f6e:	2201      	movs	r2, #1
 8000f70:	701a      	strb	r2, [r3, #0]
        break;
 8000f72:	46c0      	nop			; (mov r8, r8)
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8000f74:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000f76:	2b0f      	cmp	r3, #15
 8000f78:	d908      	bls.n	8000f8c <UART_SetConfig+0x618>
 8000f7a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000f7c:	4a13      	ldr	r2, [pc, #76]	; (8000fcc <UART_SetConfig+0x658>)
 8000f7e:	4293      	cmp	r3, r2
 8000f80:	d804      	bhi.n	8000f8c <UART_SetConfig+0x618>
    {
      huart->Instance->BRR = usartdiv;
 8000f82:	69fb      	ldr	r3, [r7, #28]
 8000f84:	681b      	ldr	r3, [r3, #0]
 8000f86:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8000f88:	60da      	str	r2, [r3, #12]
 8000f8a:	e006      	b.n	8000f9a <UART_SetConfig+0x626>
    }
    else
    {
      ret = HAL_ERROR;
 8000f8c:	2313      	movs	r3, #19
 8000f8e:	2218      	movs	r2, #24
 8000f90:	4694      	mov	ip, r2
 8000f92:	44bc      	add	ip, r7
 8000f94:	4463      	add	r3, ip
 8000f96:	2201      	movs	r2, #1
 8000f98:	701a      	strb	r2, [r3, #0]
    }
  }


  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 8000f9a:	69fb      	ldr	r3, [r7, #28]
 8000f9c:	2200      	movs	r2, #0
 8000f9e:	661a      	str	r2, [r3, #96]	; 0x60
  huart->TxISR = NULL;
 8000fa0:	69fb      	ldr	r3, [r7, #28]
 8000fa2:	2200      	movs	r2, #0
 8000fa4:	665a      	str	r2, [r3, #100]	; 0x64

  return ret;
 8000fa6:	2313      	movs	r3, #19
 8000fa8:	2218      	movs	r2, #24
 8000faa:	4694      	mov	ip, r2
 8000fac:	44bc      	add	ip, r7
 8000fae:	4463      	add	r3, ip
 8000fb0:	781b      	ldrb	r3, [r3, #0]
}
 8000fb2:	0018      	movs	r0, r3
 8000fb4:	46bd      	mov	sp, r7
 8000fb6:	b00e      	add	sp, #56	; 0x38
 8000fb8:	bdb0      	pop	{r4, r5, r7, pc}
 8000fba:	46c0      	nop			; (mov r8, r8)
 8000fbc:	0800e338 	.word	0x0800e338
 8000fc0:	40021000 	.word	0x40021000
 8000fc4:	007a1200 	.word	0x007a1200
 8000fc8:	01e84800 	.word	0x01e84800
 8000fcc:	0000ffff 	.word	0x0000ffff
 8000fd0:	0800e35c 	.word	0x0800e35c
 8000fd4:	003d0900 	.word	0x003d0900
 8000fd8:	00f42400 	.word	0x00f42400

08000fdc <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 8000fdc:	b580      	push	{r7, lr}
 8000fde:	b082      	sub	sp, #8
 8000fe0:	af00      	add	r7, sp, #0
 8000fe2:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8000fe4:	687b      	ldr	r3, [r7, #4]
 8000fe6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000fe8:	2201      	movs	r2, #1
 8000fea:	4013      	ands	r3, r2
 8000fec:	d00b      	beq.n	8001006 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8000fee:	687b      	ldr	r3, [r7, #4]
 8000ff0:	681b      	ldr	r3, [r3, #0]
 8000ff2:	685b      	ldr	r3, [r3, #4]
 8000ff4:	4a4a      	ldr	r2, [pc, #296]	; (8001120 <UART_AdvFeatureConfig+0x144>)
 8000ff6:	4013      	ands	r3, r2
 8000ff8:	0019      	movs	r1, r3
 8000ffa:	687b      	ldr	r3, [r7, #4]
 8000ffc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000ffe:	687b      	ldr	r3, [r7, #4]
 8001000:	681b      	ldr	r3, [r3, #0]
 8001002:	430a      	orrs	r2, r1
 8001004:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8001006:	687b      	ldr	r3, [r7, #4]
 8001008:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800100a:	2202      	movs	r2, #2
 800100c:	4013      	ands	r3, r2
 800100e:	d00b      	beq.n	8001028 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8001010:	687b      	ldr	r3, [r7, #4]
 8001012:	681b      	ldr	r3, [r3, #0]
 8001014:	685b      	ldr	r3, [r3, #4]
 8001016:	4a43      	ldr	r2, [pc, #268]	; (8001124 <UART_AdvFeatureConfig+0x148>)
 8001018:	4013      	ands	r3, r2
 800101a:	0019      	movs	r1, r3
 800101c:	687b      	ldr	r3, [r7, #4]
 800101e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001020:	687b      	ldr	r3, [r7, #4]
 8001022:	681b      	ldr	r3, [r3, #0]
 8001024:	430a      	orrs	r2, r1
 8001026:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8001028:	687b      	ldr	r3, [r7, #4]
 800102a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800102c:	2204      	movs	r2, #4
 800102e:	4013      	ands	r3, r2
 8001030:	d00b      	beq.n	800104a <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8001032:	687b      	ldr	r3, [r7, #4]
 8001034:	681b      	ldr	r3, [r3, #0]
 8001036:	685b      	ldr	r3, [r3, #4]
 8001038:	4a3b      	ldr	r2, [pc, #236]	; (8001128 <UART_AdvFeatureConfig+0x14c>)
 800103a:	4013      	ands	r3, r2
 800103c:	0019      	movs	r1, r3
 800103e:	687b      	ldr	r3, [r7, #4]
 8001040:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001042:	687b      	ldr	r3, [r7, #4]
 8001044:	681b      	ldr	r3, [r3, #0]
 8001046:	430a      	orrs	r2, r1
 8001048:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800104a:	687b      	ldr	r3, [r7, #4]
 800104c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800104e:	2208      	movs	r2, #8
 8001050:	4013      	ands	r3, r2
 8001052:	d00b      	beq.n	800106c <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8001054:	687b      	ldr	r3, [r7, #4]
 8001056:	681b      	ldr	r3, [r3, #0]
 8001058:	685b      	ldr	r3, [r3, #4]
 800105a:	4a34      	ldr	r2, [pc, #208]	; (800112c <UART_AdvFeatureConfig+0x150>)
 800105c:	4013      	ands	r3, r2
 800105e:	0019      	movs	r1, r3
 8001060:	687b      	ldr	r3, [r7, #4]
 8001062:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001064:	687b      	ldr	r3, [r7, #4]
 8001066:	681b      	ldr	r3, [r3, #0]
 8001068:	430a      	orrs	r2, r1
 800106a:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800106c:	687b      	ldr	r3, [r7, #4]
 800106e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001070:	2210      	movs	r2, #16
 8001072:	4013      	ands	r3, r2
 8001074:	d00b      	beq.n	800108e <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8001076:	687b      	ldr	r3, [r7, #4]
 8001078:	681b      	ldr	r3, [r3, #0]
 800107a:	689b      	ldr	r3, [r3, #8]
 800107c:	4a2c      	ldr	r2, [pc, #176]	; (8001130 <UART_AdvFeatureConfig+0x154>)
 800107e:	4013      	ands	r3, r2
 8001080:	0019      	movs	r1, r3
 8001082:	687b      	ldr	r3, [r7, #4]
 8001084:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001086:	687b      	ldr	r3, [r7, #4]
 8001088:	681b      	ldr	r3, [r3, #0]
 800108a:	430a      	orrs	r2, r1
 800108c:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800108e:	687b      	ldr	r3, [r7, #4]
 8001090:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001092:	2220      	movs	r2, #32
 8001094:	4013      	ands	r3, r2
 8001096:	d00b      	beq.n	80010b0 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8001098:	687b      	ldr	r3, [r7, #4]
 800109a:	681b      	ldr	r3, [r3, #0]
 800109c:	689b      	ldr	r3, [r3, #8]
 800109e:	4a25      	ldr	r2, [pc, #148]	; (8001134 <UART_AdvFeatureConfig+0x158>)
 80010a0:	4013      	ands	r3, r2
 80010a2:	0019      	movs	r1, r3
 80010a4:	687b      	ldr	r3, [r7, #4]
 80010a6:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80010a8:	687b      	ldr	r3, [r7, #4]
 80010aa:	681b      	ldr	r3, [r3, #0]
 80010ac:	430a      	orrs	r2, r1
 80010ae:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 80010b0:	687b      	ldr	r3, [r7, #4]
 80010b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80010b4:	2240      	movs	r2, #64	; 0x40
 80010b6:	4013      	ands	r3, r2
 80010b8:	d01d      	beq.n	80010f6 <UART_AdvFeatureConfig+0x11a>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80010ba:	687b      	ldr	r3, [r7, #4]
 80010bc:	681b      	ldr	r3, [r3, #0]
 80010be:	685b      	ldr	r3, [r3, #4]
 80010c0:	4a1d      	ldr	r2, [pc, #116]	; (8001138 <UART_AdvFeatureConfig+0x15c>)
 80010c2:	4013      	ands	r3, r2
 80010c4:	0019      	movs	r1, r3
 80010c6:	687b      	ldr	r3, [r7, #4]
 80010c8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80010ca:	687b      	ldr	r3, [r7, #4]
 80010cc:	681b      	ldr	r3, [r3, #0]
 80010ce:	430a      	orrs	r2, r1
 80010d0:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80010d2:	687b      	ldr	r3, [r7, #4]
 80010d4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80010d6:	2380      	movs	r3, #128	; 0x80
 80010d8:	035b      	lsls	r3, r3, #13
 80010da:	429a      	cmp	r2, r3
 80010dc:	d10b      	bne.n	80010f6 <UART_AdvFeatureConfig+0x11a>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 80010de:	687b      	ldr	r3, [r7, #4]
 80010e0:	681b      	ldr	r3, [r3, #0]
 80010e2:	685b      	ldr	r3, [r3, #4]
 80010e4:	4a15      	ldr	r2, [pc, #84]	; (800113c <UART_AdvFeatureConfig+0x160>)
 80010e6:	4013      	ands	r3, r2
 80010e8:	0019      	movs	r1, r3
 80010ea:	687b      	ldr	r3, [r7, #4]
 80010ec:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80010ee:	687b      	ldr	r3, [r7, #4]
 80010f0:	681b      	ldr	r3, [r3, #0]
 80010f2:	430a      	orrs	r2, r1
 80010f4:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 80010f6:	687b      	ldr	r3, [r7, #4]
 80010f8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80010fa:	2280      	movs	r2, #128	; 0x80
 80010fc:	4013      	ands	r3, r2
 80010fe:	d00b      	beq.n	8001118 <UART_AdvFeatureConfig+0x13c>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8001100:	687b      	ldr	r3, [r7, #4]
 8001102:	681b      	ldr	r3, [r3, #0]
 8001104:	685b      	ldr	r3, [r3, #4]
 8001106:	4a0e      	ldr	r2, [pc, #56]	; (8001140 <UART_AdvFeatureConfig+0x164>)
 8001108:	4013      	ands	r3, r2
 800110a:	0019      	movs	r1, r3
 800110c:	687b      	ldr	r3, [r7, #4]
 800110e:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8001110:	687b      	ldr	r3, [r7, #4]
 8001112:	681b      	ldr	r3, [r3, #0]
 8001114:	430a      	orrs	r2, r1
 8001116:	605a      	str	r2, [r3, #4]
  }
}
 8001118:	46c0      	nop			; (mov r8, r8)
 800111a:	46bd      	mov	sp, r7
 800111c:	b002      	add	sp, #8
 800111e:	bd80      	pop	{r7, pc}
 8001120:	fffdffff 	.word	0xfffdffff
 8001124:	fffeffff 	.word	0xfffeffff
 8001128:	fffbffff 	.word	0xfffbffff
 800112c:	ffff7fff 	.word	0xffff7fff
 8001130:	ffffefff 	.word	0xffffefff
 8001134:	ffffdfff 	.word	0xffffdfff
 8001138:	ffefffff 	.word	0xffefffff
 800113c:	ff9fffff 	.word	0xff9fffff
 8001140:	fff7ffff 	.word	0xfff7ffff

08001144 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 8001144:	b580      	push	{r7, lr}
 8001146:	b086      	sub	sp, #24
 8001148:	af02      	add	r7, sp, #8
 800114a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800114c:	687b      	ldr	r3, [r7, #4]
 800114e:	2200      	movs	r2, #0
 8001150:	67da      	str	r2, [r3, #124]	; 0x7c

  /* Init tickstart for timeout managment*/
  tickstart = HAL_GetTick();
 8001152:	f009 fbfd 	bl	800a950 <HAL_GetTick>
 8001156:	0003      	movs	r3, r0
 8001158:	60fb      	str	r3, [r7, #12]

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800115a:	687b      	ldr	r3, [r7, #4]
 800115c:	681b      	ldr	r3, [r3, #0]
 800115e:	681b      	ldr	r3, [r3, #0]
 8001160:	2208      	movs	r2, #8
 8001162:	4013      	ands	r3, r2
 8001164:	2b08      	cmp	r3, #8
 8001166:	d10d      	bne.n	8001184 <UART_CheckIdleState+0x40>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8001168:	68fa      	ldr	r2, [r7, #12]
 800116a:	2380      	movs	r3, #128	; 0x80
 800116c:	0399      	lsls	r1, r3, #14
 800116e:	6878      	ldr	r0, [r7, #4]
 8001170:	4b16      	ldr	r3, [pc, #88]	; (80011cc <UART_CheckIdleState+0x88>)
 8001172:	9300      	str	r3, [sp, #0]
 8001174:	0013      	movs	r3, r2
 8001176:	2200      	movs	r2, #0
 8001178:	f000 f82a 	bl	80011d0 <UART_WaitOnFlagUntilTimeout>
 800117c:	1e03      	subs	r3, r0, #0
 800117e:	d001      	beq.n	8001184 <UART_CheckIdleState+0x40>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 8001180:	2303      	movs	r3, #3
 8001182:	e01f      	b.n	80011c4 <UART_CheckIdleState+0x80>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8001184:	687b      	ldr	r3, [r7, #4]
 8001186:	681b      	ldr	r3, [r3, #0]
 8001188:	681b      	ldr	r3, [r3, #0]
 800118a:	2204      	movs	r2, #4
 800118c:	4013      	ands	r3, r2
 800118e:	2b04      	cmp	r3, #4
 8001190:	d10d      	bne.n	80011ae <UART_CheckIdleState+0x6a>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8001192:	68fa      	ldr	r2, [r7, #12]
 8001194:	2380      	movs	r3, #128	; 0x80
 8001196:	03d9      	lsls	r1, r3, #15
 8001198:	6878      	ldr	r0, [r7, #4]
 800119a:	4b0c      	ldr	r3, [pc, #48]	; (80011cc <UART_CheckIdleState+0x88>)
 800119c:	9300      	str	r3, [sp, #0]
 800119e:	0013      	movs	r3, r2
 80011a0:	2200      	movs	r2, #0
 80011a2:	f000 f815 	bl	80011d0 <UART_WaitOnFlagUntilTimeout>
 80011a6:	1e03      	subs	r3, r0, #0
 80011a8:	d001      	beq.n	80011ae <UART_CheckIdleState+0x6a>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 80011aa:	2303      	movs	r3, #3
 80011ac:	e00a      	b.n	80011c4 <UART_CheckIdleState+0x80>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 80011ae:	687b      	ldr	r3, [r7, #4]
 80011b0:	2220      	movs	r2, #32
 80011b2:	675a      	str	r2, [r3, #116]	; 0x74
  huart->RxState = HAL_UART_STATE_READY;
 80011b4:	687b      	ldr	r3, [r7, #4]
 80011b6:	2220      	movs	r2, #32
 80011b8:	679a      	str	r2, [r3, #120]	; 0x78

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 80011ba:	687b      	ldr	r3, [r7, #4]
 80011bc:	2270      	movs	r2, #112	; 0x70
 80011be:	2100      	movs	r1, #0
 80011c0:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 80011c2:	2300      	movs	r3, #0
}
 80011c4:	0018      	movs	r0, r3
 80011c6:	46bd      	mov	sp, r7
 80011c8:	b004      	add	sp, #16
 80011ca:	bd80      	pop	{r7, pc}
 80011cc:	01ffffff 	.word	0x01ffffff

080011d0 <UART_WaitOnFlagUntilTimeout>:
  * @param Tickstart Tick start value
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
{
 80011d0:	b580      	push	{r7, lr}
 80011d2:	b084      	sub	sp, #16
 80011d4:	af00      	add	r7, sp, #0
 80011d6:	60f8      	str	r0, [r7, #12]
 80011d8:	60b9      	str	r1, [r7, #8]
 80011da:	603b      	str	r3, [r7, #0]
 80011dc:	1dfb      	adds	r3, r7, #7
 80011de:	701a      	strb	r2, [r3, #0]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80011e0:	e029      	b.n	8001236 <UART_WaitOnFlagUntilTimeout+0x66>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 80011e2:	69bb      	ldr	r3, [r7, #24]
 80011e4:	3301      	adds	r3, #1
 80011e6:	d026      	beq.n	8001236 <UART_WaitOnFlagUntilTimeout+0x66>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80011e8:	f009 fbb2 	bl	800a950 <HAL_GetTick>
 80011ec:	0002      	movs	r2, r0
 80011ee:	683b      	ldr	r3, [r7, #0]
 80011f0:	1ad3      	subs	r3, r2, r3
 80011f2:	69ba      	ldr	r2, [r7, #24]
 80011f4:	429a      	cmp	r2, r3
 80011f6:	d302      	bcc.n	80011fe <UART_WaitOnFlagUntilTimeout+0x2e>
 80011f8:	69bb      	ldr	r3, [r7, #24]
 80011fa:	2b00      	cmp	r3, #0
 80011fc:	d11b      	bne.n	8001236 <UART_WaitOnFlagUntilTimeout+0x66>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80011fe:	68fb      	ldr	r3, [r7, #12]
 8001200:	681b      	ldr	r3, [r3, #0]
 8001202:	681a      	ldr	r2, [r3, #0]
 8001204:	68fb      	ldr	r3, [r7, #12]
 8001206:	681b      	ldr	r3, [r3, #0]
 8001208:	4915      	ldr	r1, [pc, #84]	; (8001260 <UART_WaitOnFlagUntilTimeout+0x90>)
 800120a:	400a      	ands	r2, r1
 800120c:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800120e:	68fb      	ldr	r3, [r7, #12]
 8001210:	681b      	ldr	r3, [r3, #0]
 8001212:	689a      	ldr	r2, [r3, #8]
 8001214:	68fb      	ldr	r3, [r7, #12]
 8001216:	681b      	ldr	r3, [r3, #0]
 8001218:	2101      	movs	r1, #1
 800121a:	438a      	bics	r2, r1
 800121c:	609a      	str	r2, [r3, #8]

        huart->gState = HAL_UART_STATE_READY;
 800121e:	68fb      	ldr	r3, [r7, #12]
 8001220:	2220      	movs	r2, #32
 8001222:	675a      	str	r2, [r3, #116]	; 0x74
        huart->RxState = HAL_UART_STATE_READY;
 8001224:	68fb      	ldr	r3, [r7, #12]
 8001226:	2220      	movs	r2, #32
 8001228:	679a      	str	r2, [r3, #120]	; 0x78

        /* Process Unlocked */
        __HAL_UNLOCK(huart);
 800122a:	68fb      	ldr	r3, [r7, #12]
 800122c:	2270      	movs	r2, #112	; 0x70
 800122e:	2100      	movs	r1, #0
 8001230:	5499      	strb	r1, [r3, r2]

        return HAL_TIMEOUT;
 8001232:	2303      	movs	r3, #3
 8001234:	e00f      	b.n	8001256 <UART_WaitOnFlagUntilTimeout+0x86>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8001236:	68fb      	ldr	r3, [r7, #12]
 8001238:	681b      	ldr	r3, [r3, #0]
 800123a:	69db      	ldr	r3, [r3, #28]
 800123c:	68ba      	ldr	r2, [r7, #8]
 800123e:	4013      	ands	r3, r2
 8001240:	68ba      	ldr	r2, [r7, #8]
 8001242:	1ad3      	subs	r3, r2, r3
 8001244:	425a      	negs	r2, r3
 8001246:	4153      	adcs	r3, r2
 8001248:	b2db      	uxtb	r3, r3
 800124a:	001a      	movs	r2, r3
 800124c:	1dfb      	adds	r3, r7, #7
 800124e:	781b      	ldrb	r3, [r3, #0]
 8001250:	429a      	cmp	r2, r3
 8001252:	d0c6      	beq.n	80011e2 <UART_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
 8001254:	2300      	movs	r3, #0
}
 8001256:	0018      	movs	r0, r3
 8001258:	46bd      	mov	sp, r7
 800125a:	b004      	add	sp, #16
 800125c:	bd80      	pop	{r7, pc}
 800125e:	46c0      	nop			; (mov r8, r8)
 8001260:	fffffe5f 	.word	0xfffffe5f

08001264 <LDL_AES_init>:
};

/* functions **********************************************************/

void LDL_AES_init(struct ldl_aes_ctx *ctx, const void *key)
{
 8001264:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001266:	b087      	sub	sp, #28
 8001268:	af00      	add	r7, sp, #0
 800126a:	6078      	str	r0, [r7, #4]
 800126c:	6039      	str	r1, [r7, #0]
    uint8_t p;
    uint8_t j;
    uint8_t b = 0U;
 800126e:	2014      	movs	r0, #20
 8001270:	183b      	adds	r3, r7, r0
 8001272:	2200      	movs	r2, #0
 8001274:	701a      	strb	r2, [r3, #0]
    uint8_t swap;
    uint8_t *k;
    uint8_t ks;
    uint8_t i = 1U;
 8001276:	2315      	movs	r3, #21
 8001278:	18fb      	adds	r3, r7, r3
 800127a:	2201      	movs	r2, #1
 800127c:	701a      	strb	r2, [r3, #0]
    };

    LDL_PEDANTIC(ctx != NULL)
    LDL_PEDANTIC(key != NULL)

    ctx->r = 10U;
 800127e:	687b      	ldr	r3, [r7, #4]
 8001280:	22f0      	movs	r2, #240	; 0xf0
 8001282:	210a      	movs	r1, #10
 8001284:	5499      	strb	r1, [r3, r2]
    b = 176U;
 8001286:	183b      	adds	r3, r7, r0
 8001288:	22b0      	movs	r2, #176	; 0xb0
 800128a:	701a      	strb	r2, [r3, #0]

    (void)memcpy(ctx->k, key, 16U);
 800128c:	687b      	ldr	r3, [r7, #4]
 800128e:	6839      	ldr	r1, [r7, #0]
 8001290:	2210      	movs	r2, #16
 8001292:	0018      	movs	r0, r3
 8001294:	f00b fb18 	bl	800c8c8 <memcpy>
    k = ctx->k;    
 8001298:	687b      	ldr	r3, [r7, #4]
 800129a:	613b      	str	r3, [r7, #16]
    ks = 16U;
 800129c:	210f      	movs	r1, #15
 800129e:	187b      	adds	r3, r7, r1
 80012a0:	2210      	movs	r2, #16
 80012a2:	701a      	strb	r2, [r3, #0]
    p = ks;
 80012a4:	2317      	movs	r3, #23
 80012a6:	18fb      	adds	r3, r7, r3
 80012a8:	187a      	adds	r2, r7, r1
 80012aa:	7812      	ldrb	r2, [r2, #0]
 80012ac:	701a      	strb	r2, [r3, #0]

    /* Rijndael key schedule */
    while(p < b){
 80012ae:	e0b0      	b.n	8001412 <LDL_AES_init+0x1ae>
        
        swap = k[p - 4U];
 80012b0:	2017      	movs	r0, #23
 80012b2:	183b      	adds	r3, r7, r0
 80012b4:	781b      	ldrb	r3, [r3, #0]
 80012b6:	3b04      	subs	r3, #4
 80012b8:	693a      	ldr	r2, [r7, #16]
 80012ba:	18d2      	adds	r2, r2, r3
 80012bc:	260e      	movs	r6, #14
 80012be:	19bb      	adds	r3, r7, r6
 80012c0:	7812      	ldrb	r2, [r2, #0]
 80012c2:	701a      	strb	r2, [r3, #0]
        k[p     ] = SBOX( k[p - 3U] ) ^ k[p      - ks] ^ RCON(i);
 80012c4:	183b      	adds	r3, r7, r0
 80012c6:	781b      	ldrb	r3, [r3, #0]
 80012c8:	3b03      	subs	r3, #3
 80012ca:	693a      	ldr	r2, [r7, #16]
 80012cc:	18d3      	adds	r3, r2, r3
 80012ce:	781b      	ldrb	r3, [r3, #0]
 80012d0:	001a      	movs	r2, r3
 80012d2:	4b56      	ldr	r3, [pc, #344]	; (800142c <LDL_AES_init+0x1c8>)
 80012d4:	5c9a      	ldrb	r2, [r3, r2]
 80012d6:	183b      	adds	r3, r7, r0
 80012d8:	7819      	ldrb	r1, [r3, #0]
 80012da:	250f      	movs	r5, #15
 80012dc:	197b      	adds	r3, r7, r5
 80012de:	781b      	ldrb	r3, [r3, #0]
 80012e0:	1acb      	subs	r3, r1, r3
 80012e2:	0019      	movs	r1, r3
 80012e4:	693b      	ldr	r3, [r7, #16]
 80012e6:	185b      	adds	r3, r3, r1
 80012e8:	781b      	ldrb	r3, [r3, #0]
 80012ea:	4053      	eors	r3, r2
 80012ec:	b2d9      	uxtb	r1, r3
 80012ee:	2315      	movs	r3, #21
 80012f0:	18fb      	adds	r3, r7, r3
 80012f2:	781b      	ldrb	r3, [r3, #0]
 80012f4:	4a4e      	ldr	r2, [pc, #312]	; (8001430 <LDL_AES_init+0x1cc>)
 80012f6:	5cd2      	ldrb	r2, [r2, r3]
 80012f8:	0004      	movs	r4, r0
 80012fa:	183b      	adds	r3, r7, r0
 80012fc:	781b      	ldrb	r3, [r3, #0]
 80012fe:	6938      	ldr	r0, [r7, #16]
 8001300:	18c3      	adds	r3, r0, r3
 8001302:	404a      	eors	r2, r1
 8001304:	b2d2      	uxtb	r2, r2
 8001306:	701a      	strb	r2, [r3, #0]
        k[p + 1U] = SBOX( k[p - 2U] ) ^ k[p + 1U - ks];
 8001308:	0020      	movs	r0, r4
 800130a:	183b      	adds	r3, r7, r0
 800130c:	781b      	ldrb	r3, [r3, #0]
 800130e:	3b02      	subs	r3, #2
 8001310:	693a      	ldr	r2, [r7, #16]
 8001312:	18d3      	adds	r3, r2, r3
 8001314:	781b      	ldrb	r3, [r3, #0]
 8001316:	001a      	movs	r2, r3
 8001318:	4b44      	ldr	r3, [pc, #272]	; (800142c <LDL_AES_init+0x1c8>)
 800131a:	5c99      	ldrb	r1, [r3, r2]
 800131c:	183b      	adds	r3, r7, r0
 800131e:	781a      	ldrb	r2, [r3, #0]
 8001320:	197b      	adds	r3, r7, r5
 8001322:	781b      	ldrb	r3, [r3, #0]
 8001324:	1ad3      	subs	r3, r2, r3
 8001326:	3301      	adds	r3, #1
 8001328:	693a      	ldr	r2, [r7, #16]
 800132a:	18d3      	adds	r3, r2, r3
 800132c:	781a      	ldrb	r2, [r3, #0]
 800132e:	0004      	movs	r4, r0
 8001330:	193b      	adds	r3, r7, r4
 8001332:	781b      	ldrb	r3, [r3, #0]
 8001334:	3301      	adds	r3, #1
 8001336:	6938      	ldr	r0, [r7, #16]
 8001338:	18c3      	adds	r3, r0, r3
 800133a:	404a      	eors	r2, r1
 800133c:	b2d2      	uxtb	r2, r2
 800133e:	701a      	strb	r2, [r3, #0]
        k[p + 2U] = SBOX( k[p - 1U] ) ^ k[p + 2U - ks];
 8001340:	193b      	adds	r3, r7, r4
 8001342:	781b      	ldrb	r3, [r3, #0]
 8001344:	3b01      	subs	r3, #1
 8001346:	693a      	ldr	r2, [r7, #16]
 8001348:	18d3      	adds	r3, r2, r3
 800134a:	781b      	ldrb	r3, [r3, #0]
 800134c:	001a      	movs	r2, r3
 800134e:	4b37      	ldr	r3, [pc, #220]	; (800142c <LDL_AES_init+0x1c8>)
 8001350:	5c99      	ldrb	r1, [r3, r2]
 8001352:	193b      	adds	r3, r7, r4
 8001354:	781a      	ldrb	r2, [r3, #0]
 8001356:	197b      	adds	r3, r7, r5
 8001358:	781b      	ldrb	r3, [r3, #0]
 800135a:	1ad3      	subs	r3, r2, r3
 800135c:	3302      	adds	r3, #2
 800135e:	693a      	ldr	r2, [r7, #16]
 8001360:	18d3      	adds	r3, r2, r3
 8001362:	781a      	ldrb	r2, [r3, #0]
 8001364:	193b      	adds	r3, r7, r4
 8001366:	781b      	ldrb	r3, [r3, #0]
 8001368:	3302      	adds	r3, #2
 800136a:	6938      	ldr	r0, [r7, #16]
 800136c:	18c3      	adds	r3, r0, r3
 800136e:	404a      	eors	r2, r1
 8001370:	b2d2      	uxtb	r2, r2
 8001372:	701a      	strb	r2, [r3, #0]
        k[p + 3U] = SBOX( swap      ) ^ k[p + 3U - ks];
 8001374:	19bb      	adds	r3, r7, r6
 8001376:	781b      	ldrb	r3, [r3, #0]
 8001378:	4a2c      	ldr	r2, [pc, #176]	; (800142c <LDL_AES_init+0x1c8>)
 800137a:	5cd1      	ldrb	r1, [r2, r3]
 800137c:	193b      	adds	r3, r7, r4
 800137e:	781a      	ldrb	r2, [r3, #0]
 8001380:	197b      	adds	r3, r7, r5
 8001382:	781b      	ldrb	r3, [r3, #0]
 8001384:	1ad3      	subs	r3, r2, r3
 8001386:	3303      	adds	r3, #3
 8001388:	693a      	ldr	r2, [r7, #16]
 800138a:	18d3      	adds	r3, r2, r3
 800138c:	781a      	ldrb	r2, [r3, #0]
 800138e:	193b      	adds	r3, r7, r4
 8001390:	781b      	ldrb	r3, [r3, #0]
 8001392:	3303      	adds	r3, #3
 8001394:	6938      	ldr	r0, [r7, #16]
 8001396:	18c3      	adds	r3, r0, r3
 8001398:	404a      	eors	r2, r1
 800139a:	b2d2      	uxtb	r2, r2
 800139c:	701a      	strb	r2, [r3, #0]
        p += 4U;
 800139e:	193b      	adds	r3, r7, r4
 80013a0:	193a      	adds	r2, r7, r4
 80013a2:	7812      	ldrb	r2, [r2, #0]
 80013a4:	3204      	adds	r2, #4
 80013a6:	701a      	strb	r2, [r3, #0]

        for(j=0U; j < 12U; j++){
 80013a8:	2316      	movs	r3, #22
 80013aa:	18fb      	adds	r3, r7, r3
 80013ac:	2200      	movs	r2, #0
 80013ae:	701a      	strb	r2, [r3, #0]
 80013b0:	e024      	b.n	80013fc <LDL_AES_init+0x198>

            k[p] = k[p - 4U] ^ k[p - ks];
 80013b2:	2017      	movs	r0, #23
 80013b4:	183b      	adds	r3, r7, r0
 80013b6:	781b      	ldrb	r3, [r3, #0]
 80013b8:	3b04      	subs	r3, #4
 80013ba:	693a      	ldr	r2, [r7, #16]
 80013bc:	18d3      	adds	r3, r2, r3
 80013be:	7819      	ldrb	r1, [r3, #0]
 80013c0:	183b      	adds	r3, r7, r0
 80013c2:	781a      	ldrb	r2, [r3, #0]
 80013c4:	230f      	movs	r3, #15
 80013c6:	18fb      	adds	r3, r7, r3
 80013c8:	781b      	ldrb	r3, [r3, #0]
 80013ca:	1ad3      	subs	r3, r2, r3
 80013cc:	001a      	movs	r2, r3
 80013ce:	693b      	ldr	r3, [r7, #16]
 80013d0:	189b      	adds	r3, r3, r2
 80013d2:	781a      	ldrb	r2, [r3, #0]
 80013d4:	0004      	movs	r4, r0
 80013d6:	183b      	adds	r3, r7, r0
 80013d8:	781b      	ldrb	r3, [r3, #0]
 80013da:	6938      	ldr	r0, [r7, #16]
 80013dc:	18c3      	adds	r3, r0, r3
 80013de:	404a      	eors	r2, r1
 80013e0:	b2d2      	uxtb	r2, r2
 80013e2:	701a      	strb	r2, [r3, #0]
            p++;
 80013e4:	0020      	movs	r0, r4
 80013e6:	183b      	adds	r3, r7, r0
 80013e8:	781a      	ldrb	r2, [r3, #0]
 80013ea:	183b      	adds	r3, r7, r0
 80013ec:	3201      	adds	r2, #1
 80013ee:	701a      	strb	r2, [r3, #0]
        for(j=0U; j < 12U; j++){
 80013f0:	2116      	movs	r1, #22
 80013f2:	187b      	adds	r3, r7, r1
 80013f4:	781a      	ldrb	r2, [r3, #0]
 80013f6:	187b      	adds	r3, r7, r1
 80013f8:	3201      	adds	r2, #1
 80013fa:	701a      	strb	r2, [r3, #0]
 80013fc:	2316      	movs	r3, #22
 80013fe:	18fb      	adds	r3, r7, r3
 8001400:	781b      	ldrb	r3, [r3, #0]
 8001402:	2b0b      	cmp	r3, #11
 8001404:	d9d5      	bls.n	80013b2 <LDL_AES_init+0x14e>
        }

        i++;
 8001406:	2115      	movs	r1, #21
 8001408:	187b      	adds	r3, r7, r1
 800140a:	781a      	ldrb	r2, [r3, #0]
 800140c:	187b      	adds	r3, r7, r1
 800140e:	3201      	adds	r2, #1
 8001410:	701a      	strb	r2, [r3, #0]
    while(p < b){
 8001412:	2317      	movs	r3, #23
 8001414:	18fa      	adds	r2, r7, r3
 8001416:	2314      	movs	r3, #20
 8001418:	18fb      	adds	r3, r7, r3
 800141a:	7812      	ldrb	r2, [r2, #0]
 800141c:	781b      	ldrb	r3, [r3, #0]
 800141e:	429a      	cmp	r2, r3
 8001420:	d200      	bcs.n	8001424 <LDL_AES_init+0x1c0>
 8001422:	e745      	b.n	80012b0 <LDL_AES_init+0x4c>
    }
}
 8001424:	46c0      	nop			; (mov r8, r8)
 8001426:	46bd      	mov	sp, r7
 8001428:	b007      	add	sp, #28
 800142a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800142c:	0800e380 	.word	0x0800e380
 8001430:	0800e480 	.word	0x0800e480

08001434 <LDL_AES_encrypt>:

void LDL_AES_encrypt(const struct ldl_aes_ctx *ctx, void *s)
{
 8001434:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001436:	b087      	sub	sp, #28
 8001438:	af00      	add	r7, sp, #0
 800143a:	6078      	str	r0, [r7, #4]
 800143c:	6039      	str	r1, [r7, #0]
    uint8_t *_s = s;
 800143e:	683b      	ldr	r3, [r7, #0]
 8001440:	613b      	str	r3, [r7, #16]
    uint8_t a;
    uint8_t b;
    uint8_t c;
    uint8_t d;    
    uint8_t i;
    uint8_t p = 0U;
 8001442:	2315      	movs	r3, #21
 8001444:	18fb      	adds	r3, r7, r3
 8001446:	2200      	movs	r2, #0
 8001448:	701a      	strb	r2, [r3, #0]
    const uint8_t *k = ctx->k;
 800144a:	687b      	ldr	r3, [r7, #4]
 800144c:	60fb      	str	r3, [r7, #12]

    /* add round key, sbox and shiftrows */
    for(r = 0U; r < ctx->r; r++){
 800144e:	2317      	movs	r3, #23
 8001450:	18fb      	adds	r3, r7, r3
 8001452:	2200      	movs	r2, #0
 8001454:	701a      	strb	r2, [r3, #0]
 8001456:	e2b3      	b.n	80019c0 <LDL_AES_encrypt+0x58c>

        /* add round key, sbox, left shift row */

        /* row 1 */
        _s[C1] = SBOX( _s[C1] ^ k[p] );
 8001458:	693b      	ldr	r3, [r7, #16]
 800145a:	781a      	ldrb	r2, [r3, #0]
 800145c:	2015      	movs	r0, #21
 800145e:	183b      	adds	r3, r7, r0
 8001460:	781b      	ldrb	r3, [r3, #0]
 8001462:	68f9      	ldr	r1, [r7, #12]
 8001464:	18cb      	adds	r3, r1, r3
 8001466:	781b      	ldrb	r3, [r3, #0]
 8001468:	4053      	eors	r3, r2
 800146a:	b2db      	uxtb	r3, r3
 800146c:	001a      	movs	r2, r3
 800146e:	4bf3      	ldr	r3, [pc, #972]	; (800183c <LDL_AES_encrypt+0x408>)
 8001470:	5c9a      	ldrb	r2, [r3, r2]
 8001472:	693b      	ldr	r3, [r7, #16]
 8001474:	701a      	strb	r2, [r3, #0]
        _s[C2] = SBOX( _s[C2] ^ k[p + C2] );
 8001476:	693b      	ldr	r3, [r7, #16]
 8001478:	3304      	adds	r3, #4
 800147a:	781a      	ldrb	r2, [r3, #0]
 800147c:	183b      	adds	r3, r7, r0
 800147e:	781b      	ldrb	r3, [r3, #0]
 8001480:	3304      	adds	r3, #4
 8001482:	68f9      	ldr	r1, [r7, #12]
 8001484:	18cb      	adds	r3, r1, r3
 8001486:	781b      	ldrb	r3, [r3, #0]
 8001488:	4053      	eors	r3, r2
 800148a:	b2db      	uxtb	r3, r3
 800148c:	0019      	movs	r1, r3
 800148e:	693b      	ldr	r3, [r7, #16]
 8001490:	3304      	adds	r3, #4
 8001492:	4aea      	ldr	r2, [pc, #936]	; (800183c <LDL_AES_encrypt+0x408>)
 8001494:	5c52      	ldrb	r2, [r2, r1]
 8001496:	701a      	strb	r2, [r3, #0]
        _s[C3] = SBOX( _s[C3] ^ k[p + C3] );
 8001498:	693b      	ldr	r3, [r7, #16]
 800149a:	3308      	adds	r3, #8
 800149c:	781a      	ldrb	r2, [r3, #0]
 800149e:	183b      	adds	r3, r7, r0
 80014a0:	781b      	ldrb	r3, [r3, #0]
 80014a2:	3308      	adds	r3, #8
 80014a4:	68f9      	ldr	r1, [r7, #12]
 80014a6:	18cb      	adds	r3, r1, r3
 80014a8:	781b      	ldrb	r3, [r3, #0]
 80014aa:	4053      	eors	r3, r2
 80014ac:	b2db      	uxtb	r3, r3
 80014ae:	0019      	movs	r1, r3
 80014b0:	693b      	ldr	r3, [r7, #16]
 80014b2:	3308      	adds	r3, #8
 80014b4:	4ae1      	ldr	r2, [pc, #900]	; (800183c <LDL_AES_encrypt+0x408>)
 80014b6:	5c52      	ldrb	r2, [r2, r1]
 80014b8:	701a      	strb	r2, [r3, #0]
        _s[C4] = SBOX( _s[C4] ^ k[p + C4] );
 80014ba:	693b      	ldr	r3, [r7, #16]
 80014bc:	330c      	adds	r3, #12
 80014be:	781a      	ldrb	r2, [r3, #0]
 80014c0:	183b      	adds	r3, r7, r0
 80014c2:	781b      	ldrb	r3, [r3, #0]
 80014c4:	330c      	adds	r3, #12
 80014c6:	68f9      	ldr	r1, [r7, #12]
 80014c8:	18cb      	adds	r3, r1, r3
 80014ca:	781b      	ldrb	r3, [r3, #0]
 80014cc:	4053      	eors	r3, r2
 80014ce:	b2db      	uxtb	r3, r3
 80014d0:	0019      	movs	r1, r3
 80014d2:	693b      	ldr	r3, [r7, #16]
 80014d4:	330c      	adds	r3, #12
 80014d6:	4ad9      	ldr	r2, [pc, #868]	; (800183c <LDL_AES_encrypt+0x408>)
 80014d8:	5c52      	ldrb	r2, [r2, r1]
 80014da:	701a      	strb	r2, [r3, #0]

        /* row 2, left shift 1 */
        a = SBOX( _s[R2] ^ k[p + R2] );
 80014dc:	693b      	ldr	r3, [r7, #16]
 80014de:	3301      	adds	r3, #1
 80014e0:	781a      	ldrb	r2, [r3, #0]
 80014e2:	183b      	adds	r3, r7, r0
 80014e4:	781b      	ldrb	r3, [r3, #0]
 80014e6:	3301      	adds	r3, #1
 80014e8:	68f9      	ldr	r1, [r7, #12]
 80014ea:	18cb      	adds	r3, r1, r3
 80014ec:	781b      	ldrb	r3, [r3, #0]
 80014ee:	4053      	eors	r3, r2
 80014f0:	b2db      	uxtb	r3, r3
 80014f2:	0019      	movs	r1, r3
 80014f4:	240b      	movs	r4, #11
 80014f6:	193b      	adds	r3, r7, r4
 80014f8:	4ad0      	ldr	r2, [pc, #832]	; (800183c <LDL_AES_encrypt+0x408>)
 80014fa:	5c52      	ldrb	r2, [r2, r1]
 80014fc:	701a      	strb	r2, [r3, #0]
        _s[R2     ] = SBOX( _s[R2 + C2] ^ k[p + R2 + C2] );
 80014fe:	693b      	ldr	r3, [r7, #16]
 8001500:	3305      	adds	r3, #5
 8001502:	781a      	ldrb	r2, [r3, #0]
 8001504:	183b      	adds	r3, r7, r0
 8001506:	781b      	ldrb	r3, [r3, #0]
 8001508:	3305      	adds	r3, #5
 800150a:	68f9      	ldr	r1, [r7, #12]
 800150c:	18cb      	adds	r3, r1, r3
 800150e:	781b      	ldrb	r3, [r3, #0]
 8001510:	4053      	eors	r3, r2
 8001512:	b2db      	uxtb	r3, r3
 8001514:	0019      	movs	r1, r3
 8001516:	693b      	ldr	r3, [r7, #16]
 8001518:	3301      	adds	r3, #1
 800151a:	4ac8      	ldr	r2, [pc, #800]	; (800183c <LDL_AES_encrypt+0x408>)
 800151c:	5c52      	ldrb	r2, [r2, r1]
 800151e:	701a      	strb	r2, [r3, #0]
        _s[R2 + C2] = SBOX( _s[R2 + C3] ^ k[p + R2 + C3] );
 8001520:	693b      	ldr	r3, [r7, #16]
 8001522:	3309      	adds	r3, #9
 8001524:	781a      	ldrb	r2, [r3, #0]
 8001526:	183b      	adds	r3, r7, r0
 8001528:	781b      	ldrb	r3, [r3, #0]
 800152a:	3309      	adds	r3, #9
 800152c:	68f9      	ldr	r1, [r7, #12]
 800152e:	18cb      	adds	r3, r1, r3
 8001530:	781b      	ldrb	r3, [r3, #0]
 8001532:	4053      	eors	r3, r2
 8001534:	b2db      	uxtb	r3, r3
 8001536:	0019      	movs	r1, r3
 8001538:	693b      	ldr	r3, [r7, #16]
 800153a:	3305      	adds	r3, #5
 800153c:	4abf      	ldr	r2, [pc, #764]	; (800183c <LDL_AES_encrypt+0x408>)
 800153e:	5c52      	ldrb	r2, [r2, r1]
 8001540:	701a      	strb	r2, [r3, #0]
        _s[R2 + C3] = SBOX( _s[R2 + C4] ^ k[p + R2 + C4] );
 8001542:	693b      	ldr	r3, [r7, #16]
 8001544:	330d      	adds	r3, #13
 8001546:	781a      	ldrb	r2, [r3, #0]
 8001548:	183b      	adds	r3, r7, r0
 800154a:	781b      	ldrb	r3, [r3, #0]
 800154c:	330d      	adds	r3, #13
 800154e:	68f9      	ldr	r1, [r7, #12]
 8001550:	18cb      	adds	r3, r1, r3
 8001552:	781b      	ldrb	r3, [r3, #0]
 8001554:	4053      	eors	r3, r2
 8001556:	b2db      	uxtb	r3, r3
 8001558:	0019      	movs	r1, r3
 800155a:	693b      	ldr	r3, [r7, #16]
 800155c:	3309      	adds	r3, #9
 800155e:	4ab7      	ldr	r2, [pc, #732]	; (800183c <LDL_AES_encrypt+0x408>)
 8001560:	5c52      	ldrb	r2, [r2, r1]
 8001562:	701a      	strb	r2, [r3, #0]
        _s[R2 + C4] = a;
 8001564:	693b      	ldr	r3, [r7, #16]
 8001566:	330d      	adds	r3, #13
 8001568:	193a      	adds	r2, r7, r4
 800156a:	7812      	ldrb	r2, [r2, #0]
 800156c:	701a      	strb	r2, [r3, #0]

        /* row 3, left shift 2 */
        a = SBOX( _s[R3     ] ^ k[p + R3] );
 800156e:	693b      	ldr	r3, [r7, #16]
 8001570:	3302      	adds	r3, #2
 8001572:	781a      	ldrb	r2, [r3, #0]
 8001574:	183b      	adds	r3, r7, r0
 8001576:	781b      	ldrb	r3, [r3, #0]
 8001578:	3302      	adds	r3, #2
 800157a:	68f9      	ldr	r1, [r7, #12]
 800157c:	18cb      	adds	r3, r1, r3
 800157e:	781b      	ldrb	r3, [r3, #0]
 8001580:	4053      	eors	r3, r2
 8001582:	b2db      	uxtb	r3, r3
 8001584:	0019      	movs	r1, r3
 8001586:	193b      	adds	r3, r7, r4
 8001588:	4aac      	ldr	r2, [pc, #688]	; (800183c <LDL_AES_encrypt+0x408>)
 800158a:	5c52      	ldrb	r2, [r2, r1]
 800158c:	701a      	strb	r2, [r3, #0]
        b = SBOX( _s[R3 + C2] ^ k[p + R3 + C2] );
 800158e:	693b      	ldr	r3, [r7, #16]
 8001590:	3306      	adds	r3, #6
 8001592:	781a      	ldrb	r2, [r3, #0]
 8001594:	183b      	adds	r3, r7, r0
 8001596:	781b      	ldrb	r3, [r3, #0]
 8001598:	3306      	adds	r3, #6
 800159a:	68f9      	ldr	r1, [r7, #12]
 800159c:	18cb      	adds	r3, r1, r3
 800159e:	781b      	ldrb	r3, [r3, #0]
 80015a0:	4053      	eors	r3, r2
 80015a2:	b2db      	uxtb	r3, r3
 80015a4:	0019      	movs	r1, r3
 80015a6:	250a      	movs	r5, #10
 80015a8:	197b      	adds	r3, r7, r5
 80015aa:	4aa4      	ldr	r2, [pc, #656]	; (800183c <LDL_AES_encrypt+0x408>)
 80015ac:	5c52      	ldrb	r2, [r2, r1]
 80015ae:	701a      	strb	r2, [r3, #0]
        _s[R3     ] = SBOX( _s[R3 + C3] ^ k[p + R3 + C3] );
 80015b0:	693b      	ldr	r3, [r7, #16]
 80015b2:	330a      	adds	r3, #10
 80015b4:	781a      	ldrb	r2, [r3, #0]
 80015b6:	183b      	adds	r3, r7, r0
 80015b8:	781b      	ldrb	r3, [r3, #0]
 80015ba:	330a      	adds	r3, #10
 80015bc:	68f9      	ldr	r1, [r7, #12]
 80015be:	18cb      	adds	r3, r1, r3
 80015c0:	781b      	ldrb	r3, [r3, #0]
 80015c2:	4053      	eors	r3, r2
 80015c4:	b2db      	uxtb	r3, r3
 80015c6:	0019      	movs	r1, r3
 80015c8:	693b      	ldr	r3, [r7, #16]
 80015ca:	3302      	adds	r3, #2
 80015cc:	4a9b      	ldr	r2, [pc, #620]	; (800183c <LDL_AES_encrypt+0x408>)
 80015ce:	5c52      	ldrb	r2, [r2, r1]
 80015d0:	701a      	strb	r2, [r3, #0]
        _s[R3 + C2] = SBOX( _s[R3 + C4] ^ k[p + R3 + C4] );
 80015d2:	693b      	ldr	r3, [r7, #16]
 80015d4:	330e      	adds	r3, #14
 80015d6:	781a      	ldrb	r2, [r3, #0]
 80015d8:	183b      	adds	r3, r7, r0
 80015da:	781b      	ldrb	r3, [r3, #0]
 80015dc:	330e      	adds	r3, #14
 80015de:	68f9      	ldr	r1, [r7, #12]
 80015e0:	18cb      	adds	r3, r1, r3
 80015e2:	781b      	ldrb	r3, [r3, #0]
 80015e4:	4053      	eors	r3, r2
 80015e6:	b2db      	uxtb	r3, r3
 80015e8:	0019      	movs	r1, r3
 80015ea:	693b      	ldr	r3, [r7, #16]
 80015ec:	3306      	adds	r3, #6
 80015ee:	4a93      	ldr	r2, [pc, #588]	; (800183c <LDL_AES_encrypt+0x408>)
 80015f0:	5c52      	ldrb	r2, [r2, r1]
 80015f2:	701a      	strb	r2, [r3, #0]
        _s[R3 + C3] = a;
 80015f4:	693b      	ldr	r3, [r7, #16]
 80015f6:	330a      	adds	r3, #10
 80015f8:	193a      	adds	r2, r7, r4
 80015fa:	7812      	ldrb	r2, [r2, #0]
 80015fc:	701a      	strb	r2, [r3, #0]
        _s[R3 + C4] = b;
 80015fe:	693b      	ldr	r3, [r7, #16]
 8001600:	330e      	adds	r3, #14
 8001602:	197a      	adds	r2, r7, r5
 8001604:	7812      	ldrb	r2, [r2, #0]
 8001606:	701a      	strb	r2, [r3, #0]

        /* row 4, left shift 3 */
        a = SBOX( _s[R4 + C4] ^ k[p + R4 + C4] );
 8001608:	693b      	ldr	r3, [r7, #16]
 800160a:	330f      	adds	r3, #15
 800160c:	781a      	ldrb	r2, [r3, #0]
 800160e:	183b      	adds	r3, r7, r0
 8001610:	781b      	ldrb	r3, [r3, #0]
 8001612:	330f      	adds	r3, #15
 8001614:	68f9      	ldr	r1, [r7, #12]
 8001616:	18cb      	adds	r3, r1, r3
 8001618:	781b      	ldrb	r3, [r3, #0]
 800161a:	4053      	eors	r3, r2
 800161c:	b2db      	uxtb	r3, r3
 800161e:	0019      	movs	r1, r3
 8001620:	193b      	adds	r3, r7, r4
 8001622:	4a86      	ldr	r2, [pc, #536]	; (800183c <LDL_AES_encrypt+0x408>)
 8001624:	5c52      	ldrb	r2, [r2, r1]
 8001626:	701a      	strb	r2, [r3, #0]
        _s[R4 + C4] = SBOX( _s[R4 + C3] ^ k[p + R4 + C3] );
 8001628:	693b      	ldr	r3, [r7, #16]
 800162a:	330b      	adds	r3, #11
 800162c:	781a      	ldrb	r2, [r3, #0]
 800162e:	183b      	adds	r3, r7, r0
 8001630:	781b      	ldrb	r3, [r3, #0]
 8001632:	330b      	adds	r3, #11
 8001634:	68f9      	ldr	r1, [r7, #12]
 8001636:	18cb      	adds	r3, r1, r3
 8001638:	781b      	ldrb	r3, [r3, #0]
 800163a:	4053      	eors	r3, r2
 800163c:	b2db      	uxtb	r3, r3
 800163e:	0019      	movs	r1, r3
 8001640:	693b      	ldr	r3, [r7, #16]
 8001642:	330f      	adds	r3, #15
 8001644:	4a7d      	ldr	r2, [pc, #500]	; (800183c <LDL_AES_encrypt+0x408>)
 8001646:	5c52      	ldrb	r2, [r2, r1]
 8001648:	701a      	strb	r2, [r3, #0]
        _s[R4 + C3] = SBOX( _s[R4 + C2] ^ k[p + R4 + C2] );
 800164a:	693b      	ldr	r3, [r7, #16]
 800164c:	3307      	adds	r3, #7
 800164e:	781a      	ldrb	r2, [r3, #0]
 8001650:	183b      	adds	r3, r7, r0
 8001652:	781b      	ldrb	r3, [r3, #0]
 8001654:	3307      	adds	r3, #7
 8001656:	68f9      	ldr	r1, [r7, #12]
 8001658:	18cb      	adds	r3, r1, r3
 800165a:	781b      	ldrb	r3, [r3, #0]
 800165c:	4053      	eors	r3, r2
 800165e:	b2db      	uxtb	r3, r3
 8001660:	0019      	movs	r1, r3
 8001662:	693b      	ldr	r3, [r7, #16]
 8001664:	330b      	adds	r3, #11
 8001666:	4a75      	ldr	r2, [pc, #468]	; (800183c <LDL_AES_encrypt+0x408>)
 8001668:	5c52      	ldrb	r2, [r2, r1]
 800166a:	701a      	strb	r2, [r3, #0]
        _s[R4 + C2] = SBOX( _s[R4     ] ^ k[p + R4     ] );
 800166c:	693b      	ldr	r3, [r7, #16]
 800166e:	3303      	adds	r3, #3
 8001670:	781a      	ldrb	r2, [r3, #0]
 8001672:	183b      	adds	r3, r7, r0
 8001674:	781b      	ldrb	r3, [r3, #0]
 8001676:	3303      	adds	r3, #3
 8001678:	68f9      	ldr	r1, [r7, #12]
 800167a:	18cb      	adds	r3, r1, r3
 800167c:	781b      	ldrb	r3, [r3, #0]
 800167e:	4053      	eors	r3, r2
 8001680:	b2db      	uxtb	r3, r3
 8001682:	0019      	movs	r1, r3
 8001684:	693b      	ldr	r3, [r7, #16]
 8001686:	3307      	adds	r3, #7
 8001688:	4a6c      	ldr	r2, [pc, #432]	; (800183c <LDL_AES_encrypt+0x408>)
 800168a:	5c52      	ldrb	r2, [r2, r1]
 800168c:	701a      	strb	r2, [r3, #0]
        _s[R4     ] = a;
 800168e:	693b      	ldr	r3, [r7, #16]
 8001690:	3303      	adds	r3, #3
 8001692:	193a      	adds	r2, r7, r4
 8001694:	7812      	ldrb	r2, [r2, #0]
 8001696:	701a      	strb	r2, [r3, #0]

        if((r+1U) == ctx->r){
 8001698:	2317      	movs	r3, #23
 800169a:	18fb      	adds	r3, r7, r3
 800169c:	781b      	ldrb	r3, [r3, #0]
 800169e:	3301      	adds	r3, #1
 80016a0:	687a      	ldr	r2, [r7, #4]
 80016a2:	21f0      	movs	r1, #240	; 0xf0
 80016a4:	5c52      	ldrb	r2, [r2, r1]
 80016a6:	4293      	cmp	r3, r2
 80016a8:	d12a      	bne.n	8001700 <LDL_AES_encrypt+0x2cc>

            p += 16U;
 80016aa:	2215      	movs	r2, #21
 80016ac:	18bb      	adds	r3, r7, r2
 80016ae:	18ba      	adds	r2, r7, r2
 80016b0:	7812      	ldrb	r2, [r2, #0]
 80016b2:	3210      	adds	r2, #16
 80016b4:	701a      	strb	r2, [r3, #0]

            /* final add round key */
            for(i=0U; i < 16U; i++){
 80016b6:	2316      	movs	r3, #22
 80016b8:	18fb      	adds	r3, r7, r3
 80016ba:	2200      	movs	r2, #0
 80016bc:	701a      	strb	r2, [r3, #0]
 80016be:	e019      	b.n	80016f4 <LDL_AES_encrypt+0x2c0>

                _s[i] ^= ctx->k[p+i];
 80016c0:	2416      	movs	r4, #22
 80016c2:	193b      	adds	r3, r7, r4
 80016c4:	781b      	ldrb	r3, [r3, #0]
 80016c6:	693a      	ldr	r2, [r7, #16]
 80016c8:	18d3      	adds	r3, r2, r3
 80016ca:	7819      	ldrb	r1, [r3, #0]
 80016cc:	2315      	movs	r3, #21
 80016ce:	18fb      	adds	r3, r7, r3
 80016d0:	781a      	ldrb	r2, [r3, #0]
 80016d2:	193b      	adds	r3, r7, r4
 80016d4:	781b      	ldrb	r3, [r3, #0]
 80016d6:	18d3      	adds	r3, r2, r3
 80016d8:	687a      	ldr	r2, [r7, #4]
 80016da:	5cd2      	ldrb	r2, [r2, r3]
 80016dc:	193b      	adds	r3, r7, r4
 80016de:	781b      	ldrb	r3, [r3, #0]
 80016e0:	6938      	ldr	r0, [r7, #16]
 80016e2:	18c3      	adds	r3, r0, r3
 80016e4:	404a      	eors	r2, r1
 80016e6:	b2d2      	uxtb	r2, r2
 80016e8:	701a      	strb	r2, [r3, #0]
            for(i=0U; i < 16U; i++){
 80016ea:	193b      	adds	r3, r7, r4
 80016ec:	781a      	ldrb	r2, [r3, #0]
 80016ee:	193b      	adds	r3, r7, r4
 80016f0:	3201      	adds	r2, #1
 80016f2:	701a      	strb	r2, [r3, #0]
 80016f4:	2316      	movs	r3, #22
 80016f6:	18fb      	adds	r3, r7, r3
 80016f8:	781b      	ldrb	r3, [r3, #0]
 80016fa:	2b0f      	cmp	r3, #15
 80016fc:	d9e0      	bls.n	80016c0 <LDL_AES_encrypt+0x28c>
            }
            
            break;
 80016fe:	e168      	b.n	80019d2 <LDL_AES_encrypt+0x59e>
        }
         
        /* mix columns */
        for(i=0U; i < 16U; i += 4U){
 8001700:	2316      	movs	r3, #22
 8001702:	18fb      	adds	r3, r7, r3
 8001704:	2200      	movs	r2, #0
 8001706:	701a      	strb	r2, [r3, #0]
 8001708:	e148      	b.n	800199c <LDL_AES_encrypt+0x568>

            a = _s[i     ];
 800170a:	2116      	movs	r1, #22
 800170c:	187b      	adds	r3, r7, r1
 800170e:	781b      	ldrb	r3, [r3, #0]
 8001710:	693a      	ldr	r2, [r7, #16]
 8001712:	18d2      	adds	r2, r2, r3
 8001714:	200b      	movs	r0, #11
 8001716:	183b      	adds	r3, r7, r0
 8001718:	7812      	ldrb	r2, [r2, #0]
 800171a:	701a      	strb	r2, [r3, #0]
            b = _s[i + 1U];
 800171c:	187b      	adds	r3, r7, r1
 800171e:	781b      	ldrb	r3, [r3, #0]
 8001720:	3301      	adds	r3, #1
 8001722:	693a      	ldr	r2, [r7, #16]
 8001724:	18d2      	adds	r2, r2, r3
 8001726:	240a      	movs	r4, #10
 8001728:	193b      	adds	r3, r7, r4
 800172a:	7812      	ldrb	r2, [r2, #0]
 800172c:	701a      	strb	r2, [r3, #0]
            c = _s[i + 2U];
 800172e:	187b      	adds	r3, r7, r1
 8001730:	781b      	ldrb	r3, [r3, #0]
 8001732:	3302      	adds	r3, #2
 8001734:	693a      	ldr	r2, [r7, #16]
 8001736:	18d2      	adds	r2, r2, r3
 8001738:	2509      	movs	r5, #9
 800173a:	197b      	adds	r3, r7, r5
 800173c:	7812      	ldrb	r2, [r2, #0]
 800173e:	701a      	strb	r2, [r3, #0]
            d = _s[i + 3U];
 8001740:	187b      	adds	r3, r7, r1
 8001742:	781b      	ldrb	r3, [r3, #0]
 8001744:	3303      	adds	r3, #3
 8001746:	693a      	ldr	r2, [r7, #16]
 8001748:	18d2      	adds	r2, r2, r3
 800174a:	2608      	movs	r6, #8
 800174c:	19bb      	adds	r3, r7, r6
 800174e:	7812      	ldrb	r2, [r2, #0]
 8001750:	701a      	strb	r2, [r3, #0]
             * 1a + 2b + 3c + 1d
             * 1a + 1b + 2c + 3d
             * 3a + 1b + 1c + 2d
             *
             * */
            _s[i     ] ^= (a ^ b ^ c ^ d) ^ GALOIS_MUL2( (a ^ b) );
 8001752:	187b      	adds	r3, r7, r1
 8001754:	781b      	ldrb	r3, [r3, #0]
 8001756:	693a      	ldr	r2, [r7, #16]
 8001758:	18d3      	adds	r3, r2, r3
 800175a:	781b      	ldrb	r3, [r3, #0]
 800175c:	b25a      	sxtb	r2, r3
 800175e:	1839      	adds	r1, r7, r0
 8001760:	193b      	adds	r3, r7, r4
 8001762:	7809      	ldrb	r1, [r1, #0]
 8001764:	781b      	ldrb	r3, [r3, #0]
 8001766:	404b      	eors	r3, r1
 8001768:	b2d9      	uxtb	r1, r3
 800176a:	197b      	adds	r3, r7, r5
 800176c:	781b      	ldrb	r3, [r3, #0]
 800176e:	404b      	eors	r3, r1
 8001770:	b2d9      	uxtb	r1, r3
 8001772:	19bb      	adds	r3, r7, r6
 8001774:	781b      	ldrb	r3, [r3, #0]
 8001776:	404b      	eors	r3, r1
 8001778:	b2db      	uxtb	r3, r3
 800177a:	b259      	sxtb	r1, r3
 800177c:	1838      	adds	r0, r7, r0
 800177e:	193b      	adds	r3, r7, r4
 8001780:	7800      	ldrb	r0, [r0, #0]
 8001782:	781b      	ldrb	r3, [r3, #0]
 8001784:	4043      	eors	r3, r0
 8001786:	b2db      	uxtb	r3, r3
 8001788:	b25b      	sxtb	r3, r3
 800178a:	2b00      	cmp	r3, #0
 800178c:	da0e      	bge.n	80017ac <LDL_AES_encrypt+0x378>
 800178e:	230b      	movs	r3, #11
 8001790:	18f8      	adds	r0, r7, r3
 8001792:	230a      	movs	r3, #10
 8001794:	18fb      	adds	r3, r7, r3
 8001796:	7800      	ldrb	r0, [r0, #0]
 8001798:	781b      	ldrb	r3, [r3, #0]
 800179a:	4043      	eors	r3, r0
 800179c:	b2db      	uxtb	r3, r3
 800179e:	18db      	adds	r3, r3, r3
 80017a0:	b2db      	uxtb	r3, r3
 80017a2:	201b      	movs	r0, #27
 80017a4:	4043      	eors	r3, r0
 80017a6:	b2db      	uxtb	r3, r3
 80017a8:	b25b      	sxtb	r3, r3
 80017aa:	e00a      	b.n	80017c2 <LDL_AES_encrypt+0x38e>
 80017ac:	230b      	movs	r3, #11
 80017ae:	18f8      	adds	r0, r7, r3
 80017b0:	230a      	movs	r3, #10
 80017b2:	18fb      	adds	r3, r7, r3
 80017b4:	7800      	ldrb	r0, [r0, #0]
 80017b6:	781b      	ldrb	r3, [r3, #0]
 80017b8:	4043      	eors	r3, r0
 80017ba:	b2db      	uxtb	r3, r3
 80017bc:	18db      	adds	r3, r3, r3
 80017be:	b2db      	uxtb	r3, r3
 80017c0:	b25b      	sxtb	r3, r3
 80017c2:	404b      	eors	r3, r1
 80017c4:	b25b      	sxtb	r3, r3
 80017c6:	4053      	eors	r3, r2
 80017c8:	b259      	sxtb	r1, r3
 80017ca:	2016      	movs	r0, #22
 80017cc:	183b      	adds	r3, r7, r0
 80017ce:	781b      	ldrb	r3, [r3, #0]
 80017d0:	693a      	ldr	r2, [r7, #16]
 80017d2:	18d3      	adds	r3, r2, r3
 80017d4:	b2ca      	uxtb	r2, r1
 80017d6:	701a      	strb	r2, [r3, #0]
            _s[i + 1U] ^= (a ^ b ^ c ^ d) ^ GALOIS_MUL2( (b ^ c) );
 80017d8:	183b      	adds	r3, r7, r0
 80017da:	781b      	ldrb	r3, [r3, #0]
 80017dc:	3301      	adds	r3, #1
 80017de:	693a      	ldr	r2, [r7, #16]
 80017e0:	18d3      	adds	r3, r2, r3
 80017e2:	781b      	ldrb	r3, [r3, #0]
 80017e4:	b25a      	sxtb	r2, r3
 80017e6:	230b      	movs	r3, #11
 80017e8:	18f9      	adds	r1, r7, r3
 80017ea:	200a      	movs	r0, #10
 80017ec:	183b      	adds	r3, r7, r0
 80017ee:	7809      	ldrb	r1, [r1, #0]
 80017f0:	781b      	ldrb	r3, [r3, #0]
 80017f2:	404b      	eors	r3, r1
 80017f4:	b2d9      	uxtb	r1, r3
 80017f6:	2409      	movs	r4, #9
 80017f8:	193b      	adds	r3, r7, r4
 80017fa:	781b      	ldrb	r3, [r3, #0]
 80017fc:	404b      	eors	r3, r1
 80017fe:	b2d9      	uxtb	r1, r3
 8001800:	2308      	movs	r3, #8
 8001802:	18fb      	adds	r3, r7, r3
 8001804:	781b      	ldrb	r3, [r3, #0]
 8001806:	404b      	eors	r3, r1
 8001808:	b2db      	uxtb	r3, r3
 800180a:	b259      	sxtb	r1, r3
 800180c:	1838      	adds	r0, r7, r0
 800180e:	193b      	adds	r3, r7, r4
 8001810:	7800      	ldrb	r0, [r0, #0]
 8001812:	781b      	ldrb	r3, [r3, #0]
 8001814:	4043      	eors	r3, r0
 8001816:	b2db      	uxtb	r3, r3
 8001818:	b25b      	sxtb	r3, r3
 800181a:	2b00      	cmp	r3, #0
 800181c:	da10      	bge.n	8001840 <LDL_AES_encrypt+0x40c>
 800181e:	230a      	movs	r3, #10
 8001820:	18f8      	adds	r0, r7, r3
 8001822:	2309      	movs	r3, #9
 8001824:	18fb      	adds	r3, r7, r3
 8001826:	7800      	ldrb	r0, [r0, #0]
 8001828:	781b      	ldrb	r3, [r3, #0]
 800182a:	4043      	eors	r3, r0
 800182c:	b2db      	uxtb	r3, r3
 800182e:	18db      	adds	r3, r3, r3
 8001830:	b2db      	uxtb	r3, r3
 8001832:	201b      	movs	r0, #27
 8001834:	4043      	eors	r3, r0
 8001836:	b2db      	uxtb	r3, r3
 8001838:	b25b      	sxtb	r3, r3
 800183a:	e00c      	b.n	8001856 <LDL_AES_encrypt+0x422>
 800183c:	0800e380 	.word	0x0800e380
 8001840:	230a      	movs	r3, #10
 8001842:	18f8      	adds	r0, r7, r3
 8001844:	2309      	movs	r3, #9
 8001846:	18fb      	adds	r3, r7, r3
 8001848:	7800      	ldrb	r0, [r0, #0]
 800184a:	781b      	ldrb	r3, [r3, #0]
 800184c:	4043      	eors	r3, r0
 800184e:	b2db      	uxtb	r3, r3
 8001850:	18db      	adds	r3, r3, r3
 8001852:	b2db      	uxtb	r3, r3
 8001854:	b25b      	sxtb	r3, r3
 8001856:	404b      	eors	r3, r1
 8001858:	b25b      	sxtb	r3, r3
 800185a:	4053      	eors	r3, r2
 800185c:	b259      	sxtb	r1, r3
 800185e:	2016      	movs	r0, #22
 8001860:	183b      	adds	r3, r7, r0
 8001862:	781b      	ldrb	r3, [r3, #0]
 8001864:	3301      	adds	r3, #1
 8001866:	693a      	ldr	r2, [r7, #16]
 8001868:	18d3      	adds	r3, r2, r3
 800186a:	b2ca      	uxtb	r2, r1
 800186c:	701a      	strb	r2, [r3, #0]
            _s[i + 2U] ^= (a ^ b ^ c ^ d) ^ GALOIS_MUL2( (c ^ d) );
 800186e:	183b      	adds	r3, r7, r0
 8001870:	781b      	ldrb	r3, [r3, #0]
 8001872:	3302      	adds	r3, #2
 8001874:	693a      	ldr	r2, [r7, #16]
 8001876:	18d3      	adds	r3, r2, r3
 8001878:	781b      	ldrb	r3, [r3, #0]
 800187a:	b25a      	sxtb	r2, r3
 800187c:	230b      	movs	r3, #11
 800187e:	18f9      	adds	r1, r7, r3
 8001880:	230a      	movs	r3, #10
 8001882:	18fb      	adds	r3, r7, r3
 8001884:	7809      	ldrb	r1, [r1, #0]
 8001886:	781b      	ldrb	r3, [r3, #0]
 8001888:	404b      	eors	r3, r1
 800188a:	b2d9      	uxtb	r1, r3
 800188c:	2009      	movs	r0, #9
 800188e:	183b      	adds	r3, r7, r0
 8001890:	781b      	ldrb	r3, [r3, #0]
 8001892:	404b      	eors	r3, r1
 8001894:	b2d9      	uxtb	r1, r3
 8001896:	2408      	movs	r4, #8
 8001898:	193b      	adds	r3, r7, r4
 800189a:	781b      	ldrb	r3, [r3, #0]
 800189c:	404b      	eors	r3, r1
 800189e:	b2db      	uxtb	r3, r3
 80018a0:	b259      	sxtb	r1, r3
 80018a2:	1838      	adds	r0, r7, r0
 80018a4:	193b      	adds	r3, r7, r4
 80018a6:	7800      	ldrb	r0, [r0, #0]
 80018a8:	781b      	ldrb	r3, [r3, #0]
 80018aa:	4043      	eors	r3, r0
 80018ac:	b2db      	uxtb	r3, r3
 80018ae:	b25b      	sxtb	r3, r3
 80018b0:	2b00      	cmp	r3, #0
 80018b2:	da0e      	bge.n	80018d2 <LDL_AES_encrypt+0x49e>
 80018b4:	2309      	movs	r3, #9
 80018b6:	18f8      	adds	r0, r7, r3
 80018b8:	2308      	movs	r3, #8
 80018ba:	18fb      	adds	r3, r7, r3
 80018bc:	7800      	ldrb	r0, [r0, #0]
 80018be:	781b      	ldrb	r3, [r3, #0]
 80018c0:	4043      	eors	r3, r0
 80018c2:	b2db      	uxtb	r3, r3
 80018c4:	18db      	adds	r3, r3, r3
 80018c6:	b2db      	uxtb	r3, r3
 80018c8:	201b      	movs	r0, #27
 80018ca:	4043      	eors	r3, r0
 80018cc:	b2db      	uxtb	r3, r3
 80018ce:	b25b      	sxtb	r3, r3
 80018d0:	e00a      	b.n	80018e8 <LDL_AES_encrypt+0x4b4>
 80018d2:	2309      	movs	r3, #9
 80018d4:	18f8      	adds	r0, r7, r3
 80018d6:	2308      	movs	r3, #8
 80018d8:	18fb      	adds	r3, r7, r3
 80018da:	7800      	ldrb	r0, [r0, #0]
 80018dc:	781b      	ldrb	r3, [r3, #0]
 80018de:	4043      	eors	r3, r0
 80018e0:	b2db      	uxtb	r3, r3
 80018e2:	18db      	adds	r3, r3, r3
 80018e4:	b2db      	uxtb	r3, r3
 80018e6:	b25b      	sxtb	r3, r3
 80018e8:	404b      	eors	r3, r1
 80018ea:	b25b      	sxtb	r3, r3
 80018ec:	4053      	eors	r3, r2
 80018ee:	b259      	sxtb	r1, r3
 80018f0:	2016      	movs	r0, #22
 80018f2:	183b      	adds	r3, r7, r0
 80018f4:	781b      	ldrb	r3, [r3, #0]
 80018f6:	3302      	adds	r3, #2
 80018f8:	693a      	ldr	r2, [r7, #16]
 80018fa:	18d3      	adds	r3, r2, r3
 80018fc:	b2ca      	uxtb	r2, r1
 80018fe:	701a      	strb	r2, [r3, #0]
            _s[i + 3U] ^= (a ^ b ^ c ^ d) ^ GALOIS_MUL2( (d ^ a) );
 8001900:	183b      	adds	r3, r7, r0
 8001902:	781b      	ldrb	r3, [r3, #0]
 8001904:	3303      	adds	r3, #3
 8001906:	693a      	ldr	r2, [r7, #16]
 8001908:	18d3      	adds	r3, r2, r3
 800190a:	781b      	ldrb	r3, [r3, #0]
 800190c:	b25a      	sxtb	r2, r3
 800190e:	240b      	movs	r4, #11
 8001910:	1939      	adds	r1, r7, r4
 8001912:	230a      	movs	r3, #10
 8001914:	18fb      	adds	r3, r7, r3
 8001916:	7809      	ldrb	r1, [r1, #0]
 8001918:	781b      	ldrb	r3, [r3, #0]
 800191a:	404b      	eors	r3, r1
 800191c:	b2d9      	uxtb	r1, r3
 800191e:	2309      	movs	r3, #9
 8001920:	18fb      	adds	r3, r7, r3
 8001922:	781b      	ldrb	r3, [r3, #0]
 8001924:	404b      	eors	r3, r1
 8001926:	b2d9      	uxtb	r1, r3
 8001928:	2008      	movs	r0, #8
 800192a:	183b      	adds	r3, r7, r0
 800192c:	781b      	ldrb	r3, [r3, #0]
 800192e:	404b      	eors	r3, r1
 8001930:	b2db      	uxtb	r3, r3
 8001932:	b259      	sxtb	r1, r3
 8001934:	1838      	adds	r0, r7, r0
 8001936:	193b      	adds	r3, r7, r4
 8001938:	7800      	ldrb	r0, [r0, #0]
 800193a:	781b      	ldrb	r3, [r3, #0]
 800193c:	4043      	eors	r3, r0
 800193e:	b2db      	uxtb	r3, r3
 8001940:	b25b      	sxtb	r3, r3
 8001942:	2b00      	cmp	r3, #0
 8001944:	da0e      	bge.n	8001964 <LDL_AES_encrypt+0x530>
 8001946:	2308      	movs	r3, #8
 8001948:	18f8      	adds	r0, r7, r3
 800194a:	230b      	movs	r3, #11
 800194c:	18fb      	adds	r3, r7, r3
 800194e:	7800      	ldrb	r0, [r0, #0]
 8001950:	781b      	ldrb	r3, [r3, #0]
 8001952:	4043      	eors	r3, r0
 8001954:	b2db      	uxtb	r3, r3
 8001956:	18db      	adds	r3, r3, r3
 8001958:	b2db      	uxtb	r3, r3
 800195a:	201b      	movs	r0, #27
 800195c:	4043      	eors	r3, r0
 800195e:	b2db      	uxtb	r3, r3
 8001960:	b25b      	sxtb	r3, r3
 8001962:	e00a      	b.n	800197a <LDL_AES_encrypt+0x546>
 8001964:	2308      	movs	r3, #8
 8001966:	18f8      	adds	r0, r7, r3
 8001968:	230b      	movs	r3, #11
 800196a:	18fb      	adds	r3, r7, r3
 800196c:	7800      	ldrb	r0, [r0, #0]
 800196e:	781b      	ldrb	r3, [r3, #0]
 8001970:	4043      	eors	r3, r0
 8001972:	b2db      	uxtb	r3, r3
 8001974:	18db      	adds	r3, r3, r3
 8001976:	b2db      	uxtb	r3, r3
 8001978:	b25b      	sxtb	r3, r3
 800197a:	404b      	eors	r3, r1
 800197c:	b25b      	sxtb	r3, r3
 800197e:	4053      	eors	r3, r2
 8001980:	b259      	sxtb	r1, r3
 8001982:	2016      	movs	r0, #22
 8001984:	183b      	adds	r3, r7, r0
 8001986:	781b      	ldrb	r3, [r3, #0]
 8001988:	3303      	adds	r3, #3
 800198a:	693a      	ldr	r2, [r7, #16]
 800198c:	18d3      	adds	r3, r2, r3
 800198e:	b2ca      	uxtb	r2, r1
 8001990:	701a      	strb	r2, [r3, #0]
        for(i=0U; i < 16U; i += 4U){
 8001992:	183b      	adds	r3, r7, r0
 8001994:	183a      	adds	r2, r7, r0
 8001996:	7812      	ldrb	r2, [r2, #0]
 8001998:	3204      	adds	r2, #4
 800199a:	701a      	strb	r2, [r3, #0]
 800199c:	2316      	movs	r3, #22
 800199e:	18fb      	adds	r3, r7, r3
 80019a0:	781b      	ldrb	r3, [r3, #0]
 80019a2:	2b0f      	cmp	r3, #15
 80019a4:	d800      	bhi.n	80019a8 <LDL_AES_encrypt+0x574>
 80019a6:	e6b0      	b.n	800170a <LDL_AES_encrypt+0x2d6>
        }

        p += 16U;
 80019a8:	2215      	movs	r2, #21
 80019aa:	18bb      	adds	r3, r7, r2
 80019ac:	18ba      	adds	r2, r7, r2
 80019ae:	7812      	ldrb	r2, [r2, #0]
 80019b0:	3210      	adds	r2, #16
 80019b2:	701a      	strb	r2, [r3, #0]
    for(r = 0U; r < ctx->r; r++){
 80019b4:	2117      	movs	r1, #23
 80019b6:	187b      	adds	r3, r7, r1
 80019b8:	781a      	ldrb	r2, [r3, #0]
 80019ba:	187b      	adds	r3, r7, r1
 80019bc:	3201      	adds	r2, #1
 80019be:	701a      	strb	r2, [r3, #0]
 80019c0:	687b      	ldr	r3, [r7, #4]
 80019c2:	22f0      	movs	r2, #240	; 0xf0
 80019c4:	5c9b      	ldrb	r3, [r3, r2]
 80019c6:	2217      	movs	r2, #23
 80019c8:	18ba      	adds	r2, r7, r2
 80019ca:	7812      	ldrb	r2, [r2, #0]
 80019cc:	429a      	cmp	r2, r3
 80019ce:	d200      	bcs.n	80019d2 <LDL_AES_encrypt+0x59e>
 80019d0:	e542      	b.n	8001458 <LDL_AES_encrypt+0x24>
    }   
}
 80019d2:	46c0      	nop			; (mov r8, r8)
 80019d4:	46bd      	mov	sp, r7
 80019d6:	b007      	add	sp, #28
 80019d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80019da:	46c0      	nop			; (mov r8, r8)

080019dc <LDL_CMAC_init>:
static void leftShift128(uint8_t *v);

/* functions  *********************************************************/

void LDL_CMAC_init(struct ldl_cmac_ctx *ctx, const struct ldl_aes_ctx *aes_ctx)
{    
 80019dc:	b580      	push	{r7, lr}
 80019de:	b082      	sub	sp, #8
 80019e0:	af00      	add	r7, sp, #0
 80019e2:	6078      	str	r0, [r7, #4]
 80019e4:	6039      	str	r1, [r7, #0]
    LDL_PEDANTIC(ctx != NULL)
    LDL_PEDANTIC(aes_ctx != NULL)

    (void)memset(ctx, 0, sizeof(*ctx));
 80019e6:	687b      	ldr	r3, [r7, #4]
 80019e8:	2228      	movs	r2, #40	; 0x28
 80019ea:	2100      	movs	r1, #0
 80019ec:	0018      	movs	r0, r3
 80019ee:	f00a ff74 	bl	800c8da <memset>
    ctx->aes_ctx = aes_ctx;
 80019f2:	687b      	ldr	r3, [r7, #4]
 80019f4:	683a      	ldr	r2, [r7, #0]
 80019f6:	601a      	str	r2, [r3, #0]
}
 80019f8:	46c0      	nop			; (mov r8, r8)
 80019fa:	46bd      	mov	sp, r7
 80019fc:	b002      	add	sp, #8
 80019fe:	bd80      	pop	{r7, pc}

08001a00 <LDL_CMAC_update>:

void LDL_CMAC_update(struct ldl_cmac_ctx *ctx, const void *data, uint8_t len)
{
 8001a00:	b5b0      	push	{r4, r5, r7, lr}
 8001a02:	b086      	sub	sp, #24
 8001a04:	af00      	add	r7, sp, #0
 8001a06:	60f8      	str	r0, [r7, #12]
 8001a08:	60b9      	str	r1, [r7, #8]
 8001a0a:	1dfb      	adds	r3, r7, #7
 8001a0c:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC((len == 0U) || (data != NULL))

    uint8_t part;
    uint8_t i;
    uint8_t blocks;
    uint8_t pos = 0U;
 8001a0e:	2314      	movs	r3, #20
 8001a10:	18fb      	adds	r3, r7, r3
 8001a12:	2200      	movs	r2, #0
 8001a14:	701a      	strb	r2, [r3, #0]
    const uint8_t *in = (const uint8_t *)data;    
 8001a16:	68bb      	ldr	r3, [r7, #8]
 8001a18:	613b      	str	r3, [r7, #16]
    
    part =  ctx->size % (uint8_t)sizeof(ctx->m);
 8001a1a:	68fb      	ldr	r3, [r7, #12]
 8001a1c:	2224      	movs	r2, #36	; 0x24
 8001a1e:	5c9a      	ldrb	r2, [r3, r2]
 8001a20:	2317      	movs	r3, #23
 8001a22:	18fb      	adds	r3, r7, r3
 8001a24:	210f      	movs	r1, #15
 8001a26:	400a      	ands	r2, r1
 8001a28:	701a      	strb	r2, [r3, #0]
    
    if(len > 0U){
 8001a2a:	1dfb      	adds	r3, r7, #7
 8001a2c:	781b      	ldrb	r3, [r3, #0]
 8001a2e:	2b00      	cmp	r3, #0
 8001a30:	d100      	bne.n	8001a34 <LDL_CMAC_update+0x34>
 8001a32:	e0a8      	b.n	8001b86 <LDL_CMAC_update+0x186>

        if(((part == 0U) && (ctx->size > 0U)) || ((part + len) > sizeof(ctx->m))){
 8001a34:	2317      	movs	r3, #23
 8001a36:	18fb      	adds	r3, r7, r3
 8001a38:	781b      	ldrb	r3, [r3, #0]
 8001a3a:	2b00      	cmp	r3, #0
 8001a3c:	d104      	bne.n	8001a48 <LDL_CMAC_update+0x48>
 8001a3e:	68fb      	ldr	r3, [r7, #12]
 8001a40:	2224      	movs	r2, #36	; 0x24
 8001a42:	5c9b      	ldrb	r3, [r3, r2]
 8001a44:	2b00      	cmp	r3, #0
 8001a46:	d108      	bne.n	8001a5a <LDL_CMAC_update+0x5a>
 8001a48:	2317      	movs	r3, #23
 8001a4a:	18fb      	adds	r3, r7, r3
 8001a4c:	781a      	ldrb	r2, [r3, #0]
 8001a4e:	1dfb      	adds	r3, r7, #7
 8001a50:	781b      	ldrb	r3, [r3, #0]
 8001a52:	18d3      	adds	r3, r2, r3
 8001a54:	2b10      	cmp	r3, #16
 8001a56:	d800      	bhi.n	8001a5a <LDL_CMAC_update+0x5a>
 8001a58:	e078      	b.n	8001b4c <LDL_CMAC_update+0x14c>

            /* sometimes a whole extra block will already be cached, process it */
            if((part == 0U) && (ctx->size > 0U)){
 8001a5a:	2317      	movs	r3, #23
 8001a5c:	18fb      	adds	r3, r7, r3
 8001a5e:	781b      	ldrb	r3, [r3, #0]
 8001a60:	2b00      	cmp	r3, #0
 8001a62:	d115      	bne.n	8001a90 <LDL_CMAC_update+0x90>
 8001a64:	68fb      	ldr	r3, [r7, #12]
 8001a66:	2224      	movs	r2, #36	; 0x24
 8001a68:	5c9b      	ldrb	r3, [r3, r2]
 8001a6a:	2b00      	cmp	r3, #0
 8001a6c:	d010      	beq.n	8001a90 <LDL_CMAC_update+0x90>
                
                xor128(ctx->x, ctx->m);
 8001a6e:	68fb      	ldr	r3, [r7, #12]
 8001a70:	3314      	adds	r3, #20
 8001a72:	001a      	movs	r2, r3
 8001a74:	68fb      	ldr	r3, [r7, #12]
 8001a76:	3304      	adds	r3, #4
 8001a78:	0019      	movs	r1, r3
 8001a7a:	0010      	movs	r0, r2
 8001a7c:	f000 f978 	bl	8001d70 <xor128>
                LDL_AES_encrypt(ctx->aes_ctx, ctx->x);
 8001a80:	68fb      	ldr	r3, [r7, #12]
 8001a82:	681a      	ldr	r2, [r3, #0]
 8001a84:	68fb      	ldr	r3, [r7, #12]
 8001a86:	3314      	adds	r3, #20
 8001a88:	0019      	movs	r1, r3
 8001a8a:	0010      	movs	r0, r2
 8001a8c:	f7ff fcd2 	bl	8001434 <LDL_AES_encrypt>
            }

            /* number of new blocks to process */
            blocks = (part + len) / sizeof(ctx->m);
 8001a90:	2117      	movs	r1, #23
 8001a92:	187b      	adds	r3, r7, r1
 8001a94:	781a      	ldrb	r2, [r3, #0]
 8001a96:	1dfb      	adds	r3, r7, #7
 8001a98:	781b      	ldrb	r3, [r3, #0]
 8001a9a:	18d3      	adds	r3, r2, r3
 8001a9c:	091a      	lsrs	r2, r3, #4
 8001a9e:	2315      	movs	r3, #21
 8001aa0:	18fb      	adds	r3, r7, r3
 8001aa2:	701a      	strb	r2, [r3, #0]
                        
            /* do not process the last new block */
            if(((part + len) % sizeof(ctx->m)) == 0U){
 8001aa4:	187b      	adds	r3, r7, r1
 8001aa6:	781a      	ldrb	r2, [r3, #0]
 8001aa8:	1dfb      	adds	r3, r7, #7
 8001aaa:	781b      	ldrb	r3, [r3, #0]
 8001aac:	18d3      	adds	r3, r2, r3
 8001aae:	001a      	movs	r2, r3
 8001ab0:	230f      	movs	r3, #15
 8001ab2:	4013      	ands	r3, r2
 8001ab4:	d105      	bne.n	8001ac2 <LDL_CMAC_update+0xc2>
            
                blocks -= 1U;
 8001ab6:	2215      	movs	r2, #21
 8001ab8:	18bb      	adds	r3, r7, r2
 8001aba:	18ba      	adds	r2, r7, r2
 8001abc:	7812      	ldrb	r2, [r2, #0]
 8001abe:	3a01      	subs	r2, #1
 8001ac0:	701a      	strb	r2, [r3, #0]
            }
            
            /* make up the first block to process */
            
            for(i=0U; i < blocks; i++){
 8001ac2:	2316      	movs	r3, #22
 8001ac4:	18fb      	adds	r3, r7, r3
 8001ac6:	2200      	movs	r2, #0
 8001ac8:	701a      	strb	r2, [r3, #0]
 8001aca:	e037      	b.n	8001b3c <LDL_CMAC_update+0x13c>

                (void)memcpy(&ctx->m[part], &in[pos], sizeof(ctx->m) - part);
 8001acc:	2117      	movs	r1, #23
 8001ace:	000c      	movs	r4, r1
 8001ad0:	187b      	adds	r3, r7, r1
 8001ad2:	781b      	ldrb	r3, [r3, #0]
 8001ad4:	68fa      	ldr	r2, [r7, #12]
 8001ad6:	18d3      	adds	r3, r2, r3
 8001ad8:	1d18      	adds	r0, r3, #4
 8001ada:	2514      	movs	r5, #20
 8001adc:	197b      	adds	r3, r7, r5
 8001ade:	781b      	ldrb	r3, [r3, #0]
 8001ae0:	693a      	ldr	r2, [r7, #16]
 8001ae2:	18d1      	adds	r1, r2, r3
 8001ae4:	193b      	adds	r3, r7, r4
 8001ae6:	781b      	ldrb	r3, [r3, #0]
 8001ae8:	2210      	movs	r2, #16
 8001aea:	1ad3      	subs	r3, r2, r3
 8001aec:	001a      	movs	r2, r3
 8001aee:	f00a feeb 	bl	800c8c8 <memcpy>
                pos += sizeof(ctx->m) - part;
 8001af2:	0028      	movs	r0, r5
 8001af4:	183a      	adds	r2, r7, r0
 8001af6:	0021      	movs	r1, r4
 8001af8:	193b      	adds	r3, r7, r4
 8001afa:	7812      	ldrb	r2, [r2, #0]
 8001afc:	781b      	ldrb	r3, [r3, #0]
 8001afe:	1ad3      	subs	r3, r2, r3
 8001b00:	b2da      	uxtb	r2, r3
 8001b02:	183b      	adds	r3, r7, r0
 8001b04:	3210      	adds	r2, #16
 8001b06:	701a      	strb	r2, [r3, #0]

                part = 0U;
 8001b08:	187b      	adds	r3, r7, r1
 8001b0a:	2200      	movs	r2, #0
 8001b0c:	701a      	strb	r2, [r3, #0]

                xor128(ctx->x, ctx->m);
 8001b0e:	68fb      	ldr	r3, [r7, #12]
 8001b10:	3314      	adds	r3, #20
 8001b12:	001a      	movs	r2, r3
 8001b14:	68fb      	ldr	r3, [r7, #12]
 8001b16:	3304      	adds	r3, #4
 8001b18:	0019      	movs	r1, r3
 8001b1a:	0010      	movs	r0, r2
 8001b1c:	f000 f928 	bl	8001d70 <xor128>
                LDL_AES_encrypt(ctx->aes_ctx, ctx->x);                
 8001b20:	68fb      	ldr	r3, [r7, #12]
 8001b22:	681a      	ldr	r2, [r3, #0]
 8001b24:	68fb      	ldr	r3, [r7, #12]
 8001b26:	3314      	adds	r3, #20
 8001b28:	0019      	movs	r1, r3
 8001b2a:	0010      	movs	r0, r2
 8001b2c:	f7ff fc82 	bl	8001434 <LDL_AES_encrypt>
            for(i=0U; i < blocks; i++){
 8001b30:	2116      	movs	r1, #22
 8001b32:	187b      	adds	r3, r7, r1
 8001b34:	781a      	ldrb	r2, [r3, #0]
 8001b36:	187b      	adds	r3, r7, r1
 8001b38:	3201      	adds	r2, #1
 8001b3a:	701a      	strb	r2, [r3, #0]
 8001b3c:	2316      	movs	r3, #22
 8001b3e:	18fa      	adds	r2, r7, r3
 8001b40:	2315      	movs	r3, #21
 8001b42:	18fb      	adds	r3, r7, r3
 8001b44:	7812      	ldrb	r2, [r2, #0]
 8001b46:	781b      	ldrb	r3, [r3, #0]
 8001b48:	429a      	cmp	r2, r3
 8001b4a:	d3bf      	bcc.n	8001acc <LDL_CMAC_update+0xcc>
            }
        }
                    
        (void)memcpy(&ctx->m[part], &in[pos], len - pos);
 8001b4c:	2317      	movs	r3, #23
 8001b4e:	18fb      	adds	r3, r7, r3
 8001b50:	781b      	ldrb	r3, [r3, #0]
 8001b52:	68fa      	ldr	r2, [r7, #12]
 8001b54:	18d3      	adds	r3, r2, r3
 8001b56:	1d18      	adds	r0, r3, #4
 8001b58:	2414      	movs	r4, #20
 8001b5a:	193b      	adds	r3, r7, r4
 8001b5c:	781b      	ldrb	r3, [r3, #0]
 8001b5e:	693a      	ldr	r2, [r7, #16]
 8001b60:	18d1      	adds	r1, r2, r3
 8001b62:	1dfb      	adds	r3, r7, #7
 8001b64:	781a      	ldrb	r2, [r3, #0]
 8001b66:	193b      	adds	r3, r7, r4
 8001b68:	781b      	ldrb	r3, [r3, #0]
 8001b6a:	1ad3      	subs	r3, r2, r3
 8001b6c:	001a      	movs	r2, r3
 8001b6e:	f00a feab 	bl	800c8c8 <memcpy>
        ctx->size += len;        
 8001b72:	68fb      	ldr	r3, [r7, #12]
 8001b74:	2224      	movs	r2, #36	; 0x24
 8001b76:	5c9a      	ldrb	r2, [r3, r2]
 8001b78:	1dfb      	adds	r3, r7, #7
 8001b7a:	781b      	ldrb	r3, [r3, #0]
 8001b7c:	18d3      	adds	r3, r2, r3
 8001b7e:	b2d9      	uxtb	r1, r3
 8001b80:	68fb      	ldr	r3, [r7, #12]
 8001b82:	2224      	movs	r2, #36	; 0x24
 8001b84:	5499      	strb	r1, [r3, r2]
    }
}
 8001b86:	46c0      	nop			; (mov r8, r8)
 8001b88:	46bd      	mov	sp, r7
 8001b8a:	b006      	add	sp, #24
 8001b8c:	bdb0      	pop	{r4, r5, r7, pc}

08001b8e <LDL_CMAC_finish>:

void LDL_CMAC_finish(const struct ldl_cmac_ctx *ctx, void *out, uint8_t outMax)
{
 8001b8e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001b90:	b097      	sub	sp, #92	; 0x5c
 8001b92:	af00      	add	r7, sp, #0
 8001b94:	60f8      	str	r0, [r7, #12]
 8001b96:	60b9      	str	r1, [r7, #8]
 8001b98:	1dfb      	adds	r3, r7, #7
 8001b9a:	701a      	strb	r2, [r3, #0]

    uint8_t part;

    /* generate subkeys */
    
    (void)memset(k, 0, sizeof(k));
 8001b9c:	2444      	movs	r4, #68	; 0x44
 8001b9e:	193b      	adds	r3, r7, r4
 8001ba0:	2210      	movs	r2, #16
 8001ba2:	2100      	movs	r1, #0
 8001ba4:	0018      	movs	r0, r3
 8001ba6:	f00a fe98 	bl	800c8da <memset>
    LDL_AES_encrypt(ctx->aes_ctx, k);
 8001baa:	68fb      	ldr	r3, [r7, #12]
 8001bac:	681b      	ldr	r3, [r3, #0]
 8001bae:	193a      	adds	r2, r7, r4
 8001bb0:	0011      	movs	r1, r2
 8001bb2:	0018      	movs	r0, r3
 8001bb4:	f7ff fc3e 	bl	8001434 <LDL_AES_encrypt>
    
    (void)memcpy(k1, k, sizeof(k1));
 8001bb8:	2134      	movs	r1, #52	; 0x34
 8001bba:	187b      	adds	r3, r7, r1
 8001bbc:	193a      	adds	r2, r7, r4
 8001bbe:	ca61      	ldmia	r2!, {r0, r5, r6}
 8001bc0:	c361      	stmia	r3!, {r0, r5, r6}
 8001bc2:	6812      	ldr	r2, [r2, #0]
 8001bc4:	601a      	str	r2, [r3, #0]
    leftShift128(k1);
 8001bc6:	187b      	adds	r3, r7, r1
 8001bc8:	0018      	movs	r0, r3
 8001bca:	f000 f88d 	bl	8001ce8 <leftShift128>

    if((k[0] & 0x80U) == 0x80U){
 8001bce:	193b      	adds	r3, r7, r4
 8001bd0:	781b      	ldrb	r3, [r3, #0]
 8001bd2:	b25b      	sxtb	r3, r3
 8001bd4:	2b00      	cmp	r3, #0
 8001bd6:	da08      	bge.n	8001bea <LDL_CMAC_finish+0x5c>

        k1[15] ^= 0x87U;
 8001bd8:	2134      	movs	r1, #52	; 0x34
 8001bda:	187b      	adds	r3, r7, r1
 8001bdc:	7bdb      	ldrb	r3, [r3, #15]
 8001bde:	2279      	movs	r2, #121	; 0x79
 8001be0:	4252      	negs	r2, r2
 8001be2:	4053      	eors	r3, r2
 8001be4:	b2da      	uxtb	r2, r3
 8001be6:	187b      	adds	r3, r7, r1
 8001be8:	73da      	strb	r2, [r3, #15]
    }

    (void)memcpy(k2, k1, sizeof(k2));
 8001bea:	2124      	movs	r1, #36	; 0x24
 8001bec:	187b      	adds	r3, r7, r1
 8001bee:	2434      	movs	r4, #52	; 0x34
 8001bf0:	193a      	adds	r2, r7, r4
 8001bf2:	ca61      	ldmia	r2!, {r0, r5, r6}
 8001bf4:	c361      	stmia	r3!, {r0, r5, r6}
 8001bf6:	6812      	ldr	r2, [r2, #0]
 8001bf8:	601a      	str	r2, [r3, #0]
    leftShift128(k2);
 8001bfa:	187b      	adds	r3, r7, r1
 8001bfc:	0018      	movs	r0, r3
 8001bfe:	f000 f873 	bl	8001ce8 <leftShift128>

    if((k1[0] & 0x80U) == 0x80U){
 8001c02:	193b      	adds	r3, r7, r4
 8001c04:	781b      	ldrb	r3, [r3, #0]
 8001c06:	b25b      	sxtb	r3, r3
 8001c08:	2b00      	cmp	r3, #0
 8001c0a:	da08      	bge.n	8001c1e <LDL_CMAC_finish+0x90>

        k2[15] ^= 0x87U;
 8001c0c:	2124      	movs	r1, #36	; 0x24
 8001c0e:	187b      	adds	r3, r7, r1
 8001c10:	7bdb      	ldrb	r3, [r3, #15]
 8001c12:	2279      	movs	r2, #121	; 0x79
 8001c14:	4252      	negs	r2, r2
 8001c16:	4053      	eors	r3, r2
 8001c18:	b2da      	uxtb	r2, r3
 8001c1a:	187b      	adds	r3, r7, r1
 8001c1c:	73da      	strb	r2, [r3, #15]
    }

    /* process last block (m_last) */
    
    part = ctx->size % (uint8_t)sizeof(ctx->m);
 8001c1e:	68fb      	ldr	r3, [r7, #12]
 8001c20:	2224      	movs	r2, #36	; 0x24
 8001c22:	5c9a      	ldrb	r2, [r3, r2]
 8001c24:	2357      	movs	r3, #87	; 0x57
 8001c26:	18fb      	adds	r3, r7, r3
 8001c28:	210f      	movs	r1, #15
 8001c2a:	400a      	ands	r2, r1
 8001c2c:	701a      	strb	r2, [r3, #0]

    (void)memset(m_last, 0, sizeof(m_last));
 8001c2e:	2314      	movs	r3, #20
 8001c30:	18fb      	adds	r3, r7, r3
 8001c32:	2210      	movs	r2, #16
 8001c34:	2100      	movs	r1, #0
 8001c36:	0018      	movs	r0, r3
 8001c38:	f00a fe4f 	bl	800c8da <memset>
    
    if((ctx->size == 0U) || (part > 0U)){
 8001c3c:	68fb      	ldr	r3, [r7, #12]
 8001c3e:	2224      	movs	r2, #36	; 0x24
 8001c40:	5c9b      	ldrb	r3, [r3, r2]
 8001c42:	2b00      	cmp	r3, #0
 8001c44:	d004      	beq.n	8001c50 <LDL_CMAC_finish+0xc2>
 8001c46:	2357      	movs	r3, #87	; 0x57
 8001c48:	18fb      	adds	r3, r7, r3
 8001c4a:	781b      	ldrb	r3, [r3, #0]
 8001c4c:	2b00      	cmp	r3, #0
 8001c4e:	d018      	beq.n	8001c82 <LDL_CMAC_finish+0xf4>

        (void)memcpy(m_last, ctx->m, part);
 8001c50:	68fb      	ldr	r3, [r7, #12]
 8001c52:	1d19      	adds	r1, r3, #4
 8001c54:	2557      	movs	r5, #87	; 0x57
 8001c56:	197b      	adds	r3, r7, r5
 8001c58:	781a      	ldrb	r2, [r3, #0]
 8001c5a:	2014      	movs	r0, #20
 8001c5c:	0004      	movs	r4, r0
 8001c5e:	183b      	adds	r3, r7, r0
 8001c60:	0018      	movs	r0, r3
 8001c62:	f00a fe31 	bl	800c8c8 <memcpy>

        m_last[part] = 0x80U;
 8001c66:	197b      	adds	r3, r7, r5
 8001c68:	781b      	ldrb	r3, [r3, #0]
 8001c6a:	0020      	movs	r0, r4
 8001c6c:	183a      	adds	r2, r7, r0
 8001c6e:	2180      	movs	r1, #128	; 0x80
 8001c70:	54d1      	strb	r1, [r2, r3]
        xor128(m_last, k2);        
 8001c72:	2324      	movs	r3, #36	; 0x24
 8001c74:	18fa      	adds	r2, r7, r3
 8001c76:	183b      	adds	r3, r7, r0
 8001c78:	0011      	movs	r1, r2
 8001c7a:	0018      	movs	r0, r3
 8001c7c:	f000 f878 	bl	8001d70 <xor128>
 8001c80:	e010      	b.n	8001ca4 <LDL_CMAC_finish+0x116>
    }
    else{        

        (void)memcpy(m_last, ctx->m, sizeof(m_last));
 8001c82:	68fb      	ldr	r3, [r7, #12]
 8001c84:	3304      	adds	r3, #4
 8001c86:	2414      	movs	r4, #20
 8001c88:	193a      	adds	r2, r7, r4
 8001c8a:	0010      	movs	r0, r2
 8001c8c:	0019      	movs	r1, r3
 8001c8e:	2310      	movs	r3, #16
 8001c90:	001a      	movs	r2, r3
 8001c92:	f00a fe19 	bl	800c8c8 <memcpy>

        xor128(m_last, k1);
 8001c96:	2334      	movs	r3, #52	; 0x34
 8001c98:	18fa      	adds	r2, r7, r3
 8001c9a:	193b      	adds	r3, r7, r4
 8001c9c:	0011      	movs	r1, r2
 8001c9e:	0018      	movs	r0, r3
 8001ca0:	f000 f866 	bl	8001d70 <xor128>
    }

    xor128(m_last, ctx->x);
 8001ca4:	68fb      	ldr	r3, [r7, #12]
 8001ca6:	3314      	adds	r3, #20
 8001ca8:	001a      	movs	r2, r3
 8001caa:	2414      	movs	r4, #20
 8001cac:	193b      	adds	r3, r7, r4
 8001cae:	0011      	movs	r1, r2
 8001cb0:	0018      	movs	r0, r3
 8001cb2:	f000 f85d 	bl	8001d70 <xor128>

    LDL_AES_encrypt(ctx->aes_ctx, m_last);
 8001cb6:	68fb      	ldr	r3, [r7, #12]
 8001cb8:	681b      	ldr	r3, [r3, #0]
 8001cba:	193a      	adds	r2, r7, r4
 8001cbc:	0011      	movs	r1, r2
 8001cbe:	0018      	movs	r0, r3
 8001cc0:	f7ff fbb8 	bl	8001434 <LDL_AES_encrypt>

    (void)memcpy(out, m_last, (outMax > sizeof(m_last)) ? sizeof(m_last) : outMax);
 8001cc4:	1dfb      	adds	r3, r7, #7
 8001cc6:	781b      	ldrb	r3, [r3, #0]
 8001cc8:	b2da      	uxtb	r2, r3
 8001cca:	2a10      	cmp	r2, #16
 8001ccc:	d900      	bls.n	8001cd0 <LDL_CMAC_finish+0x142>
 8001cce:	2310      	movs	r3, #16
 8001cd0:	b2db      	uxtb	r3, r3
 8001cd2:	001a      	movs	r2, r3
 8001cd4:	2314      	movs	r3, #20
 8001cd6:	18f9      	adds	r1, r7, r3
 8001cd8:	68bb      	ldr	r3, [r7, #8]
 8001cda:	0018      	movs	r0, r3
 8001cdc:	f00a fdf4 	bl	800c8c8 <memcpy>
}
 8001ce0:	46c0      	nop			; (mov r8, r8)
 8001ce2:	46bd      	mov	sp, r7
 8001ce4:	b017      	add	sp, #92	; 0x5c
 8001ce6:	bdf0      	pop	{r4, r5, r6, r7, pc}

08001ce8 <leftShift128>:

/* static functions  **************************************************/

static void leftShift128(uint8_t *v)
{
 8001ce8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001cea:	b085      	sub	sp, #20
 8001cec:	af00      	add	r7, sp, #0
 8001cee:	6078      	str	r0, [r7, #4]
    uint8_t t;
    uint8_t tt;
    uint8_t carry;
    uint8_t i;
    
    carry = 0U;
 8001cf0:	230f      	movs	r3, #15
 8001cf2:	18fb      	adds	r3, r7, r3
 8001cf4:	2200      	movs	r2, #0
 8001cf6:	701a      	strb	r2, [r3, #0]

    for(i=16U; i > 0U; i--){
 8001cf8:	230e      	movs	r3, #14
 8001cfa:	18fb      	adds	r3, r7, r3
 8001cfc:	2210      	movs	r2, #16
 8001cfe:	701a      	strb	r2, [r3, #0]
 8001d00:	e02d      	b.n	8001d5e <leftShift128+0x76>

        t = v[i-1U];
 8001d02:	240e      	movs	r4, #14
 8001d04:	193b      	adds	r3, r7, r4
 8001d06:	781b      	ldrb	r3, [r3, #0]
 8001d08:	3b01      	subs	r3, #1
 8001d0a:	687a      	ldr	r2, [r7, #4]
 8001d0c:	18d2      	adds	r2, r2, r3
 8001d0e:	250d      	movs	r5, #13
 8001d10:	197b      	adds	r3, r7, r5
 8001d12:	7812      	ldrb	r2, [r2, #0]
 8001d14:	701a      	strb	r2, [r3, #0]

        tt = t;
 8001d16:	200c      	movs	r0, #12
 8001d18:	183b      	adds	r3, r7, r0
 8001d1a:	197a      	adds	r2, r7, r5
 8001d1c:	7812      	ldrb	r2, [r2, #0]
 8001d1e:	701a      	strb	r2, [r3, #0]
        tt <<= 1;
 8001d20:	183a      	adds	r2, r7, r0
 8001d22:	183b      	adds	r3, r7, r0
 8001d24:	781b      	ldrb	r3, [r3, #0]
 8001d26:	18db      	adds	r3, r3, r3
 8001d28:	7013      	strb	r3, [r2, #0]
        tt |= carry;
 8001d2a:	183b      	adds	r3, r7, r0
 8001d2c:	1839      	adds	r1, r7, r0
 8001d2e:	260f      	movs	r6, #15
 8001d30:	19ba      	adds	r2, r7, r6
 8001d32:	7809      	ldrb	r1, [r1, #0]
 8001d34:	7812      	ldrb	r2, [r2, #0]
 8001d36:	430a      	orrs	r2, r1
 8001d38:	701a      	strb	r2, [r3, #0]

        carry = ((t & MSB) == MSB) ? LSB : 0x0U;
 8001d3a:	19bb      	adds	r3, r7, r6
 8001d3c:	197a      	adds	r2, r7, r5
 8001d3e:	7812      	ldrb	r2, [r2, #0]
 8001d40:	09d2      	lsrs	r2, r2, #7
 8001d42:	701a      	strb	r2, [r3, #0]
        v[i-1U] = tt;
 8001d44:	193b      	adds	r3, r7, r4
 8001d46:	781b      	ldrb	r3, [r3, #0]
 8001d48:	3b01      	subs	r3, #1
 8001d4a:	687a      	ldr	r2, [r7, #4]
 8001d4c:	18d3      	adds	r3, r2, r3
 8001d4e:	183a      	adds	r2, r7, r0
 8001d50:	7812      	ldrb	r2, [r2, #0]
 8001d52:	701a      	strb	r2, [r3, #0]
    for(i=16U; i > 0U; i--){
 8001d54:	193b      	adds	r3, r7, r4
 8001d56:	781a      	ldrb	r2, [r3, #0]
 8001d58:	193b      	adds	r3, r7, r4
 8001d5a:	3a01      	subs	r2, #1
 8001d5c:	701a      	strb	r2, [r3, #0]
 8001d5e:	230e      	movs	r3, #14
 8001d60:	18fb      	adds	r3, r7, r3
 8001d62:	781b      	ldrb	r3, [r3, #0]
 8001d64:	2b00      	cmp	r3, #0
 8001d66:	d1cc      	bne.n	8001d02 <leftShift128+0x1a>
    }
}
 8001d68:	46c0      	nop			; (mov r8, r8)
 8001d6a:	46bd      	mov	sp, r7
 8001d6c:	b005      	add	sp, #20
 8001d6e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08001d70 <xor128>:

static void xor128(uint8_t *acc, const uint8_t *mask)
{
 8001d70:	b580      	push	{r7, lr}
 8001d72:	b082      	sub	sp, #8
 8001d74:	af00      	add	r7, sp, #0
 8001d76:	6078      	str	r0, [r7, #4]
 8001d78:	6039      	str	r1, [r7, #0]
    acc[0] ^= mask[0];
 8001d7a:	687b      	ldr	r3, [r7, #4]
 8001d7c:	781a      	ldrb	r2, [r3, #0]
 8001d7e:	683b      	ldr	r3, [r7, #0]
 8001d80:	781b      	ldrb	r3, [r3, #0]
 8001d82:	4053      	eors	r3, r2
 8001d84:	b2da      	uxtb	r2, r3
 8001d86:	687b      	ldr	r3, [r7, #4]
 8001d88:	701a      	strb	r2, [r3, #0]
    acc[1] ^= mask[1];
 8001d8a:	687b      	ldr	r3, [r7, #4]
 8001d8c:	3301      	adds	r3, #1
 8001d8e:	7819      	ldrb	r1, [r3, #0]
 8001d90:	683b      	ldr	r3, [r7, #0]
 8001d92:	3301      	adds	r3, #1
 8001d94:	781a      	ldrb	r2, [r3, #0]
 8001d96:	687b      	ldr	r3, [r7, #4]
 8001d98:	3301      	adds	r3, #1
 8001d9a:	404a      	eors	r2, r1
 8001d9c:	b2d2      	uxtb	r2, r2
 8001d9e:	701a      	strb	r2, [r3, #0]
    acc[2] ^= mask[2];
 8001da0:	687b      	ldr	r3, [r7, #4]
 8001da2:	3302      	adds	r3, #2
 8001da4:	7819      	ldrb	r1, [r3, #0]
 8001da6:	683b      	ldr	r3, [r7, #0]
 8001da8:	3302      	adds	r3, #2
 8001daa:	781a      	ldrb	r2, [r3, #0]
 8001dac:	687b      	ldr	r3, [r7, #4]
 8001dae:	3302      	adds	r3, #2
 8001db0:	404a      	eors	r2, r1
 8001db2:	b2d2      	uxtb	r2, r2
 8001db4:	701a      	strb	r2, [r3, #0]
    acc[3] ^= mask[3];
 8001db6:	687b      	ldr	r3, [r7, #4]
 8001db8:	3303      	adds	r3, #3
 8001dba:	7819      	ldrb	r1, [r3, #0]
 8001dbc:	683b      	ldr	r3, [r7, #0]
 8001dbe:	3303      	adds	r3, #3
 8001dc0:	781a      	ldrb	r2, [r3, #0]
 8001dc2:	687b      	ldr	r3, [r7, #4]
 8001dc4:	3303      	adds	r3, #3
 8001dc6:	404a      	eors	r2, r1
 8001dc8:	b2d2      	uxtb	r2, r2
 8001dca:	701a      	strb	r2, [r3, #0]
    acc[4] ^= mask[4];
 8001dcc:	687b      	ldr	r3, [r7, #4]
 8001dce:	3304      	adds	r3, #4
 8001dd0:	7819      	ldrb	r1, [r3, #0]
 8001dd2:	683b      	ldr	r3, [r7, #0]
 8001dd4:	3304      	adds	r3, #4
 8001dd6:	781a      	ldrb	r2, [r3, #0]
 8001dd8:	687b      	ldr	r3, [r7, #4]
 8001dda:	3304      	adds	r3, #4
 8001ddc:	404a      	eors	r2, r1
 8001dde:	b2d2      	uxtb	r2, r2
 8001de0:	701a      	strb	r2, [r3, #0]
    acc[5] ^= mask[5];
 8001de2:	687b      	ldr	r3, [r7, #4]
 8001de4:	3305      	adds	r3, #5
 8001de6:	7819      	ldrb	r1, [r3, #0]
 8001de8:	683b      	ldr	r3, [r7, #0]
 8001dea:	3305      	adds	r3, #5
 8001dec:	781a      	ldrb	r2, [r3, #0]
 8001dee:	687b      	ldr	r3, [r7, #4]
 8001df0:	3305      	adds	r3, #5
 8001df2:	404a      	eors	r2, r1
 8001df4:	b2d2      	uxtb	r2, r2
 8001df6:	701a      	strb	r2, [r3, #0]
    acc[6] ^= mask[6];
 8001df8:	687b      	ldr	r3, [r7, #4]
 8001dfa:	3306      	adds	r3, #6
 8001dfc:	7819      	ldrb	r1, [r3, #0]
 8001dfe:	683b      	ldr	r3, [r7, #0]
 8001e00:	3306      	adds	r3, #6
 8001e02:	781a      	ldrb	r2, [r3, #0]
 8001e04:	687b      	ldr	r3, [r7, #4]
 8001e06:	3306      	adds	r3, #6
 8001e08:	404a      	eors	r2, r1
 8001e0a:	b2d2      	uxtb	r2, r2
 8001e0c:	701a      	strb	r2, [r3, #0]
    acc[7] ^= mask[7];
 8001e0e:	687b      	ldr	r3, [r7, #4]
 8001e10:	3307      	adds	r3, #7
 8001e12:	7819      	ldrb	r1, [r3, #0]
 8001e14:	683b      	ldr	r3, [r7, #0]
 8001e16:	3307      	adds	r3, #7
 8001e18:	781a      	ldrb	r2, [r3, #0]
 8001e1a:	687b      	ldr	r3, [r7, #4]
 8001e1c:	3307      	adds	r3, #7
 8001e1e:	404a      	eors	r2, r1
 8001e20:	b2d2      	uxtb	r2, r2
 8001e22:	701a      	strb	r2, [r3, #0]
    acc[8] ^= mask[8];
 8001e24:	687b      	ldr	r3, [r7, #4]
 8001e26:	3308      	adds	r3, #8
 8001e28:	7819      	ldrb	r1, [r3, #0]
 8001e2a:	683b      	ldr	r3, [r7, #0]
 8001e2c:	3308      	adds	r3, #8
 8001e2e:	781a      	ldrb	r2, [r3, #0]
 8001e30:	687b      	ldr	r3, [r7, #4]
 8001e32:	3308      	adds	r3, #8
 8001e34:	404a      	eors	r2, r1
 8001e36:	b2d2      	uxtb	r2, r2
 8001e38:	701a      	strb	r2, [r3, #0]
    acc[9] ^= mask[9];
 8001e3a:	687b      	ldr	r3, [r7, #4]
 8001e3c:	3309      	adds	r3, #9
 8001e3e:	7819      	ldrb	r1, [r3, #0]
 8001e40:	683b      	ldr	r3, [r7, #0]
 8001e42:	3309      	adds	r3, #9
 8001e44:	781a      	ldrb	r2, [r3, #0]
 8001e46:	687b      	ldr	r3, [r7, #4]
 8001e48:	3309      	adds	r3, #9
 8001e4a:	404a      	eors	r2, r1
 8001e4c:	b2d2      	uxtb	r2, r2
 8001e4e:	701a      	strb	r2, [r3, #0]
    acc[10] ^= mask[10];
 8001e50:	687b      	ldr	r3, [r7, #4]
 8001e52:	330a      	adds	r3, #10
 8001e54:	7819      	ldrb	r1, [r3, #0]
 8001e56:	683b      	ldr	r3, [r7, #0]
 8001e58:	330a      	adds	r3, #10
 8001e5a:	781a      	ldrb	r2, [r3, #0]
 8001e5c:	687b      	ldr	r3, [r7, #4]
 8001e5e:	330a      	adds	r3, #10
 8001e60:	404a      	eors	r2, r1
 8001e62:	b2d2      	uxtb	r2, r2
 8001e64:	701a      	strb	r2, [r3, #0]
    acc[11] ^= mask[11];
 8001e66:	687b      	ldr	r3, [r7, #4]
 8001e68:	330b      	adds	r3, #11
 8001e6a:	7819      	ldrb	r1, [r3, #0]
 8001e6c:	683b      	ldr	r3, [r7, #0]
 8001e6e:	330b      	adds	r3, #11
 8001e70:	781a      	ldrb	r2, [r3, #0]
 8001e72:	687b      	ldr	r3, [r7, #4]
 8001e74:	330b      	adds	r3, #11
 8001e76:	404a      	eors	r2, r1
 8001e78:	b2d2      	uxtb	r2, r2
 8001e7a:	701a      	strb	r2, [r3, #0]
    acc[12] ^= mask[12];
 8001e7c:	687b      	ldr	r3, [r7, #4]
 8001e7e:	330c      	adds	r3, #12
 8001e80:	7819      	ldrb	r1, [r3, #0]
 8001e82:	683b      	ldr	r3, [r7, #0]
 8001e84:	330c      	adds	r3, #12
 8001e86:	781a      	ldrb	r2, [r3, #0]
 8001e88:	687b      	ldr	r3, [r7, #4]
 8001e8a:	330c      	adds	r3, #12
 8001e8c:	404a      	eors	r2, r1
 8001e8e:	b2d2      	uxtb	r2, r2
 8001e90:	701a      	strb	r2, [r3, #0]
    acc[13] ^= mask[13];
 8001e92:	687b      	ldr	r3, [r7, #4]
 8001e94:	330d      	adds	r3, #13
 8001e96:	7819      	ldrb	r1, [r3, #0]
 8001e98:	683b      	ldr	r3, [r7, #0]
 8001e9a:	330d      	adds	r3, #13
 8001e9c:	781a      	ldrb	r2, [r3, #0]
 8001e9e:	687b      	ldr	r3, [r7, #4]
 8001ea0:	330d      	adds	r3, #13
 8001ea2:	404a      	eors	r2, r1
 8001ea4:	b2d2      	uxtb	r2, r2
 8001ea6:	701a      	strb	r2, [r3, #0]
    acc[14] ^= mask[14];
 8001ea8:	687b      	ldr	r3, [r7, #4]
 8001eaa:	330e      	adds	r3, #14
 8001eac:	7819      	ldrb	r1, [r3, #0]
 8001eae:	683b      	ldr	r3, [r7, #0]
 8001eb0:	330e      	adds	r3, #14
 8001eb2:	781a      	ldrb	r2, [r3, #0]
 8001eb4:	687b      	ldr	r3, [r7, #4]
 8001eb6:	330e      	adds	r3, #14
 8001eb8:	404a      	eors	r2, r1
 8001eba:	b2d2      	uxtb	r2, r2
 8001ebc:	701a      	strb	r2, [r3, #0]
    acc[15] ^= mask[15];        
 8001ebe:	687b      	ldr	r3, [r7, #4]
 8001ec0:	330f      	adds	r3, #15
 8001ec2:	7819      	ldrb	r1, [r3, #0]
 8001ec4:	683b      	ldr	r3, [r7, #0]
 8001ec6:	330f      	adds	r3, #15
 8001ec8:	781a      	ldrb	r2, [r3, #0]
 8001eca:	687b      	ldr	r3, [r7, #4]
 8001ecc:	330f      	adds	r3, #15
 8001ece:	404a      	eors	r2, r1
 8001ed0:	b2d2      	uxtb	r2, r2
 8001ed2:	701a      	strb	r2, [r3, #0]
}
 8001ed4:	46c0      	nop			; (mov r8, r8)
 8001ed6:	46bd      	mov	sp, r7
 8001ed8:	b002      	add	sp, #8
 8001eda:	bd80      	pop	{r7, pc}

08001edc <LDL_CTR_encrypt>:
static void xor128(uint8_t *acc, const uint8_t *op);

/* functions **********************************************************/

void LDL_CTR_encrypt(struct ldl_aes_ctx *ctx, const void *iv, const void *in, void *out, uint8_t len)
{
 8001edc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001ede:	b095      	sub	sp, #84	; 0x54
 8001ee0:	af00      	add	r7, sp, #0
 8001ee2:	60f8      	str	r0, [r7, #12]
 8001ee4:	60b9      	str	r1, [r7, #8]
 8001ee6:	607a      	str	r2, [r7, #4]
 8001ee8:	603b      	str	r3, [r7, #0]
    uint8_t size;
    const uint8_t *ptr_in;
    uint8_t *ptr_out;

    /* number of blocks */
    k = (len / 16U) + (((len % 16U) != 0U) ? 1U : 0U);
 8001eea:	2258      	movs	r2, #88	; 0x58
 8001eec:	2010      	movs	r0, #16
 8001eee:	183b      	adds	r3, r7, r0
 8001ef0:	189b      	adds	r3, r3, r2
 8001ef2:	781b      	ldrb	r3, [r3, #0]
 8001ef4:	091b      	lsrs	r3, r3, #4
 8001ef6:	b2d9      	uxtb	r1, r3
 8001ef8:	183b      	adds	r3, r7, r0
 8001efa:	189b      	adds	r3, r3, r2
 8001efc:	781b      	ldrb	r3, [r3, #0]
 8001efe:	220f      	movs	r2, #15
 8001f00:	4013      	ands	r3, r2
 8001f02:	b2db      	uxtb	r3, r3
 8001f04:	2b00      	cmp	r3, #0
 8001f06:	d001      	beq.n	8001f0c <LDL_CTR_encrypt+0x30>
 8001f08:	2301      	movs	r3, #1
 8001f0a:	e000      	b.n	8001f0e <LDL_CTR_encrypt+0x32>
 8001f0c:	2300      	movs	r3, #0
 8001f0e:	224d      	movs	r2, #77	; 0x4d
 8001f10:	18ba      	adds	r2, r7, r2
 8001f12:	185b      	adds	r3, r3, r1
 8001f14:	7013      	strb	r3, [r2, #0]
    
    pos = 0U;
 8001f16:	234e      	movs	r3, #78	; 0x4e
 8001f18:	18fb      	adds	r3, r7, r3
 8001f1a:	2200      	movs	r2, #0
 8001f1c:	701a      	strb	r2, [r3, #0]

    ptr_in = (const uint8_t *)in;
 8001f1e:	687b      	ldr	r3, [r7, #4]
 8001f20:	64bb      	str	r3, [r7, #72]	; 0x48
    ptr_out = (uint8_t *)out;
 8001f22:	683b      	ldr	r3, [r7, #0]
 8001f24:	647b      	str	r3, [r7, #68]	; 0x44

    (void)memcpy(a, iv, sizeof(a)); 
 8001f26:	2330      	movs	r3, #48	; 0x30
 8001f28:	18fa      	adds	r2, r7, r3
 8001f2a:	68bb      	ldr	r3, [r7, #8]
 8001f2c:	0010      	movs	r0, r2
 8001f2e:	0019      	movs	r1, r3
 8001f30:	2310      	movs	r3, #16
 8001f32:	001a      	movs	r2, r3
 8001f34:	f00a fcc8 	bl	800c8c8 <memcpy>

    for(i=0U; i < k; i++){
 8001f38:	234f      	movs	r3, #79	; 0x4f
 8001f3a:	18fb      	adds	r3, r7, r3
 8001f3c:	2200      	movs	r2, #0
 8001f3e:	701a      	strb	r2, [r3, #0]
 8001f40:	e055      	b.n	8001fee <LDL_CTR_encrypt+0x112>

        size = ((len - pos) >= (uint8_t)sizeof(a)) ? (uint8_t)sizeof(a) : (len - pos);
 8001f42:	2358      	movs	r3, #88	; 0x58
 8001f44:	2210      	movs	r2, #16
 8001f46:	4694      	mov	ip, r2
 8001f48:	44bc      	add	ip, r7
 8001f4a:	4463      	add	r3, ip
 8001f4c:	781a      	ldrb	r2, [r3, #0]
 8001f4e:	234e      	movs	r3, #78	; 0x4e
 8001f50:	18fb      	adds	r3, r7, r3
 8001f52:	781b      	ldrb	r3, [r3, #0]
 8001f54:	1ad3      	subs	r3, r2, r3
 8001f56:	2b10      	cmp	r3, #16
 8001f58:	dd00      	ble.n	8001f5c <LDL_CTR_encrypt+0x80>
 8001f5a:	2310      	movs	r3, #16
 8001f5c:	2643      	movs	r6, #67	; 0x43
 8001f5e:	19ba      	adds	r2, r7, r6
 8001f60:	7013      	strb	r3, [r2, #0]
        
        (void)memset(pld, 0, sizeof(pld));
 8001f62:	2410      	movs	r4, #16
 8001f64:	193b      	adds	r3, r7, r4
 8001f66:	2210      	movs	r2, #16
 8001f68:	2100      	movs	r1, #0
 8001f6a:	0018      	movs	r0, r3
 8001f6c:	f00a fcb5 	bl	800c8da <memset>
        
        (void)memcpy(pld, &ptr_in[pos], size);
 8001f70:	254e      	movs	r5, #78	; 0x4e
 8001f72:	197b      	adds	r3, r7, r5
 8001f74:	781b      	ldrb	r3, [r3, #0]
 8001f76:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8001f78:	18d1      	adds	r1, r2, r3
 8001f7a:	19bb      	adds	r3, r7, r6
 8001f7c:	781a      	ldrb	r2, [r3, #0]
 8001f7e:	193b      	adds	r3, r7, r4
 8001f80:	0018      	movs	r0, r3
 8001f82:	f00a fca1 	bl	800c8c8 <memcpy>

        (void)memcpy(s, a, sizeof(s));
 8001f86:	2320      	movs	r3, #32
 8001f88:	18fa      	adds	r2, r7, r3
 8001f8a:	2130      	movs	r1, #48	; 0x30
 8001f8c:	187b      	adds	r3, r7, r1
 8001f8e:	0010      	movs	r0, r2
 8001f90:	0019      	movs	r1, r3
 8001f92:	2310      	movs	r3, #16
 8001f94:	001a      	movs	r2, r3
 8001f96:	f00a fc97 	bl	800c8c8 <memcpy>
        
        a[15U]++;
 8001f9a:	2130      	movs	r1, #48	; 0x30
 8001f9c:	187b      	adds	r3, r7, r1
 8001f9e:	7bdb      	ldrb	r3, [r3, #15]
 8001fa0:	3301      	adds	r3, #1
 8001fa2:	b2da      	uxtb	r2, r3
 8001fa4:	187b      	adds	r3, r7, r1
 8001fa6:	73da      	strb	r2, [r3, #15]
        
        LDL_AES_encrypt(ctx, s);
 8001fa8:	2320      	movs	r3, #32
 8001faa:	18fa      	adds	r2, r7, r3
 8001fac:	68fb      	ldr	r3, [r7, #12]
 8001fae:	0011      	movs	r1, r2
 8001fb0:	0018      	movs	r0, r3
 8001fb2:	f7ff fa3f 	bl	8001434 <LDL_AES_encrypt>

        xor128(pld, s);
 8001fb6:	2320      	movs	r3, #32
 8001fb8:	18fa      	adds	r2, r7, r3
 8001fba:	193b      	adds	r3, r7, r4
 8001fbc:	0011      	movs	r1, r2
 8001fbe:	0018      	movs	r0, r3
 8001fc0:	f000 f821 	bl	8002006 <xor128>

        (void)memcpy(&ptr_out[pos], pld, size);
 8001fc4:	197b      	adds	r3, r7, r5
 8001fc6:	781b      	ldrb	r3, [r3, #0]
 8001fc8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8001fca:	18d0      	adds	r0, r2, r3
 8001fcc:	19bb      	adds	r3, r7, r6
 8001fce:	781a      	ldrb	r2, [r3, #0]
 8001fd0:	193b      	adds	r3, r7, r4
 8001fd2:	0019      	movs	r1, r3
 8001fd4:	f00a fc78 	bl	800c8c8 <memcpy>
        
        pos += (uint8_t)sizeof(a);
 8001fd8:	197b      	adds	r3, r7, r5
 8001fda:	197a      	adds	r2, r7, r5
 8001fdc:	7812      	ldrb	r2, [r2, #0]
 8001fde:	3210      	adds	r2, #16
 8001fe0:	701a      	strb	r2, [r3, #0]
    for(i=0U; i < k; i++){
 8001fe2:	214f      	movs	r1, #79	; 0x4f
 8001fe4:	187b      	adds	r3, r7, r1
 8001fe6:	781a      	ldrb	r2, [r3, #0]
 8001fe8:	187b      	adds	r3, r7, r1
 8001fea:	3201      	adds	r2, #1
 8001fec:	701a      	strb	r2, [r3, #0]
 8001fee:	234f      	movs	r3, #79	; 0x4f
 8001ff0:	18fa      	adds	r2, r7, r3
 8001ff2:	234d      	movs	r3, #77	; 0x4d
 8001ff4:	18fb      	adds	r3, r7, r3
 8001ff6:	7812      	ldrb	r2, [r2, #0]
 8001ff8:	781b      	ldrb	r3, [r3, #0]
 8001ffa:	429a      	cmp	r2, r3
 8001ffc:	d3a1      	bcc.n	8001f42 <LDL_CTR_encrypt+0x66>
    }
}
 8001ffe:	46c0      	nop			; (mov r8, r8)
 8002000:	46bd      	mov	sp, r7
 8002002:	b015      	add	sp, #84	; 0x54
 8002004:	bdf0      	pop	{r4, r5, r6, r7, pc}

08002006 <xor128>:

/* static functions ***************************************************/

static void xor128(uint8_t *acc, const uint8_t *op)
{
 8002006:	b580      	push	{r7, lr}
 8002008:	b082      	sub	sp, #8
 800200a:	af00      	add	r7, sp, #0
 800200c:	6078      	str	r0, [r7, #4]
 800200e:	6039      	str	r1, [r7, #0]
    acc[0] ^= op[0];
 8002010:	687b      	ldr	r3, [r7, #4]
 8002012:	781a      	ldrb	r2, [r3, #0]
 8002014:	683b      	ldr	r3, [r7, #0]
 8002016:	781b      	ldrb	r3, [r3, #0]
 8002018:	4053      	eors	r3, r2
 800201a:	b2da      	uxtb	r2, r3
 800201c:	687b      	ldr	r3, [r7, #4]
 800201e:	701a      	strb	r2, [r3, #0]
    acc[1] ^= op[1];
 8002020:	687b      	ldr	r3, [r7, #4]
 8002022:	3301      	adds	r3, #1
 8002024:	7819      	ldrb	r1, [r3, #0]
 8002026:	683b      	ldr	r3, [r7, #0]
 8002028:	3301      	adds	r3, #1
 800202a:	781a      	ldrb	r2, [r3, #0]
 800202c:	687b      	ldr	r3, [r7, #4]
 800202e:	3301      	adds	r3, #1
 8002030:	404a      	eors	r2, r1
 8002032:	b2d2      	uxtb	r2, r2
 8002034:	701a      	strb	r2, [r3, #0]
    acc[2] ^= op[2];
 8002036:	687b      	ldr	r3, [r7, #4]
 8002038:	3302      	adds	r3, #2
 800203a:	7819      	ldrb	r1, [r3, #0]
 800203c:	683b      	ldr	r3, [r7, #0]
 800203e:	3302      	adds	r3, #2
 8002040:	781a      	ldrb	r2, [r3, #0]
 8002042:	687b      	ldr	r3, [r7, #4]
 8002044:	3302      	adds	r3, #2
 8002046:	404a      	eors	r2, r1
 8002048:	b2d2      	uxtb	r2, r2
 800204a:	701a      	strb	r2, [r3, #0]
    acc[3] ^= op[3];
 800204c:	687b      	ldr	r3, [r7, #4]
 800204e:	3303      	adds	r3, #3
 8002050:	7819      	ldrb	r1, [r3, #0]
 8002052:	683b      	ldr	r3, [r7, #0]
 8002054:	3303      	adds	r3, #3
 8002056:	781a      	ldrb	r2, [r3, #0]
 8002058:	687b      	ldr	r3, [r7, #4]
 800205a:	3303      	adds	r3, #3
 800205c:	404a      	eors	r2, r1
 800205e:	b2d2      	uxtb	r2, r2
 8002060:	701a      	strb	r2, [r3, #0]
    acc[4] ^= op[4];
 8002062:	687b      	ldr	r3, [r7, #4]
 8002064:	3304      	adds	r3, #4
 8002066:	7819      	ldrb	r1, [r3, #0]
 8002068:	683b      	ldr	r3, [r7, #0]
 800206a:	3304      	adds	r3, #4
 800206c:	781a      	ldrb	r2, [r3, #0]
 800206e:	687b      	ldr	r3, [r7, #4]
 8002070:	3304      	adds	r3, #4
 8002072:	404a      	eors	r2, r1
 8002074:	b2d2      	uxtb	r2, r2
 8002076:	701a      	strb	r2, [r3, #0]
    acc[5] ^= op[5];
 8002078:	687b      	ldr	r3, [r7, #4]
 800207a:	3305      	adds	r3, #5
 800207c:	7819      	ldrb	r1, [r3, #0]
 800207e:	683b      	ldr	r3, [r7, #0]
 8002080:	3305      	adds	r3, #5
 8002082:	781a      	ldrb	r2, [r3, #0]
 8002084:	687b      	ldr	r3, [r7, #4]
 8002086:	3305      	adds	r3, #5
 8002088:	404a      	eors	r2, r1
 800208a:	b2d2      	uxtb	r2, r2
 800208c:	701a      	strb	r2, [r3, #0]
    acc[6] ^= op[6];
 800208e:	687b      	ldr	r3, [r7, #4]
 8002090:	3306      	adds	r3, #6
 8002092:	7819      	ldrb	r1, [r3, #0]
 8002094:	683b      	ldr	r3, [r7, #0]
 8002096:	3306      	adds	r3, #6
 8002098:	781a      	ldrb	r2, [r3, #0]
 800209a:	687b      	ldr	r3, [r7, #4]
 800209c:	3306      	adds	r3, #6
 800209e:	404a      	eors	r2, r1
 80020a0:	b2d2      	uxtb	r2, r2
 80020a2:	701a      	strb	r2, [r3, #0]
    acc[7] ^= op[7];
 80020a4:	687b      	ldr	r3, [r7, #4]
 80020a6:	3307      	adds	r3, #7
 80020a8:	7819      	ldrb	r1, [r3, #0]
 80020aa:	683b      	ldr	r3, [r7, #0]
 80020ac:	3307      	adds	r3, #7
 80020ae:	781a      	ldrb	r2, [r3, #0]
 80020b0:	687b      	ldr	r3, [r7, #4]
 80020b2:	3307      	adds	r3, #7
 80020b4:	404a      	eors	r2, r1
 80020b6:	b2d2      	uxtb	r2, r2
 80020b8:	701a      	strb	r2, [r3, #0]
    acc[8] ^= op[8];
 80020ba:	687b      	ldr	r3, [r7, #4]
 80020bc:	3308      	adds	r3, #8
 80020be:	7819      	ldrb	r1, [r3, #0]
 80020c0:	683b      	ldr	r3, [r7, #0]
 80020c2:	3308      	adds	r3, #8
 80020c4:	781a      	ldrb	r2, [r3, #0]
 80020c6:	687b      	ldr	r3, [r7, #4]
 80020c8:	3308      	adds	r3, #8
 80020ca:	404a      	eors	r2, r1
 80020cc:	b2d2      	uxtb	r2, r2
 80020ce:	701a      	strb	r2, [r3, #0]
    acc[9] ^= op[9];
 80020d0:	687b      	ldr	r3, [r7, #4]
 80020d2:	3309      	adds	r3, #9
 80020d4:	7819      	ldrb	r1, [r3, #0]
 80020d6:	683b      	ldr	r3, [r7, #0]
 80020d8:	3309      	adds	r3, #9
 80020da:	781a      	ldrb	r2, [r3, #0]
 80020dc:	687b      	ldr	r3, [r7, #4]
 80020de:	3309      	adds	r3, #9
 80020e0:	404a      	eors	r2, r1
 80020e2:	b2d2      	uxtb	r2, r2
 80020e4:	701a      	strb	r2, [r3, #0]
    acc[10] ^= op[10];
 80020e6:	687b      	ldr	r3, [r7, #4]
 80020e8:	330a      	adds	r3, #10
 80020ea:	7819      	ldrb	r1, [r3, #0]
 80020ec:	683b      	ldr	r3, [r7, #0]
 80020ee:	330a      	adds	r3, #10
 80020f0:	781a      	ldrb	r2, [r3, #0]
 80020f2:	687b      	ldr	r3, [r7, #4]
 80020f4:	330a      	adds	r3, #10
 80020f6:	404a      	eors	r2, r1
 80020f8:	b2d2      	uxtb	r2, r2
 80020fa:	701a      	strb	r2, [r3, #0]
    acc[11] ^= op[11];
 80020fc:	687b      	ldr	r3, [r7, #4]
 80020fe:	330b      	adds	r3, #11
 8002100:	7819      	ldrb	r1, [r3, #0]
 8002102:	683b      	ldr	r3, [r7, #0]
 8002104:	330b      	adds	r3, #11
 8002106:	781a      	ldrb	r2, [r3, #0]
 8002108:	687b      	ldr	r3, [r7, #4]
 800210a:	330b      	adds	r3, #11
 800210c:	404a      	eors	r2, r1
 800210e:	b2d2      	uxtb	r2, r2
 8002110:	701a      	strb	r2, [r3, #0]
    acc[12] ^= op[12];
 8002112:	687b      	ldr	r3, [r7, #4]
 8002114:	330c      	adds	r3, #12
 8002116:	7819      	ldrb	r1, [r3, #0]
 8002118:	683b      	ldr	r3, [r7, #0]
 800211a:	330c      	adds	r3, #12
 800211c:	781a      	ldrb	r2, [r3, #0]
 800211e:	687b      	ldr	r3, [r7, #4]
 8002120:	330c      	adds	r3, #12
 8002122:	404a      	eors	r2, r1
 8002124:	b2d2      	uxtb	r2, r2
 8002126:	701a      	strb	r2, [r3, #0]
    acc[13] ^= op[13];
 8002128:	687b      	ldr	r3, [r7, #4]
 800212a:	330d      	adds	r3, #13
 800212c:	7819      	ldrb	r1, [r3, #0]
 800212e:	683b      	ldr	r3, [r7, #0]
 8002130:	330d      	adds	r3, #13
 8002132:	781a      	ldrb	r2, [r3, #0]
 8002134:	687b      	ldr	r3, [r7, #4]
 8002136:	330d      	adds	r3, #13
 8002138:	404a      	eors	r2, r1
 800213a:	b2d2      	uxtb	r2, r2
 800213c:	701a      	strb	r2, [r3, #0]
    acc[14] ^= op[14];
 800213e:	687b      	ldr	r3, [r7, #4]
 8002140:	330e      	adds	r3, #14
 8002142:	7819      	ldrb	r1, [r3, #0]
 8002144:	683b      	ldr	r3, [r7, #0]
 8002146:	330e      	adds	r3, #14
 8002148:	781a      	ldrb	r2, [r3, #0]
 800214a:	687b      	ldr	r3, [r7, #4]
 800214c:	330e      	adds	r3, #14
 800214e:	404a      	eors	r2, r1
 8002150:	b2d2      	uxtb	r2, r2
 8002152:	701a      	strb	r2, [r3, #0]
    acc[15] ^= op[15];
 8002154:	687b      	ldr	r3, [r7, #4]
 8002156:	330f      	adds	r3, #15
 8002158:	7819      	ldrb	r1, [r3, #0]
 800215a:	683b      	ldr	r3, [r7, #0]
 800215c:	330f      	adds	r3, #15
 800215e:	781a      	ldrb	r2, [r3, #0]
 8002160:	687b      	ldr	r3, [r7, #4]
 8002162:	330f      	adds	r3, #15
 8002164:	404a      	eors	r2, r1
 8002166:	b2d2      	uxtb	r2, r2
 8002168:	701a      	strb	r2, [r3, #0]
}
 800216a:	46c0      	nop			; (mov r8, r8)
 800216c:	46bd      	mov	sp, r7
 800216e:	b002      	add	sp, #8
 8002170:	bd80      	pop	{r7, pc}

08002172 <LDL_Frame_updateMIC>:
static bool getFrameType(uint8_t tag, enum ldl_frame_type *type);

/* functions **********************************************************/

void LDL_Frame_updateMIC(void *msg, uint8_t len, uint32_t mic)
{
 8002172:	b5b0      	push	{r4, r5, r7, lr}
 8002174:	b088      	sub	sp, #32
 8002176:	af00      	add	r7, sp, #0
 8002178:	60f8      	str	r0, [r7, #12]
 800217a:	607a      	str	r2, [r7, #4]
 800217c:	200b      	movs	r0, #11
 800217e:	183b      	adds	r3, r7, r0
 8002180:	1c0a      	adds	r2, r1, #0
 8002182:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(msg != NULL)
    
    struct ldl_stream s;    
    
    if(len > sizeof(mic)){
 8002184:	183b      	adds	r3, r7, r0
 8002186:	781b      	ldrb	r3, [r3, #0]
 8002188:	2b04      	cmp	r3, #4
 800218a:	d917      	bls.n	80021bc <LDL_Frame_updateMIC+0x4a>
    
        LDL_Stream_init(&s, msg, len);
 800218c:	250b      	movs	r5, #11
 800218e:	197b      	adds	r3, r7, r5
 8002190:	781a      	ldrb	r2, [r3, #0]
 8002192:	68f9      	ldr	r1, [r7, #12]
 8002194:	2414      	movs	r4, #20
 8002196:	193b      	adds	r3, r7, r4
 8002198:	0018      	movs	r0, r3
 800219a:	f007 f932 	bl	8009402 <LDL_Stream_init>
        
        (void)LDL_Stream_seekSet(&s, len - sizeof(mic));
 800219e:	197b      	adds	r3, r7, r5
 80021a0:	781b      	ldrb	r3, [r3, #0]
 80021a2:	3b04      	subs	r3, #4
 80021a4:	b2da      	uxtb	r2, r3
 80021a6:	193b      	adds	r3, r7, r4
 80021a8:	0011      	movs	r1, r2
 80021aa:	0018      	movs	r0, r3
 80021ac:	f007 fa19 	bl	80095e2 <LDL_Stream_seekSet>
        
        (void)LDL_Stream_putU32(&s, mic);    
 80021b0:	687a      	ldr	r2, [r7, #4]
 80021b2:	193b      	adds	r3, r7, r4
 80021b4:	0011      	movs	r1, r2
 80021b6:	0018      	movs	r0, r3
 80021b8:	f007 faa9 	bl	800970e <LDL_Stream_putU32>
    }
}
 80021bc:	46c0      	nop			; (mov r8, r8)
 80021be:	46bd      	mov	sp, r7
 80021c0:	b008      	add	sp, #32
 80021c2:	bdb0      	pop	{r4, r5, r7, pc}

080021c4 <LDL_Frame_putData>:

uint8_t LDL_Frame_putData(const struct ldl_frame_data *f, void *out, uint8_t max, struct ldl_frame_data_offset *off)
{
 80021c4:	b590      	push	{r4, r7, lr}
 80021c6:	b089      	sub	sp, #36	; 0x24
 80021c8:	af00      	add	r7, sp, #0
 80021ca:	60f8      	str	r0, [r7, #12]
 80021cc:	60b9      	str	r1, [r7, #8]
 80021ce:	603b      	str	r3, [r7, #0]
 80021d0:	1dfb      	adds	r3, r7, #7
 80021d2:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(f != NULL)
    
    struct ldl_stream s;    
    
    LDL_Stream_init(&s, out, max);
 80021d4:	1dfb      	adds	r3, r7, #7
 80021d6:	781a      	ldrb	r2, [r3, #0]
 80021d8:	68b9      	ldr	r1, [r7, #8]
 80021da:	2414      	movs	r4, #20
 80021dc:	193b      	adds	r3, r7, r4
 80021de:	0018      	movs	r0, r3
 80021e0:	f007 f90f 	bl	8009402 <LDL_Stream_init>
    
    (void)memset(off, 0, sizeof(*off));
 80021e4:	683b      	ldr	r3, [r7, #0]
 80021e6:	2202      	movs	r2, #2
 80021e8:	2100      	movs	r1, #0
 80021ea:	0018      	movs	r0, r3
 80021ec:	f00a fb75 	bl	800c8da <memset>
    
    (void)LDL_Stream_putU8(&s, ((uint8_t)f->type) << 5);
 80021f0:	68fb      	ldr	r3, [r7, #12]
 80021f2:	781b      	ldrb	r3, [r3, #0]
 80021f4:	015b      	lsls	r3, r3, #5
 80021f6:	b2da      	uxtb	r2, r3
 80021f8:	193b      	adds	r3, r7, r4
 80021fa:	0011      	movs	r1, r2
 80021fc:	0018      	movs	r0, r3
 80021fe:	f007 fa50 	bl	80096a2 <LDL_Stream_putU8>
    (void)LDL_Stream_putU32(&s, f->devAddr);
 8002202:	68fb      	ldr	r3, [r7, #12]
 8002204:	685a      	ldr	r2, [r3, #4]
 8002206:	193b      	adds	r3, r7, r4
 8002208:	0011      	movs	r1, r2
 800220a:	0018      	movs	r0, r3
 800220c:	f007 fa7f 	bl	800970e <LDL_Stream_putU32>
    (void)LDL_Stream_putU8(&s, (f->adr ? 0x80U : 0U) | (f->adrAckReq ? 0x40U : 0U) | (f->ack ? 0x20U : 0U) | (f->pending ? 0x10U : 0U) | (f->optsLen & 0xfU));
 8002210:	68fb      	ldr	r3, [r7, #12]
 8002212:	7adb      	ldrb	r3, [r3, #11]
 8002214:	2b00      	cmp	r3, #0
 8002216:	d001      	beq.n	800221c <LDL_Frame_putData+0x58>
 8002218:	2280      	movs	r2, #128	; 0x80
 800221a:	e000      	b.n	800221e <LDL_Frame_putData+0x5a>
 800221c:	2200      	movs	r2, #0
 800221e:	68fb      	ldr	r3, [r7, #12]
 8002220:	7b1b      	ldrb	r3, [r3, #12]
 8002222:	2b00      	cmp	r3, #0
 8002224:	d001      	beq.n	800222a <LDL_Frame_putData+0x66>
 8002226:	2340      	movs	r3, #64	; 0x40
 8002228:	e000      	b.n	800222c <LDL_Frame_putData+0x68>
 800222a:	2300      	movs	r3, #0
 800222c:	4313      	orrs	r3, r2
 800222e:	b2da      	uxtb	r2, r3
 8002230:	68fb      	ldr	r3, [r7, #12]
 8002232:	7a9b      	ldrb	r3, [r3, #10]
 8002234:	2b00      	cmp	r3, #0
 8002236:	d001      	beq.n	800223c <LDL_Frame_putData+0x78>
 8002238:	2320      	movs	r3, #32
 800223a:	e000      	b.n	800223e <LDL_Frame_putData+0x7a>
 800223c:	2300      	movs	r3, #0
 800223e:	4313      	orrs	r3, r2
 8002240:	b2da      	uxtb	r2, r3
 8002242:	68fb      	ldr	r3, [r7, #12]
 8002244:	7b5b      	ldrb	r3, [r3, #13]
 8002246:	2b00      	cmp	r3, #0
 8002248:	d001      	beq.n	800224e <LDL_Frame_putData+0x8a>
 800224a:	2310      	movs	r3, #16
 800224c:	e000      	b.n	8002250 <LDL_Frame_putData+0x8c>
 800224e:	2300      	movs	r3, #0
 8002250:	4313      	orrs	r3, r2
 8002252:	b2da      	uxtb	r2, r3
 8002254:	68fb      	ldr	r3, [r7, #12]
 8002256:	7d1b      	ldrb	r3, [r3, #20]
 8002258:	210f      	movs	r1, #15
 800225a:	400b      	ands	r3, r1
 800225c:	b2db      	uxtb	r3, r3
 800225e:	4313      	orrs	r3, r2
 8002260:	b2da      	uxtb	r2, r3
 8002262:	2414      	movs	r4, #20
 8002264:	193b      	adds	r3, r7, r4
 8002266:	0011      	movs	r1, r2
 8002268:	0018      	movs	r0, r3
 800226a:	f007 fa1a 	bl	80096a2 <LDL_Stream_putU8>
    (void)LDL_Stream_putU16(&s, f->counter);
 800226e:	68fb      	ldr	r3, [r7, #12]
 8002270:	891a      	ldrh	r2, [r3, #8]
 8002272:	193b      	adds	r3, r7, r4
 8002274:	0011      	movs	r1, r2
 8002276:	0018      	movs	r0, r3
 8002278:	f007 fa25 	bl	80096c6 <LDL_Stream_putU16>
    
    off->opts = LDL_Stream_tell(&s);
 800227c:	193b      	adds	r3, r7, r4
 800227e:	0018      	movs	r0, r3
 8002280:	f007 f975 	bl	800956e <LDL_Stream_tell>
 8002284:	0003      	movs	r3, r0
 8002286:	001a      	movs	r2, r3
 8002288:	683b      	ldr	r3, [r7, #0]
 800228a:	701a      	strb	r2, [r3, #0]
    (void)LDL_Stream_write(&s, f->opts, f->optsLen & 0xfU);
 800228c:	68fb      	ldr	r3, [r7, #12]
 800228e:	6919      	ldr	r1, [r3, #16]
 8002290:	68fb      	ldr	r3, [r7, #12]
 8002292:	7d1b      	ldrb	r3, [r3, #20]
 8002294:	220f      	movs	r2, #15
 8002296:	4013      	ands	r3, r2
 8002298:	b2da      	uxtb	r2, r3
 800229a:	193b      	adds	r3, r7, r4
 800229c:	0018      	movs	r0, r3
 800229e:	f007 f924 	bl	80094ea <LDL_Stream_write>
    
    if(f->data != NULL){
 80022a2:	68fb      	ldr	r3, [r7, #12]
 80022a4:	699b      	ldr	r3, [r3, #24]
 80022a6:	2b00      	cmp	r3, #0
 80022a8:	d017      	beq.n	80022da <LDL_Frame_putData+0x116>

        (void)LDL_Stream_putU8(&s, f->port);            
 80022aa:	68fb      	ldr	r3, [r7, #12]
 80022ac:	7d5a      	ldrb	r2, [r3, #21]
 80022ae:	2414      	movs	r4, #20
 80022b0:	193b      	adds	r3, r7, r4
 80022b2:	0011      	movs	r1, r2
 80022b4:	0018      	movs	r0, r3
 80022b6:	f007 f9f4 	bl	80096a2 <LDL_Stream_putU8>
        off->data = LDL_Stream_tell(&s);            
 80022ba:	193b      	adds	r3, r7, r4
 80022bc:	0018      	movs	r0, r3
 80022be:	f007 f956 	bl	800956e <LDL_Stream_tell>
 80022c2:	0003      	movs	r3, r0
 80022c4:	001a      	movs	r2, r3
 80022c6:	683b      	ldr	r3, [r7, #0]
 80022c8:	705a      	strb	r2, [r3, #1]
        (void)LDL_Stream_write(&s, f->data, f->dataLen);        
 80022ca:	68fb      	ldr	r3, [r7, #12]
 80022cc:	6999      	ldr	r1, [r3, #24]
 80022ce:	68fb      	ldr	r3, [r7, #12]
 80022d0:	7f1a      	ldrb	r2, [r3, #28]
 80022d2:	193b      	adds	r3, r7, r4
 80022d4:	0018      	movs	r0, r3
 80022d6:	f007 f908 	bl	80094ea <LDL_Stream_write>
    }
    
    (void)LDL_Stream_putU32(&s, f->mic);                
 80022da:	68fb      	ldr	r3, [r7, #12]
 80022dc:	6a1a      	ldr	r2, [r3, #32]
 80022de:	2414      	movs	r4, #20
 80022e0:	193b      	adds	r3, r7, r4
 80022e2:	0011      	movs	r1, r2
 80022e4:	0018      	movs	r0, r3
 80022e6:	f007 fa12 	bl	800970e <LDL_Stream_putU32>
    
    return LDL_Stream_error(&s) ? 0U : LDL_Stream_tell(&s);
 80022ea:	193b      	adds	r3, r7, r4
 80022ec:	0018      	movs	r0, r3
 80022ee:	f007 fb1a 	bl	8009926 <LDL_Stream_error>
 80022f2:	1e03      	subs	r3, r0, #0
 80022f4:	d106      	bne.n	8002304 <LDL_Frame_putData+0x140>
 80022f6:	2314      	movs	r3, #20
 80022f8:	18fb      	adds	r3, r7, r3
 80022fa:	0018      	movs	r0, r3
 80022fc:	f007 f937 	bl	800956e <LDL_Stream_tell>
 8002300:	0003      	movs	r3, r0
 8002302:	e000      	b.n	8002306 <LDL_Frame_putData+0x142>
 8002304:	2300      	movs	r3, #0
}
 8002306:	0018      	movs	r0, r3
 8002308:	46bd      	mov	sp, r7
 800230a:	b009      	add	sp, #36	; 0x24
 800230c:	bd90      	pop	{r4, r7, pc}

0800230e <LDL_Frame_putJoinRequest>:

uint8_t LDL_Frame_putJoinRequest(const struct ldl_frame_join_request *f, void *out, uint8_t max)
{
 800230e:	b590      	push	{r4, r7, lr}
 8002310:	b089      	sub	sp, #36	; 0x24
 8002312:	af00      	add	r7, sp, #0
 8002314:	60f8      	str	r0, [r7, #12]
 8002316:	60b9      	str	r1, [r7, #8]
 8002318:	1dfb      	adds	r3, r7, #7
 800231a:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(f->joinEUI != NULL)
    LDL_PEDANTIC(f->devEUI != NULL)
    
    struct ldl_stream s;    
    
    LDL_Stream_init(&s, out, max);
 800231c:	1dfb      	adds	r3, r7, #7
 800231e:	781a      	ldrb	r2, [r3, #0]
 8002320:	68b9      	ldr	r1, [r7, #8]
 8002322:	2414      	movs	r4, #20
 8002324:	193b      	adds	r3, r7, r4
 8002326:	0018      	movs	r0, r3
 8002328:	f007 f86b 	bl	8009402 <LDL_Stream_init>
    
    (void)LDL_Stream_putU8(&s, ((uint8_t)FRAME_TYPE_JOIN_REQ) << 5);
 800232c:	193b      	adds	r3, r7, r4
 800232e:	2100      	movs	r1, #0
 8002330:	0018      	movs	r0, r3
 8002332:	f007 f9b6 	bl	80096a2 <LDL_Stream_putU8>
    (void)LDL_Stream_putEUI(&s, f->joinEUI);
 8002336:	68fb      	ldr	r3, [r7, #12]
 8002338:	681a      	ldr	r2, [r3, #0]
 800233a:	193b      	adds	r3, r7, r4
 800233c:	0011      	movs	r1, r2
 800233e:	0018      	movs	r0, r3
 8002340:	f007 fa0e 	bl	8009760 <LDL_Stream_putEUI>
    (void)LDL_Stream_putEUI(&s, f->devEUI);
 8002344:	68fb      	ldr	r3, [r7, #12]
 8002346:	685a      	ldr	r2, [r3, #4]
 8002348:	193b      	adds	r3, r7, r4
 800234a:	0011      	movs	r1, r2
 800234c:	0018      	movs	r0, r3
 800234e:	f007 fa07 	bl	8009760 <LDL_Stream_putEUI>
    (void)LDL_Stream_putU16(&s, f->devNonce);
 8002352:	68fb      	ldr	r3, [r7, #12]
 8002354:	891a      	ldrh	r2, [r3, #8]
 8002356:	193b      	adds	r3, r7, r4
 8002358:	0011      	movs	r1, r2
 800235a:	0018      	movs	r0, r3
 800235c:	f007 f9b3 	bl	80096c6 <LDL_Stream_putU16>
    (void)LDL_Stream_putU32(&s, f->mic);
 8002360:	68fb      	ldr	r3, [r7, #12]
 8002362:	68da      	ldr	r2, [r3, #12]
 8002364:	193b      	adds	r3, r7, r4
 8002366:	0011      	movs	r1, r2
 8002368:	0018      	movs	r0, r3
 800236a:	f007 f9d0 	bl	800970e <LDL_Stream_putU32>

    return LDL_Stream_error(&s) ? 0U : LDL_Stream_tell(&s);
 800236e:	193b      	adds	r3, r7, r4
 8002370:	0018      	movs	r0, r3
 8002372:	f007 fad8 	bl	8009926 <LDL_Stream_error>
 8002376:	1e03      	subs	r3, r0, #0
 8002378:	d106      	bne.n	8002388 <LDL_Frame_putJoinRequest+0x7a>
 800237a:	2314      	movs	r3, #20
 800237c:	18fb      	adds	r3, r7, r3
 800237e:	0018      	movs	r0, r3
 8002380:	f007 f8f5 	bl	800956e <LDL_Stream_tell>
 8002384:	0003      	movs	r3, r0
 8002386:	e000      	b.n	800238a <LDL_Frame_putJoinRequest+0x7c>
 8002388:	2300      	movs	r3, #0
}
 800238a:	0018      	movs	r0, r3
 800238c:	46bd      	mov	sp, r7
 800238e:	b009      	add	sp, #36	; 0x24
 8002390:	bd90      	pop	{r4, r7, pc}

08002392 <LDL_Frame_sizeofJoinAccept>:
    
    return LDL_Stream_error(&s) ? 0U : LDL_Stream_tell(&s);
}

uint8_t LDL_Frame_sizeofJoinAccept(bool withCFList)
{
 8002392:	b580      	push	{r7, lr}
 8002394:	b082      	sub	sp, #8
 8002396:	af00      	add	r7, sp, #0
 8002398:	0002      	movs	r2, r0
 800239a:	1dfb      	adds	r3, r7, #7
 800239c:	701a      	strb	r2, [r3, #0]
    return 17U + (withCFList ? 16U : 0U);
 800239e:	1dfb      	adds	r3, r7, #7
 80023a0:	781b      	ldrb	r3, [r3, #0]
 80023a2:	2b00      	cmp	r3, #0
 80023a4:	d001      	beq.n	80023aa <LDL_Frame_sizeofJoinAccept+0x18>
 80023a6:	2321      	movs	r3, #33	; 0x21
 80023a8:	e000      	b.n	80023ac <LDL_Frame_sizeofJoinAccept+0x1a>
 80023aa:	2311      	movs	r3, #17
}
 80023ac:	0018      	movs	r0, r3
 80023ae:	46bd      	mov	sp, r7
 80023b0:	b002      	add	sp, #8
 80023b2:	bd80      	pop	{r7, pc}

080023b4 <LDL_Frame_decode>:

bool LDL_Frame_decode(struct ldl_frame_down *f, void *in, uint8_t len)
{
 80023b4:	b5b0      	push	{r4, r5, r7, lr}
 80023b6:	b08a      	sub	sp, #40	; 0x28
 80023b8:	af00      	add	r7, sp, #0
 80023ba:	60f8      	str	r0, [r7, #12]
 80023bc:	60b9      	str	r1, [r7, #8]
 80023be:	1dfb      	adds	r3, r7, #7
 80023c0:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(f != NULL)
    LDL_PEDANTIC((in != NULL) && (len > 0U))
    
    uint8_t *ptr = (uint8_t *)in;
 80023c2:	68bb      	ldr	r3, [r7, #8]
 80023c4:	623b      	str	r3, [r7, #32]
    bool retval = false;    
 80023c6:	2327      	movs	r3, #39	; 0x27
 80023c8:	18fb      	adds	r3, r7, r3
 80023ca:	2200      	movs	r2, #0
 80023cc:	701a      	strb	r2, [r3, #0]
    uint8_t fhdr = 0U;
 80023ce:	231f      	movs	r3, #31
 80023d0:	18fb      	adds	r3, r7, r3
 80023d2:	2200      	movs	r2, #0
 80023d4:	701a      	strb	r2, [r3, #0]
    uint8_t tag;
    uint8_t dlSettings = 0U;
 80023d6:	231d      	movs	r3, #29
 80023d8:	18fb      	adds	r3, r7, r3
 80023da:	2200      	movs	r2, #0
 80023dc:	701a      	strb	r2, [r3, #0]
    struct ldl_stream s;    
    
    (void)memset(f, 0, sizeof(*f));    
 80023de:	68fb      	ldr	r3, [r7, #12]
 80023e0:	2234      	movs	r2, #52	; 0x34
 80023e2:	2100      	movs	r1, #0
 80023e4:	0018      	movs	r0, r3
 80023e6:	f00a fa78 	bl	800c8da <memset>
    
    LDL_Stream_initReadOnly(&s, in, len);
 80023ea:	1dfb      	adds	r3, r7, #7
 80023ec:	781a      	ldrb	r2, [r3, #0]
 80023ee:	68b9      	ldr	r1, [r7, #8]
 80023f0:	2410      	movs	r4, #16
 80023f2:	193b      	adds	r3, r7, r4
 80023f4:	0018      	movs	r0, r3
 80023f6:	f007 f81f 	bl	8009438 <LDL_Stream_initReadOnly>

    if(LDL_Stream_getU8(&s, &tag)){
 80023fa:	231e      	movs	r3, #30
 80023fc:	18fa      	adds	r2, r7, r3
 80023fe:	193b      	adds	r3, r7, r4
 8002400:	0011      	movs	r1, r2
 8002402:	0018      	movs	r0, r3
 8002404:	f007 f9dd 	bl	80097c2 <LDL_Stream_getU8>
 8002408:	1e03      	subs	r3, r0, #0
 800240a:	d100      	bne.n	800240e <LDL_Frame_decode+0x5a>
 800240c:	e16f      	b.n	80026ee <LDL_Frame_decode+0x33a>
    
        if(getFrameType(tag, &f->type)){
 800240e:	231e      	movs	r3, #30
 8002410:	18fb      	adds	r3, r7, r3
 8002412:	781b      	ldrb	r3, [r3, #0]
 8002414:	68fa      	ldr	r2, [r7, #12]
 8002416:	0011      	movs	r1, r2
 8002418:	0018      	movs	r0, r3
 800241a:	f000 f981 	bl	8002720 <getFrameType>
 800241e:	1e03      	subs	r3, r0, #0
 8002420:	d100      	bne.n	8002424 <LDL_Frame_decode+0x70>
 8002422:	e164      	b.n	80026ee <LDL_Frame_decode+0x33a>
    
            switch(f->type){
 8002424:	68fb      	ldr	r3, [r7, #12]
 8002426:	781b      	ldrb	r3, [r3, #0]
 8002428:	2b03      	cmp	r3, #3
 800242a:	d100      	bne.n	800242e <LDL_Frame_decode+0x7a>
 800242c:	e08e      	b.n	800254c <LDL_Frame_decode+0x198>
 800242e:	2b05      	cmp	r3, #5
 8002430:	d100      	bne.n	8002434 <LDL_Frame_decode+0x80>
 8002432:	e08b      	b.n	800254c <LDL_Frame_decode+0x198>
 8002434:	2b01      	cmp	r3, #1
 8002436:	d000      	beq.n	800243a <LDL_Frame_decode+0x86>
            default:  
            case FRAME_TYPE_REJOIN_REQ:            
            case FRAME_TYPE_JOIN_REQ:
            case FRAME_TYPE_DATA_UNCONFIRMED_UP:
            case FRAME_TYPE_DATA_CONFIRMED_UP:
                break;
 8002438:	e15e      	b.n	80026f8 <LDL_Frame_decode+0x344>
                
            case FRAME_TYPE_JOIN_ACCEPT:
            
                (void)LDL_Stream_getU24(&s, &f->joinNonce);
 800243a:	68fb      	ldr	r3, [r7, #12]
 800243c:	1d1a      	adds	r2, r3, #4
 800243e:	2410      	movs	r4, #16
 8002440:	193b      	adds	r3, r7, r4
 8002442:	0011      	movs	r1, r2
 8002444:	0018      	movs	r0, r3
 8002446:	f007 f9f8 	bl	800983a <LDL_Stream_getU24>
                (void)LDL_Stream_getU24(&s, &f->netID);
 800244a:	68fb      	ldr	r3, [r7, #12]
 800244c:	3308      	adds	r3, #8
 800244e:	001a      	movs	r2, r3
 8002450:	193b      	adds	r3, r7, r4
 8002452:	0011      	movs	r1, r2
 8002454:	0018      	movs	r0, r3
 8002456:	f007 f9f0 	bl	800983a <LDL_Stream_getU24>
                (void)LDL_Stream_getU32(&s, &f->devAddr);
 800245a:	68fb      	ldr	r3, [r7, #12]
 800245c:	330c      	adds	r3, #12
 800245e:	001a      	movs	r2, r3
 8002460:	193b      	adds	r3, r7, r4
 8002462:	0011      	movs	r1, r2
 8002464:	0018      	movs	r0, r3
 8002466:	f007 fa1d 	bl	80098a4 <LDL_Stream_getU32>
                (void)LDL_Stream_getU8(&s, &dlSettings);
 800246a:	251d      	movs	r5, #29
 800246c:	197a      	adds	r2, r7, r5
 800246e:	193b      	adds	r3, r7, r4
 8002470:	0011      	movs	r1, r2
 8002472:	0018      	movs	r0, r3
 8002474:	f007 f9a5 	bl	80097c2 <LDL_Stream_getU8>
                (void)LDL_Stream_getU8(&s, &f->rxDelay);
 8002478:	68fb      	ldr	r3, [r7, #12]
 800247a:	3312      	adds	r3, #18
 800247c:	001a      	movs	r2, r3
 800247e:	193b      	adds	r3, r7, r4
 8002480:	0011      	movs	r1, r2
 8002482:	0018      	movs	r0, r3
 8002484:	f007 f99d 	bl	80097c2 <LDL_Stream_getU8>
                
                f->optNeg =             ((dlSettings & 0x80U) != 0);
 8002488:	197b      	adds	r3, r7, r5
 800248a:	781b      	ldrb	r3, [r3, #0]
 800248c:	b25b      	sxtb	r3, r3
 800248e:	b2db      	uxtb	r3, r3
 8002490:	09db      	lsrs	r3, r3, #7
 8002492:	b2da      	uxtb	r2, r3
 8002494:	68fb      	ldr	r3, [r7, #12]
 8002496:	74da      	strb	r2, [r3, #19]
                f->rx1DataRateOffset =  (dlSettings >> 4) & 0x7U;
 8002498:	197b      	adds	r3, r7, r5
 800249a:	781b      	ldrb	r3, [r3, #0]
 800249c:	091b      	lsrs	r3, r3, #4
 800249e:	b2db      	uxtb	r3, r3
 80024a0:	2207      	movs	r2, #7
 80024a2:	4013      	ands	r3, r2
 80024a4:	b2da      	uxtb	r2, r3
 80024a6:	68fb      	ldr	r3, [r7, #12]
 80024a8:	741a      	strb	r2, [r3, #16]
                f->rx2DataRate =        dlSettings & 0xfU;                    
 80024aa:	197b      	adds	r3, r7, r5
 80024ac:	781b      	ldrb	r3, [r3, #0]
 80024ae:	220f      	movs	r2, #15
 80024b0:	4013      	ands	r3, r2
 80024b2:	b2da      	uxtb	r2, r3
 80024b4:	68fb      	ldr	r3, [r7, #12]
 80024b6:	745a      	strb	r2, [r3, #17]
                
                f->rxDelay = ( f->rxDelay == 0U) ? 1U : f->rxDelay;
 80024b8:	68fb      	ldr	r3, [r7, #12]
 80024ba:	7c9b      	ldrb	r3, [r3, #18]
 80024bc:	2b00      	cmp	r3, #0
 80024be:	d002      	beq.n	80024c6 <LDL_Frame_decode+0x112>
 80024c0:	68fb      	ldr	r3, [r7, #12]
 80024c2:	7c9a      	ldrb	r2, [r3, #18]
 80024c4:	e000      	b.n	80024c8 <LDL_Frame_decode+0x114>
 80024c6:	2201      	movs	r2, #1
 80024c8:	68fb      	ldr	r3, [r7, #12]
 80024ca:	749a      	strb	r2, [r3, #18]
                
                /* cflist is included */
                if(LDL_Stream_remaining(&s) > sizeof(f->mic)){
 80024cc:	2310      	movs	r3, #16
 80024ce:	18fb      	adds	r3, r7, r3
 80024d0:	0018      	movs	r0, r3
 80024d2:	f007 f856 	bl	8009582 <LDL_Stream_remaining>
 80024d6:	0003      	movs	r3, r0
 80024d8:	2b04      	cmp	r3, #4
 80024da:	d915      	bls.n	8002508 <LDL_Frame_decode+0x154>
                
                    f->cfList = &ptr[LDL_Stream_tell(&s)];
 80024dc:	2410      	movs	r4, #16
 80024de:	193b      	adds	r3, r7, r4
 80024e0:	0018      	movs	r0, r3
 80024e2:	f007 f844 	bl	800956e <LDL_Stream_tell>
 80024e6:	0003      	movs	r3, r0
 80024e8:	001a      	movs	r2, r3
 80024ea:	6a3b      	ldr	r3, [r7, #32]
 80024ec:	189a      	adds	r2, r3, r2
 80024ee:	68fb      	ldr	r3, [r7, #12]
 80024f0:	615a      	str	r2, [r3, #20]
                    f->cfListLen = 16U;
 80024f2:	68fb      	ldr	r3, [r7, #12]
 80024f4:	2210      	movs	r2, #16
 80024f6:	761a      	strb	r2, [r3, #24]
                    (void)LDL_Stream_seekCur(&s, f->cfListLen);
 80024f8:	68fb      	ldr	r3, [r7, #12]
 80024fa:	7e1b      	ldrb	r3, [r3, #24]
 80024fc:	b21a      	sxth	r2, r3
 80024fe:	193b      	adds	r3, r7, r4
 8002500:	0011      	movs	r1, r2
 8002502:	0018      	movs	r0, r3
 8002504:	f007 f88d 	bl	8009622 <LDL_Stream_seekCur>
                }
                
                (void)LDL_Stream_getU32(&s, &f->mic);
 8002508:	68fb      	ldr	r3, [r7, #12]
 800250a:	3330      	adds	r3, #48	; 0x30
 800250c:	001a      	movs	r2, r3
 800250e:	2410      	movs	r4, #16
 8002510:	193b      	adds	r3, r7, r4
 8002512:	0011      	movs	r1, r2
 8002514:	0018      	movs	r0, r3
 8002516:	f007 f9c5 	bl	80098a4 <LDL_Stream_getU32>
                    
                if(!LDL_Stream_error(&s)){
 800251a:	193b      	adds	r3, r7, r4
 800251c:	0018      	movs	r0, r3
 800251e:	f007 fa02 	bl	8009926 <LDL_Stream_error>
 8002522:	0003      	movs	r3, r0
 8002524:	001a      	movs	r2, r3
 8002526:	2301      	movs	r3, #1
 8002528:	4053      	eors	r3, r2
 800252a:	b2db      	uxtb	r3, r3
 800252c:	2b00      	cmp	r3, #0
 800252e:	d100      	bne.n	8002532 <LDL_Frame_decode+0x17e>
 8002530:	e0df      	b.n	80026f2 <LDL_Frame_decode+0x33e>
                    
                    /* buffer should only be this size */
                    if(LDL_Stream_remaining(&s) == 0U){
 8002532:	2310      	movs	r3, #16
 8002534:	18fb      	adds	r3, r7, r3
 8002536:	0018      	movs	r0, r3
 8002538:	f007 f823 	bl	8009582 <LDL_Stream_remaining>
 800253c:	1e03      	subs	r3, r0, #0
 800253e:	d000      	beq.n	8002542 <LDL_Frame_decode+0x18e>
 8002540:	e0d7      	b.n	80026f2 <LDL_Frame_decode+0x33e>
                        
                        retval = true;                    
 8002542:	2327      	movs	r3, #39	; 0x27
 8002544:	18fb      	adds	r3, r7, r3
 8002546:	2201      	movs	r2, #1
 8002548:	701a      	strb	r2, [r3, #0]
                    }                    
                }
                break;
 800254a:	e0d2      	b.n	80026f2 <LDL_Frame_decode+0x33e>

            case FRAME_TYPE_DATA_UNCONFIRMED_DOWN:            
            case FRAME_TYPE_DATA_CONFIRMED_DOWN:

                (void)LDL_Stream_getU32(&s, &f->devAddr);
 800254c:	68fb      	ldr	r3, [r7, #12]
 800254e:	330c      	adds	r3, #12
 8002550:	001a      	movs	r2, r3
 8002552:	2510      	movs	r5, #16
 8002554:	197b      	adds	r3, r7, r5
 8002556:	0011      	movs	r1, r2
 8002558:	0018      	movs	r0, r3
 800255a:	f007 f9a3 	bl	80098a4 <LDL_Stream_getU32>
                (void)LDL_Stream_getU8(&s, &fhdr);
 800255e:	211f      	movs	r1, #31
 8002560:	000c      	movs	r4, r1
 8002562:	187a      	adds	r2, r7, r1
 8002564:	197b      	adds	r3, r7, r5
 8002566:	0011      	movs	r1, r2
 8002568:	0018      	movs	r0, r3
 800256a:	f007 f92a 	bl	80097c2 <LDL_Stream_getU8>
                
                f->adr =        ((fhdr & 0x80U) > 0U) ? true : false;
 800256e:	0021      	movs	r1, r4
 8002570:	187b      	adds	r3, r7, r1
 8002572:	781b      	ldrb	r3, [r3, #0]
 8002574:	b25b      	sxtb	r3, r3
 8002576:	11db      	asrs	r3, r3, #7
 8002578:	b25b      	sxtb	r3, r3
 800257a:	001a      	movs	r2, r3
 800257c:	2301      	movs	r3, #1
 800257e:	4013      	ands	r3, r2
 8002580:	1e5a      	subs	r2, r3, #1
 8002582:	4193      	sbcs	r3, r2
 8002584:	b2da      	uxtb	r2, r3
 8002586:	68fb      	ldr	r3, [r7, #12]
 8002588:	775a      	strb	r2, [r3, #29]
                f->adrAckReq =  ((fhdr & 0x40U) > 0U) ? true : false;
 800258a:	187b      	adds	r3, r7, r1
 800258c:	781b      	ldrb	r3, [r3, #0]
 800258e:	099b      	lsrs	r3, r3, #6
 8002590:	001a      	movs	r2, r3
 8002592:	2301      	movs	r3, #1
 8002594:	4013      	ands	r3, r2
 8002596:	1e5a      	subs	r2, r3, #1
 8002598:	4193      	sbcs	r3, r2
 800259a:	b2da      	uxtb	r2, r3
 800259c:	68fb      	ldr	r3, [r7, #12]
 800259e:	779a      	strb	r2, [r3, #30]
                f->ack =        ((fhdr & 0x20U) > 0U) ? true : false;
 80025a0:	187b      	adds	r3, r7, r1
 80025a2:	781b      	ldrb	r3, [r3, #0]
 80025a4:	095b      	lsrs	r3, r3, #5
 80025a6:	001a      	movs	r2, r3
 80025a8:	2301      	movs	r3, #1
 80025aa:	4013      	ands	r3, r2
 80025ac:	1e5a      	subs	r2, r3, #1
 80025ae:	4193      	sbcs	r3, r2
 80025b0:	b2da      	uxtb	r2, r3
 80025b2:	68fb      	ldr	r3, [r7, #12]
 80025b4:	771a      	strb	r2, [r3, #28]
                f->pending =    ((fhdr & 0x10U) > 0U) ? true : false;
 80025b6:	187b      	adds	r3, r7, r1
 80025b8:	781b      	ldrb	r3, [r3, #0]
 80025ba:	091b      	lsrs	r3, r3, #4
 80025bc:	001a      	movs	r2, r3
 80025be:	2301      	movs	r3, #1
 80025c0:	4013      	ands	r3, r2
 80025c2:	1e5a      	subs	r2, r3, #1
 80025c4:	4193      	sbcs	r3, r2
 80025c6:	b2da      	uxtb	r2, r3
 80025c8:	68fb      	ldr	r3, [r7, #12]
 80025ca:	77da      	strb	r2, [r3, #31]
                f->optsLen =    fhdr & 0xfU;
 80025cc:	187b      	adds	r3, r7, r1
 80025ce:	781b      	ldrb	r3, [r3, #0]
 80025d0:	220f      	movs	r2, #15
 80025d2:	4013      	ands	r3, r2
 80025d4:	b2d9      	uxtb	r1, r3
 80025d6:	68fb      	ldr	r3, [r7, #12]
 80025d8:	2224      	movs	r2, #36	; 0x24
 80025da:	5499      	strb	r1, [r3, r2]
                
                (void)LDL_Stream_getU16(&s, &f->counter);
 80025dc:	68fb      	ldr	r3, [r7, #12]
 80025de:	331a      	adds	r3, #26
 80025e0:	001a      	movs	r2, r3
 80025e2:	197b      	adds	r3, r7, r5
 80025e4:	0011      	movs	r1, r2
 80025e6:	0018      	movs	r0, r3
 80025e8:	f007 f8fb 	bl	80097e2 <LDL_Stream_getU16>
                
                f->opts = (f->optsLen > 0U) ? &ptr[LDL_Stream_tell(&s)] : NULL; 
 80025ec:	68fb      	ldr	r3, [r7, #12]
 80025ee:	2224      	movs	r2, #36	; 0x24
 80025f0:	5c9b      	ldrb	r3, [r3, r2]
 80025f2:	2b00      	cmp	r3, #0
 80025f4:	d009      	beq.n	800260a <LDL_Frame_decode+0x256>
 80025f6:	2310      	movs	r3, #16
 80025f8:	18fb      	adds	r3, r7, r3
 80025fa:	0018      	movs	r0, r3
 80025fc:	f006 ffb7 	bl	800956e <LDL_Stream_tell>
 8002600:	0003      	movs	r3, r0
 8002602:	001a      	movs	r2, r3
 8002604:	6a3b      	ldr	r3, [r7, #32]
 8002606:	189a      	adds	r2, r3, r2
 8002608:	e000      	b.n	800260c <LDL_Frame_decode+0x258>
 800260a:	2200      	movs	r2, #0
 800260c:	68fb      	ldr	r3, [r7, #12]
 800260e:	621a      	str	r2, [r3, #32]
                (void)LDL_Stream_seekCur(&s, f->optsLen);
 8002610:	68fb      	ldr	r3, [r7, #12]
 8002612:	2224      	movs	r2, #36	; 0x24
 8002614:	5c9b      	ldrb	r3, [r3, r2]
 8002616:	b21a      	sxth	r2, r3
 8002618:	2410      	movs	r4, #16
 800261a:	193b      	adds	r3, r7, r4
 800261c:	0011      	movs	r1, r2
 800261e:	0018      	movs	r0, r3
 8002620:	f006 ffff 	bl	8009622 <LDL_Stream_seekCur>
                
                if(LDL_Stream_remaining(&s) > sizeof(f->mic)){
 8002624:	193b      	adds	r3, r7, r4
 8002626:	0018      	movs	r0, r3
 8002628:	f006 ffab 	bl	8009582 <LDL_Stream_remaining>
 800262c:	0003      	movs	r3, r0
 800262e:	2b04      	cmp	r3, #4
 8002630:	d932      	bls.n	8002698 <LDL_Frame_decode+0x2e4>
                    
                    f->dataPresent = true;
 8002632:	68fb      	ldr	r3, [r7, #12]
 8002634:	2225      	movs	r2, #37	; 0x25
 8002636:	2101      	movs	r1, #1
 8002638:	5499      	strb	r1, [r3, r2]
                    
                    (void)LDL_Stream_getU8(&s, &f->port);
 800263a:	68fb      	ldr	r3, [r7, #12]
 800263c:	3326      	adds	r3, #38	; 0x26
 800263e:	001a      	movs	r2, r3
 8002640:	2410      	movs	r4, #16
 8002642:	193b      	adds	r3, r7, r4
 8002644:	0011      	movs	r1, r2
 8002646:	0018      	movs	r0, r3
 8002648:	f007 f8bb 	bl	80097c2 <LDL_Stream_getU8>
                    f->dataLen = LDL_Stream_remaining(&s) - sizeof(f->mic);                                                
 800264c:	193b      	adds	r3, r7, r4
 800264e:	0018      	movs	r0, r3
 8002650:	f006 ff97 	bl	8009582 <LDL_Stream_remaining>
 8002654:	0003      	movs	r3, r0
 8002656:	3b04      	subs	r3, #4
 8002658:	b2d9      	uxtb	r1, r3
 800265a:	68fb      	ldr	r3, [r7, #12]
 800265c:	222c      	movs	r2, #44	; 0x2c
 800265e:	5499      	strb	r1, [r3, r2]
                    f->data = (f->dataLen == 0U) ? NULL : &ptr[LDL_Stream_tell(&s)];                    
 8002660:	68fb      	ldr	r3, [r7, #12]
 8002662:	222c      	movs	r2, #44	; 0x2c
 8002664:	5c9b      	ldrb	r3, [r3, r2]
 8002666:	2b00      	cmp	r3, #0
 8002668:	d009      	beq.n	800267e <LDL_Frame_decode+0x2ca>
 800266a:	2310      	movs	r3, #16
 800266c:	18fb      	adds	r3, r7, r3
 800266e:	0018      	movs	r0, r3
 8002670:	f006 ff7d 	bl	800956e <LDL_Stream_tell>
 8002674:	0003      	movs	r3, r0
 8002676:	001a      	movs	r2, r3
 8002678:	6a3b      	ldr	r3, [r7, #32]
 800267a:	189a      	adds	r2, r3, r2
 800267c:	e000      	b.n	8002680 <LDL_Frame_decode+0x2cc>
 800267e:	2200      	movs	r2, #0
 8002680:	68fb      	ldr	r3, [r7, #12]
 8002682:	629a      	str	r2, [r3, #40]	; 0x28
                    (void)LDL_Stream_seekCur(&s, f->dataLen);
 8002684:	68fb      	ldr	r3, [r7, #12]
 8002686:	222c      	movs	r2, #44	; 0x2c
 8002688:	5c9b      	ldrb	r3, [r3, r2]
 800268a:	b21a      	sxth	r2, r3
 800268c:	2310      	movs	r3, #16
 800268e:	18fb      	adds	r3, r7, r3
 8002690:	0011      	movs	r1, r2
 8002692:	0018      	movs	r0, r3
 8002694:	f006 ffc5 	bl	8009622 <LDL_Stream_seekCur>
                }
                
                (void)LDL_Stream_getU32(&s, &f->mic);
 8002698:	68fb      	ldr	r3, [r7, #12]
 800269a:	3330      	adds	r3, #48	; 0x30
 800269c:	001a      	movs	r2, r3
 800269e:	2410      	movs	r4, #16
 80026a0:	193b      	adds	r3, r7, r4
 80026a2:	0011      	movs	r1, r2
 80026a4:	0018      	movs	r0, r3
 80026a6:	f007 f8fd 	bl	80098a4 <LDL_Stream_getU32>
                
                if(!LDL_Stream_error(&s)){
 80026aa:	193b      	adds	r3, r7, r4
 80026ac:	0018      	movs	r0, r3
 80026ae:	f007 f93a 	bl	8009926 <LDL_Stream_error>
 80026b2:	0003      	movs	r3, r0
 80026b4:	001a      	movs	r2, r3
 80026b6:	2301      	movs	r3, #1
 80026b8:	4053      	eors	r3, r2
 80026ba:	b2db      	uxtb	r3, r3
 80026bc:	2b00      	cmp	r3, #0
 80026be:	d01a      	beq.n	80026f6 <LDL_Frame_decode+0x342>
                    
                    /* cannot have fopts when data is present and port == 0 */
                    if(!(f->dataPresent && (f->optsLen > 0) && (f->port == 0U))){
 80026c0:	68fb      	ldr	r3, [r7, #12]
 80026c2:	2225      	movs	r2, #37	; 0x25
 80026c4:	5c9b      	ldrb	r3, [r3, r2]
 80026c6:	2201      	movs	r2, #1
 80026c8:	4053      	eors	r3, r2
 80026ca:	b2db      	uxtb	r3, r3
 80026cc:	2b00      	cmp	r3, #0
 80026ce:	d109      	bne.n	80026e4 <LDL_Frame_decode+0x330>
 80026d0:	68fb      	ldr	r3, [r7, #12]
 80026d2:	2224      	movs	r2, #36	; 0x24
 80026d4:	5c9b      	ldrb	r3, [r3, r2]
 80026d6:	2b00      	cmp	r3, #0
 80026d8:	d004      	beq.n	80026e4 <LDL_Frame_decode+0x330>
 80026da:	68fb      	ldr	r3, [r7, #12]
 80026dc:	2226      	movs	r2, #38	; 0x26
 80026de:	5c9b      	ldrb	r3, [r3, r2]
 80026e0:	2b00      	cmp	r3, #0
 80026e2:	d008      	beq.n	80026f6 <LDL_Frame_decode+0x342>
                        
                        retval = true;
 80026e4:	2327      	movs	r3, #39	; 0x27
 80026e6:	18fb      	adds	r3, r7, r3
 80026e8:	2201      	movs	r2, #1
 80026ea:	701a      	strb	r2, [r3, #0]
                    }                                
                }
                break;
 80026ec:	e003      	b.n	80026f6 <LDL_Frame_decode+0x342>
            }
        }
 80026ee:	46c0      	nop			; (mov r8, r8)
 80026f0:	e002      	b.n	80026f8 <LDL_Frame_decode+0x344>
                break;
 80026f2:	46c0      	nop			; (mov r8, r8)
 80026f4:	e000      	b.n	80026f8 <LDL_Frame_decode+0x344>
                break;
 80026f6:	46c0      	nop			; (mov r8, r8)
    }
    
    return retval;
 80026f8:	2327      	movs	r3, #39	; 0x27
 80026fa:	18fb      	adds	r3, r7, r3
 80026fc:	781b      	ldrb	r3, [r3, #0]
}
 80026fe:	0018      	movs	r0, r3
 8002700:	46bd      	mov	sp, r7
 8002702:	b00a      	add	sp, #40	; 0x28
 8002704:	bdb0      	pop	{r4, r5, r7, pc}

08002706 <LDL_Frame_dataOverhead>:

uint8_t LDL_Frame_dataOverhead(void)
{
 8002706:	b580      	push	{r7, lr}
 8002708:	af00      	add	r7, sp, #0
    /* DevAddr + FCtrl + FCnt + FOpts + FPort */
    return (4U + 1U + 2U) + (1U);
 800270a:	2308      	movs	r3, #8
}
 800270c:	0018      	movs	r0, r3
 800270e:	46bd      	mov	sp, r7
 8002710:	bd80      	pop	{r7, pc}

08002712 <LDL_Frame_phyOverhead>:

uint8_t LDL_Frame_phyOverhead(void)
{
 8002712:	b580      	push	{r7, lr}
 8002714:	af00      	add	r7, sp, #0
    /* MHDR + MIC */
    return 1U + 4U;
 8002716:	2305      	movs	r3, #5
}
 8002718:	0018      	movs	r0, r3
 800271a:	46bd      	mov	sp, r7
 800271c:	bd80      	pop	{r7, pc}
	...

08002720 <getFrameType>:


/* static functions ***************************************************/

static bool getFrameType(uint8_t tag, enum ldl_frame_type *type)
{
 8002720:	b580      	push	{r7, lr}
 8002722:	b084      	sub	sp, #16
 8002724:	af00      	add	r7, sp, #0
 8002726:	0002      	movs	r2, r0
 8002728:	6039      	str	r1, [r7, #0]
 800272a:	1dfb      	adds	r3, r7, #7
 800272c:	701a      	strb	r2, [r3, #0]
    bool retval = false;
 800272e:	230f      	movs	r3, #15
 8002730:	18fb      	adds	r3, r7, r3
 8002732:	2200      	movs	r2, #0
 8002734:	701a      	strb	r2, [r3, #0]
    
    if((tag & 0x1fU) == 0U){
 8002736:	1dfb      	adds	r3, r7, #7
 8002738:	781b      	ldrb	r3, [r3, #0]
 800273a:	221f      	movs	r2, #31
 800273c:	4013      	ands	r3, r2
 800273e:	d12f      	bne.n	80027a0 <getFrameType+0x80>
        
        retval = true;
 8002740:	230f      	movs	r3, #15
 8002742:	18fb      	adds	r3, r7, r3
 8002744:	2201      	movs	r2, #1
 8002746:	701a      	strb	r2, [r3, #0]
        
        switch((tag >> 5)){
 8002748:	1dfb      	adds	r3, r7, #7
 800274a:	781b      	ldrb	r3, [r3, #0]
 800274c:	095b      	lsrs	r3, r3, #5
 800274e:	b2db      	uxtb	r3, r3
 8002750:	2b06      	cmp	r3, #6
 8002752:	d820      	bhi.n	8002796 <getFrameType+0x76>
 8002754:	009a      	lsls	r2, r3, #2
 8002756:	4b16      	ldr	r3, [pc, #88]	; (80027b0 <getFrameType+0x90>)
 8002758:	18d3      	adds	r3, r2, r3
 800275a:	681b      	ldr	r3, [r3, #0]
 800275c:	469f      	mov	pc, r3
        case FRAME_TYPE_JOIN_REQ:
            *type = FRAME_TYPE_JOIN_REQ;
 800275e:	683b      	ldr	r3, [r7, #0]
 8002760:	2200      	movs	r2, #0
 8002762:	701a      	strb	r2, [r3, #0]
            break;
 8002764:	e01d      	b.n	80027a2 <getFrameType+0x82>
        case FRAME_TYPE_JOIN_ACCEPT:
            *type = FRAME_TYPE_JOIN_ACCEPT;
 8002766:	683b      	ldr	r3, [r7, #0]
 8002768:	2201      	movs	r2, #1
 800276a:	701a      	strb	r2, [r3, #0]
            break;
 800276c:	e019      	b.n	80027a2 <getFrameType+0x82>
        case FRAME_TYPE_DATA_UNCONFIRMED_UP:
            *type = FRAME_TYPE_DATA_UNCONFIRMED_UP;
 800276e:	683b      	ldr	r3, [r7, #0]
 8002770:	2202      	movs	r2, #2
 8002772:	701a      	strb	r2, [r3, #0]
            break;
 8002774:	e015      	b.n	80027a2 <getFrameType+0x82>
        case FRAME_TYPE_DATA_UNCONFIRMED_DOWN:
            *type = FRAME_TYPE_DATA_UNCONFIRMED_DOWN;
 8002776:	683b      	ldr	r3, [r7, #0]
 8002778:	2203      	movs	r2, #3
 800277a:	701a      	strb	r2, [r3, #0]
            break;
 800277c:	e011      	b.n	80027a2 <getFrameType+0x82>
        case FRAME_TYPE_DATA_CONFIRMED_UP:
            *type = FRAME_TYPE_DATA_CONFIRMED_UP;
 800277e:	683b      	ldr	r3, [r7, #0]
 8002780:	2204      	movs	r2, #4
 8002782:	701a      	strb	r2, [r3, #0]
            break;
 8002784:	e00d      	b.n	80027a2 <getFrameType+0x82>
        case FRAME_TYPE_DATA_CONFIRMED_DOWN:
            *type = FRAME_TYPE_DATA_CONFIRMED_DOWN;
 8002786:	683b      	ldr	r3, [r7, #0]
 8002788:	2205      	movs	r2, #5
 800278a:	701a      	strb	r2, [r3, #0]
            break;
 800278c:	e009      	b.n	80027a2 <getFrameType+0x82>
        case FRAME_TYPE_REJOIN_REQ:
            *type = FRAME_TYPE_REJOIN_REQ;
 800278e:	683b      	ldr	r3, [r7, #0]
 8002790:	2206      	movs	r2, #6
 8002792:	701a      	strb	r2, [r3, #0]
            break;
 8002794:	e005      	b.n	80027a2 <getFrameType+0x82>
        default:
            retval = false;
 8002796:	230f      	movs	r3, #15
 8002798:	18fb      	adds	r3, r7, r3
 800279a:	2200      	movs	r2, #0
 800279c:	701a      	strb	r2, [r3, #0]
            break;
 800279e:	e000      	b.n	80027a2 <getFrameType+0x82>
        }
    }
 80027a0:	46c0      	nop			; (mov r8, r8)
    
    return retval;
 80027a2:	230f      	movs	r3, #15
 80027a4:	18fb      	adds	r3, r7, r3
 80027a6:	781b      	ldrb	r3, [r3, #0]
}
 80027a8:	0018      	movs	r0, r3
 80027aa:	46bd      	mov	sp, r7
 80027ac:	b004      	add	sp, #16
 80027ae:	bd80      	pop	{r7, pc}
 80027b0:	0800e48c 	.word	0x0800e48c

080027b4 <LDL_MAC_init>:
static void setPendingCommand(struct ldl_mac *self, enum ldl_mac_cmd_type type);

/* functions **********************************************************/

void LDL_MAC_init(struct ldl_mac *self, enum ldl_region region, const struct ldl_mac_init_arg *arg)
{
 80027b4:	b590      	push	{r4, r7, lr}
 80027b6:	b085      	sub	sp, #20
 80027b8:	af00      	add	r7, sp, #0
 80027ba:	60f8      	str	r0, [r7, #12]
 80027bc:	607a      	str	r2, [r7, #4]
 80027be:	240b      	movs	r4, #11
 80027c0:	193b      	adds	r3, r7, r4
 80027c2:	1c0a      	adds	r2, r1, #0
 80027c4:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(LDL_System_tps() >= 1000UL)
    
    LDL_ASSERT(arg->joinEUI != NULL)
    LDL_ASSERT(arg->devEUI != NULL)
    
    (void)memset(self, 0, sizeof(*self));
 80027c6:	239c      	movs	r3, #156	; 0x9c
 80027c8:	009a      	lsls	r2, r3, #2
 80027ca:	68fb      	ldr	r3, [r7, #12]
 80027cc:	2100      	movs	r1, #0
 80027ce:	0018      	movs	r0, r3
 80027d0:	f00a f883 	bl	800c8da <memset>
    
    self->tx.chIndex = UINT8_MAX;
 80027d4:	68fa      	ldr	r2, [r7, #12]
 80027d6:	23a6      	movs	r3, #166	; 0xa6
 80027d8:	005b      	lsls	r3, r3, #1
 80027da:	21ff      	movs	r1, #255	; 0xff
 80027dc:	54d1      	strb	r1, [r2, r3]
    
    self->region = region;
 80027de:	68fa      	ldr	r2, [r7, #12]
 80027e0:	1939      	adds	r1, r7, r4
 80027e2:	2391      	movs	r3, #145	; 0x91
 80027e4:	009b      	lsls	r3, r3, #2
 80027e6:	7809      	ldrb	r1, [r1, #0]
 80027e8:	54d1      	strb	r1, [r2, r3]
    
    self->app = arg->app;    
 80027ea:	687b      	ldr	r3, [r7, #4]
 80027ec:	6819      	ldr	r1, [r3, #0]
 80027ee:	68fa      	ldr	r2, [r7, #12]
 80027f0:	2393      	movs	r3, #147	; 0x93
 80027f2:	009b      	lsls	r3, r3, #2
 80027f4:	50d1      	str	r1, [r2, r3]
    self->handler = arg->handler ? arg->handler : dummyResponseHandler;
 80027f6:	687b      	ldr	r3, [r7, #4]
 80027f8:	68db      	ldr	r3, [r3, #12]
 80027fa:	2b00      	cmp	r3, #0
 80027fc:	d002      	beq.n	8002804 <LDL_MAC_init+0x50>
 80027fe:	687b      	ldr	r3, [r7, #4]
 8002800:	68db      	ldr	r3, [r3, #12]
 8002802:	e000      	b.n	8002806 <LDL_MAC_init+0x52>
 8002804:	4b4d      	ldr	r3, [pc, #308]	; (800293c <LDL_MAC_init+0x188>)
 8002806:	68f9      	ldr	r1, [r7, #12]
 8002808:	2292      	movs	r2, #146	; 0x92
 800280a:	0092      	lsls	r2, r2, #2
 800280c:	508b      	str	r3, [r1, r2]
    self->radio = arg->radio;
 800280e:	687b      	ldr	r3, [r7, #4]
 8002810:	6859      	ldr	r1, [r3, #4]
 8002812:	68fa      	ldr	r2, [r7, #12]
 8002814:	2388      	movs	r3, #136	; 0x88
 8002816:	009b      	lsls	r3, r3, #2
 8002818:	50d1      	str	r1, [r2, r3]
    self->sm = arg->sm;      
 800281a:	687b      	ldr	r3, [r7, #4]
 800281c:	6899      	ldr	r1, [r3, #8]
 800281e:	68fa      	ldr	r2, [r7, #12]
 8002820:	2387      	movs	r3, #135	; 0x87
 8002822:	009b      	lsls	r3, r3, #2
 8002824:	50d1      	str	r1, [r2, r3]
    self->devNonce = arg->devNonce;  
 8002826:	687b      	ldr	r3, [r7, #4]
 8002828:	8b99      	ldrh	r1, [r3, #28]
 800282a:	68fa      	ldr	r2, [r7, #12]
 800282c:	239a      	movs	r3, #154	; 0x9a
 800282e:	005b      	lsls	r3, r3, #1
 8002830:	52d1      	strh	r1, [r2, r3]
    self->joinNonce = arg->joinNonce;  
 8002832:	687b      	ldr	r3, [r7, #4]
 8002834:	6a19      	ldr	r1, [r3, #32]
 8002836:	68fa      	ldr	r2, [r7, #12]
 8002838:	239c      	movs	r3, #156	; 0x9c
 800283a:	005b      	lsls	r3, r3, #1
 800283c:	50d1      	str	r1, [r2, r3]
    self->gain = arg->gain;
 800283e:	687b      	ldr	r3, [r7, #4]
 8002840:	2124      	movs	r1, #36	; 0x24
 8002842:	5e59      	ldrsh	r1, [r3, r1]
 8002844:	68fa      	ldr	r2, [r7, #12]
 8002846:	239b      	movs	r3, #155	; 0x9b
 8002848:	009b      	lsls	r3, r3, #2
 800284a:	52d1      	strh	r1, [r2, r3]
    
    (void)memcpy(self->devEUI, arg->devEUI, sizeof(self->devEUI));
 800284c:	68fb      	ldr	r3, [r7, #12]
 800284e:	330b      	adds	r3, #11
 8002850:	0018      	movs	r0, r3
 8002852:	687b      	ldr	r3, [r7, #4]
 8002854:	699b      	ldr	r3, [r3, #24]
 8002856:	2208      	movs	r2, #8
 8002858:	0019      	movs	r1, r3
 800285a:	f00a f835 	bl	800c8c8 <memcpy>
    (void)memcpy(self->joinEUI, arg->joinEUI, sizeof(self->joinEUI));
 800285e:	68fb      	ldr	r3, [r7, #12]
 8002860:	1cd8      	adds	r0, r3, #3
 8002862:	687b      	ldr	r3, [r7, #4]
 8002864:	695b      	ldr	r3, [r3, #20]
 8002866:	2208      	movs	r2, #8
 8002868:	0019      	movs	r1, r3
 800286a:	f00a f82d 	bl	800c8c8 <memcpy>
    
    if(self->radio != NULL){
 800286e:	68fa      	ldr	r2, [r7, #12]
 8002870:	2388      	movs	r3, #136	; 0x88
 8002872:	009b      	lsls	r3, r3, #2
 8002874:	58d3      	ldr	r3, [r2, r3]
 8002876:	2b00      	cmp	r3, #0
 8002878:	d009      	beq.n	800288e <LDL_MAC_init+0xda>
        
        LDL_Radio_setHandler(self->radio, self, LDL_MAC_radioEvent);
 800287a:	68fa      	ldr	r2, [r7, #12]
 800287c:	2388      	movs	r3, #136	; 0x88
 800287e:	009b      	lsls	r3, r3, #2
 8002880:	58d3      	ldr	r3, [r2, r3]
 8002882:	4a2f      	ldr	r2, [pc, #188]	; (8002940 <LDL_MAC_init+0x18c>)
 8002884:	68f9      	ldr	r1, [r7, #12]
 8002886:	0018      	movs	r0, r3
 8002888:	f005 fafd 	bl	8007e86 <LDL_Radio_setHandler>
 800288c:	e00b      	b.n	80028a6 <LDL_MAC_init+0xf2>
    }
    else{
        
        LDL_INFO(self->app, "radio is undefined")
 800288e:	4b2d      	ldr	r3, [pc, #180]	; (8002944 <LDL_MAC_init+0x190>)
 8002890:	0018      	movs	r0, r3
 8002892:	f00a f82b 	bl	800c8ec <iprintf>
 8002896:	4b2c      	ldr	r3, [pc, #176]	; (8002948 <LDL_MAC_init+0x194>)
 8002898:	0018      	movs	r0, r3
 800289a:	f00a f827 	bl	800c8ec <iprintf>
 800289e:	4b2b      	ldr	r3, [pc, #172]	; (800294c <LDL_MAC_init+0x198>)
 80028a0:	0018      	movs	r0, r3
 80028a2:	f00a f89d 	bl	800c9e0 <puts>
    }
    
    if(arg->session != NULL){
 80028a6:	687b      	ldr	r3, [r7, #4]
 80028a8:	691b      	ldr	r3, [r3, #16]
 80028aa:	2b00      	cmp	r3, #0
 80028ac:	d00a      	beq.n	80028c4 <LDL_MAC_init+0x110>
        
        (void)memcpy(&self->ctx, arg->session, sizeof(self->ctx));
 80028ae:	68fb      	ldr	r3, [r7, #12]
 80028b0:	335d      	adds	r3, #93	; 0x5d
 80028b2:	33ff      	adds	r3, #255	; 0xff
 80028b4:	0018      	movs	r0, r3
 80028b6:	687b      	ldr	r3, [r7, #4]
 80028b8:	691b      	ldr	r3, [r3, #16]
 80028ba:	22c0      	movs	r2, #192	; 0xc0
 80028bc:	0019      	movs	r1, r3
 80028be:	f00a f803 	bl	800c8c8 <memcpy>
 80028c2:	e004      	b.n	80028ce <LDL_MAC_init+0x11a>
    }
    else{
        
        restoreDefaults(self, false);
 80028c4:	68fb      	ldr	r3, [r7, #12]
 80028c6:	2100      	movs	r1, #0
 80028c8:	0018      	movs	r0, r3
 80028ca:	f003 f9cb 	bl	8005c64 <restoreDefaults>
     
#ifndef LDL_STARTUP_DELAY
#   define LDL_STARTUP_DELAY 0UL
#endif
    
    self->band[LDL_BAND_GLOBAL] = (uint32_t)LDL_STARTUP_DELAY;
 80028ce:	68fa      	ldr	r2, [r7, #12]
 80028d0:	2394      	movs	r3, #148	; 0x94
 80028d2:	005b      	lsls	r3, r3, #1
 80028d4:	2100      	movs	r1, #0
 80028d6:	50d1      	str	r1, [r2, r3]
    
    self->polled_band_ticks = LDL_System_ticks(self->app);
 80028d8:	68fa      	ldr	r2, [r7, #12]
 80028da:	2393      	movs	r3, #147	; 0x93
 80028dc:	009b      	lsls	r3, r3, #2
 80028de:	58d3      	ldr	r3, [r2, r3]
 80028e0:	0018      	movs	r0, r3
 80028e2:	f007 faf5 	bl	8009ed0 <LDL_System_ticks>
 80028e6:	0001      	movs	r1, r0
 80028e8:	68fa      	ldr	r2, [r7, #12]
 80028ea:	2398      	movs	r3, #152	; 0x98
 80028ec:	005b      	lsls	r3, r3, #1
 80028ee:	50d1      	str	r1, [r2, r3]
    self->polled_time_ticks = self->polled_band_ticks;
 80028f0:	68fa      	ldr	r2, [r7, #12]
 80028f2:	2398      	movs	r3, #152	; 0x98
 80028f4:	005b      	lsls	r3, r3, #1
 80028f6:	58d1      	ldr	r1, [r2, r3]
 80028f8:	68fa      	ldr	r2, [r7, #12]
 80028fa:	2397      	movs	r3, #151	; 0x97
 80028fc:	009b      	lsls	r3, r3, #2
 80028fe:	50d1      	str	r1, [r2, r3]
    
    LDL_Radio_reset(self->radio, false);
 8002900:	68fa      	ldr	r2, [r7, #12]
 8002902:	2388      	movs	r3, #136	; 0x88
 8002904:	009b      	lsls	r3, r3, #2
 8002906:	58d3      	ldr	r3, [r2, r3]
 8002908:	2100      	movs	r1, #0
 800290a:	0018      	movs	r0, r3
 800290c:	f005 fae9 	bl	8007ee2 <LDL_Radio_reset>

    /* leave reset line alone for 10ms */
    LDL_MAC_timerSet(self, LDL_TIMER_WAITA, (LDL_System_tps() + LDL_System_eps())/100UL);
 8002910:	f007 fae9 	bl	8009ee6 <LDL_System_tps>
 8002914:	0004      	movs	r4, r0
 8002916:	f007 faed 	bl	8009ef4 <LDL_System_eps>
 800291a:	0003      	movs	r3, r0
 800291c:	18e3      	adds	r3, r4, r3
 800291e:	2164      	movs	r1, #100	; 0x64
 8002920:	0018      	movs	r0, r3
 8002922:	f7fd fbf1 	bl	8000108 <__udivsi3>
 8002926:	0003      	movs	r3, r0
 8002928:	001a      	movs	r2, r3
 800292a:	68fb      	ldr	r3, [r7, #12]
 800292c:	2100      	movs	r1, #0
 800292e:	0018      	movs	r0, r3
 8002930:	f001 fa84 	bl	8003e3c <LDL_MAC_timerSet>
    
    /* self->state is LDL_STATE_INIT */
}
 8002934:	46c0      	nop			; (mov r8, r8)
 8002936:	46bd      	mov	sp, r7
 8002938:	b005      	add	sp, #20
 800293a:	bd90      	pop	{r4, r7, pc}
 800293c:	08006953 	.word	0x08006953
 8002940:	08003d69 	.word	0x08003d69
 8002944:	0800d8c8 	.word	0x0800d8c8
 8002948:	0800d8d0 	.word	0x0800d8d0
 800294c:	0800d8e4 	.word	0x0800d8e4

08002950 <LDL_MAC_unconfirmedData>:
    
    return self->state;
}

bool LDL_MAC_unconfirmedData(struct ldl_mac *self, uint8_t port, const void *data, uint8_t len, const struct ldl_mac_data_opts *opts)
{    
 8002950:	b5b0      	push	{r4, r5, r7, lr}
 8002952:	b086      	sub	sp, #24
 8002954:	af02      	add	r7, sp, #8
 8002956:	60f8      	str	r0, [r7, #12]
 8002958:	0008      	movs	r0, r1
 800295a:	607a      	str	r2, [r7, #4]
 800295c:	0019      	movs	r1, r3
 800295e:	240b      	movs	r4, #11
 8002960:	193b      	adds	r3, r7, r4
 8002962:	1c02      	adds	r2, r0, #0
 8002964:	701a      	strb	r2, [r3, #0]
 8002966:	250a      	movs	r5, #10
 8002968:	197b      	adds	r3, r7, r5
 800296a:	1c0a      	adds	r2, r1, #0
 800296c:	701a      	strb	r2, [r3, #0]
    return externalDataCommand(self, false, port, data, len, opts);
 800296e:	6879      	ldr	r1, [r7, #4]
 8002970:	193b      	adds	r3, r7, r4
 8002972:	781a      	ldrb	r2, [r3, #0]
 8002974:	68f8      	ldr	r0, [r7, #12]
 8002976:	6a3b      	ldr	r3, [r7, #32]
 8002978:	9301      	str	r3, [sp, #4]
 800297a:	197b      	adds	r3, r7, r5
 800297c:	781b      	ldrb	r3, [r3, #0]
 800297e:	9300      	str	r3, [sp, #0]
 8002980:	000b      	movs	r3, r1
 8002982:	2100      	movs	r1, #0
 8002984:	f001 fbce 	bl	8004124 <externalDataCommand>
 8002988:	0003      	movs	r3, r0
}
 800298a:	0018      	movs	r0, r3
 800298c:	46bd      	mov	sp, r7
 800298e:	b004      	add	sp, #16
 8002990:	bdb0      	pop	{r4, r5, r7, pc}
	...

08002994 <LDL_MAC_otaa>:
{    
    return externalDataCommand(self, true, port, data, len, opts);
}

bool LDL_MAC_otaa(struct ldl_mac *self)
{
 8002994:	b590      	push	{r4, r7, lr}
 8002996:	b08b      	sub	sp, #44	; 0x2c
 8002998:	af02      	add	r7, sp, #8
 800299a:	6078      	str	r0, [r7, #4]
    LDL_PEDANTIC(self != NULL)
    
    uint32_t delay;
    struct ldl_frame_join_request f;
    
    bool retval = false;
 800299c:	231f      	movs	r3, #31
 800299e:	18fb      	adds	r3, r7, r3
 80029a0:	2200      	movs	r2, #0
 80029a2:	701a      	strb	r2, [r3, #0]
    
    self->errno = LDL_ERRNO_NONE;
 80029a4:	687b      	ldr	r3, [r7, #4]
 80029a6:	2200      	movs	r2, #0
 80029a8:	709a      	strb	r2, [r3, #2]
    
    if(self->state == LDL_STATE_IDLE){
 80029aa:	687b      	ldr	r3, [r7, #4]
 80029ac:	781b      	ldrb	r3, [r3, #0]
 80029ae:	2b06      	cmp	r3, #6
 80029b0:	d000      	beq.n	80029b4 <LDL_MAC_otaa+0x20>
 80029b2:	e0c0      	b.n	8002b36 <LDL_MAC_otaa+0x1a2>
        
        if(self->ctx.joined){
 80029b4:	687a      	ldr	r2, [r7, #4]
 80029b6:	2381      	movs	r3, #129	; 0x81
 80029b8:	009b      	lsls	r3, r3, #2
 80029ba:	5cd3      	ldrb	r3, [r2, r3]
 80029bc:	2b00      	cmp	r3, #0
 80029be:	d003      	beq.n	80029c8 <LDL_MAC_otaa+0x34>
            
            LDL_MAC_forget(self);
 80029c0:	687b      	ldr	r3, [r7, #4]
 80029c2:	0018      	movs	r0, r3
 80029c4:	f000 f8d4 	bl	8002b70 <LDL_MAC_forget>
        }
        
        self->trials = 0U;
 80029c8:	687a      	ldr	r2, [r7, #4]
 80029ca:	2399      	movs	r3, #153	; 0x99
 80029cc:	009b      	lsls	r3, r3, #2
 80029ce:	2100      	movs	r1, #0
 80029d0:	50d1      	str	r1, [r2, r3]
        
        self->tx.rate = LDL_Region_getJoinRate(self->region, self->trials);
 80029d2:	687a      	ldr	r2, [r7, #4]
 80029d4:	2391      	movs	r3, #145	; 0x91
 80029d6:	009b      	lsls	r3, r3, #2
 80029d8:	5cd0      	ldrb	r0, [r2, r3]
 80029da:	687a      	ldr	r2, [r7, #4]
 80029dc:	2399      	movs	r3, #153	; 0x99
 80029de:	009b      	lsls	r3, r3, #2
 80029e0:	58d3      	ldr	r3, [r2, r3]
 80029e2:	0019      	movs	r1, r3
 80029e4:	f006 fb4f 	bl	8009086 <LDL_Region_getJoinRate>
 80029e8:	0003      	movs	r3, r0
 80029ea:	0019      	movs	r1, r3
 80029ec:	687a      	ldr	r2, [r7, #4]
 80029ee:	234e      	movs	r3, #78	; 0x4e
 80029f0:	33ff      	adds	r3, #255	; 0xff
 80029f2:	54d1      	strb	r1, [r2, r3]
        self->band[LDL_BAND_RETRY] = 0U;
 80029f4:	687a      	ldr	r2, [r7, #4]
 80029f6:	2396      	movs	r3, #150	; 0x96
 80029f8:	005b      	lsls	r3, r3, #1
 80029fa:	2100      	movs	r1, #0
 80029fc:	50d1      	str	r1, [r2, r3]
        self->tx.power = 0U;
 80029fe:	687a      	ldr	r2, [r7, #4]
 8002a00:	23a7      	movs	r3, #167	; 0xa7
 8002a02:	005b      	lsls	r3, r3, #1
 8002a04:	2100      	movs	r1, #0
 8002a06:	54d1      	strb	r1, [r2, r3]
        
        if(self->band[LDL_BAND_GLOBAL] == 0UL){
 8002a08:	687a      	ldr	r2, [r7, #4]
 8002a0a:	2394      	movs	r3, #148	; 0x94
 8002a0c:	005b      	lsls	r3, r3, #1
 8002a0e:	58d3      	ldr	r3, [r2, r3]
 8002a10:	2b00      	cmp	r3, #0
 8002a12:	d000      	beq.n	8002a16 <LDL_MAC_otaa+0x82>
 8002a14:	e08b      	b.n	8002b2e <LDL_MAC_otaa+0x19a>
        
            if(selectChannel(self, self->tx.rate, self->tx.chIndex, 0UL, &self->tx.chIndex, &self->tx.freq)){
 8002a16:	687a      	ldr	r2, [r7, #4]
 8002a18:	234e      	movs	r3, #78	; 0x4e
 8002a1a:	33ff      	adds	r3, #255	; 0xff
 8002a1c:	5cd1      	ldrb	r1, [r2, r3]
 8002a1e:	687a      	ldr	r2, [r7, #4]
 8002a20:	23a6      	movs	r3, #166	; 0xa6
 8002a22:	005b      	lsls	r3, r3, #1
 8002a24:	5cd4      	ldrb	r4, [r2, r3]
 8002a26:	687b      	ldr	r3, [r7, #4]
 8002a28:	334d      	adds	r3, #77	; 0x4d
 8002a2a:	33ff      	adds	r3, #255	; 0xff
 8002a2c:	687a      	ldr	r2, [r7, #4]
 8002a2e:	3245      	adds	r2, #69	; 0x45
 8002a30:	32ff      	adds	r2, #255	; 0xff
 8002a32:	6878      	ldr	r0, [r7, #4]
 8002a34:	9201      	str	r2, [sp, #4]
 8002a36:	9300      	str	r3, [sp, #0]
 8002a38:	2300      	movs	r3, #0
 8002a3a:	0022      	movs	r2, r4
 8002a3c:	f002 ff3e 	bl	80058bc <selectChannel>
 8002a40:	1e03      	subs	r3, r0, #0
 8002a42:	d070      	beq.n	8002b26 <LDL_MAC_otaa+0x192>
            
#ifndef LDL_DISABLE_POINTONE          
                LDL_OPS_deriveJoinKeys(self);
#endif                
            
                f.joinEUI = self->joinEUI;
 8002a44:	687b      	ldr	r3, [r7, #4]
 8002a46:	1cda      	adds	r2, r3, #3
 8002a48:	2408      	movs	r4, #8
 8002a4a:	193b      	adds	r3, r7, r4
 8002a4c:	601a      	str	r2, [r3, #0]
                f.devEUI = self->devEUI;
 8002a4e:	687b      	ldr	r3, [r7, #4]
 8002a50:	330b      	adds	r3, #11
 8002a52:	001a      	movs	r2, r3
 8002a54:	193b      	adds	r3, r7, r4
 8002a56:	605a      	str	r2, [r3, #4]
                
#ifdef LDL_DISABLE_POINTONE
                /* LoRAWAN 1.0 uses random nonce */
                self->devNonce = rand32(self->app);
 8002a58:	687a      	ldr	r2, [r7, #4]
 8002a5a:	2393      	movs	r3, #147	; 0x93
 8002a5c:	009b      	lsls	r3, r3, #2
 8002a5e:	58d3      	ldr	r3, [r2, r3]
 8002a60:	0018      	movs	r0, r3
 8002a62:	f003 ff29 	bl	80068b8 <rand32>
 8002a66:	0003      	movs	r3, r0
 8002a68:	b299      	uxth	r1, r3
 8002a6a:	687a      	ldr	r2, [r7, #4]
 8002a6c:	239a      	movs	r3, #154	; 0x9a
 8002a6e:	005b      	lsls	r3, r3, #1
 8002a70:	52d1      	strh	r1, [r2, r3]
#endif                                
                f.devNonce = self->devNonce;
 8002a72:	687a      	ldr	r2, [r7, #4]
 8002a74:	239a      	movs	r3, #154	; 0x9a
 8002a76:	005b      	lsls	r3, r3, #1
 8002a78:	5ad2      	ldrh	r2, [r2, r3]
 8002a7a:	193b      	adds	r3, r7, r4
 8002a7c:	811a      	strh	r2, [r3, #8]

                self->bufferLen = LDL_OPS_prepareJoinRequest(self, &f, self->buffer, sizeof(self->buffer));
 8002a7e:	687b      	ldr	r3, [r7, #4]
 8002a80:	3313      	adds	r3, #19
 8002a82:	001a      	movs	r2, r3
 8002a84:	1939      	adds	r1, r7, r4
 8002a86:	6878      	ldr	r0, [r7, #4]
 8002a88:	23ff      	movs	r3, #255	; 0xff
 8002a8a:	f004 fd63 	bl	8007554 <LDL_OPS_prepareJoinRequest>
 8002a8e:	0003      	movs	r3, r0
 8002a90:	0019      	movs	r1, r3
 8002a92:	687a      	ldr	r2, [r7, #4]
 8002a94:	2389      	movs	r3, #137	; 0x89
 8002a96:	005b      	lsls	r3, r3, #1
 8002a98:	54d1      	strb	r1, [r2, r3]

                delay = rand32(self->app) % (60UL*LDL_System_tps());
 8002a9a:	687a      	ldr	r2, [r7, #4]
 8002a9c:	2393      	movs	r3, #147	; 0x93
 8002a9e:	009b      	lsls	r3, r3, #2
 8002aa0:	58d3      	ldr	r3, [r2, r3]
 8002aa2:	0018      	movs	r0, r3
 8002aa4:	f003 ff08 	bl	80068b8 <rand32>
 8002aa8:	0004      	movs	r4, r0
 8002aaa:	f007 fa1c 	bl	8009ee6 <LDL_System_tps>
 8002aae:	0002      	movs	r2, r0
 8002ab0:	0013      	movs	r3, r2
 8002ab2:	011b      	lsls	r3, r3, #4
 8002ab4:	1a9b      	subs	r3, r3, r2
 8002ab6:	009b      	lsls	r3, r3, #2
 8002ab8:	0019      	movs	r1, r3
 8002aba:	0020      	movs	r0, r4
 8002abc:	f7fd fbaa 	bl	8000214 <__aeabi_uidivmod>
 8002ac0:	000b      	movs	r3, r1
 8002ac2:	61bb      	str	r3, [r7, #24]
                
                LDL_DEBUG(self->app, "sending join in %"PRIu32" ticks", delay)
 8002ac4:	4b21      	ldr	r3, [pc, #132]	; (8002b4c <LDL_MAC_otaa+0x1b8>)
 8002ac6:	0018      	movs	r0, r3
 8002ac8:	f009 ff10 	bl	800c8ec <iprintf>
 8002acc:	69ba      	ldr	r2, [r7, #24]
 8002ace:	4b20      	ldr	r3, [pc, #128]	; (8002b50 <LDL_MAC_otaa+0x1bc>)
 8002ad0:	0011      	movs	r1, r2
 8002ad2:	0018      	movs	r0, r3
 8002ad4:	f009 ff0a 	bl	800c8ec <iprintf>
 8002ad8:	4b1e      	ldr	r3, [pc, #120]	; (8002b54 <LDL_MAC_otaa+0x1c0>)
 8002ada:	0018      	movs	r0, r3
 8002adc:	f009 ff80 	bl	800c9e0 <puts>
                            
                LDL_MAC_timerSet(self, LDL_TIMER_WAITA, delay);
 8002ae0:	69ba      	ldr	r2, [r7, #24]
 8002ae2:	687b      	ldr	r3, [r7, #4]
 8002ae4:	2100      	movs	r1, #0
 8002ae6:	0018      	movs	r0, r3
 8002ae8:	f001 f9a8 	bl	8003e3c <LDL_MAC_timerSet>
                
                self->state = LDL_STATE_WAIT_TX;
 8002aec:	687b      	ldr	r3, [r7, #4]
 8002aee:	2207      	movs	r2, #7
 8002af0:	701a      	strb	r2, [r3, #0]
                self->op = LDL_OP_JOINING;            
 8002af2:	687b      	ldr	r3, [r7, #4]
 8002af4:	2201      	movs	r2, #1
 8002af6:	705a      	strb	r2, [r3, #1]
                self->service_start_time = timeNow(self) + (delay / LDL_System_tps());            
 8002af8:	687b      	ldr	r3, [r7, #4]
 8002afa:	0018      	movs	r0, r3
 8002afc:	f003 fb52 	bl	80061a4 <timeNow>
 8002b00:	0004      	movs	r4, r0
 8002b02:	f007 f9f0 	bl	8009ee6 <LDL_System_tps>
 8002b06:	0003      	movs	r3, r0
 8002b08:	0019      	movs	r1, r3
 8002b0a:	69b8      	ldr	r0, [r7, #24]
 8002b0c:	f7fd fafc 	bl	8000108 <__udivsi3>
 8002b10:	0003      	movs	r3, r0
 8002b12:	18e1      	adds	r1, r4, r3
 8002b14:	687a      	ldr	r2, [r7, #4]
 8002b16:	2398      	movs	r3, #152	; 0x98
 8002b18:	009b      	lsls	r3, r3, #2
 8002b1a:	50d1      	str	r1, [r2, r3]
                retval = true;        
 8002b1c:	231f      	movs	r3, #31
 8002b1e:	18fb      	adds	r3, r7, r3
 8002b20:	2201      	movs	r2, #1
 8002b22:	701a      	strb	r2, [r3, #0]
 8002b24:	e00a      	b.n	8002b3c <LDL_MAC_otaa+0x1a8>
            }
            else{
                
                self->errno = LDL_ERRNO_NOCHANNEL;
 8002b26:	687b      	ldr	r3, [r7, #4]
 8002b28:	2201      	movs	r2, #1
 8002b2a:	709a      	strb	r2, [r3, #2]
 8002b2c:	e006      	b.n	8002b3c <LDL_MAC_otaa+0x1a8>
            }
        }
        else{
            
            self->errno = LDL_ERRNO_NOCHANNEL;
 8002b2e:	687b      	ldr	r3, [r7, #4]
 8002b30:	2201      	movs	r2, #1
 8002b32:	709a      	strb	r2, [r3, #2]
 8002b34:	e002      	b.n	8002b3c <LDL_MAC_otaa+0x1a8>
        }
    }
    else{
        
        self->errno = LDL_ERRNO_BUSY;
 8002b36:	687b      	ldr	r3, [r7, #4]
 8002b38:	2205      	movs	r2, #5
 8002b3a:	709a      	strb	r2, [r3, #2]
    }
    
    return retval;
 8002b3c:	231f      	movs	r3, #31
 8002b3e:	18fb      	adds	r3, r7, r3
 8002b40:	781b      	ldrb	r3, [r3, #0]
}
 8002b42:	0018      	movs	r0, r3
 8002b44:	46bd      	mov	sp, r7
 8002b46:	b009      	add	sp, #36	; 0x24
 8002b48:	bd90      	pop	{r4, r7, pc}
 8002b4a:	46c0      	nop			; (mov r8, r8)
 8002b4c:	0800d8e8 	.word	0x0800d8e8
 8002b50:	0800d8f4 	.word	0x0800d8f4
 8002b54:	0800d8e4 	.word	0x0800d8e4

08002b58 <LDL_MAC_joined>:

bool LDL_MAC_joined(const struct ldl_mac *self)
{
 8002b58:	b580      	push	{r7, lr}
 8002b5a:	b082      	sub	sp, #8
 8002b5c:	af00      	add	r7, sp, #0
 8002b5e:	6078      	str	r0, [r7, #4]
    return self->ctx.joined;
 8002b60:	687a      	ldr	r2, [r7, #4]
 8002b62:	2381      	movs	r3, #129	; 0x81
 8002b64:	009b      	lsls	r3, r3, #2
 8002b66:	5cd3      	ldrb	r3, [r2, r3]
}
 8002b68:	0018      	movs	r0, r3
 8002b6a:	46bd      	mov	sp, r7
 8002b6c:	b002      	add	sp, #8
 8002b6e:	bd80      	pop	{r7, pc}

08002b70 <LDL_MAC_forget>:

void LDL_MAC_forget(struct ldl_mac *self)
{
 8002b70:	b580      	push	{r7, lr}
 8002b72:	b082      	sub	sp, #8
 8002b74:	af00      	add	r7, sp, #0
 8002b76:	6078      	str	r0, [r7, #4]
    LDL_PEDANTIC(self != NULL)    
    
    LDL_MAC_cancel(self);    
 8002b78:	687b      	ldr	r3, [r7, #4]
 8002b7a:	0018      	movs	r0, r3
 8002b7c:	f000 f813 	bl	8002ba6 <LDL_MAC_cancel>
    
    if(self->ctx.joined){
 8002b80:	687a      	ldr	r2, [r7, #4]
 8002b82:	2381      	movs	r3, #129	; 0x81
 8002b84:	009b      	lsls	r3, r3, #2
 8002b86:	5cd3      	ldrb	r3, [r2, r3]
 8002b88:	2b00      	cmp	r3, #0
 8002b8a:	d008      	beq.n	8002b9e <LDL_MAC_forget+0x2e>
    
        restoreDefaults(self, true);    
 8002b8c:	687b      	ldr	r3, [r7, #4]
 8002b8e:	2101      	movs	r1, #1
 8002b90:	0018      	movs	r0, r3
 8002b92:	f003 f867 	bl	8005c64 <restoreDefaults>
        
#ifndef LDL_DISABLE_SESSION_UPDATE        
        pushSessionUpdate(self);   
 8002b96:	687b      	ldr	r3, [r7, #4]
 8002b98:	0018      	movs	r0, r3
 8002b9a:	f003 fec0 	bl	800691e <pushSessionUpdate>
#endif
    }
}
 8002b9e:	46c0      	nop			; (mov r8, r8)
 8002ba0:	46bd      	mov	sp, r7
 8002ba2:	b002      	add	sp, #8
 8002ba4:	bd80      	pop	{r7, pc}

08002ba6 <LDL_MAC_cancel>:

void LDL_MAC_cancel(struct ldl_mac *self)
{
 8002ba6:	b580      	push	{r7, lr}
 8002ba8:	b082      	sub	sp, #8
 8002baa:	af00      	add	r7, sp, #0
 8002bac:	6078      	str	r0, [r7, #4]
    LDL_PEDANTIC(self != NULL)
    
    switch(self->state){
 8002bae:	687b      	ldr	r3, [r7, #4]
 8002bb0:	781b      	ldrb	r3, [r3, #0]
 8002bb2:	3b01      	subs	r3, #1
 8002bb4:	2b05      	cmp	r3, #5
 8002bb6:	d90a      	bls.n	8002bce <LDL_MAC_cancel+0x28>
    case LDL_STATE_RECOVERY_RESET:    
    case LDL_STATE_RECOVERY_LOCKOUT:    
    case LDL_STATE_ENTROPY:    
        break;
    default:
        self->state = LDL_STATE_IDLE;
 8002bb8:	687b      	ldr	r3, [r7, #4]
 8002bba:	2206      	movs	r2, #6
 8002bbc:	701a      	strb	r2, [r3, #0]
        LDL_Radio_sleep(self->radio);    
 8002bbe:	687a      	ldr	r2, [r7, #4]
 8002bc0:	2388      	movs	r3, #136	; 0x88
 8002bc2:	009b      	lsls	r3, r3, #2
 8002bc4:	58d3      	ldr	r3, [r2, r3]
 8002bc6:	0018      	movs	r0, r3
 8002bc8:	f005 fb3b 	bl	8008242 <LDL_Radio_sleep>
        break;
 8002bcc:	e000      	b.n	8002bd0 <LDL_MAC_cancel+0x2a>
        break;
 8002bce:	46c0      	nop			; (mov r8, r8)
    }   
}
 8002bd0:	46c0      	nop			; (mov r8, r8)
 8002bd2:	46bd      	mov	sp, r7
 8002bd4:	b002      	add	sp, #8
 8002bd6:	bd80      	pop	{r7, pc}

08002bd8 <LDL_MAC_process>:
{
    return transmitTime(bw, sf, size, false);
}

void LDL_MAC_process(struct ldl_mac *self)
{
 8002bd8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002bda:	b0f3      	sub	sp, #460	; 0x1cc
 8002bdc:	af02      	add	r7, sp, #8
 8002bde:	6078      	str	r0, [r7, #4]
    LDL_PEDANTIC(self != NULL)
    
    uint32_t error;    
    union ldl_mac_response_arg arg;

    (void)timeNow(self);    
 8002be0:	687b      	ldr	r3, [r7, #4]
 8002be2:	0018      	movs	r0, r3
 8002be4:	f003 fade 	bl	80061a4 <timeNow>
    
    processBands(self);
 8002be8:	687b      	ldr	r3, [r7, #4]
 8002bea:	0018      	movs	r0, r3
 8002bec:	f003 fb5d 	bl	80062aa <processBands>
    
    switch(self->state){
 8002bf0:	687b      	ldr	r3, [r7, #4]
 8002bf2:	781b      	ldrb	r3, [r3, #0]
 8002bf4:	2b0e      	cmp	r3, #14
 8002bf6:	d901      	bls.n	8002bfc <LDL_MAC_process+0x24>
 8002bf8:	f001 f817 	bl	8003c2a <LDL_MAC_process+0x1052>
 8002bfc:	009a      	lsls	r2, r3, #2
 8002bfe:	4bcf      	ldr	r3, [pc, #828]	; (8002f3c <LDL_MAC_process+0x364>)
 8002c00:	18d3      	adds	r3, r2, r3
 8002c02:	681b      	ldr	r3, [r3, #0]
 8002c04:	469f      	mov	pc, r3
    case LDL_STATE_IDLE:
        /* do nothing */
        break;    
    case LDL_STATE_INIT:
    
        if(LDL_MAC_timerCheck(self, LDL_TIMER_WAITA, &error)){
 8002c06:	23c2      	movs	r3, #194	; 0xc2
 8002c08:	005b      	lsls	r3, r3, #1
 8002c0a:	18fa      	adds	r2, r7, r3
 8002c0c:	687b      	ldr	r3, [r7, #4]
 8002c0e:	2100      	movs	r1, #0
 8002c10:	0018      	movs	r0, r3
 8002c12:	f001 f949 	bl	8003ea8 <LDL_MAC_timerCheck>
 8002c16:	1e03      	subs	r3, r0, #0
 8002c18:	d101      	bne.n	8002c1e <LDL_MAC_process+0x46>
 8002c1a:	f001 f808 	bl	8003c2e <LDL_MAC_process+0x1056>
    
            LDL_Radio_reset(self->radio, true);
 8002c1e:	687a      	ldr	r2, [r7, #4]
 8002c20:	2388      	movs	r3, #136	; 0x88
 8002c22:	009b      	lsls	r3, r3, #2
 8002c24:	58d3      	ldr	r3, [r2, r3]
 8002c26:	2101      	movs	r1, #1
 8002c28:	0018      	movs	r0, r3
 8002c2a:	f005 f95a 	bl	8007ee2 <LDL_Radio_reset>
        
            self->state = LDL_STATE_INIT_RESET;
 8002c2e:	687b      	ldr	r3, [r7, #4]
 8002c30:	2201      	movs	r2, #1
 8002c32:	701a      	strb	r2, [r3, #0]
            self->op = LDL_OP_RESET;
 8002c34:	687b      	ldr	r3, [r7, #4]
 8002c36:	2205      	movs	r2, #5
 8002c38:	705a      	strb	r2, [r3, #1]
            
            /* hold reset for at least 100us */
            LDL_MAC_timerSet(self, LDL_TIMER_WAITA, ((LDL_System_tps() + LDL_System_eps())/10000UL) + 1UL);
 8002c3a:	f007 f954 	bl	8009ee6 <LDL_System_tps>
 8002c3e:	0004      	movs	r4, r0
 8002c40:	f007 f958 	bl	8009ef4 <LDL_System_eps>
 8002c44:	0003      	movs	r3, r0
 8002c46:	18e3      	adds	r3, r4, r3
 8002c48:	49bd      	ldr	r1, [pc, #756]	; (8002f40 <LDL_MAC_process+0x368>)
 8002c4a:	0018      	movs	r0, r3
 8002c4c:	f7fd fa5c 	bl	8000108 <__udivsi3>
 8002c50:	0003      	movs	r3, r0
 8002c52:	1c5a      	adds	r2, r3, #1
 8002c54:	687b      	ldr	r3, [r7, #4]
 8002c56:	2100      	movs	r1, #0
 8002c58:	0018      	movs	r0, r3
 8002c5a:	f001 f8ef 	bl	8003e3c <LDL_MAC_timerSet>
            
#ifndef LDL_DISABLE_MAC_RESET_EVENT         
            self->handler(self->app, LDL_MAC_RESET, NULL); 
 8002c5e:	687a      	ldr	r2, [r7, #4]
 8002c60:	2392      	movs	r3, #146	; 0x92
 8002c62:	009b      	lsls	r3, r3, #2
 8002c64:	58d3      	ldr	r3, [r2, r3]
 8002c66:	6879      	ldr	r1, [r7, #4]
 8002c68:	2293      	movs	r2, #147	; 0x93
 8002c6a:	0092      	lsls	r2, r2, #2
 8002c6c:	5888      	ldr	r0, [r1, r2]
 8002c6e:	2200      	movs	r2, #0
 8002c70:	2101      	movs	r1, #1
 8002c72:	4798      	blx	r3
#endif                    
        }
        break;
 8002c74:	f000 ffdb 	bl	8003c2e <LDL_MAC_process+0x1056>
        
    case LDL_STATE_INIT_RESET:
    case LDL_STATE_RECOVERY_RESET:
    
        if(LDL_MAC_timerCheck(self, LDL_TIMER_WAITA, &error)){
 8002c78:	23c2      	movs	r3, #194	; 0xc2
 8002c7a:	005b      	lsls	r3, r3, #1
 8002c7c:	18fa      	adds	r2, r7, r3
 8002c7e:	687b      	ldr	r3, [r7, #4]
 8002c80:	2100      	movs	r1, #0
 8002c82:	0018      	movs	r0, r3
 8002c84:	f001 f910 	bl	8003ea8 <LDL_MAC_timerCheck>
 8002c88:	1e03      	subs	r3, r0, #0
 8002c8a:	d039      	beq.n	8002d00 <LDL_MAC_process+0x128>
        
            LDL_Radio_reset(self->radio, false);
 8002c8c:	687a      	ldr	r2, [r7, #4]
 8002c8e:	2388      	movs	r3, #136	; 0x88
 8002c90:	009b      	lsls	r3, r3, #2
 8002c92:	58d3      	ldr	r3, [r2, r3]
 8002c94:	2100      	movs	r1, #0
 8002c96:	0018      	movs	r0, r3
 8002c98:	f005 f923 	bl	8007ee2 <LDL_Radio_reset>
            
            self->op = LDL_OP_RESET;
 8002c9c:	687b      	ldr	r3, [r7, #4]
 8002c9e:	2205      	movs	r2, #5
 8002ca0:	705a      	strb	r2, [r3, #1]
            
            switch(self->state){
 8002ca2:	687b      	ldr	r3, [r7, #4]
 8002ca4:	781b      	ldrb	r3, [r3, #0]
 8002ca6:	2b03      	cmp	r3, #3
 8002ca8:	d015      	beq.n	8002cd6 <LDL_MAC_process+0xfe>
            default:
            case LDL_STATE_INIT_RESET:
                self->state = LDL_STATE_INIT_LOCKOUT;                
 8002caa:	687b      	ldr	r3, [r7, #4]
 8002cac:	2202      	movs	r2, #2
 8002cae:	701a      	strb	r2, [r3, #0]
                /* 10ms */
                LDL_MAC_timerSet(self, LDL_TIMER_WAITA, ((LDL_System_tps() + LDL_System_eps())/100UL) + 1UL); 
 8002cb0:	f007 f919 	bl	8009ee6 <LDL_System_tps>
 8002cb4:	0004      	movs	r4, r0
 8002cb6:	f007 f91d 	bl	8009ef4 <LDL_System_eps>
 8002cba:	0003      	movs	r3, r0
 8002cbc:	18e3      	adds	r3, r4, r3
 8002cbe:	2164      	movs	r1, #100	; 0x64
 8002cc0:	0018      	movs	r0, r3
 8002cc2:	f7fd fa21 	bl	8000108 <__udivsi3>
 8002cc6:	0003      	movs	r3, r0
 8002cc8:	1c5a      	adds	r2, r3, #1
 8002cca:	687b      	ldr	r3, [r7, #4]
 8002ccc:	2100      	movs	r1, #0
 8002cce:	0018      	movs	r0, r3
 8002cd0:	f001 f8b4 	bl	8003e3c <LDL_MAC_timerSet>
                break;            
 8002cd4:	e015      	b.n	8002d02 <LDL_MAC_process+0x12a>
            case LDL_STATE_RECOVERY_RESET:
                self->state = LDL_STATE_RECOVERY_LOCKOUT;
 8002cd6:	687b      	ldr	r3, [r7, #4]
 8002cd8:	2204      	movs	r2, #4
 8002cda:	701a      	strb	r2, [r3, #0]
                /* 60s */
                LDL_MAC_timerSet(self, LDL_TIMER_WAITA, (LDL_System_tps() + LDL_System_eps()) * 60UL);
 8002cdc:	f007 f903 	bl	8009ee6 <LDL_System_tps>
 8002ce0:	0004      	movs	r4, r0
 8002ce2:	f007 f907 	bl	8009ef4 <LDL_System_eps>
 8002ce6:	0003      	movs	r3, r0
 8002ce8:	18e2      	adds	r2, r4, r3
 8002cea:	0013      	movs	r3, r2
 8002cec:	011b      	lsls	r3, r3, #4
 8002cee:	1a9b      	subs	r3, r3, r2
 8002cf0:	009b      	lsls	r3, r3, #2
 8002cf2:	001a      	movs	r2, r3
 8002cf4:	687b      	ldr	r3, [r7, #4]
 8002cf6:	2100      	movs	r1, #0
 8002cf8:	0018      	movs	r0, r3
 8002cfa:	f001 f89f 	bl	8003e3c <LDL_MAC_timerSet>
                break;
 8002cfe:	e000      	b.n	8002d02 <LDL_MAC_process+0x12a>
            }            
        }    
 8002d00:	46c0      	nop			; (mov r8, r8)
        break;
 8002d02:	f000 ffa7 	bl	8003c54 <LDL_MAC_process+0x107c>
        
    case LDL_STATE_INIT_LOCKOUT:
    case LDL_STATE_RECOVERY_LOCKOUT:
    
        if(LDL_MAC_timerCheck(self, LDL_TIMER_WAITA, &error)){
 8002d06:	23c2      	movs	r3, #194	; 0xc2
 8002d08:	005b      	lsls	r3, r3, #1
 8002d0a:	18fa      	adds	r2, r7, r3
 8002d0c:	687b      	ldr	r3, [r7, #4]
 8002d0e:	2100      	movs	r1, #0
 8002d10:	0018      	movs	r0, r3
 8002d12:	f001 f8c9 	bl	8003ea8 <LDL_MAC_timerCheck>
 8002d16:	1e03      	subs	r3, r0, #0
 8002d18:	d101      	bne.n	8002d1e <LDL_MAC_process+0x146>
 8002d1a:	f000 ff8a 	bl	8003c32 <LDL_MAC_process+0x105a>
            
            self->op = LDL_OP_RESET;
 8002d1e:	687b      	ldr	r3, [r7, #4]
 8002d20:	2205      	movs	r2, #5
 8002d22:	705a      	strb	r2, [r3, #1]
            self->state = LDL_STATE_ENTROPY;
 8002d24:	687b      	ldr	r3, [r7, #4]
 8002d26:	2205      	movs	r2, #5
 8002d28:	701a      	strb	r2, [r3, #0]
            
            LDL_Radio_entropyBegin(self->radio);                 
 8002d2a:	687a      	ldr	r2, [r7, #4]
 8002d2c:	2388      	movs	r3, #136	; 0x88
 8002d2e:	009b      	lsls	r3, r3, #2
 8002d30:	58d3      	ldr	r3, [r2, r3]
 8002d32:	0018      	movs	r0, r3
 8002d34:	f005 fa2c 	bl	8008190 <LDL_Radio_entropyBegin>
            
            /* 100us */
            LDL_MAC_timerSet(self, LDL_TIMER_WAITA, ((LDL_System_tps() + LDL_System_eps())/10000UL) + 1UL);
 8002d38:	f007 f8d5 	bl	8009ee6 <LDL_System_tps>
 8002d3c:	0004      	movs	r4, r0
 8002d3e:	f007 f8d9 	bl	8009ef4 <LDL_System_eps>
 8002d42:	0003      	movs	r3, r0
 8002d44:	18e3      	adds	r3, r4, r3
 8002d46:	497e      	ldr	r1, [pc, #504]	; (8002f40 <LDL_MAC_process+0x368>)
 8002d48:	0018      	movs	r0, r3
 8002d4a:	f7fd f9dd 	bl	8000108 <__udivsi3>
 8002d4e:	0003      	movs	r3, r0
 8002d50:	1c5a      	adds	r2, r3, #1
 8002d52:	687b      	ldr	r3, [r7, #4]
 8002d54:	2100      	movs	r1, #0
 8002d56:	0018      	movs	r0, r3
 8002d58:	f001 f870 	bl	8003e3c <LDL_MAC_timerSet>
        }
        break;
 8002d5c:	f000 ff69 	bl	8003c32 <LDL_MAC_process+0x105a>
            
    case LDL_STATE_ENTROPY:
    
        if(LDL_MAC_timerCheck(self, LDL_TIMER_WAITA, &error)){
 8002d60:	23c2      	movs	r3, #194	; 0xc2
 8002d62:	005b      	lsls	r3, r3, #1
 8002d64:	18fa      	adds	r2, r7, r3
 8002d66:	687b      	ldr	r3, [r7, #4]
 8002d68:	2100      	movs	r1, #0
 8002d6a:	0018      	movs	r0, r3
 8002d6c:	f001 f89c 	bl	8003ea8 <LDL_MAC_timerCheck>
 8002d70:	1e03      	subs	r3, r0, #0
 8002d72:	d101      	bne.n	8002d78 <LDL_MAC_process+0x1a0>
 8002d74:	f000 ff5f 	bl	8003c36 <LDL_MAC_process+0x105e>
    
            self->op = LDL_OP_RESET;
 8002d78:	687b      	ldr	r3, [r7, #4]
 8002d7a:	2205      	movs	r2, #5
 8002d7c:	705a      	strb	r2, [r3, #1]
            
            arg.startup.entropy = LDL_Radio_entropyEnd(self->radio);                    
 8002d7e:	687a      	ldr	r2, [r7, #4]
 8002d80:	2388      	movs	r3, #136	; 0x88
 8002d82:	009b      	lsls	r3, r3, #2
 8002d84:	58d3      	ldr	r3, [r2, r3]
 8002d86:	0018      	movs	r0, r3
 8002d88:	f005 fa34 	bl	80081f4 <LDL_Radio_entropyEnd>
 8002d8c:	0002      	movs	r2, r0
 8002d8e:	24ba      	movs	r4, #186	; 0xba
 8002d90:	0064      	lsls	r4, r4, #1
 8002d92:	193b      	adds	r3, r7, r4
 8002d94:	601a      	str	r2, [r3, #0]
                
            self->state = LDL_STATE_IDLE;
 8002d96:	687b      	ldr	r3, [r7, #4]
 8002d98:	2206      	movs	r2, #6
 8002d9a:	701a      	strb	r2, [r3, #0]
            self->op = LDL_OP_NONE;
 8002d9c:	687b      	ldr	r3, [r7, #4]
 8002d9e:	2200      	movs	r2, #0
 8002da0:	705a      	strb	r2, [r3, #1]
            
#ifndef LDL_DISABLE_MAC_STARTUP_EVENT            
            self->handler(self->app, LDL_MAC_STARTUP, &arg);        
 8002da2:	687a      	ldr	r2, [r7, #4]
 8002da4:	2392      	movs	r3, #146	; 0x92
 8002da6:	009b      	lsls	r3, r3, #2
 8002da8:	58d3      	ldr	r3, [r2, r3]
 8002daa:	6879      	ldr	r1, [r7, #4]
 8002dac:	2293      	movs	r2, #147	; 0x93
 8002dae:	0092      	lsls	r2, r2, #2
 8002db0:	5888      	ldr	r0, [r1, r2]
 8002db2:	193a      	adds	r2, r7, r4
 8002db4:	2102      	movs	r1, #2
 8002db6:	4798      	blx	r3
#endif                                
        }
        break;
 8002db8:	f000 ff3d 	bl	8003c36 <LDL_MAC_process+0x105e>
    
    case LDL_STATE_WAIT_TX:
    
        if(LDL_MAC_timerCheck(self, LDL_TIMER_WAITA, &error)){
 8002dbc:	23c2      	movs	r3, #194	; 0xc2
 8002dbe:	005b      	lsls	r3, r3, #1
 8002dc0:	18fa      	adds	r2, r7, r3
 8002dc2:	687b      	ldr	r3, [r7, #4]
 8002dc4:	2100      	movs	r1, #0
 8002dc6:	0018      	movs	r0, r3
 8002dc8:	f001 f86e 	bl	8003ea8 <LDL_MAC_timerCheck>
 8002dcc:	1e03      	subs	r3, r0, #0
 8002dce:	d101      	bne.n	8002dd4 <LDL_MAC_process+0x1fc>
 8002dd0:	f000 ff33 	bl	8003c3a <LDL_MAC_process+0x1062>
            
            struct ldl_radio_tx_setting radio_setting;
            uint32_t tx_time;
            uint8_t mtu;
            
            LDL_Region_convertRate(self->region, self->tx.rate, &radio_setting.sf, &radio_setting.bw, &mtu);
 8002dd4:	687a      	ldr	r2, [r7, #4]
 8002dd6:	2391      	movs	r3, #145	; 0x91
 8002dd8:	009b      	lsls	r3, r3, #2
 8002dda:	5cd0      	ldrb	r0, [r2, r3]
 8002ddc:	687a      	ldr	r2, [r7, #4]
 8002dde:	234e      	movs	r3, #78	; 0x4e
 8002de0:	33ff      	adds	r3, #255	; 0xff
 8002de2:	5cd1      	ldrb	r1, [r2, r3]
 8002de4:	25b6      	movs	r5, #182	; 0xb6
 8002de6:	006d      	lsls	r5, r5, #1
 8002de8:	197b      	adds	r3, r7, r5
 8002dea:	1d1c      	adds	r4, r3, #4
 8002dec:	197b      	adds	r3, r7, r5
 8002dee:	1d5a      	adds	r2, r3, #5
 8002df0:	236c      	movs	r3, #108	; 0x6c
 8002df2:	33ff      	adds	r3, #255	; 0xff
 8002df4:	18fb      	adds	r3, r7, r3
 8002df6:	9300      	str	r3, [sp, #0]
 8002df8:	0023      	movs	r3, r4
 8002dfa:	f005 fdab 	bl	8008954 <LDL_Region_convertRate>
            
            radio_setting.dbm = LDL_Region_getTXPower(self->region, self->tx.power) + self->gain;
 8002dfe:	687a      	ldr	r2, [r7, #4]
 8002e00:	2391      	movs	r3, #145	; 0x91
 8002e02:	009b      	lsls	r3, r3, #2
 8002e04:	5cd0      	ldrb	r0, [r2, r3]
 8002e06:	687a      	ldr	r2, [r7, #4]
 8002e08:	23a7      	movs	r3, #167	; 0xa7
 8002e0a:	005b      	lsls	r3, r3, #1
 8002e0c:	5cd3      	ldrb	r3, [r2, r3]
 8002e0e:	0019      	movs	r1, r3
 8002e10:	f006 f901 	bl	8009016 <LDL_Region_getTXPower>
 8002e14:	0003      	movs	r3, r0
 8002e16:	b29a      	uxth	r2, r3
 8002e18:	6879      	ldr	r1, [r7, #4]
 8002e1a:	239b      	movs	r3, #155	; 0x9b
 8002e1c:	009b      	lsls	r3, r3, #2
 8002e1e:	5ecb      	ldrsh	r3, [r1, r3]
 8002e20:	b29b      	uxth	r3, r3
 8002e22:	18d3      	adds	r3, r2, r3
 8002e24:	b29b      	uxth	r3, r3
 8002e26:	b21a      	sxth	r2, r3
 8002e28:	197b      	adds	r3, r7, r5
 8002e2a:	80da      	strh	r2, [r3, #6]
            
            radio_setting.freq = self->tx.freq;
 8002e2c:	687a      	ldr	r2, [r7, #4]
 8002e2e:	23a2      	movs	r3, #162	; 0xa2
 8002e30:	005b      	lsls	r3, r3, #1
 8002e32:	58d2      	ldr	r2, [r2, r3]
 8002e34:	197b      	adds	r3, r7, r5
 8002e36:	601a      	str	r2, [r3, #0]
            
            tx_time = transmitTime(radio_setting.bw, radio_setting.sf, self->bufferLen, true);
 8002e38:	197b      	adds	r3, r7, r5
 8002e3a:	7918      	ldrb	r0, [r3, #4]
 8002e3c:	197b      	adds	r3, r7, r5
 8002e3e:	7959      	ldrb	r1, [r3, #5]
 8002e40:	687a      	ldr	r2, [r7, #4]
 8002e42:	2389      	movs	r3, #137	; 0x89
 8002e44:	005b      	lsls	r3, r3, #1
 8002e46:	5cd2      	ldrb	r2, [r2, r3]
 8002e48:	2301      	movs	r3, #1
 8002e4a:	f001 fe61 	bl	8004b10 <transmitTime>
 8002e4e:	0003      	movs	r3, r0
 8002e50:	26c6      	movs	r6, #198	; 0xc6
 8002e52:	0076      	lsls	r6, r6, #1
 8002e54:	19ba      	adds	r2, r7, r6
 8002e56:	6013      	str	r3, [r2, #0]
            
            LDL_MAC_inputClear(self);  
 8002e58:	687b      	ldr	r3, [r7, #4]
 8002e5a:	0018      	movs	r0, r3
 8002e5c:	f001 f944 	bl	80040e8 <LDL_MAC_inputClear>
            LDL_MAC_inputArm(self, LDL_INPUT_TX_COMPLETE);  
 8002e60:	687b      	ldr	r3, [r7, #4]
 8002e62:	2100      	movs	r1, #0
 8002e64:	0018      	movs	r0, r3
 8002e66:	f001 f8d5 	bl	8004014 <LDL_MAC_inputArm>
            
            LDL_Radio_transmit(self->radio, &radio_setting, self->buffer, self->bufferLen);
 8002e6a:	687a      	ldr	r2, [r7, #4]
 8002e6c:	2388      	movs	r3, #136	; 0x88
 8002e6e:	009b      	lsls	r3, r3, #2
 8002e70:	58d0      	ldr	r0, [r2, r3]
 8002e72:	687b      	ldr	r3, [r7, #4]
 8002e74:	3313      	adds	r3, #19
 8002e76:	001c      	movs	r4, r3
 8002e78:	687a      	ldr	r2, [r7, #4]
 8002e7a:	2389      	movs	r3, #137	; 0x89
 8002e7c:	005b      	lsls	r3, r3, #1
 8002e7e:	5cd3      	ldrb	r3, [r2, r3]
 8002e80:	1979      	adds	r1, r7, r5
 8002e82:	0022      	movs	r2, r4
 8002e84:	f005 f840 	bl	8007f08 <LDL_Radio_transmit>

            registerTime(self, self->tx.freq, tx_time);
 8002e88:	687a      	ldr	r2, [r7, #4]
 8002e8a:	23a2      	movs	r3, #162	; 0xa2
 8002e8c:	005b      	lsls	r3, r3, #1
 8002e8e:	58d1      	ldr	r1, [r2, r3]
 8002e90:	19bb      	adds	r3, r7, r6
 8002e92:	681a      	ldr	r2, [r3, #0]
 8002e94:	687b      	ldr	r3, [r7, #4]
 8002e96:	0018      	movs	r0, r3
 8002e98:	f002 fc76 	bl	8005788 <registerTime>
            
            self->state = LDL_STATE_TX;
 8002e9c:	687b      	ldr	r3, [r7, #4]
 8002e9e:	2208      	movs	r2, #8
 8002ea0:	701a      	strb	r2, [r3, #0]
            
            LDL_PEDANTIC((tx_time & 0x80000000UL) != 0x80000000UL)
            
            /* reset the radio if the tx complete interrupt doesn't appear after double the expected time */      
            LDL_MAC_timerSet(self, LDL_TIMER_WAITA, tx_time << 1UL);    
 8002ea2:	19bb      	adds	r3, r7, r6
 8002ea4:	681b      	ldr	r3, [r3, #0]
 8002ea6:	005a      	lsls	r2, r3, #1
 8002ea8:	687b      	ldr	r3, [r7, #4]
 8002eaa:	2100      	movs	r1, #0
 8002eac:	0018      	movs	r0, r3
 8002eae:	f000 ffc5 	bl	8003e3c <LDL_MAC_timerSet>
            
#ifndef LDL_DISABLE_TX_BEGIN_EVENT            
            arg.tx_begin.freq = self->tx.freq;
 8002eb2:	687a      	ldr	r2, [r7, #4]
 8002eb4:	23a2      	movs	r3, #162	; 0xa2
 8002eb6:	005b      	lsls	r3, r3, #1
 8002eb8:	58d2      	ldr	r2, [r2, r3]
 8002eba:	24ba      	movs	r4, #186	; 0xba
 8002ebc:	0064      	lsls	r4, r4, #1
 8002ebe:	193b      	adds	r3, r7, r4
 8002ec0:	601a      	str	r2, [r3, #0]
            arg.tx_begin.power = self->tx.power;
 8002ec2:	687a      	ldr	r2, [r7, #4]
 8002ec4:	23a7      	movs	r3, #167	; 0xa7
 8002ec6:	005b      	lsls	r3, r3, #1
 8002ec8:	5cd2      	ldrb	r2, [r2, r3]
 8002eca:	193b      	adds	r3, r7, r4
 8002ecc:	719a      	strb	r2, [r3, #6]
            arg.tx_begin.sf = radio_setting.sf;
 8002ece:	197b      	adds	r3, r7, r5
 8002ed0:	795a      	ldrb	r2, [r3, #5]
 8002ed2:	193b      	adds	r3, r7, r4
 8002ed4:	711a      	strb	r2, [r3, #4]
            arg.tx_begin.bw = radio_setting.bw;
 8002ed6:	197b      	adds	r3, r7, r5
 8002ed8:	791a      	ldrb	r2, [r3, #4]
 8002eda:	193b      	adds	r3, r7, r4
 8002edc:	715a      	strb	r2, [r3, #5]
            arg.tx_begin.size = self->bufferLen;
 8002ede:	687a      	ldr	r2, [r7, #4]
 8002ee0:	2389      	movs	r3, #137	; 0x89
 8002ee2:	005b      	lsls	r3, r3, #1
 8002ee4:	5cd2      	ldrb	r2, [r2, r3]
 8002ee6:	193b      	adds	r3, r7, r4
 8002ee8:	71da      	strb	r2, [r3, #7]
            
            self->handler(self->app, LDL_MAC_TX_BEGIN, &arg);
 8002eea:	687a      	ldr	r2, [r7, #4]
 8002eec:	2392      	movs	r3, #146	; 0x92
 8002eee:	009b      	lsls	r3, r3, #2
 8002ef0:	58d3      	ldr	r3, [r2, r3]
 8002ef2:	6879      	ldr	r1, [r7, #4]
 8002ef4:	2293      	movs	r2, #147	; 0x93
 8002ef6:	0092      	lsls	r2, r2, #2
 8002ef8:	5888      	ldr	r0, [r1, r2]
 8002efa:	193a      	adds	r2, r7, r4
 8002efc:	210e      	movs	r1, #14
 8002efe:	4798      	blx	r3
#endif            
        }
        break;
 8002f00:	f000 fe9b 	bl	8003c3a <LDL_MAC_process+0x1062>
        
    case LDL_STATE_TX:
    
        if(LDL_MAC_inputCheck(self, LDL_INPUT_TX_COMPLETE, &error)){
 8002f04:	23c2      	movs	r3, #194	; 0xc2
 8002f06:	005b      	lsls	r3, r3, #1
 8002f08:	18fa      	adds	r2, r7, r3
 8002f0a:	687b      	ldr	r3, [r7, #4]
 8002f0c:	2100      	movs	r1, #0
 8002f0e:	0018      	movs	r0, r3
 8002f10:	f001 f8a6 	bl	8004060 <LDL_MAC_inputCheck>
 8002f14:	1e03      	subs	r3, r0, #0
 8002f16:	d100      	bne.n	8002f1a <LDL_MAC_process+0x342>
 8002f18:	e186      	b.n	8003228 <LDL_MAC_process+0x650>
        
            LDL_MAC_inputClear(self);
 8002f1a:	687b      	ldr	r3, [r7, #4]
 8002f1c:	0018      	movs	r0, r3
 8002f1e:	f001 f8e3 	bl	80040e8 <LDL_MAC_inputClear>
            uint8_t extra_symbols;
            uint32_t xtal_error;
            uint8_t mtu;
            
            /* the wait interval is always measured in whole seconds */
            waitSeconds = (self->op == LDL_OP_JOINING) ? LDL_Region_getJA1Delay(self->region) : self->ctx.rx1Delay;    
 8002f22:	687b      	ldr	r3, [r7, #4]
 8002f24:	785b      	ldrb	r3, [r3, #1]
 8002f26:	2b01      	cmp	r3, #1
 8002f28:	d10c      	bne.n	8002f44 <LDL_MAC_process+0x36c>
 8002f2a:	687a      	ldr	r2, [r7, #4]
 8002f2c:	2391      	movs	r3, #145	; 0x91
 8002f2e:	009b      	lsls	r3, r3, #2
 8002f30:	5cd3      	ldrb	r3, [r2, r3]
 8002f32:	0018      	movs	r0, r3
 8002f34:	f006 f815 	bl	8008f62 <LDL_Region_getJA1Delay>
 8002f38:	0003      	movs	r3, r0
 8002f3a:	e007      	b.n	8002f4c <LDL_MAC_process+0x374>
 8002f3c:	0800e4a8 	.word	0x0800e4a8
 8002f40:	00002710 	.word	0x00002710
 8002f44:	687a      	ldr	r2, [r7, #4]
 8002f46:	23fd      	movs	r3, #253	; 0xfd
 8002f48:	005b      	lsls	r3, r3, #1
 8002f4a:	5cd3      	ldrb	r3, [r2, r3]
 8002f4c:	25d4      	movs	r5, #212	; 0xd4
 8002f4e:	006d      	lsls	r5, r5, #1
 8002f50:	197a      	adds	r2, r7, r5
 8002f52:	6013      	str	r3, [r2, #0]
            
            /* add xtal error to ensure the fastest clock will not open before the earliest start time */
            waitTicks = (waitSeconds * LDL_System_tps()) + (waitSeconds * LDL_System_eps());
 8002f54:	f006 ffc7 	bl	8009ee6 <LDL_System_tps>
 8002f58:	0004      	movs	r4, r0
 8002f5a:	f006 ffcb 	bl	8009ef4 <LDL_System_eps>
 8002f5e:	0003      	movs	r3, r0
 8002f60:	18e2      	adds	r2, r4, r3
 8002f62:	1979      	adds	r1, r7, r5
 8002f64:	680b      	ldr	r3, [r1, #0]
 8002f66:	4353      	muls	r3, r2
 8002f68:	22d2      	movs	r2, #210	; 0xd2
 8002f6a:	0052      	lsls	r2, r2, #1
 8002f6c:	18b9      	adds	r1, r7, r2
 8002f6e:	600b      	str	r3, [r1, #0]
             * 
             * - LDL_System_advance(): interrupt response time + radio RX ramp up
             * - error: ticks since tx complete event
             * 
             * */
            advance = LDL_System_advance() + error;    
 8002f70:	f006 fcf8 	bl	8009964 <LDL_System_advance>
 8002f74:	0002      	movs	r2, r0
 8002f76:	21c2      	movs	r1, #194	; 0xc2
 8002f78:	0049      	lsls	r1, r1, #1
 8002f7a:	1879      	adds	r1, r7, r1
 8002f7c:	680b      	ldr	r3, [r1, #0]
 8002f7e:	18d3      	adds	r3, r2, r3
 8002f80:	22d0      	movs	r2, #208	; 0xd0
 8002f82:	0052      	lsls	r2, r2, #1
 8002f84:	18b9      	adds	r1, r7, r2
 8002f86:	600b      	str	r3, [r1, #0]
            
            /* RX1 */
            {
                LDL_Region_getRX1DataRate(self->region, self->tx.rate, self->ctx.rx1DROffset, &rate);
 8002f88:	687a      	ldr	r2, [r7, #4]
 8002f8a:	2391      	movs	r3, #145	; 0x91
 8002f8c:	009b      	lsls	r3, r3, #2
 8002f8e:	5cd0      	ldrb	r0, [r2, r3]
 8002f90:	687a      	ldr	r2, [r7, #4]
 8002f92:	234e      	movs	r3, #78	; 0x4e
 8002f94:	33ff      	adds	r3, #255	; 0xff
 8002f96:	5cd1      	ldrb	r1, [r2, r3]
 8002f98:	687a      	ldr	r2, [r7, #4]
 8002f9a:	23fa      	movs	r3, #250	; 0xfa
 8002f9c:	33ff      	adds	r3, #255	; 0xff
 8002f9e:	5cd2      	ldrb	r2, [r2, r3]
 8002fa0:	26b4      	movs	r6, #180	; 0xb4
 8002fa2:	0076      	lsls	r6, r6, #1
 8002fa4:	19bb      	adds	r3, r7, r6
 8002fa6:	f005 ff61 	bl	8008e6c <LDL_Region_getRX1DataRate>
                LDL_Region_convertRate(self->region, rate, &sf, &bw, &mtu);
 8002faa:	687a      	ldr	r2, [r7, #4]
 8002fac:	2391      	movs	r3, #145	; 0x91
 8002fae:	009b      	lsls	r3, r3, #2
 8002fb0:	5cd0      	ldrb	r0, [r2, r3]
 8002fb2:	19bb      	adds	r3, r7, r6
 8002fb4:	7819      	ldrb	r1, [r3, #0]
 8002fb6:	256a      	movs	r5, #106	; 0x6a
 8002fb8:	35ff      	adds	r5, #255	; 0xff
 8002fba:	197c      	adds	r4, r7, r5
 8002fbc:	26b5      	movs	r6, #181	; 0xb5
 8002fbe:	0076      	lsls	r6, r6, #1
 8002fc0:	19ba      	adds	r2, r7, r6
 8002fc2:	2368      	movs	r3, #104	; 0x68
 8002fc4:	33ff      	adds	r3, #255	; 0xff
 8002fc6:	18fb      	adds	r3, r7, r3
 8002fc8:	9300      	str	r3, [sp, #0]
 8002fca:	0023      	movs	r3, r4
 8002fcc:	f005 fcc2 	bl	8008954 <LDL_Region_convertRate>
                
                xtal_error = (waitSeconds * LDL_System_eps() * 2U);
 8002fd0:	f006 ff90 	bl	8009ef4 <LDL_System_eps>
 8002fd4:	0002      	movs	r2, r0
 8002fd6:	23d4      	movs	r3, #212	; 0xd4
 8002fd8:	005b      	lsls	r3, r3, #1
 8002fda:	18f9      	adds	r1, r7, r3
 8002fdc:	680b      	ldr	r3, [r1, #0]
 8002fde:	4353      	muls	r3, r2
 8002fe0:	005b      	lsls	r3, r3, #1
 8002fe2:	22ce      	movs	r2, #206	; 0xce
 8002fe4:	0052      	lsls	r2, r2, #1
 8002fe6:	18b8      	adds	r0, r7, r2
 8002fe8:	6003      	str	r3, [r0, #0]
                
                extra_symbols = extraSymbols(xtal_error, symbolPeriod(sf, bw));
 8002fea:	19bb      	adds	r3, r7, r6
 8002fec:	781a      	ldrb	r2, [r3, #0]
 8002fee:	197b      	adds	r3, r7, r5
 8002ff0:	781b      	ldrb	r3, [r3, #0]
 8002ff2:	0019      	movs	r1, r3
 8002ff4:	0010      	movs	r0, r2
 8002ff6:	f001 fe16 	bl	8004c26 <symbolPeriod>
 8002ffa:	0002      	movs	r2, r0
 8002ffc:	209c      	movs	r0, #156	; 0x9c
 8002ffe:	30ff      	adds	r0, #255	; 0xff
 8003000:	183c      	adds	r4, r7, r0
 8003002:	21ce      	movs	r1, #206	; 0xce
 8003004:	0049      	lsls	r1, r1, #1
 8003006:	1879      	adds	r1, r7, r1
 8003008:	680b      	ldr	r3, [r1, #0]
 800300a:	0011      	movs	r1, r2
 800300c:	0018      	movs	r0, r3
 800300e:	f001 fe29 	bl	8004c64 <extraSymbols>
 8003012:	0003      	movs	r3, r0
 8003014:	7023      	strb	r3, [r4, #0]
                
                self->rx1_margin = (((3U + extra_symbols) * symbolPeriod(sf, bw)));
 8003016:	209c      	movs	r0, #156	; 0x9c
 8003018:	30ff      	adds	r0, #255	; 0xff
 800301a:	183b      	adds	r3, r7, r0
 800301c:	781b      	ldrb	r3, [r3, #0]
 800301e:	1cdc      	adds	r4, r3, #3
 8003020:	19bb      	adds	r3, r7, r6
 8003022:	781a      	ldrb	r2, [r3, #0]
 8003024:	197b      	adds	r3, r7, r5
 8003026:	781b      	ldrb	r3, [r3, #0]
 8003028:	0019      	movs	r1, r3
 800302a:	0010      	movs	r0, r2
 800302c:	f001 fdfb 	bl	8004c26 <symbolPeriod>
 8003030:	0003      	movs	r3, r0
 8003032:	0019      	movs	r1, r3
 8003034:	4361      	muls	r1, r4
 8003036:	687a      	ldr	r2, [r7, #4]
 8003038:	23a8      	movs	r3, #168	; 0xa8
 800303a:	005b      	lsls	r3, r3, #1
 800303c:	50d1      	str	r1, [r2, r3]
                self->rx1_symbols = 8U + extra_symbols;
 800303e:	209c      	movs	r0, #156	; 0x9c
 8003040:	30ff      	adds	r0, #255	; 0xff
 8003042:	183b      	adds	r3, r7, r0
 8003044:	781b      	ldrb	r3, [r3, #0]
 8003046:	3308      	adds	r3, #8
 8003048:	b2d9      	uxtb	r1, r3
 800304a:	687a      	ldr	r2, [r7, #4]
 800304c:	23ac      	movs	r3, #172	; 0xac
 800304e:	005b      	lsls	r3, r3, #1
 8003050:	54d1      	strb	r1, [r2, r3]
            
                /* advance timer by time required for extra symbols */
                advanceA = advance + (extra_symbols * symbolPeriod(sf, bw));
 8003052:	183b      	adds	r3, r7, r0
 8003054:	781c      	ldrb	r4, [r3, #0]
 8003056:	19bb      	adds	r3, r7, r6
 8003058:	781a      	ldrb	r2, [r3, #0]
 800305a:	197b      	adds	r3, r7, r5
 800305c:	781b      	ldrb	r3, [r3, #0]
 800305e:	0019      	movs	r1, r3
 8003060:	0010      	movs	r0, r2
 8003062:	f001 fde0 	bl	8004c26 <symbolPeriod>
 8003066:	0003      	movs	r3, r0
 8003068:	4363      	muls	r3, r4
 800306a:	24d0      	movs	r4, #208	; 0xd0
 800306c:	0064      	lsls	r4, r4, #1
 800306e:	1939      	adds	r1, r7, r4
 8003070:	680a      	ldr	r2, [r1, #0]
 8003072:	18d3      	adds	r3, r2, r3
 8003074:	21ca      	movs	r1, #202	; 0xca
 8003076:	0049      	lsls	r1, r1, #1
 8003078:	1879      	adds	r1, r7, r1
 800307a:	600b      	str	r3, [r1, #0]
            }
            
            /* RX2 */
            {
                LDL_Region_convertRate(self->region, self->ctx.rx2Rate, &sf, &bw, &mtu);
 800307c:	687a      	ldr	r2, [r7, #4]
 800307e:	2391      	movs	r3, #145	; 0x91
 8003080:	009b      	lsls	r3, r3, #2
 8003082:	5cd0      	ldrb	r0, [r2, r3]
 8003084:	687a      	ldr	r2, [r7, #4]
 8003086:	23fe      	movs	r3, #254	; 0xfe
 8003088:	005b      	lsls	r3, r3, #1
 800308a:	5cd1      	ldrb	r1, [r2, r3]
 800308c:	197c      	adds	r4, r7, r5
 800308e:	19ba      	adds	r2, r7, r6
 8003090:	2368      	movs	r3, #104	; 0x68
 8003092:	33ff      	adds	r3, #255	; 0xff
 8003094:	18fb      	adds	r3, r7, r3
 8003096:	9300      	str	r3, [sp, #0]
 8003098:	0023      	movs	r3, r4
 800309a:	f005 fc5b 	bl	8008954 <LDL_Region_convertRate>
                
                xtal_error = ((waitSeconds + 1UL) * LDL_System_eps() * 2UL);
 800309e:	23d4      	movs	r3, #212	; 0xd4
 80030a0:	005b      	lsls	r3, r3, #1
 80030a2:	18fb      	adds	r3, r7, r3
 80030a4:	681b      	ldr	r3, [r3, #0]
 80030a6:	1c5c      	adds	r4, r3, #1
 80030a8:	f006 ff24 	bl	8009ef4 <LDL_System_eps>
 80030ac:	0003      	movs	r3, r0
 80030ae:	4363      	muls	r3, r4
 80030b0:	005b      	lsls	r3, r3, #1
 80030b2:	22ce      	movs	r2, #206	; 0xce
 80030b4:	0052      	lsls	r2, r2, #1
 80030b6:	18bc      	adds	r4, r7, r2
 80030b8:	6023      	str	r3, [r4, #0]
                
                extra_symbols = extraSymbols(xtal_error, symbolPeriod(sf, bw));
 80030ba:	19bb      	adds	r3, r7, r6
 80030bc:	781a      	ldrb	r2, [r3, #0]
 80030be:	197b      	adds	r3, r7, r5
 80030c0:	781b      	ldrb	r3, [r3, #0]
 80030c2:	0019      	movs	r1, r3
 80030c4:	0010      	movs	r0, r2
 80030c6:	f001 fdae 	bl	8004c26 <symbolPeriod>
 80030ca:	0002      	movs	r2, r0
 80030cc:	209c      	movs	r0, #156	; 0x9c
 80030ce:	30ff      	adds	r0, #255	; 0xff
 80030d0:	183c      	adds	r4, r7, r0
 80030d2:	21ce      	movs	r1, #206	; 0xce
 80030d4:	0049      	lsls	r1, r1, #1
 80030d6:	1879      	adds	r1, r7, r1
 80030d8:	680b      	ldr	r3, [r1, #0]
 80030da:	0011      	movs	r1, r2
 80030dc:	0018      	movs	r0, r3
 80030de:	f001 fdc1 	bl	8004c64 <extraSymbols>
 80030e2:	0003      	movs	r3, r0
 80030e4:	7023      	strb	r3, [r4, #0]
                
                self->rx2_margin = (((3U + extra_symbols) * symbolPeriod(sf, bw)));
 80030e6:	209c      	movs	r0, #156	; 0x9c
 80030e8:	30ff      	adds	r0, #255	; 0xff
 80030ea:	183b      	adds	r3, r7, r0
 80030ec:	781b      	ldrb	r3, [r3, #0]
 80030ee:	1cdc      	adds	r4, r3, #3
 80030f0:	19bb      	adds	r3, r7, r6
 80030f2:	781a      	ldrb	r2, [r3, #0]
 80030f4:	197b      	adds	r3, r7, r5
 80030f6:	781b      	ldrb	r3, [r3, #0]
 80030f8:	0019      	movs	r1, r3
 80030fa:	0010      	movs	r0, r2
 80030fc:	f001 fd93 	bl	8004c26 <symbolPeriod>
 8003100:	0003      	movs	r3, r0
 8003102:	0019      	movs	r1, r3
 8003104:	4361      	muls	r1, r4
 8003106:	687a      	ldr	r2, [r7, #4]
 8003108:	23aa      	movs	r3, #170	; 0xaa
 800310a:	005b      	lsls	r3, r3, #1
 800310c:	50d1      	str	r1, [r2, r3]
                self->rx2_symbols = 8U + extra_symbols;
 800310e:	209c      	movs	r0, #156	; 0x9c
 8003110:	30ff      	adds	r0, #255	; 0xff
 8003112:	183b      	adds	r3, r7, r0
 8003114:	781b      	ldrb	r3, [r3, #0]
 8003116:	3308      	adds	r3, #8
 8003118:	b2d9      	uxtb	r1, r3
 800311a:	687a      	ldr	r2, [r7, #4]
 800311c:	235a      	movs	r3, #90	; 0x5a
 800311e:	33ff      	adds	r3, #255	; 0xff
 8003120:	54d1      	strb	r1, [r2, r3]
                
                /* advance timer by time required for extra symbols */
                advanceB = advance + (extra_symbols * symbolPeriod(sf, bw));
 8003122:	183b      	adds	r3, r7, r0
 8003124:	781c      	ldrb	r4, [r3, #0]
 8003126:	19bb      	adds	r3, r7, r6
 8003128:	781a      	ldrb	r2, [r3, #0]
 800312a:	197b      	adds	r3, r7, r5
 800312c:	781b      	ldrb	r3, [r3, #0]
 800312e:	0019      	movs	r1, r3
 8003130:	0010      	movs	r0, r2
 8003132:	f001 fd78 	bl	8004c26 <symbolPeriod>
 8003136:	0003      	movs	r3, r0
 8003138:	4363      	muls	r3, r4
 800313a:	22d0      	movs	r2, #208	; 0xd0
 800313c:	0052      	lsls	r2, r2, #1
 800313e:	18b9      	adds	r1, r7, r2
 8003140:	680a      	ldr	r2, [r1, #0]
 8003142:	18d3      	adds	r3, r2, r3
 8003144:	25c8      	movs	r5, #200	; 0xc8
 8003146:	006d      	lsls	r5, r5, #1
 8003148:	1979      	adds	r1, r7, r5
 800314a:	600b      	str	r3, [r1, #0]
            }
                
            if(advanceB <= (waitTicks + (LDL_System_tps() + LDL_System_eps()))){
 800314c:	f006 fecb 	bl	8009ee6 <LDL_System_tps>
 8003150:	0004      	movs	r4, r0
 8003152:	f006 fecf 	bl	8009ef4 <LDL_System_eps>
 8003156:	0003      	movs	r3, r0
 8003158:	18e2      	adds	r2, r4, r3
 800315a:	23d2      	movs	r3, #210	; 0xd2
 800315c:	005b      	lsls	r3, r3, #1
 800315e:	18fb      	adds	r3, r7, r3
 8003160:	681b      	ldr	r3, [r3, #0]
 8003162:	18d3      	adds	r3, r2, r3
 8003164:	197a      	adds	r2, r7, r5
 8003166:	6812      	ldr	r2, [r2, #0]
 8003168:	429a      	cmp	r2, r3
 800316a:	d838      	bhi.n	80031de <LDL_MAC_process+0x606>
                
                LDL_MAC_timerSet(self, LDL_TIMER_WAITB, waitTicks + (LDL_System_tps() + LDL_System_eps()) - advanceB);
 800316c:	f006 febb 	bl	8009ee6 <LDL_System_tps>
 8003170:	0004      	movs	r4, r0
 8003172:	f006 febf 	bl	8009ef4 <LDL_System_eps>
 8003176:	0003      	movs	r3, r0
 8003178:	18e2      	adds	r2, r4, r3
 800317a:	24d2      	movs	r4, #210	; 0xd2
 800317c:	0064      	lsls	r4, r4, #1
 800317e:	193b      	adds	r3, r7, r4
 8003180:	681b      	ldr	r3, [r3, #0]
 8003182:	18d2      	adds	r2, r2, r3
 8003184:	23c8      	movs	r3, #200	; 0xc8
 8003186:	005b      	lsls	r3, r3, #1
 8003188:	18fb      	adds	r3, r7, r3
 800318a:	681b      	ldr	r3, [r3, #0]
 800318c:	1ad2      	subs	r2, r2, r3
 800318e:	687b      	ldr	r3, [r7, #4]
 8003190:	2101      	movs	r1, #1
 8003192:	0018      	movs	r0, r3
 8003194:	f000 fe52 	bl	8003e3c <LDL_MAC_timerSet>
                
                if(advanceA <= waitTicks){
 8003198:	23ca      	movs	r3, #202	; 0xca
 800319a:	005b      	lsls	r3, r3, #1
 800319c:	18fb      	adds	r3, r7, r3
 800319e:	681a      	ldr	r2, [r3, #0]
 80031a0:	193b      	adds	r3, r7, r4
 80031a2:	681b      	ldr	r3, [r3, #0]
 80031a4:	429a      	cmp	r2, r3
 80031a6:	d811      	bhi.n	80031cc <LDL_MAC_process+0x5f4>
                
                    LDL_MAC_timerSet(self, LDL_TIMER_WAITA, waitTicks - advanceA);
 80031a8:	23d2      	movs	r3, #210	; 0xd2
 80031aa:	005b      	lsls	r3, r3, #1
 80031ac:	18fb      	adds	r3, r7, r3
 80031ae:	681a      	ldr	r2, [r3, #0]
 80031b0:	23ca      	movs	r3, #202	; 0xca
 80031b2:	005b      	lsls	r3, r3, #1
 80031b4:	18fb      	adds	r3, r7, r3
 80031b6:	681b      	ldr	r3, [r3, #0]
 80031b8:	1ad2      	subs	r2, r2, r3
 80031ba:	687b      	ldr	r3, [r7, #4]
 80031bc:	2100      	movs	r1, #0
 80031be:	0018      	movs	r0, r3
 80031c0:	f000 fe3c 	bl	8003e3c <LDL_MAC_timerSet>
                    self->state = LDL_STATE_WAIT_RX1;
 80031c4:	687b      	ldr	r3, [r7, #4]
 80031c6:	2209      	movs	r2, #9
 80031c8:	701a      	strb	r2, [r3, #0]
 80031ca:	e019      	b.n	8003200 <LDL_MAC_process+0x628>
                }
                else{
                    
                    LDL_MAC_timerClear(self, LDL_TIMER_WAITA);
 80031cc:	687b      	ldr	r3, [r7, #4]
 80031ce:	2100      	movs	r1, #0
 80031d0:	0018      	movs	r0, r3
 80031d2:	f000 fecd 	bl	8003f70 <LDL_MAC_timerClear>
                    self->state = LDL_STATE_WAIT_RX2;
 80031d6:	687b      	ldr	r3, [r7, #4]
 80031d8:	220b      	movs	r2, #11
 80031da:	701a      	strb	r2, [r3, #0]
 80031dc:	e010      	b.n	8003200 <LDL_MAC_process+0x628>
                }
            }
            else{
                
                self->state = LDL_STATE_WAIT_RX2;
 80031de:	687b      	ldr	r3, [r7, #4]
 80031e0:	220b      	movs	r2, #11
 80031e2:	701a      	strb	r2, [r3, #0]
                LDL_MAC_timerClear(self, LDL_TIMER_WAITA);
 80031e4:	687b      	ldr	r3, [r7, #4]
 80031e6:	2100      	movs	r1, #0
 80031e8:	0018      	movs	r0, r3
 80031ea:	f000 fec1 	bl	8003f70 <LDL_MAC_timerClear>
                LDL_MAC_timerSet(self, LDL_TIMER_WAITB, 0U);
 80031ee:	687b      	ldr	r3, [r7, #4]
 80031f0:	2200      	movs	r2, #0
 80031f2:	2101      	movs	r1, #1
 80031f4:	0018      	movs	r0, r3
 80031f6:	f000 fe21 	bl	8003e3c <LDL_MAC_timerSet>
                self->state = LDL_STATE_WAIT_RX2;                
 80031fa:	687b      	ldr	r3, [r7, #4]
 80031fc:	220b      	movs	r2, #11
 80031fe:	701a      	strb	r2, [r3, #0]
            }    
            
            LDL_Radio_clearInterrupt(self->radio);
 8003200:	687a      	ldr	r2, [r7, #4]
 8003202:	2388      	movs	r3, #136	; 0x88
 8003204:	009b      	lsls	r3, r3, #2
 8003206:	58d3      	ldr	r3, [r2, r3]
 8003208:	0018      	movs	r0, r3
 800320a:	f005 f826 	bl	800825a <LDL_Radio_clearInterrupt>
            
#ifndef LDL_DISABLE_TX_COMPLETE_EVENT            
            self->handler(self->app, LDL_MAC_TX_COMPLETE, NULL);                        
 800320e:	687a      	ldr	r2, [r7, #4]
 8003210:	2392      	movs	r3, #146	; 0x92
 8003212:	009b      	lsls	r3, r3, #2
 8003214:	58d3      	ldr	r3, [r2, r3]
 8003216:	6879      	ldr	r1, [r7, #4]
 8003218:	2293      	movs	r2, #147	; 0x93
 800321a:	0092      	lsls	r2, r2, #2
 800321c:	5888      	ldr	r0, [r1, r2]
 800321e:	2200      	movs	r2, #0
 8003220:	210d      	movs	r1, #13
 8003222:	4798      	blx	r3
                
                /* hold reset for at least 100us */
                LDL_MAC_timerSet(self, LDL_TIMER_WAITA, ((LDL_System_tps() + LDL_System_eps())/10000UL) + 1UL);
            }
        }
        break;
 8003224:	f000 fd0b 	bl	8003c3e <LDL_MAC_process+0x1066>
            if(LDL_MAC_timerCheck(self, LDL_TIMER_WAITA, &error)){
 8003228:	23c2      	movs	r3, #194	; 0xc2
 800322a:	005b      	lsls	r3, r3, #1
 800322c:	18fa      	adds	r2, r7, r3
 800322e:	687b      	ldr	r3, [r7, #4]
 8003230:	2100      	movs	r1, #0
 8003232:	0018      	movs	r0, r3
 8003234:	f000 fe38 	bl	8003ea8 <LDL_MAC_timerCheck>
 8003238:	1e03      	subs	r3, r0, #0
 800323a:	d101      	bne.n	8003240 <LDL_MAC_process+0x668>
 800323c:	f000 fcff 	bl	8003c3e <LDL_MAC_process+0x1066>
                self->handler(self->app, LDL_MAC_CHIP_ERROR, NULL);                
 8003240:	687a      	ldr	r2, [r7, #4]
 8003242:	2392      	movs	r3, #146	; 0x92
 8003244:	009b      	lsls	r3, r3, #2
 8003246:	58d3      	ldr	r3, [r2, r3]
 8003248:	6879      	ldr	r1, [r7, #4]
 800324a:	2293      	movs	r2, #147	; 0x93
 800324c:	0092      	lsls	r2, r2, #2
 800324e:	5888      	ldr	r0, [r1, r2]
 8003250:	2200      	movs	r2, #0
 8003252:	2100      	movs	r1, #0
 8003254:	4798      	blx	r3
                LDL_MAC_inputClear(self);
 8003256:	687b      	ldr	r3, [r7, #4]
 8003258:	0018      	movs	r0, r3
 800325a:	f000 ff45 	bl	80040e8 <LDL_MAC_inputClear>
                self->state = LDL_STATE_RECOVERY_RESET;
 800325e:	687b      	ldr	r3, [r7, #4]
 8003260:	2203      	movs	r2, #3
 8003262:	701a      	strb	r2, [r3, #0]
                self->op = LDL_OP_RESET;
 8003264:	687b      	ldr	r3, [r7, #4]
 8003266:	2205      	movs	r2, #5
 8003268:	705a      	strb	r2, [r3, #1]
                LDL_Radio_reset(self->radio, true);
 800326a:	687a      	ldr	r2, [r7, #4]
 800326c:	2388      	movs	r3, #136	; 0x88
 800326e:	009b      	lsls	r3, r3, #2
 8003270:	58d3      	ldr	r3, [r2, r3]
 8003272:	2101      	movs	r1, #1
 8003274:	0018      	movs	r0, r3
 8003276:	f004 fe34 	bl	8007ee2 <LDL_Radio_reset>
                LDL_MAC_timerSet(self, LDL_TIMER_WAITA, ((LDL_System_tps() + LDL_System_eps())/10000UL) + 1UL);
 800327a:	f006 fe34 	bl	8009ee6 <LDL_System_tps>
 800327e:	0004      	movs	r4, r0
 8003280:	f006 fe38 	bl	8009ef4 <LDL_System_eps>
 8003284:	0003      	movs	r3, r0
 8003286:	18e3      	adds	r3, r4, r3
 8003288:	49c3      	ldr	r1, [pc, #780]	; (8003598 <LDL_MAC_process+0x9c0>)
 800328a:	0018      	movs	r0, r3
 800328c:	f7fc ff3c 	bl	8000108 <__udivsi3>
 8003290:	0003      	movs	r3, r0
 8003292:	1c5a      	adds	r2, r3, #1
 8003294:	687b      	ldr	r3, [r7, #4]
 8003296:	2100      	movs	r1, #0
 8003298:	0018      	movs	r0, r3
 800329a:	f000 fdcf 	bl	8003e3c <LDL_MAC_timerSet>
        break;
 800329e:	f000 fcce 	bl	8003c3e <LDL_MAC_process+0x1066>
        
    case LDL_STATE_WAIT_RX1:
    
        if(LDL_MAC_timerCheck(self, LDL_TIMER_WAITA, &error)){
 80032a2:	23c2      	movs	r3, #194	; 0xc2
 80032a4:	005b      	lsls	r3, r3, #1
 80032a6:	18fa      	adds	r2, r7, r3
 80032a8:	687b      	ldr	r3, [r7, #4]
 80032aa:	2100      	movs	r1, #0
 80032ac:	0018      	movs	r0, r3
 80032ae:	f000 fdfb 	bl	8003ea8 <LDL_MAC_timerCheck>
 80032b2:	1e03      	subs	r3, r0, #0
 80032b4:	d101      	bne.n	80032ba <LDL_MAC_process+0x6e2>
 80032b6:	f000 fcc4 	bl	8003c42 <LDL_MAC_process+0x106a>
    
            struct ldl_radio_rx_setting radio_setting;
            uint32_t freq;    
            uint8_t rate;
            
            LDL_Region_getRX1DataRate(self->region, self->tx.rate, self->ctx.rx1DROffset, &rate);
 80032ba:	687a      	ldr	r2, [r7, #4]
 80032bc:	2391      	movs	r3, #145	; 0x91
 80032be:	009b      	lsls	r3, r3, #2
 80032c0:	5cd0      	ldrb	r0, [r2, r3]
 80032c2:	687a      	ldr	r2, [r7, #4]
 80032c4:	234e      	movs	r3, #78	; 0x4e
 80032c6:	33ff      	adds	r3, #255	; 0xff
 80032c8:	5cd1      	ldrb	r1, [r2, r3]
 80032ca:	687a      	ldr	r2, [r7, #4]
 80032cc:	23fa      	movs	r3, #250	; 0xfa
 80032ce:	33ff      	adds	r3, #255	; 0xff
 80032d0:	5cd2      	ldrb	r2, [r2, r3]
 80032d2:	2454      	movs	r4, #84	; 0x54
 80032d4:	34ff      	adds	r4, #255	; 0xff
 80032d6:	193b      	adds	r3, r7, r4
 80032d8:	f005 fdc8 	bl	8008e6c <LDL_Region_getRX1DataRate>
            LDL_Region_getRX1Freq(self->region, self->tx.freq, self->tx.chIndex, &freq);    
 80032dc:	687a      	ldr	r2, [r7, #4]
 80032de:	2391      	movs	r3, #145	; 0x91
 80032e0:	009b      	lsls	r3, r3, #2
 80032e2:	5cd0      	ldrb	r0, [r2, r3]
 80032e4:	687a      	ldr	r2, [r7, #4]
 80032e6:	23a2      	movs	r3, #162	; 0xa2
 80032e8:	005b      	lsls	r3, r3, #1
 80032ea:	58d1      	ldr	r1, [r2, r3]
 80032ec:	687a      	ldr	r2, [r7, #4]
 80032ee:	23a6      	movs	r3, #166	; 0xa6
 80032f0:	005b      	lsls	r3, r3, #1
 80032f2:	5cd2      	ldrb	r2, [r2, r3]
 80032f4:	23aa      	movs	r3, #170	; 0xaa
 80032f6:	005b      	lsls	r3, r3, #1
 80032f8:	18fb      	adds	r3, r7, r3
 80032fa:	f005 fe11 	bl	8008f20 <LDL_Region_getRX1Freq>
                                    
            LDL_Region_convertRate(self->region, rate, &radio_setting.sf, &radio_setting.bw, &radio_setting.max);
 80032fe:	687a      	ldr	r2, [r7, #4]
 8003300:	2391      	movs	r3, #145	; 0x91
 8003302:	009b      	lsls	r3, r3, #2
 8003304:	5cd0      	ldrb	r0, [r2, r3]
 8003306:	193b      	adds	r3, r7, r4
 8003308:	7819      	ldrb	r1, [r3, #0]
 800330a:	25ac      	movs	r5, #172	; 0xac
 800330c:	006d      	lsls	r5, r5, #1
 800330e:	197b      	adds	r3, r7, r5
 8003310:	3308      	adds	r3, #8
 8003312:	001c      	movs	r4, r3
 8003314:	197b      	adds	r3, r7, r5
 8003316:	3309      	adds	r3, #9
 8003318:	001a      	movs	r2, r3
 800331a:	197b      	adds	r3, r7, r5
 800331c:	330b      	adds	r3, #11
 800331e:	9300      	str	r3, [sp, #0]
 8003320:	0023      	movs	r3, r4
 8003322:	f005 fb17 	bl	8008954 <LDL_Region_convertRate>
            
            radio_setting.max += LDL_Frame_phyOverhead();
 8003326:	f7ff f9f4 	bl	8002712 <LDL_Frame_phyOverhead>
 800332a:	0003      	movs	r3, r0
 800332c:	001a      	movs	r2, r3
 800332e:	197b      	adds	r3, r7, r5
 8003330:	7adb      	ldrb	r3, [r3, #11]
 8003332:	18d3      	adds	r3, r2, r3
 8003334:	b2da      	uxtb	r2, r3
 8003336:	197b      	adds	r3, r7, r5
 8003338:	72da      	strb	r2, [r3, #11]
            
            self->state = LDL_STATE_RX1;
 800333a:	687b      	ldr	r3, [r7, #4]
 800333c:	220a      	movs	r2, #10
 800333e:	701a      	strb	r2, [r3, #0]
            
            if(error <= self->rx1_margin){
 8003340:	687a      	ldr	r2, [r7, #4]
 8003342:	23a8      	movs	r3, #168	; 0xa8
 8003344:	005b      	lsls	r3, r3, #1
 8003346:	58d2      	ldr	r2, [r2, r3]
 8003348:	23c2      	movs	r3, #194	; 0xc2
 800334a:	005b      	lsls	r3, r3, #1
 800334c:	18fb      	adds	r3, r7, r3
 800334e:	681b      	ldr	r3, [r3, #0]
 8003350:	429a      	cmp	r2, r3
 8003352:	d33e      	bcc.n	80033d2 <LDL_MAC_process+0x7fa>
                
                radio_setting.freq = freq;
 8003354:	23aa      	movs	r3, #170	; 0xaa
 8003356:	005b      	lsls	r3, r3, #1
 8003358:	18fb      	adds	r3, r7, r3
 800335a:	681a      	ldr	r2, [r3, #0]
 800335c:	24ac      	movs	r4, #172	; 0xac
 800335e:	0064      	lsls	r4, r4, #1
 8003360:	193b      	adds	r3, r7, r4
 8003362:	605a      	str	r2, [r3, #4]
                radio_setting.timeout = self->rx1_symbols;
 8003364:	687a      	ldr	r2, [r7, #4]
 8003366:	23ac      	movs	r3, #172	; 0xac
 8003368:	005b      	lsls	r3, r3, #1
 800336a:	5cd2      	ldrb	r2, [r2, r3]
 800336c:	193b      	adds	r3, r7, r4
 800336e:	729a      	strb	r2, [r3, #10]
                
                LDL_MAC_inputClear(self);
 8003370:	687b      	ldr	r3, [r7, #4]
 8003372:	0018      	movs	r0, r3
 8003374:	f000 feb8 	bl	80040e8 <LDL_MAC_inputClear>
                LDL_MAC_inputArm(self, LDL_INPUT_RX_READY);
 8003378:	687b      	ldr	r3, [r7, #4]
 800337a:	2101      	movs	r1, #1
 800337c:	0018      	movs	r0, r3
 800337e:	f000 fe49 	bl	8004014 <LDL_MAC_inputArm>
                LDL_MAC_inputArm(self, LDL_INPUT_RX_TIMEOUT);
 8003382:	687b      	ldr	r3, [r7, #4]
 8003384:	2102      	movs	r1, #2
 8003386:	0018      	movs	r0, r3
 8003388:	f000 fe44 	bl	8004014 <LDL_MAC_inputArm>
                
                LDL_Radio_receive(self->radio, &radio_setting);
 800338c:	687a      	ldr	r2, [r7, #4]
 800338e:	2388      	movs	r3, #136	; 0x88
 8003390:	009b      	lsls	r3, r3, #2
 8003392:	58d3      	ldr	r3, [r2, r3]
 8003394:	193a      	adds	r2, r7, r4
 8003396:	0011      	movs	r1, r2
 8003398:	0018      	movs	r0, r3
 800339a:	f004 fe27 	bl	8007fec <LDL_Radio_receive>
                
                /* use waitA as a guard */
                LDL_MAC_timerSet(self, LDL_TIMER_WAITA, (LDL_System_tps()) << 4U);                                
 800339e:	f006 fda2 	bl	8009ee6 <LDL_System_tps>
 80033a2:	0003      	movs	r3, r0
 80033a4:	011a      	lsls	r2, r3, #4
 80033a6:	687b      	ldr	r3, [r7, #4]
 80033a8:	2100      	movs	r1, #0
 80033aa:	0018      	movs	r0, r3
 80033ac:	f000 fd46 	bl	8003e3c <LDL_MAC_timerSet>
            
                self->snr_min = LDL_Radio_minSNR(self->radio, radio_setting.sf);
 80033b0:	687a      	ldr	r2, [r7, #4]
 80033b2:	2388      	movs	r3, #136	; 0x88
 80033b4:	009b      	lsls	r3, r3, #2
 80033b6:	58d2      	ldr	r2, [r2, r3]
 80033b8:	193b      	adds	r3, r7, r4
 80033ba:	7a5b      	ldrb	r3, [r3, #9]
 80033bc:	0019      	movs	r1, r3
 80033be:	0010      	movs	r0, r2
 80033c0:	f004 ff64 	bl	800828c <LDL_Radio_minSNR>
 80033c4:	0003      	movs	r3, r0
 80033c6:	0019      	movs	r1, r3
 80033c8:	687a      	ldr	r2, [r7, #4]
 80033ca:	239e      	movs	r3, #158	; 0x9e
 80033cc:	005b      	lsls	r3, r3, #1
 80033ce:	52d1      	strh	r1, [r2, r3]
 80033d0:	e002      	b.n	80033d8 <LDL_MAC_process+0x800>
            }
            else{
                
                self->state = LDL_STATE_WAIT_RX2;
 80033d2:	687b      	ldr	r3, [r7, #4]
 80033d4:	220b      	movs	r2, #11
 80033d6:	701a      	strb	r2, [r3, #0]
            }
                
#ifndef LDL_DISABLE_SLOT_EVENT                           
            arg.rx_slot.margin = self->rx1_margin;                
 80033d8:	687a      	ldr	r2, [r7, #4]
 80033da:	23a8      	movs	r3, #168	; 0xa8
 80033dc:	005b      	lsls	r3, r3, #1
 80033de:	58d2      	ldr	r2, [r2, r3]
 80033e0:	24ba      	movs	r4, #186	; 0xba
 80033e2:	0064      	lsls	r4, r4, #1
 80033e4:	193b      	adds	r3, r7, r4
 80033e6:	601a      	str	r2, [r3, #0]
            arg.rx_slot.timeout = self->rx1_symbols;                
 80033e8:	687a      	ldr	r2, [r7, #4]
 80033ea:	23ac      	movs	r3, #172	; 0xac
 80033ec:	005b      	lsls	r3, r3, #1
 80033ee:	5cd2      	ldrb	r2, [r2, r3]
 80033f0:	193b      	adds	r3, r7, r4
 80033f2:	739a      	strb	r2, [r3, #14]
            arg.rx_slot.error = error;
 80033f4:	23c2      	movs	r3, #194	; 0xc2
 80033f6:	005b      	lsls	r3, r3, #1
 80033f8:	18fb      	adds	r3, r7, r3
 80033fa:	681a      	ldr	r2, [r3, #0]
 80033fc:	193b      	adds	r3, r7, r4
 80033fe:	605a      	str	r2, [r3, #4]
            arg.rx_slot.freq = freq;
 8003400:	23aa      	movs	r3, #170	; 0xaa
 8003402:	005b      	lsls	r3, r3, #1
 8003404:	18fb      	adds	r3, r7, r3
 8003406:	681a      	ldr	r2, [r3, #0]
 8003408:	193b      	adds	r3, r7, r4
 800340a:	609a      	str	r2, [r3, #8]
            arg.rx_slot.bw = radio_setting.bw;
 800340c:	21ac      	movs	r1, #172	; 0xac
 800340e:	0049      	lsls	r1, r1, #1
 8003410:	187b      	adds	r3, r7, r1
 8003412:	7a1a      	ldrb	r2, [r3, #8]
 8003414:	193b      	adds	r3, r7, r4
 8003416:	731a      	strb	r2, [r3, #12]
            arg.rx_slot.sf = radio_setting.sf;
 8003418:	187b      	adds	r3, r7, r1
 800341a:	7a5a      	ldrb	r2, [r3, #9]
 800341c:	193b      	adds	r3, r7, r4
 800341e:	735a      	strb	r2, [r3, #13]
                            
            self->handler(self->app, LDL_MAC_RX1_SLOT, &arg);                    
 8003420:	687a      	ldr	r2, [r7, #4]
 8003422:	2392      	movs	r3, #146	; 0x92
 8003424:	009b      	lsls	r3, r3, #2
 8003426:	58d3      	ldr	r3, [r2, r3]
 8003428:	6879      	ldr	r1, [r7, #4]
 800342a:	2293      	movs	r2, #147	; 0x93
 800342c:	0092      	lsls	r2, r2, #2
 800342e:	5888      	ldr	r0, [r1, r2]
 8003430:	193a      	adds	r2, r7, r4
 8003432:	210a      	movs	r1, #10
 8003434:	4798      	blx	r3
#endif                
        }
        break;
 8003436:	f000 fc04 	bl	8003c42 <LDL_MAC_process+0x106a>
            
    case LDL_STATE_WAIT_RX2:
    
        if(LDL_MAC_timerCheck(self, LDL_TIMER_WAITB, &error)){
 800343a:	23c2      	movs	r3, #194	; 0xc2
 800343c:	005b      	lsls	r3, r3, #1
 800343e:	18fa      	adds	r2, r7, r3
 8003440:	687b      	ldr	r3, [r7, #4]
 8003442:	2101      	movs	r1, #1
 8003444:	0018      	movs	r0, r3
 8003446:	f000 fd2f 	bl	8003ea8 <LDL_MAC_timerCheck>
 800344a:	1e03      	subs	r3, r0, #0
 800344c:	d101      	bne.n	8003452 <LDL_MAC_process+0x87a>
 800344e:	f000 fbfa 	bl	8003c46 <LDL_MAC_process+0x106e>
            
            struct ldl_radio_rx_setting radio_setting;
            
            LDL_Region_convertRate(self->region, self->ctx.rx2DataRate, &radio_setting.sf, &radio_setting.bw, &radio_setting.max);
 8003452:	687a      	ldr	r2, [r7, #4]
 8003454:	2391      	movs	r3, #145	; 0x91
 8003456:	009b      	lsls	r3, r3, #2
 8003458:	5cd0      	ldrb	r0, [r2, r3]
 800345a:	687a      	ldr	r2, [r7, #4]
 800345c:	23fc      	movs	r3, #252	; 0xfc
 800345e:	33ff      	adds	r3, #255	; 0xff
 8003460:	5cd1      	ldrb	r1, [r2, r3]
 8003462:	25a2      	movs	r5, #162	; 0xa2
 8003464:	006d      	lsls	r5, r5, #1
 8003466:	197b      	adds	r3, r7, r5
 8003468:	3308      	adds	r3, #8
 800346a:	001c      	movs	r4, r3
 800346c:	197b      	adds	r3, r7, r5
 800346e:	3309      	adds	r3, #9
 8003470:	001a      	movs	r2, r3
 8003472:	197b      	adds	r3, r7, r5
 8003474:	330b      	adds	r3, #11
 8003476:	9300      	str	r3, [sp, #0]
 8003478:	0023      	movs	r3, r4
 800347a:	f005 fa6b 	bl	8008954 <LDL_Region_convertRate>
            
            radio_setting.max += LDL_Frame_phyOverhead();
 800347e:	f7ff f948 	bl	8002712 <LDL_Frame_phyOverhead>
 8003482:	0003      	movs	r3, r0
 8003484:	001a      	movs	r2, r3
 8003486:	197b      	adds	r3, r7, r5
 8003488:	7adb      	ldrb	r3, [r3, #11]
 800348a:	18d3      	adds	r3, r2, r3
 800348c:	b2da      	uxtb	r2, r3
 800348e:	197b      	adds	r3, r7, r5
 8003490:	72da      	strb	r2, [r3, #11]
            
            self->state = LDL_STATE_RX2;
 8003492:	687b      	ldr	r3, [r7, #4]
 8003494:	220c      	movs	r2, #12
 8003496:	701a      	strb	r2, [r3, #0]
            
            if(error <= self->rx2_margin){
 8003498:	687a      	ldr	r2, [r7, #4]
 800349a:	23aa      	movs	r3, #170	; 0xaa
 800349c:	005b      	lsls	r3, r3, #1
 800349e:	58d2      	ldr	r2, [r2, r3]
 80034a0:	23c2      	movs	r3, #194	; 0xc2
 80034a2:	005b      	lsls	r3, r3, #1
 80034a4:	18fb      	adds	r3, r7, r3
 80034a6:	681b      	ldr	r3, [r3, #0]
 80034a8:	429a      	cmp	r2, r3
 80034aa:	d33e      	bcc.n	800352a <LDL_MAC_process+0x952>
                
                radio_setting.freq = self->ctx.rx2Freq;
 80034ac:	687a      	ldr	r2, [r7, #4]
 80034ae:	2380      	movs	r3, #128	; 0x80
 80034b0:	009b      	lsls	r3, r3, #2
 80034b2:	58d2      	ldr	r2, [r2, r3]
 80034b4:	24a2      	movs	r4, #162	; 0xa2
 80034b6:	0064      	lsls	r4, r4, #1
 80034b8:	193b      	adds	r3, r7, r4
 80034ba:	605a      	str	r2, [r3, #4]
                radio_setting.timeout = self->rx2_symbols;
 80034bc:	687a      	ldr	r2, [r7, #4]
 80034be:	235a      	movs	r3, #90	; 0x5a
 80034c0:	33ff      	adds	r3, #255	; 0xff
 80034c2:	5cd2      	ldrb	r2, [r2, r3]
 80034c4:	193b      	adds	r3, r7, r4
 80034c6:	729a      	strb	r2, [r3, #10]
                
                LDL_MAC_inputClear(self);
 80034c8:	687b      	ldr	r3, [r7, #4]
 80034ca:	0018      	movs	r0, r3
 80034cc:	f000 fe0c 	bl	80040e8 <LDL_MAC_inputClear>
                LDL_MAC_inputArm(self, LDL_INPUT_RX_READY);
 80034d0:	687b      	ldr	r3, [r7, #4]
 80034d2:	2101      	movs	r1, #1
 80034d4:	0018      	movs	r0, r3
 80034d6:	f000 fd9d 	bl	8004014 <LDL_MAC_inputArm>
                LDL_MAC_inputArm(self, LDL_INPUT_RX_TIMEOUT);
 80034da:	687b      	ldr	r3, [r7, #4]
 80034dc:	2102      	movs	r1, #2
 80034de:	0018      	movs	r0, r3
 80034e0:	f000 fd98 	bl	8004014 <LDL_MAC_inputArm>
                
                LDL_Radio_receive(self->radio, &radio_setting);
 80034e4:	687a      	ldr	r2, [r7, #4]
 80034e6:	2388      	movs	r3, #136	; 0x88
 80034e8:	009b      	lsls	r3, r3, #2
 80034ea:	58d3      	ldr	r3, [r2, r3]
 80034ec:	193a      	adds	r2, r7, r4
 80034ee:	0011      	movs	r1, r2
 80034f0:	0018      	movs	r0, r3
 80034f2:	f004 fd7b 	bl	8007fec <LDL_Radio_receive>
                
                /* use waitA as a guard */
                LDL_MAC_timerSet(self, LDL_TIMER_WAITA, (LDL_System_tps()) << 4U);
 80034f6:	f006 fcf6 	bl	8009ee6 <LDL_System_tps>
 80034fa:	0003      	movs	r3, r0
 80034fc:	011a      	lsls	r2, r3, #4
 80034fe:	687b      	ldr	r3, [r7, #4]
 8003500:	2100      	movs	r1, #0
 8003502:	0018      	movs	r0, r3
 8003504:	f000 fc9a 	bl	8003e3c <LDL_MAC_timerSet>
                
                self->snr_min = LDL_Radio_minSNR(self->radio, radio_setting.sf);
 8003508:	687a      	ldr	r2, [r7, #4]
 800350a:	2388      	movs	r3, #136	; 0x88
 800350c:	009b      	lsls	r3, r3, #2
 800350e:	58d2      	ldr	r2, [r2, r3]
 8003510:	193b      	adds	r3, r7, r4
 8003512:	7a5b      	ldrb	r3, [r3, #9]
 8003514:	0019      	movs	r1, r3
 8003516:	0010      	movs	r0, r2
 8003518:	f004 feb8 	bl	800828c <LDL_Radio_minSNR>
 800351c:	0003      	movs	r3, r0
 800351e:	0019      	movs	r1, r3
 8003520:	687a      	ldr	r2, [r7, #4]
 8003522:	239e      	movs	r3, #158	; 0x9e
 8003524:	005b      	lsls	r3, r3, #1
 8003526:	52d1      	strh	r1, [r2, r3]
 8003528:	e006      	b.n	8003538 <LDL_MAC_process+0x960>
            }
            else{
                
                adaptRate(self);
 800352a:	687b      	ldr	r3, [r7, #4]
 800352c:	0018      	movs	r0, r3
 800352e:	f001 fa1d 	bl	800496c <adaptRate>
                
                self->state = LDL_STATE_IDLE;
 8003532:	687b      	ldr	r3, [r7, #4]
 8003534:	2206      	movs	r2, #6
 8003536:	701a      	strb	r2, [r3, #0]
            }
                
#ifndef LDL_DISABLE_SLOT_EVENT                                    
            arg.rx_slot.margin = self->rx2_margin;                
 8003538:	687a      	ldr	r2, [r7, #4]
 800353a:	23aa      	movs	r3, #170	; 0xaa
 800353c:	005b      	lsls	r3, r3, #1
 800353e:	58d2      	ldr	r2, [r2, r3]
 8003540:	24ba      	movs	r4, #186	; 0xba
 8003542:	0064      	lsls	r4, r4, #1
 8003544:	193b      	adds	r3, r7, r4
 8003546:	601a      	str	r2, [r3, #0]
            arg.rx_slot.timeout = self->rx2_symbols;                
 8003548:	687a      	ldr	r2, [r7, #4]
 800354a:	235a      	movs	r3, #90	; 0x5a
 800354c:	33ff      	adds	r3, #255	; 0xff
 800354e:	5cd2      	ldrb	r2, [r2, r3]
 8003550:	193b      	adds	r3, r7, r4
 8003552:	739a      	strb	r2, [r3, #14]
            arg.rx_slot.error = error;
 8003554:	23c2      	movs	r3, #194	; 0xc2
 8003556:	005b      	lsls	r3, r3, #1
 8003558:	18fb      	adds	r3, r7, r3
 800355a:	681a      	ldr	r2, [r3, #0]
 800355c:	193b      	adds	r3, r7, r4
 800355e:	605a      	str	r2, [r3, #4]
            arg.rx_slot.freq = self->ctx.rx2Freq;
 8003560:	687a      	ldr	r2, [r7, #4]
 8003562:	2380      	movs	r3, #128	; 0x80
 8003564:	009b      	lsls	r3, r3, #2
 8003566:	58d2      	ldr	r2, [r2, r3]
 8003568:	193b      	adds	r3, r7, r4
 800356a:	609a      	str	r2, [r3, #8]
            arg.rx_slot.bw = radio_setting.bw;
 800356c:	21a2      	movs	r1, #162	; 0xa2
 800356e:	0049      	lsls	r1, r1, #1
 8003570:	187b      	adds	r3, r7, r1
 8003572:	7a1a      	ldrb	r2, [r3, #8]
 8003574:	193b      	adds	r3, r7, r4
 8003576:	731a      	strb	r2, [r3, #12]
            arg.rx_slot.sf = radio_setting.sf;           
 8003578:	187b      	adds	r3, r7, r1
 800357a:	7a5a      	ldrb	r2, [r3, #9]
 800357c:	193b      	adds	r3, r7, r4
 800357e:	735a      	strb	r2, [r3, #13]
                 
            self->handler(self->app, LDL_MAC_RX2_SLOT, &arg);                    
 8003580:	687a      	ldr	r2, [r7, #4]
 8003582:	2392      	movs	r3, #146	; 0x92
 8003584:	009b      	lsls	r3, r3, #2
 8003586:	58d3      	ldr	r3, [r2, r3]
 8003588:	6879      	ldr	r1, [r7, #4]
 800358a:	2293      	movs	r2, #147	; 0x93
 800358c:	0092      	lsls	r2, r2, #2
 800358e:	5888      	ldr	r0, [r1, r2]
 8003590:	193a      	adds	r2, r7, r4
 8003592:	210b      	movs	r1, #11
 8003594:	4798      	blx	r3
#endif                
        }
        break;
 8003596:	e356      	b.n	8003c46 <LDL_MAC_process+0x106e>
 8003598:	00002710 	.word	0x00002710
        
    case LDL_STATE_RX1:    
    case LDL_STATE_RX2:

        if(LDL_MAC_inputCheck(self, LDL_INPUT_RX_READY, &error)){
 800359c:	23c2      	movs	r3, #194	; 0xc2
 800359e:	005b      	lsls	r3, r3, #1
 80035a0:	18fa      	adds	r2, r7, r3
 80035a2:	687b      	ldr	r3, [r7, #4]
 80035a4:	2101      	movs	r1, #1
 80035a6:	0018      	movs	r0, r3
 80035a8:	f000 fd5a 	bl	8004060 <LDL_MAC_inputCheck>
 80035ac:	1e03      	subs	r3, r0, #0
 80035ae:	d100      	bne.n	80035b2 <LDL_MAC_process+0x9da>
 80035b0:	e249      	b.n	8003a46 <LDL_MAC_process+0xe6e>
        
            LDL_MAC_inputClear(self);
 80035b2:	687b      	ldr	r3, [r7, #4]
 80035b4:	0018      	movs	r0, r3
 80035b6:	f000 fd97 	bl	80040e8 <LDL_MAC_inputClear>
            struct ldl_radio_packet_metadata meta;            
            
            const uint8_t *fopts;
            uint8_t foptsLen;
            
            LDL_MAC_timerClear(self, LDL_TIMER_WAITA);
 80035ba:	687b      	ldr	r3, [r7, #4]
 80035bc:	2100      	movs	r1, #0
 80035be:	0018      	movs	r0, r3
 80035c0:	f000 fcd6 	bl	8003f70 <LDL_MAC_timerClear>
            LDL_MAC_timerClear(self, LDL_TIMER_WAITB);
 80035c4:	687b      	ldr	r3, [r7, #4]
 80035c6:	2101      	movs	r1, #1
 80035c8:	0018      	movs	r0, r3
 80035ca:	f000 fcd1 	bl	8003f70 <LDL_MAC_timerClear>
            
            len = LDL_Radio_collect(self->radio, &meta, buffer, LDL_MAX_PACKET);        
 80035ce:	687a      	ldr	r2, [r7, #4]
 80035d0:	2388      	movs	r3, #136	; 0x88
 80035d2:	009b      	lsls	r3, r3, #2
 80035d4:	58d0      	ldr	r0, [r2, r3]
 80035d6:	26b0      	movs	r6, #176	; 0xb0
 80035d8:	36ff      	adds	r6, #255	; 0xff
 80035da:	19bc      	adds	r4, r7, r6
 80035dc:	233c      	movs	r3, #60	; 0x3c
 80035de:	18fa      	adds	r2, r7, r3
 80035e0:	25a0      	movs	r5, #160	; 0xa0
 80035e2:	006d      	lsls	r5, r5, #1
 80035e4:	1979      	adds	r1, r7, r5
 80035e6:	23ff      	movs	r3, #255	; 0xff
 80035e8:	f004 fd5f 	bl	80080aa <LDL_Radio_collect>
 80035ec:	0003      	movs	r3, r0
 80035ee:	7023      	strb	r3, [r4, #0]
            
            LDL_Radio_clearInterrupt(self->radio);
 80035f0:	687a      	ldr	r2, [r7, #4]
 80035f2:	2388      	movs	r3, #136	; 0x88
 80035f4:	009b      	lsls	r3, r3, #2
 80035f6:	58d3      	ldr	r3, [r2, r3]
 80035f8:	0018      	movs	r0, r3
 80035fa:	f004 fe2e 	bl	800825a <LDL_Radio_clearInterrupt>
            
            /* notify of a downstream message */
#ifndef LDL_DISABLE_DOWNSTREAM_EVENT            
            arg.downstream.rssi = meta.rssi;
 80035fe:	002c      	movs	r4, r5
 8003600:	193b      	adds	r3, r7, r4
 8003602:	2100      	movs	r1, #0
 8003604:	5e5a      	ldrsh	r2, [r3, r1]
 8003606:	25ba      	movs	r5, #186	; 0xba
 8003608:	006d      	lsls	r5, r5, #1
 800360a:	197b      	adds	r3, r7, r5
 800360c:	801a      	strh	r2, [r3, #0]
            arg.downstream.snr = meta.snr;
 800360e:	193b      	adds	r3, r7, r4
 8003610:	2102      	movs	r1, #2
 8003612:	5e5a      	ldrsh	r2, [r3, r1]
 8003614:	197b      	adds	r3, r7, r5
 8003616:	805a      	strh	r2, [r3, #2]
            arg.downstream.size = len;
 8003618:	197b      	adds	r3, r7, r5
 800361a:	19ba      	adds	r2, r7, r6
 800361c:	7812      	ldrb	r2, [r2, #0]
 800361e:	711a      	strb	r2, [r3, #4]
            
            self->handler(self->app, LDL_MAC_DOWNSTREAM, &arg);      
 8003620:	687a      	ldr	r2, [r7, #4]
 8003622:	2392      	movs	r3, #146	; 0x92
 8003624:	009b      	lsls	r3, r3, #2
 8003626:	58d3      	ldr	r3, [r2, r3]
 8003628:	6879      	ldr	r1, [r7, #4]
 800362a:	2293      	movs	r2, #147	; 0x93
 800362c:	0092      	lsls	r2, r2, #2
 800362e:	5888      	ldr	r0, [r1, r2]
 8003630:	197a      	adds	r2, r7, r5
 8003632:	210c      	movs	r1, #12
 8003634:	4798      	blx	r3
#endif  
            self->margin = meta.snr - self->snr_min;
 8003636:	193b      	adds	r3, r7, r4
 8003638:	2102      	movs	r1, #2
 800363a:	5e5b      	ldrsh	r3, [r3, r1]
 800363c:	b29a      	uxth	r2, r3
 800363e:	6879      	ldr	r1, [r7, #4]
 8003640:	239e      	movs	r3, #158	; 0x9e
 8003642:	005b      	lsls	r3, r3, #1
 8003644:	5ecb      	ldrsh	r3, [r1, r3]
 8003646:	b29b      	uxth	r3, r3
 8003648:	1ad3      	subs	r3, r2, r3
 800364a:	b29b      	uxth	r3, r3
 800364c:	b219      	sxth	r1, r3
 800364e:	687a      	ldr	r2, [r7, #4]
 8003650:	239f      	movs	r3, #159	; 0x9f
 8003652:	005b      	lsls	r3, r3, #1
 8003654:	52d1      	strh	r1, [r2, r3]
            
            if(LDL_OPS_receiveFrame(self, &frame, buffer, len)){
 8003656:	19bb      	adds	r3, r7, r6
 8003658:	781b      	ldrb	r3, [r3, #0]
 800365a:	223c      	movs	r2, #60	; 0x3c
 800365c:	18ba      	adds	r2, r7, r2
 800365e:	2108      	movs	r1, #8
 8003660:	1879      	adds	r1, r7, r1
 8003662:	6878      	ldr	r0, [r7, #4]
 8003664:	f003 ffaa 	bl	80075bc <LDL_OPS_receiveFrame>
 8003668:	1e03      	subs	r3, r0, #0
 800366a:	d100      	bne.n	800366e <LDL_MAC_process+0xa96>
 800366c:	e1e6      	b.n	8003a3c <LDL_MAC_process+0xe64>
                
                self->last_valid_downlink = timeNow(self);
 800366e:	687b      	ldr	r3, [r7, #4]
 8003670:	0018      	movs	r0, r3
 8003672:	f002 fd97 	bl	80061a4 <timeNow>
 8003676:	0001      	movs	r1, r0
 8003678:	687a      	ldr	r2, [r7, #4]
 800367a:	23a0      	movs	r3, #160	; 0xa0
 800367c:	005b      	lsls	r3, r3, #1
 800367e:	50d1      	str	r1, [r2, r3]
                
                switch(frame.type){
 8003680:	4bea      	ldr	r3, [pc, #936]	; (8003a2c <LDL_MAC_process+0xe54>)
 8003682:	22e0      	movs	r2, #224	; 0xe0
 8003684:	0052      	lsls	r2, r2, #1
 8003686:	4694      	mov	ip, r2
 8003688:	44bc      	add	ip, r7
 800368a:	4463      	add	r3, ip
 800368c:	781b      	ldrb	r3, [r3, #0]
 800368e:	2b03      	cmp	r3, #3
 8003690:	d100      	bne.n	8003694 <LDL_MAC_process+0xabc>
 8003692:	e0d5      	b.n	8003840 <LDL_MAC_process+0xc68>
 8003694:	2b05      	cmp	r3, #5
 8003696:	d100      	bne.n	800369a <LDL_MAC_process+0xac2>
 8003698:	e0d2      	b.n	8003840 <LDL_MAC_process+0xc68>
                default:
                case FRAME_TYPE_JOIN_ACCEPT:

                    restoreDefaults(self, true);
 800369a:	687b      	ldr	r3, [r7, #4]
 800369c:	2101      	movs	r1, #1
 800369e:	0018      	movs	r0, r3
 80036a0:	f002 fae0 	bl	8005c64 <restoreDefaults>
                    
                    self->ctx.joined = true;
 80036a4:	687a      	ldr	r2, [r7, #4]
 80036a6:	2381      	movs	r3, #129	; 0x81
 80036a8:	009b      	lsls	r3, r3, #2
 80036aa:	2101      	movs	r1, #1
 80036ac:	54d1      	strb	r1, [r2, r3]
                    
                    if(self->ctx.adr){
 80036ae:	687b      	ldr	r3, [r7, #4]
 80036b0:	4adf      	ldr	r2, [pc, #892]	; (8003a30 <LDL_MAC_process+0xe58>)
 80036b2:	5c9b      	ldrb	r3, [r3, r2]
 80036b4:	2b00      	cmp	r3, #0
 80036b6:	d007      	beq.n	80036c8 <LDL_MAC_process+0xaf0>
                        
                        /* keep the joining rate */
                        self->ctx.rate = self->tx.rate;
 80036b8:	687a      	ldr	r2, [r7, #4]
 80036ba:	234e      	movs	r3, #78	; 0x4e
 80036bc:	33ff      	adds	r3, #255	; 0xff
 80036be:	5cd1      	ldrb	r1, [r2, r3]
 80036c0:	687a      	ldr	r2, [r7, #4]
 80036c2:	23f6      	movs	r3, #246	; 0xf6
 80036c4:	33ff      	adds	r3, #255	; 0xff
 80036c6:	54d1      	strb	r1, [r2, r3]
                    }                
                    
                    self->ctx.rx1DROffset = frame.rx1DataRateOffset;
 80036c8:	4bd8      	ldr	r3, [pc, #864]	; (8003a2c <LDL_MAC_process+0xe54>)
 80036ca:	22e0      	movs	r2, #224	; 0xe0
 80036cc:	0052      	lsls	r2, r2, #1
 80036ce:	4694      	mov	ip, r2
 80036d0:	44bc      	add	ip, r7
 80036d2:	4463      	add	r3, ip
 80036d4:	7c19      	ldrb	r1, [r3, #16]
 80036d6:	687a      	ldr	r2, [r7, #4]
 80036d8:	23fa      	movs	r3, #250	; 0xfa
 80036da:	33ff      	adds	r3, #255	; 0xff
 80036dc:	54d1      	strb	r1, [r2, r3]
                    self->ctx.rx2DataRate = frame.rx2DataRate;
 80036de:	4bd3      	ldr	r3, [pc, #844]	; (8003a2c <LDL_MAC_process+0xe54>)
 80036e0:	22e0      	movs	r2, #224	; 0xe0
 80036e2:	0052      	lsls	r2, r2, #1
 80036e4:	4694      	mov	ip, r2
 80036e6:	44bc      	add	ip, r7
 80036e8:	4463      	add	r3, ip
 80036ea:	7c59      	ldrb	r1, [r3, #17]
 80036ec:	687a      	ldr	r2, [r7, #4]
 80036ee:	23fc      	movs	r3, #252	; 0xfc
 80036f0:	33ff      	adds	r3, #255	; 0xff
 80036f2:	54d1      	strb	r1, [r2, r3]
                    self->ctx.rx1Delay = frame.rxDelay;
 80036f4:	4bcd      	ldr	r3, [pc, #820]	; (8003a2c <LDL_MAC_process+0xe54>)
 80036f6:	22e0      	movs	r2, #224	; 0xe0
 80036f8:	0052      	lsls	r2, r2, #1
 80036fa:	4694      	mov	ip, r2
 80036fc:	44bc      	add	ip, r7
 80036fe:	4463      	add	r3, ip
 8003700:	7c99      	ldrb	r1, [r3, #18]
 8003702:	687a      	ldr	r2, [r7, #4]
 8003704:	23fd      	movs	r3, #253	; 0xfd
 8003706:	005b      	lsls	r3, r3, #1
 8003708:	54d1      	strb	r1, [r2, r3]
                    
                    if(frame.cfList != NULL){
 800370a:	4bc8      	ldr	r3, [pc, #800]	; (8003a2c <LDL_MAC_process+0xe54>)
 800370c:	22e0      	movs	r2, #224	; 0xe0
 800370e:	0052      	lsls	r2, r2, #1
 8003710:	4694      	mov	ip, r2
 8003712:	44bc      	add	ip, r7
 8003714:	4463      	add	r3, ip
 8003716:	695b      	ldr	r3, [r3, #20]
 8003718:	2b00      	cmp	r3, #0
 800371a:	d014      	beq.n	8003746 <LDL_MAC_process+0xb6e>
                        
                        LDL_Region_processCFList(self->region, self, frame.cfList, frame.cfListLen);                        
 800371c:	687a      	ldr	r2, [r7, #4]
 800371e:	2391      	movs	r3, #145	; 0x91
 8003720:	009b      	lsls	r3, r3, #2
 8003722:	5cd0      	ldrb	r0, [r2, r3]
 8003724:	4bc1      	ldr	r3, [pc, #772]	; (8003a2c <LDL_MAC_process+0xe54>)
 8003726:	22e0      	movs	r2, #224	; 0xe0
 8003728:	0052      	lsls	r2, r2, #1
 800372a:	4694      	mov	ip, r2
 800372c:	44bc      	add	ip, r7
 800372e:	4463      	add	r3, ip
 8003730:	695a      	ldr	r2, [r3, #20]
 8003732:	4bbe      	ldr	r3, [pc, #760]	; (8003a2c <LDL_MAC_process+0xe54>)
 8003734:	21e0      	movs	r1, #224	; 0xe0
 8003736:	0049      	lsls	r1, r1, #1
 8003738:	468c      	mov	ip, r1
 800373a:	44bc      	add	ip, r7
 800373c:	4463      	add	r3, ip
 800373e:	7e1b      	ldrb	r3, [r3, #24]
 8003740:	6879      	ldr	r1, [r7, #4]
 8003742:	f005 fab6 	bl	8008cb2 <LDL_Region_processCFList>
                    }
                    
                    self->ctx.devAddr = frame.devAddr;    
 8003746:	4bb9      	ldr	r3, [pc, #740]	; (8003a2c <LDL_MAC_process+0xe54>)
 8003748:	22e0      	movs	r2, #224	; 0xe0
 800374a:	0052      	lsls	r2, r2, #1
 800374c:	4694      	mov	ip, r2
 800374e:	44bc      	add	ip, r7
 8003750:	4463      	add	r3, ip
 8003752:	68d9      	ldr	r1, [r3, #12]
 8003754:	687a      	ldr	r2, [r7, #4]
 8003756:	23b2      	movs	r3, #178	; 0xb2
 8003758:	005b      	lsls	r3, r3, #1
 800375a:	50d1      	str	r1, [r2, r3]
                    self->ctx.netID = frame.netID;
 800375c:	4bb3      	ldr	r3, [pc, #716]	; (8003a2c <LDL_MAC_process+0xe54>)
 800375e:	22e0      	movs	r2, #224	; 0xe0
 8003760:	0052      	lsls	r2, r2, #1
 8003762:	4694      	mov	ip, r2
 8003764:	44bc      	add	ip, r7
 8003766:	4463      	add	r3, ip
 8003768:	6899      	ldr	r1, [r3, #8]
 800376a:	687a      	ldr	r2, [r7, #4]
 800376c:	23b4      	movs	r3, #180	; 0xb4
 800376e:	005b      	lsls	r3, r3, #1
 8003770:	50d1      	str	r1, [r2, r3]
                    self->joinNonce = frame.joinNonce;
 8003772:	4bae      	ldr	r3, [pc, #696]	; (8003a2c <LDL_MAC_process+0xe54>)
 8003774:	22e0      	movs	r2, #224	; 0xe0
 8003776:	0052      	lsls	r2, r2, #1
 8003778:	4694      	mov	ip, r2
 800377a:	44bc      	add	ip, r7
 800377c:	4463      	add	r3, ip
 800377e:	6859      	ldr	r1, [r3, #4]
 8003780:	687a      	ldr	r2, [r7, #4]
 8003782:	239c      	movs	r3, #156	; 0x9c
 8003784:	005b      	lsls	r3, r3, #1
 8003786:	50d1      	str	r1, [r2, r3]
                    
                    self->ctx.version = (frame.optNeg) ? 1U : 0U;
 8003788:	4ba8      	ldr	r3, [pc, #672]	; (8003a2c <LDL_MAC_process+0xe54>)
 800378a:	22e0      	movs	r2, #224	; 0xe0
 800378c:	0052      	lsls	r2, r2, #1
 800378e:	4694      	mov	ip, r2
 8003790:	44bc      	add	ip, r7
 8003792:	4463      	add	r3, ip
 8003794:	7cdb      	ldrb	r3, [r3, #19]
 8003796:	2b00      	cmp	r3, #0
 8003798:	d001      	beq.n	800379e <LDL_MAC_process+0xbc6>
 800379a:	2101      	movs	r1, #1
 800379c:	e000      	b.n	80037a0 <LDL_MAC_process+0xbc8>
 800379e:	2100      	movs	r1, #0
 80037a0:	687b      	ldr	r3, [r7, #4]
 80037a2:	4aa4      	ldr	r2, [pc, #656]	; (8003a34 <LDL_MAC_process+0xe5c>)
 80037a4:	5499      	strb	r1, [r3, r2]
                    
                    if(self->ctx.version > 0){
 80037a6:	687b      	ldr	r3, [r7, #4]
 80037a8:	4aa2      	ldr	r2, [pc, #648]	; (8003a34 <LDL_MAC_process+0xe5c>)
 80037aa:	5c9b      	ldrb	r3, [r3, r2]
 80037ac:	2b00      	cmp	r3, #0
 80037ae:	d004      	beq.n	80037ba <LDL_MAC_process+0xbe2>
                        
                        setPendingCommand(self, LDL_CMD_REKEY);
 80037b0:	687b      	ldr	r3, [r7, #4]
 80037b2:	2109      	movs	r1, #9
 80037b4:	0018      	movs	r0, r3
 80037b6:	f003 f912 	bl	80069de <setPendingCommand>
                    }
                    
                    LDL_OPS_deriveKeys(self);
 80037ba:	687b      	ldr	r3, [r7, #4]
 80037bc:	0018      	movs	r0, r3
 80037be:	f003 fced 	bl	800719c <LDL_OPS_deriveKeys>
                    
                    self->joinNonce++;                    
 80037c2:	687a      	ldr	r2, [r7, #4]
 80037c4:	239c      	movs	r3, #156	; 0x9c
 80037c6:	005b      	lsls	r3, r3, #1
 80037c8:	58d3      	ldr	r3, [r2, r3]
 80037ca:	1c59      	adds	r1, r3, #1
 80037cc:	687a      	ldr	r2, [r7, #4]
 80037ce:	239c      	movs	r3, #156	; 0x9c
 80037d0:	005b      	lsls	r3, r3, #1
 80037d2:	50d1      	str	r1, [r2, r3]
                    self->devNonce++;
 80037d4:	687a      	ldr	r2, [r7, #4]
 80037d6:	239a      	movs	r3, #154	; 0x9a
 80037d8:	005b      	lsls	r3, r3, #1
 80037da:	5ad3      	ldrh	r3, [r2, r3]
 80037dc:	3301      	adds	r3, #1
 80037de:	b299      	uxth	r1, r3
 80037e0:	687a      	ldr	r2, [r7, #4]
 80037e2:	239a      	movs	r3, #154	; 0x9a
 80037e4:	005b      	lsls	r3, r3, #1
 80037e6:	52d1      	strh	r1, [r2, r3]
                    
#ifndef LDL_DISABLE_JOIN_COMPLETE_EVENT                    
                    arg.join_complete.joinNonce = self->joinNonce;
 80037e8:	687a      	ldr	r2, [r7, #4]
 80037ea:	239c      	movs	r3, #156	; 0x9c
 80037ec:	005b      	lsls	r3, r3, #1
 80037ee:	58d2      	ldr	r2, [r2, r3]
 80037f0:	24ba      	movs	r4, #186	; 0xba
 80037f2:	0064      	lsls	r4, r4, #1
 80037f4:	193b      	adds	r3, r7, r4
 80037f6:	601a      	str	r2, [r3, #0]
                    arg.join_complete.nextDevNonce = self->devNonce;
 80037f8:	687a      	ldr	r2, [r7, #4]
 80037fa:	239a      	movs	r3, #154	; 0x9a
 80037fc:	005b      	lsls	r3, r3, #1
 80037fe:	5ad2      	ldrh	r2, [r2, r3]
 8003800:	193b      	adds	r3, r7, r4
 8003802:	809a      	strh	r2, [r3, #4]
                    arg.join_complete.netID = self->ctx.netID;
 8003804:	687a      	ldr	r2, [r7, #4]
 8003806:	23b4      	movs	r3, #180	; 0xb4
 8003808:	005b      	lsls	r3, r3, #1
 800380a:	58d2      	ldr	r2, [r2, r3]
 800380c:	193b      	adds	r3, r7, r4
 800380e:	609a      	str	r2, [r3, #8]
                    arg.join_complete.devAddr = self->ctx.devAddr;
 8003810:	687a      	ldr	r2, [r7, #4]
 8003812:	23b2      	movs	r3, #178	; 0xb2
 8003814:	005b      	lsls	r3, r3, #1
 8003816:	58d2      	ldr	r2, [r2, r3]
 8003818:	193b      	adds	r3, r7, r4
 800381a:	60da      	str	r2, [r3, #12]
                    self->handler(self->app, LDL_MAC_JOIN_COMPLETE, &arg);                    
 800381c:	687a      	ldr	r2, [r7, #4]
 800381e:	2392      	movs	r3, #146	; 0x92
 8003820:	009b      	lsls	r3, r3, #2
 8003822:	58d3      	ldr	r3, [r2, r3]
 8003824:	6879      	ldr	r1, [r7, #4]
 8003826:	2293      	movs	r2, #147	; 0x93
 8003828:	0092      	lsls	r2, r2, #2
 800382a:	5888      	ldr	r0, [r1, r2]
 800382c:	193a      	adds	r2, r7, r4
 800382e:	2103      	movs	r1, #3
 8003830:	4798      	blx	r3
#endif                                      
                    self->state = LDL_STATE_IDLE;           
 8003832:	687b      	ldr	r3, [r7, #4]
 8003834:	2206      	movs	r2, #6
 8003836:	701a      	strb	r2, [r3, #0]
                    self->op = LDL_OP_NONE;                                
 8003838:	687b      	ldr	r3, [r7, #4]
 800383a:	2200      	movs	r2, #0
 800383c:	705a      	strb	r2, [r3, #1]
                    break;
 800383e:	e0f0      	b.n	8003a22 <LDL_MAC_process+0xe4a>
                
                case FRAME_TYPE_DATA_UNCONFIRMED_DOWN:
                case FRAME_TYPE_DATA_CONFIRMED_DOWN:
                                
                    LDL_OPS_syncDownCounter(self, frame.port, frame.counter);
 8003840:	4b7a      	ldr	r3, [pc, #488]	; (8003a2c <LDL_MAC_process+0xe54>)
 8003842:	22e0      	movs	r2, #224	; 0xe0
 8003844:	0052      	lsls	r2, r2, #1
 8003846:	4694      	mov	ip, r2
 8003848:	44bc      	add	ip, r7
 800384a:	4463      	add	r3, ip
 800384c:	2226      	movs	r2, #38	; 0x26
 800384e:	5c99      	ldrb	r1, [r3, r2]
 8003850:	4b76      	ldr	r3, [pc, #472]	; (8003a2c <LDL_MAC_process+0xe54>)
 8003852:	22e0      	movs	r2, #224	; 0xe0
 8003854:	0052      	lsls	r2, r2, #1
 8003856:	4694      	mov	ip, r2
 8003858:	44bc      	add	ip, r7
 800385a:	4463      	add	r3, ip
 800385c:	8b5a      	ldrh	r2, [r3, #26]
 800385e:	687b      	ldr	r3, [r7, #4]
 8003860:	0018      	movs	r0, r3
 8003862:	f003 fc67 	bl	8007134 <LDL_OPS_syncDownCounter>
                        
                    clearPendingCommand(self, LDL_CMD_RX_PARAM_SETUP);
 8003866:	687b      	ldr	r3, [r7, #4]
 8003868:	2103      	movs	r1, #3
 800386a:	0018      	movs	r0, r3
 800386c:	f003 f898 	bl	80069a0 <clearPendingCommand>
                    clearPendingCommand(self, LDL_CMD_DL_CHANNEL);
 8003870:	687b      	ldr	r3, [r7, #4]
 8003872:	2108      	movs	r1, #8
 8003874:	0018      	movs	r0, r3
 8003876:	f003 f893 	bl	80069a0 <clearPendingCommand>
                    clearPendingCommand(self, LDL_CMD_RX_TIMING_SETUP);
 800387a:	687b      	ldr	r3, [r7, #4]
 800387c:	2106      	movs	r1, #6
 800387e:	0018      	movs	r0, r3
 8003880:	f003 f88e 	bl	80069a0 <clearPendingCommand>
                    
                    self->adrAckCounter = 0U;
 8003884:	687a      	ldr	r2, [r7, #4]
 8003886:	2395      	movs	r3, #149	; 0x95
 8003888:	009b      	lsls	r3, r3, #2
 800388a:	2100      	movs	r1, #0
 800388c:	54d1      	strb	r1, [r2, r3]
                    self->adrAckReq = false;
 800388e:	687b      	ldr	r3, [r7, #4]
 8003890:	4a69      	ldr	r2, [pc, #420]	; (8003a38 <LDL_MAC_process+0xe60>)
 8003892:	2100      	movs	r1, #0
 8003894:	5499      	strb	r1, [r3, r2]
                        
                    fopts = frame.opts;
 8003896:	4b65      	ldr	r3, [pc, #404]	; (8003a2c <LDL_MAC_process+0xe54>)
 8003898:	22e0      	movs	r2, #224	; 0xe0
 800389a:	0052      	lsls	r2, r2, #1
 800389c:	4694      	mov	ip, r2
 800389e:	44bc      	add	ip, r7
 80038a0:	4463      	add	r3, ip
 80038a2:	6a1b      	ldr	r3, [r3, #32]
 80038a4:	22de      	movs	r2, #222	; 0xde
 80038a6:	0052      	lsls	r2, r2, #1
 80038a8:	18ba      	adds	r2, r7, r2
 80038aa:	6013      	str	r3, [r2, #0]
                    foptsLen = frame.optsLen;
 80038ac:	23bc      	movs	r3, #188	; 0xbc
 80038ae:	33ff      	adds	r3, #255	; 0xff
 80038b0:	18fb      	adds	r3, r7, r3
 80038b2:	4a5e      	ldr	r2, [pc, #376]	; (8003a2c <LDL_MAC_process+0xe54>)
 80038b4:	21e0      	movs	r1, #224	; 0xe0
 80038b6:	0049      	lsls	r1, r1, #1
 80038b8:	468c      	mov	ip, r1
 80038ba:	44bc      	add	ip, r7
 80038bc:	4462      	add	r2, ip
 80038be:	2124      	movs	r1, #36	; 0x24
 80038c0:	5c52      	ldrb	r2, [r2, r1]
 80038c2:	701a      	strb	r2, [r3, #0]
                                        
                    if((frame.data != NULL) && (frame.port == 0U)){
 80038c4:	4b59      	ldr	r3, [pc, #356]	; (8003a2c <LDL_MAC_process+0xe54>)
 80038c6:	22e0      	movs	r2, #224	; 0xe0
 80038c8:	0052      	lsls	r2, r2, #1
 80038ca:	4694      	mov	ip, r2
 80038cc:	44bc      	add	ip, r7
 80038ce:	4463      	add	r3, ip
 80038d0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80038d2:	2b00      	cmp	r3, #0
 80038d4:	d05e      	beq.n	8003994 <LDL_MAC_process+0xdbc>
 80038d6:	4b55      	ldr	r3, [pc, #340]	; (8003a2c <LDL_MAC_process+0xe54>)
 80038d8:	22e0      	movs	r2, #224	; 0xe0
 80038da:	0052      	lsls	r2, r2, #1
 80038dc:	4694      	mov	ip, r2
 80038de:	44bc      	add	ip, r7
 80038e0:	4463      	add	r3, ip
 80038e2:	2226      	movs	r2, #38	; 0x26
 80038e4:	5c9b      	ldrb	r3, [r3, r2]
 80038e6:	2b00      	cmp	r3, #0
 80038e8:	d154      	bne.n	8003994 <LDL_MAC_process+0xdbc>
                    
                        if(frame.port == 0U){
 80038ea:	4b50      	ldr	r3, [pc, #320]	; (8003a2c <LDL_MAC_process+0xe54>)
 80038ec:	22e0      	movs	r2, #224	; 0xe0
 80038ee:	0052      	lsls	r2, r2, #1
 80038f0:	4694      	mov	ip, r2
 80038f2:	44bc      	add	ip, r7
 80038f4:	4463      	add	r3, ip
 80038f6:	2226      	movs	r2, #38	; 0x26
 80038f8:	5c9b      	ldrb	r3, [r3, r2]
 80038fa:	2b00      	cmp	r3, #0
 80038fc:	d117      	bne.n	800392e <LDL_MAC_process+0xd56>
                    
                            fopts = frame.data;
 80038fe:	4b4b      	ldr	r3, [pc, #300]	; (8003a2c <LDL_MAC_process+0xe54>)
 8003900:	22e0      	movs	r2, #224	; 0xe0
 8003902:	0052      	lsls	r2, r2, #1
 8003904:	4694      	mov	ip, r2
 8003906:	44bc      	add	ip, r7
 8003908:	4463      	add	r3, ip
 800390a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800390c:	22de      	movs	r2, #222	; 0xde
 800390e:	0052      	lsls	r2, r2, #1
 8003910:	18ba      	adds	r2, r7, r2
 8003912:	6013      	str	r3, [r2, #0]
                            foptsLen = frame.dataLen;                        
 8003914:	23bc      	movs	r3, #188	; 0xbc
 8003916:	33ff      	adds	r3, #255	; 0xff
 8003918:	18fb      	adds	r3, r7, r3
 800391a:	4a44      	ldr	r2, [pc, #272]	; (8003a2c <LDL_MAC_process+0xe54>)
 800391c:	21e0      	movs	r1, #224	; 0xe0
 800391e:	0049      	lsls	r1, r1, #1
 8003920:	468c      	mov	ip, r1
 8003922:	44bc      	add	ip, r7
 8003924:	4462      	add	r2, ip
 8003926:	212c      	movs	r1, #44	; 0x2c
 8003928:	5c52      	ldrb	r2, [r2, r1]
 800392a:	701a      	strb	r2, [r3, #0]
 800392c:	e032      	b.n	8003994 <LDL_MAC_process+0xdbc>
                        }
                        else{
                            
#ifndef LDL_DISABLE_RX_EVENT                                            
                            arg.rx.counter = frame.counter;
 800392e:	4b3f      	ldr	r3, [pc, #252]	; (8003a2c <LDL_MAC_process+0xe54>)
 8003930:	22e0      	movs	r2, #224	; 0xe0
 8003932:	0052      	lsls	r2, r2, #1
 8003934:	4694      	mov	ip, r2
 8003936:	44bc      	add	ip, r7
 8003938:	4463      	add	r3, ip
 800393a:	8b5a      	ldrh	r2, [r3, #26]
 800393c:	24ba      	movs	r4, #186	; 0xba
 800393e:	0064      	lsls	r4, r4, #1
 8003940:	193b      	adds	r3, r7, r4
 8003942:	809a      	strh	r2, [r3, #4]
                            arg.rx.port = frame.port;
 8003944:	4b39      	ldr	r3, [pc, #228]	; (8003a2c <LDL_MAC_process+0xe54>)
 8003946:	22e0      	movs	r2, #224	; 0xe0
 8003948:	0052      	lsls	r2, r2, #1
 800394a:	4694      	mov	ip, r2
 800394c:	44bc      	add	ip, r7
 800394e:	4463      	add	r3, ip
 8003950:	2226      	movs	r2, #38	; 0x26
 8003952:	5c9a      	ldrb	r2, [r3, r2]
 8003954:	193b      	adds	r3, r7, r4
 8003956:	719a      	strb	r2, [r3, #6]
                            arg.rx.data = frame.data;
 8003958:	4b34      	ldr	r3, [pc, #208]	; (8003a2c <LDL_MAC_process+0xe54>)
 800395a:	22e0      	movs	r2, #224	; 0xe0
 800395c:	0052      	lsls	r2, r2, #1
 800395e:	4694      	mov	ip, r2
 8003960:	44bc      	add	ip, r7
 8003962:	4463      	add	r3, ip
 8003964:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8003966:	193b      	adds	r3, r7, r4
 8003968:	601a      	str	r2, [r3, #0]
                            arg.rx.size = frame.dataLen;                                            
 800396a:	4b30      	ldr	r3, [pc, #192]	; (8003a2c <LDL_MAC_process+0xe54>)
 800396c:	22e0      	movs	r2, #224	; 0xe0
 800396e:	0052      	lsls	r2, r2, #1
 8003970:	4694      	mov	ip, r2
 8003972:	44bc      	add	ip, r7
 8003974:	4463      	add	r3, ip
 8003976:	222c      	movs	r2, #44	; 0x2c
 8003978:	5c9a      	ldrb	r2, [r3, r2]
 800397a:	193b      	adds	r3, r7, r4
 800397c:	71da      	strb	r2, [r3, #7]
                            
                            self->handler(self->app, LDL_MAC_RX, &arg);                                        
 800397e:	687a      	ldr	r2, [r7, #4]
 8003980:	2392      	movs	r3, #146	; 0x92
 8003982:	009b      	lsls	r3, r3, #2
 8003984:	58d3      	ldr	r3, [r2, r3]
 8003986:	6879      	ldr	r1, [r7, #4]
 8003988:	2293      	movs	r2, #147	; 0x93
 800398a:	0092      	lsls	r2, r2, #2
 800398c:	5888      	ldr	r0, [r1, r2]
 800398e:	193a      	adds	r2, r7, r4
 8003990:	2108      	movs	r1, #8
 8003992:	4798      	blx	r3
#endif                                                   
                        }
                    }
                    
                    processCommands(self, fopts, foptsLen);
 8003994:	23bc      	movs	r3, #188	; 0xbc
 8003996:	33ff      	adds	r3, #255	; 0xff
 8003998:	18fb      	adds	r3, r7, r3
 800399a:	781a      	ldrb	r2, [r3, #0]
 800399c:	23de      	movs	r3, #222	; 0xde
 800399e:	005b      	lsls	r3, r3, #1
 80039a0:	18fb      	adds	r3, r7, r3
 80039a2:	6819      	ldr	r1, [r3, #0]
 80039a4:	687b      	ldr	r3, [r7, #4]
 80039a6:	0018      	movs	r0, r3
 80039a8:	f001 f978 	bl	8004c9c <processCommands>
                    
                    switch(self->op){
 80039ac:	687b      	ldr	r3, [r7, #4]
 80039ae:	785b      	ldrb	r3, [r3, #1]
 80039b0:	2b02      	cmp	r3, #2
 80039b2:	d02e      	beq.n	8003a12 <LDL_MAC_process+0xe3a>
 80039b4:	2b04      	cmp	r3, #4
 80039b6:	d00b      	beq.n	80039d0 <LDL_MAC_process+0xdf8>
                    default:
                    case LDL_OP_DATA_UNCONFIRMED:
#ifndef LDL_DISABLE_DATA_COMPLETE_EVENT
                        self->handler(self->app, LDL_MAC_DATA_COMPLETE, NULL);
 80039b8:	687a      	ldr	r2, [r7, #4]
 80039ba:	2392      	movs	r3, #146	; 0x92
 80039bc:	009b      	lsls	r3, r3, #2
 80039be:	58d3      	ldr	r3, [r2, r3]
 80039c0:	6879      	ldr	r1, [r7, #4]
 80039c2:	2293      	movs	r2, #147	; 0x93
 80039c4:	0092      	lsls	r2, r2, #2
 80039c6:	5888      	ldr	r0, [r1, r2]
 80039c8:	2200      	movs	r2, #0
 80039ca:	2105      	movs	r1, #5
 80039cc:	4798      	blx	r3
#endif              
                        break;
 80039ce:	e021      	b.n	8003a14 <LDL_MAC_process+0xe3c>
                    case LDL_OP_DATA_CONFIRMED:
                    
                        if(frame.ack){
 80039d0:	4b16      	ldr	r3, [pc, #88]	; (8003a2c <LDL_MAC_process+0xe54>)
 80039d2:	22e0      	movs	r2, #224	; 0xe0
 80039d4:	0052      	lsls	r2, r2, #1
 80039d6:	4694      	mov	ip, r2
 80039d8:	44bc      	add	ip, r7
 80039da:	4463      	add	r3, ip
 80039dc:	7f1b      	ldrb	r3, [r3, #28]
 80039de:	2b00      	cmp	r3, #0
 80039e0:	d00b      	beq.n	80039fa <LDL_MAC_process+0xe22>
#ifndef LDL_DISABLE_DATA_COMPLETE_EVENT
                            self->handler(self->app, LDL_MAC_DATA_COMPLETE, NULL);
 80039e2:	687a      	ldr	r2, [r7, #4]
 80039e4:	2392      	movs	r3, #146	; 0x92
 80039e6:	009b      	lsls	r3, r3, #2
 80039e8:	58d3      	ldr	r3, [r2, r3]
 80039ea:	6879      	ldr	r1, [r7, #4]
 80039ec:	2293      	movs	r2, #147	; 0x93
 80039ee:	0092      	lsls	r2, r2, #2
 80039f0:	5888      	ldr	r0, [r1, r2]
 80039f2:	2200      	movs	r2, #0
 80039f4:	2105      	movs	r1, #5
 80039f6:	4798      	blx	r3
                            
#ifndef LDL_DISABLE_DATA_NAK_EVENT
                            self->handler(self->app, LDL_MAC_DATA_COMPLETE, NULL);
#endif                                                 
                        }
                        break;                    
 80039f8:	e00c      	b.n	8003a14 <LDL_MAC_process+0xe3c>
                            self->handler(self->app, LDL_MAC_DATA_COMPLETE, NULL);
 80039fa:	687a      	ldr	r2, [r7, #4]
 80039fc:	2392      	movs	r3, #146	; 0x92
 80039fe:	009b      	lsls	r3, r3, #2
 8003a00:	58d3      	ldr	r3, [r2, r3]
 8003a02:	6879      	ldr	r1, [r7, #4]
 8003a04:	2293      	movs	r2, #147	; 0x93
 8003a06:	0092      	lsls	r2, r2, #2
 8003a08:	5888      	ldr	r0, [r1, r2]
 8003a0a:	2200      	movs	r2, #0
 8003a0c:	2105      	movs	r1, #5
 8003a0e:	4798      	blx	r3
                        break;                    
 8003a10:	e000      	b.n	8003a14 <LDL_MAC_process+0xe3c>
                    
                    case LDL_OP_REJOINING:
                        break;
 8003a12:	46c0      	nop			; (mov r8, r8)
                    }
                      
                    self->state = LDL_STATE_IDLE;           
 8003a14:	687b      	ldr	r3, [r7, #4]
 8003a16:	2206      	movs	r2, #6
 8003a18:	701a      	strb	r2, [r3, #0]
                    self->op = LDL_OP_NONE;
 8003a1a:	687b      	ldr	r3, [r7, #4]
 8003a1c:	2200      	movs	r2, #0
 8003a1e:	705a      	strb	r2, [r3, #1]
                    break;
 8003a20:	46c0      	nop			; (mov r8, r8)
                }
                
#ifndef LDL_DISABLE_SESSION_UPDATE
                pushSessionUpdate(self);    
 8003a22:	687b      	ldr	r3, [r7, #4]
 8003a24:	0018      	movs	r0, r3
 8003a26:	f002 ff7a 	bl	800691e <pushSessionUpdate>
                
                /* hold reset for at least 100us */
                LDL_MAC_timerSet(self, LDL_TIMER_WAITA, ((LDL_System_tps() + LDL_System_eps())/10000UL) + 1U);                     
            }
        }
        break;
 8003a2a:	e10e      	b.n	8003c4a <LDL_MAC_process+0x1072>
 8003a2c:	fffffe48 	.word	0xfffffe48
 8003a30:	00000205 	.word	0x00000205
 8003a34:	00000206 	.word	0x00000206
 8003a38:	00000255 	.word	0x00000255
                downlinkMissingHandler(self);
 8003a3c:	687b      	ldr	r3, [r7, #4]
 8003a3e:	0018      	movs	r0, r3
 8003a40:	f002 fcdc 	bl	80063fc <downlinkMissingHandler>
        break;
 8003a44:	e101      	b.n	8003c4a <LDL_MAC_process+0x1072>
        else if(LDL_MAC_inputCheck(self, LDL_INPUT_RX_TIMEOUT, &error)){
 8003a46:	23c2      	movs	r3, #194	; 0xc2
 8003a48:	005b      	lsls	r3, r3, #1
 8003a4a:	18fa      	adds	r2, r7, r3
 8003a4c:	687b      	ldr	r3, [r7, #4]
 8003a4e:	2102      	movs	r1, #2
 8003a50:	0018      	movs	r0, r3
 8003a52:	f000 fb05 	bl	8004060 <LDL_MAC_inputCheck>
 8003a56:	1e03      	subs	r3, r0, #0
 8003a58:	d04e      	beq.n	8003af8 <LDL_MAC_process+0xf20>
            LDL_MAC_inputClear(self);
 8003a5a:	687b      	ldr	r3, [r7, #4]
 8003a5c:	0018      	movs	r0, r3
 8003a5e:	f000 fb43 	bl	80040e8 <LDL_MAC_inputClear>
            LDL_Radio_clearInterrupt(self->radio);
 8003a62:	687a      	ldr	r2, [r7, #4]
 8003a64:	2388      	movs	r3, #136	; 0x88
 8003a66:	009b      	lsls	r3, r3, #2
 8003a68:	58d3      	ldr	r3, [r2, r3]
 8003a6a:	0018      	movs	r0, r3
 8003a6c:	f004 fbf5 	bl	800825a <LDL_Radio_clearInterrupt>
            if(self->state == LDL_STATE_RX2){
 8003a70:	687b      	ldr	r3, [r7, #4]
 8003a72:	781b      	ldrb	r3, [r3, #0]
 8003a74:	2b0c      	cmp	r3, #12
 8003a76:	d136      	bne.n	8003ae6 <LDL_MAC_process+0xf0e>
                LDL_MAC_timerClear(self, LDL_TIMER_WAITB);
 8003a78:	687b      	ldr	r3, [r7, #4]
 8003a7a:	2101      	movs	r1, #1
 8003a7c:	0018      	movs	r0, r3
 8003a7e:	f000 fa77 	bl	8003f70 <LDL_MAC_timerClear>
                LDL_Region_convertRate(self->region, self->tx.rate, &sf, &bw, &mtu);                        
 8003a82:	687a      	ldr	r2, [r7, #4]
 8003a84:	2391      	movs	r3, #145	; 0x91
 8003a86:	009b      	lsls	r3, r3, #2
 8003a88:	5cd0      	ldrb	r0, [r2, r3]
 8003a8a:	687a      	ldr	r2, [r7, #4]
 8003a8c:	234e      	movs	r3, #78	; 0x4e
 8003a8e:	33ff      	adds	r3, #255	; 0xff
 8003a90:	5cd1      	ldrb	r1, [r2, r3]
 8003a92:	253e      	movs	r5, #62	; 0x3e
 8003a94:	35ff      	adds	r5, #255	; 0xff
 8003a96:	197c      	adds	r4, r7, r5
 8003a98:	269f      	movs	r6, #159	; 0x9f
 8003a9a:	0076      	lsls	r6, r6, #1
 8003a9c:	19ba      	adds	r2, r7, r6
 8003a9e:	2340      	movs	r3, #64	; 0x40
 8003aa0:	33ff      	adds	r3, #255	; 0xff
 8003aa2:	18fb      	adds	r3, r7, r3
 8003aa4:	9300      	str	r3, [sp, #0]
 8003aa6:	0023      	movs	r3, r4
 8003aa8:	f004 ff54 	bl	8008954 <LDL_Region_convertRate>
                uint32_t tempaaaaa = transmitTime(bw, sf, mtu, false);
 8003aac:	197b      	adds	r3, r7, r5
 8003aae:	7818      	ldrb	r0, [r3, #0]
 8003ab0:	19bb      	adds	r3, r7, r6
 8003ab2:	7819      	ldrb	r1, [r3, #0]
 8003ab4:	2340      	movs	r3, #64	; 0x40
 8003ab6:	33ff      	adds	r3, #255	; 0xff
 8003ab8:	18fb      	adds	r3, r7, r3
 8003aba:	781a      	ldrb	r2, [r3, #0]
 8003abc:	2300      	movs	r3, #0
 8003abe:	f001 f827 	bl	8004b10 <transmitTime>
 8003ac2:	0003      	movs	r3, r0
 8003ac4:	22d8      	movs	r2, #216	; 0xd8
 8003ac6:	0052      	lsls	r2, r2, #1
 8003ac8:	18ba      	adds	r2, r7, r2
 8003aca:	6013      	str	r3, [r2, #0]
                LDL_MAC_timerSet(self, LDL_TIMER_WAITA, LDL_System_tps()*2);
 8003acc:	f006 fa0b 	bl	8009ee6 <LDL_System_tps>
 8003ad0:	0003      	movs	r3, r0
 8003ad2:	005a      	lsls	r2, r3, #1
 8003ad4:	687b      	ldr	r3, [r7, #4]
 8003ad6:	2100      	movs	r1, #0
 8003ad8:	0018      	movs	r0, r3
 8003ada:	f000 f9af 	bl	8003e3c <LDL_MAC_timerSet>
                self->state = LDL_STATE_RX2_LOCKOUT;
 8003ade:	687b      	ldr	r3, [r7, #4]
 8003ae0:	220d      	movs	r2, #13
 8003ae2:	701a      	strb	r2, [r3, #0]
        break;
 8003ae4:	e0b1      	b.n	8003c4a <LDL_MAC_process+0x1072>
                LDL_MAC_timerClear(self, LDL_TIMER_WAITA);
 8003ae6:	687b      	ldr	r3, [r7, #4]
 8003ae8:	2100      	movs	r1, #0
 8003aea:	0018      	movs	r0, r3
 8003aec:	f000 fa40 	bl	8003f70 <LDL_MAC_timerClear>
                self->state = LDL_STATE_WAIT_RX2;
 8003af0:	687b      	ldr	r3, [r7, #4]
 8003af2:	220b      	movs	r2, #11
 8003af4:	701a      	strb	r2, [r3, #0]
        break;
 8003af6:	e0a8      	b.n	8003c4a <LDL_MAC_process+0x1072>
            if(LDL_MAC_timerCheck(self, LDL_TIMER_WAITA, &error) || LDL_MAC_timerCheck(self, LDL_TIMER_WAITB, &error)){
 8003af8:	23c2      	movs	r3, #194	; 0xc2
 8003afa:	005b      	lsls	r3, r3, #1
 8003afc:	18fa      	adds	r2, r7, r3
 8003afe:	687b      	ldr	r3, [r7, #4]
 8003b00:	2100      	movs	r1, #0
 8003b02:	0018      	movs	r0, r3
 8003b04:	f000 f9d0 	bl	8003ea8 <LDL_MAC_timerCheck>
 8003b08:	1e03      	subs	r3, r0, #0
 8003b0a:	d10a      	bne.n	8003b22 <LDL_MAC_process+0xf4a>
 8003b0c:	23c2      	movs	r3, #194	; 0xc2
 8003b0e:	005b      	lsls	r3, r3, #1
 8003b10:	18fa      	adds	r2, r7, r3
 8003b12:	687b      	ldr	r3, [r7, #4]
 8003b14:	2101      	movs	r1, #1
 8003b16:	0018      	movs	r0, r3
 8003b18:	f000 f9c6 	bl	8003ea8 <LDL_MAC_timerCheck>
 8003b1c:	1e03      	subs	r3, r0, #0
 8003b1e:	d100      	bne.n	8003b22 <LDL_MAC_process+0xf4a>
 8003b20:	e093      	b.n	8003c4a <LDL_MAC_process+0x1072>
                self->handler(self->app, LDL_MAC_CHIP_ERROR, NULL); 
 8003b22:	687a      	ldr	r2, [r7, #4]
 8003b24:	2392      	movs	r3, #146	; 0x92
 8003b26:	009b      	lsls	r3, r3, #2
 8003b28:	58d3      	ldr	r3, [r2, r3]
 8003b2a:	6879      	ldr	r1, [r7, #4]
 8003b2c:	2293      	movs	r2, #147	; 0x93
 8003b2e:	0092      	lsls	r2, r2, #2
 8003b30:	5888      	ldr	r0, [r1, r2]
 8003b32:	2200      	movs	r2, #0
 8003b34:	2100      	movs	r1, #0
 8003b36:	4798      	blx	r3
                LDL_MAC_inputClear(self);
 8003b38:	687b      	ldr	r3, [r7, #4]
 8003b3a:	0018      	movs	r0, r3
 8003b3c:	f000 fad4 	bl	80040e8 <LDL_MAC_inputClear>
                LDL_MAC_timerClear(self, LDL_TIMER_WAITA);
 8003b40:	687b      	ldr	r3, [r7, #4]
 8003b42:	2100      	movs	r1, #0
 8003b44:	0018      	movs	r0, r3
 8003b46:	f000 fa13 	bl	8003f70 <LDL_MAC_timerClear>
                LDL_MAC_timerClear(self, LDL_TIMER_WAITB);
 8003b4a:	687b      	ldr	r3, [r7, #4]
 8003b4c:	2101      	movs	r1, #1
 8003b4e:	0018      	movs	r0, r3
 8003b50:	f000 fa0e 	bl	8003f70 <LDL_MAC_timerClear>
                self->state = LDL_STATE_RECOVERY_RESET;
 8003b54:	687b      	ldr	r3, [r7, #4]
 8003b56:	2203      	movs	r2, #3
 8003b58:	701a      	strb	r2, [r3, #0]
                self->op = LDL_OP_RESET;
 8003b5a:	687b      	ldr	r3, [r7, #4]
 8003b5c:	2205      	movs	r2, #5
 8003b5e:	705a      	strb	r2, [r3, #1]
                LDL_Radio_reset(self->radio, true);
 8003b60:	687a      	ldr	r2, [r7, #4]
 8003b62:	2388      	movs	r3, #136	; 0x88
 8003b64:	009b      	lsls	r3, r3, #2
 8003b66:	58d3      	ldr	r3, [r2, r3]
 8003b68:	2101      	movs	r1, #1
 8003b6a:	0018      	movs	r0, r3
 8003b6c:	f004 f9b9 	bl	8007ee2 <LDL_Radio_reset>
                LDL_MAC_timerSet(self, LDL_TIMER_WAITA, ((LDL_System_tps() + LDL_System_eps())/10000UL) + 1U);                     
 8003b70:	f006 f9b9 	bl	8009ee6 <LDL_System_tps>
 8003b74:	0004      	movs	r4, r0
 8003b76:	f006 f9bd 	bl	8009ef4 <LDL_System_eps>
 8003b7a:	0003      	movs	r3, r0
 8003b7c:	18e3      	adds	r3, r4, r3
 8003b7e:	4955      	ldr	r1, [pc, #340]	; (8003cd4 <LDL_MAC_process+0x10fc>)
 8003b80:	0018      	movs	r0, r3
 8003b82:	f7fc fac1 	bl	8000108 <__udivsi3>
 8003b86:	0003      	movs	r3, r0
 8003b88:	1c5a      	adds	r2, r3, #1
 8003b8a:	687b      	ldr	r3, [r7, #4]
 8003b8c:	2100      	movs	r1, #0
 8003b8e:	0018      	movs	r0, r3
 8003b90:	f000 f954 	bl	8003e3c <LDL_MAC_timerSet>
        break;
 8003b94:	e059      	b.n	8003c4a <LDL_MAC_process+0x1072>
    
    case LDL_STATE_RX2_LOCKOUT:
    
        if(LDL_MAC_timerCheck(self, LDL_TIMER_WAITA, &error)){
 8003b96:	23c2      	movs	r3, #194	; 0xc2
 8003b98:	005b      	lsls	r3, r3, #1
 8003b9a:	18fa      	adds	r2, r7, r3
 8003b9c:	687b      	ldr	r3, [r7, #4]
 8003b9e:	2100      	movs	r1, #0
 8003ba0:	0018      	movs	r0, r3
 8003ba2:	f000 f981 	bl	8003ea8 <LDL_MAC_timerCheck>
 8003ba6:	1e03      	subs	r3, r0, #0
 8003ba8:	d051      	beq.n	8003c4e <LDL_MAC_process+0x1076>
            
            downlinkMissingHandler(self);  
 8003baa:	687b      	ldr	r3, [r7, #4]
 8003bac:	0018      	movs	r0, r3
 8003bae:	f002 fc25 	bl	80063fc <downlinkMissingHandler>
            
#ifndef LDL_DISABLE_SESSION_UPDATE              
            pushSessionUpdate(self);
 8003bb2:	687b      	ldr	r3, [r7, #4]
 8003bb4:	0018      	movs	r0, r3
 8003bb6:	f002 feb2 	bl	800691e <pushSessionUpdate>
#endif            
        }
        break;
 8003bba:	e048      	b.n	8003c4e <LDL_MAC_process+0x1076>
    
    case LDL_STATE_WAIT_RETRY:
        
        if(self->band[LDL_BAND_RETRY] == 0U){
 8003bbc:	687a      	ldr	r2, [r7, #4]
 8003bbe:	2396      	movs	r3, #150	; 0x96
 8003bc0:	005b      	lsls	r3, r3, #1
 8003bc2:	58d3      	ldr	r3, [r2, r3]
 8003bc4:	2b00      	cmp	r3, #0
 8003bc6:	d144      	bne.n	8003c52 <LDL_MAC_process+0x107a>
                
            if(self->band[LDL_BAND_GLOBAL] == 0UL){
 8003bc8:	687a      	ldr	r2, [r7, #4]
 8003bca:	2394      	movs	r3, #148	; 0x94
 8003bcc:	005b      	lsls	r3, r3, #1
 8003bce:	58d3      	ldr	r3, [r2, r3]
 8003bd0:	2b00      	cmp	r3, #0
 8003bd2:	d13e      	bne.n	8003c52 <LDL_MAC_process+0x107a>
                //CHANGE HERE
                uint32_t delay = (self->state == LDL_STATE_WAIT_RETRY) ? ((LDL_System_tps()*10UL)) : 0UL;
 8003bd4:	687b      	ldr	r3, [r7, #4]
 8003bd6:	781b      	ldrb	r3, [r3, #0]
 8003bd8:	2b0e      	cmp	r3, #14
 8003bda:	d107      	bne.n	8003bec <LDL_MAC_process+0x1014>
 8003bdc:	f006 f983 	bl	8009ee6 <LDL_System_tps>
 8003be0:	0002      	movs	r2, r0
 8003be2:	0013      	movs	r3, r2
 8003be4:	009b      	lsls	r3, r3, #2
 8003be6:	189b      	adds	r3, r3, r2
 8003be8:	005b      	lsls	r3, r3, #1
 8003bea:	e000      	b.n	8003bee <LDL_MAC_process+0x1016>
 8003bec:	2300      	movs	r3, #0
 8003bee:	24da      	movs	r4, #218	; 0xda
 8003bf0:	0064      	lsls	r4, r4, #1
 8003bf2:	193a      	adds	r2, r7, r4
 8003bf4:	6013      	str	r3, [r2, #0]
                            
                LDL_DEBUG(self->app, "dither retry by %"PRIu32" ticks", delay)
 8003bf6:	4b38      	ldr	r3, [pc, #224]	; (8003cd8 <LDL_MAC_process+0x1100>)
 8003bf8:	0018      	movs	r0, r3
 8003bfa:	f008 fe77 	bl	800c8ec <iprintf>
 8003bfe:	193b      	adds	r3, r7, r4
 8003c00:	681a      	ldr	r2, [r3, #0]
 8003c02:	4b36      	ldr	r3, [pc, #216]	; (8003cdc <LDL_MAC_process+0x1104>)
 8003c04:	0011      	movs	r1, r2
 8003c06:	0018      	movs	r0, r3
 8003c08:	f008 fe70 	bl	800c8ec <iprintf>
 8003c0c:	4b34      	ldr	r3, [pc, #208]	; (8003ce0 <LDL_MAC_process+0x1108>)
 8003c0e:	0018      	movs	r0, r3
 8003c10:	f008 fee6 	bl	800c9e0 <puts>
                        
                LDL_MAC_timerSet(self, LDL_TIMER_WAITA, delay);
 8003c14:	193b      	adds	r3, r7, r4
 8003c16:	681a      	ldr	r2, [r3, #0]
 8003c18:	687b      	ldr	r3, [r7, #4]
 8003c1a:	2100      	movs	r1, #0
 8003c1c:	0018      	movs	r0, r3
 8003c1e:	f000 f90d 	bl	8003e3c <LDL_MAC_timerSet>
                self->state = LDL_STATE_WAIT_TX;
 8003c22:	687b      	ldr	r3, [r7, #4]
 8003c24:	2207      	movs	r2, #7
 8003c26:	701a      	strb	r2, [r3, #0]
            }                            
        }
        break;    
 8003c28:	e013      	b.n	8003c52 <LDL_MAC_process+0x107a>
        break;    
 8003c2a:	46c0      	nop			; (mov r8, r8)
 8003c2c:	e012      	b.n	8003c54 <LDL_MAC_process+0x107c>
        break;
 8003c2e:	46c0      	nop			; (mov r8, r8)
 8003c30:	e010      	b.n	8003c54 <LDL_MAC_process+0x107c>
        break;
 8003c32:	46c0      	nop			; (mov r8, r8)
 8003c34:	e00e      	b.n	8003c54 <LDL_MAC_process+0x107c>
        break;
 8003c36:	46c0      	nop			; (mov r8, r8)
 8003c38:	e00c      	b.n	8003c54 <LDL_MAC_process+0x107c>
        break;
 8003c3a:	46c0      	nop			; (mov r8, r8)
 8003c3c:	e00a      	b.n	8003c54 <LDL_MAC_process+0x107c>
        break;
 8003c3e:	46c0      	nop			; (mov r8, r8)
 8003c40:	e008      	b.n	8003c54 <LDL_MAC_process+0x107c>
        break;
 8003c42:	46c0      	nop			; (mov r8, r8)
 8003c44:	e006      	b.n	8003c54 <LDL_MAC_process+0x107c>
        break;
 8003c46:	46c0      	nop			; (mov r8, r8)
 8003c48:	e004      	b.n	8003c54 <LDL_MAC_process+0x107c>
        break;
 8003c4a:	46c0      	nop			; (mov r8, r8)
 8003c4c:	e002      	b.n	8003c54 <LDL_MAC_process+0x107c>
        break;
 8003c4e:	46c0      	nop			; (mov r8, r8)
 8003c50:	e000      	b.n	8003c54 <LDL_MAC_process+0x107c>
        break;    
 8003c52:	46c0      	nop			; (mov r8, r8)
    }
    
    {
        uint32_t next = nextBandEvent(self);     
 8003c54:	687b      	ldr	r3, [r7, #4]
 8003c56:	0018      	movs	r0, r3
 8003c58:	f002 fba0 	bl	800639c <nextBandEvent>
 8003c5c:	0003      	movs	r3, r0
 8003c5e:	24c4      	movs	r4, #196	; 0xc4
 8003c60:	0064      	lsls	r4, r4, #1
 8003c62:	193a      	adds	r2, r7, r4
 8003c64:	6013      	str	r3, [r2, #0]
            
        if(next < ticksToMSCoarse(60UL*LDL_System_tps())){
 8003c66:	f006 f93e 	bl	8009ee6 <LDL_System_tps>
 8003c6a:	0002      	movs	r2, r0
 8003c6c:	0013      	movs	r3, r2
 8003c6e:	011b      	lsls	r3, r3, #4
 8003c70:	1a9b      	subs	r3, r3, r2
 8003c72:	009b      	lsls	r3, r3, #2
 8003c74:	0018      	movs	r0, r3
 8003c76:	f002 fdcd 	bl	8006814 <ticksToMSCoarse>
 8003c7a:	0002      	movs	r2, r0
 8003c7c:	193b      	adds	r3, r7, r4
 8003c7e:	681b      	ldr	r3, [r3, #0]
 8003c80:	4293      	cmp	r3, r2
 8003c82:	d215      	bcs.n	8003cb0 <LDL_MAC_process+0x10d8>
            
            LDL_MAC_timerSet(self, LDL_TIMER_BAND, LDL_System_tps() / 1000UL * (next+1U));                    
 8003c84:	f006 f92f 	bl	8009ee6 <LDL_System_tps>
 8003c88:	0002      	movs	r2, r0
 8003c8a:	23fa      	movs	r3, #250	; 0xfa
 8003c8c:	0099      	lsls	r1, r3, #2
 8003c8e:	0010      	movs	r0, r2
 8003c90:	f7fc fa3a 	bl	8000108 <__udivsi3>
 8003c94:	0003      	movs	r3, r0
 8003c96:	001a      	movs	r2, r3
 8003c98:	23c4      	movs	r3, #196	; 0xc4
 8003c9a:	005b      	lsls	r3, r3, #1
 8003c9c:	18fb      	adds	r3, r7, r3
 8003c9e:	681b      	ldr	r3, [r3, #0]
 8003ca0:	3301      	adds	r3, #1
 8003ca2:	435a      	muls	r2, r3
 8003ca4:	687b      	ldr	r3, [r7, #4]
 8003ca6:	2102      	movs	r1, #2
 8003ca8:	0018      	movs	r0, r3
 8003caa:	f000 f8c7 	bl	8003e3c <LDL_MAC_timerSet>
        else{
        
            LDL_MAC_timerSet(self, LDL_TIMER_BAND, 60UL*LDL_System_tps());                    
        }
    }       
}
 8003cae:	e00c      	b.n	8003cca <LDL_MAC_process+0x10f2>
            LDL_MAC_timerSet(self, LDL_TIMER_BAND, 60UL*LDL_System_tps());                    
 8003cb0:	f006 f919 	bl	8009ee6 <LDL_System_tps>
 8003cb4:	0002      	movs	r2, r0
 8003cb6:	0013      	movs	r3, r2
 8003cb8:	011b      	lsls	r3, r3, #4
 8003cba:	1a9b      	subs	r3, r3, r2
 8003cbc:	009b      	lsls	r3, r3, #2
 8003cbe:	001a      	movs	r2, r3
 8003cc0:	687b      	ldr	r3, [r7, #4]
 8003cc2:	2102      	movs	r1, #2
 8003cc4:	0018      	movs	r0, r3
 8003cc6:	f000 f8b9 	bl	8003e3c <LDL_MAC_timerSet>
}
 8003cca:	46c0      	nop			; (mov r8, r8)
 8003ccc:	46bd      	mov	sp, r7
 8003cce:	b071      	add	sp, #452	; 0x1c4
 8003cd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003cd2:	46c0      	nop			; (mov r8, r8)
 8003cd4:	00002710 	.word	0x00002710
 8003cd8:	0800d8e8 	.word	0x0800d8e8
 8003cdc:	0800d910 	.word	0x0800d910
 8003ce0:	0800d8e4 	.word	0x0800d8e4

08003ce4 <LDL_MAC_ready>:
    pushSessionUpdate(self);       
#endif     
}

bool LDL_MAC_ready(const struct ldl_mac *self)
{
 8003ce4:	b580      	push	{r7, lr}
 8003ce6:	b084      	sub	sp, #16
 8003ce8:	af00      	add	r7, sp, #0
 8003cea:	6078      	str	r0, [r7, #4]
    LDL_PEDANTIC(self != NULL)
    
    bool retval = false;
 8003cec:	230f      	movs	r3, #15
 8003cee:	18fb      	adds	r3, r7, r3
 8003cf0:	2200      	movs	r2, #0
 8003cf2:	701a      	strb	r2, [r3, #0]
    
    if(self->state == LDL_STATE_IDLE){
 8003cf4:	687b      	ldr	r3, [r7, #4]
 8003cf6:	781b      	ldrb	r3, [r3, #0]
 8003cf8:	2b06      	cmp	r3, #6
 8003cfa:	d10e      	bne.n	8003d1a <LDL_MAC_ready+0x36>
        
        retval = (msUntilNextChannel(self, self->ctx.rate) == 0UL);
 8003cfc:	687a      	ldr	r2, [r7, #4]
 8003cfe:	23f6      	movs	r3, #246	; 0xf6
 8003d00:	33ff      	adds	r3, #255	; 0xff
 8003d02:	5cd2      	ldrb	r2, [r2, r3]
 8003d04:	687b      	ldr	r3, [r7, #4]
 8003d06:	0011      	movs	r1, r2
 8003d08:	0018      	movs	r0, r3
 8003d0a:	f002 fd9a 	bl	8006842 <msUntilNextChannel>
 8003d0e:	0002      	movs	r2, r0
 8003d10:	230f      	movs	r3, #15
 8003d12:	18fb      	adds	r3, r7, r3
 8003d14:	4251      	negs	r1, r2
 8003d16:	414a      	adcs	r2, r1
 8003d18:	701a      	strb	r2, [r3, #0]
    }
    
    return retval;
 8003d1a:	230f      	movs	r3, #15
 8003d1c:	18fb      	adds	r3, r7, r3
 8003d1e:	781b      	ldrb	r3, [r3, #0]
}
 8003d20:	0018      	movs	r0, r3
 8003d22:	46bd      	mov	sp, r7
 8003d24:	b004      	add	sp, #16
 8003d26:	bd80      	pop	{r7, pc}

08003d28 <LDL_MAC_bwToNumber>:

uint32_t LDL_MAC_bwToNumber(enum ldl_signal_bandwidth bw)
{
 8003d28:	b580      	push	{r7, lr}
 8003d2a:	b084      	sub	sp, #16
 8003d2c:	af00      	add	r7, sp, #0
 8003d2e:	0002      	movs	r2, r0
 8003d30:	1dfb      	adds	r3, r7, #7
 8003d32:	701a      	strb	r2, [r3, #0]
    uint32_t retval;
    
    switch(bw){
 8003d34:	1dfb      	adds	r3, r7, #7
 8003d36:	781b      	ldrb	r3, [r3, #0]
 8003d38:	2b01      	cmp	r3, #1
 8003d3a:	d004      	beq.n	8003d46 <LDL_MAC_bwToNumber+0x1e>
 8003d3c:	2b02      	cmp	r3, #2
 8003d3e:	d005      	beq.n	8003d4c <LDL_MAC_bwToNumber+0x24>
    default:
    case LDL_BW_125:
        retval = 125000UL;
 8003d40:	4b06      	ldr	r3, [pc, #24]	; (8003d5c <LDL_MAC_bwToNumber+0x34>)
 8003d42:	60fb      	str	r3, [r7, #12]
        break;        
 8003d44:	e005      	b.n	8003d52 <LDL_MAC_bwToNumber+0x2a>
    case LDL_BW_250:
        retval = 250000UL;
 8003d46:	4b06      	ldr	r3, [pc, #24]	; (8003d60 <LDL_MAC_bwToNumber+0x38>)
 8003d48:	60fb      	str	r3, [r7, #12]
        break;            
 8003d4a:	e002      	b.n	8003d52 <LDL_MAC_bwToNumber+0x2a>
    case LDL_BW_500:
        retval = 500000UL;
 8003d4c:	4b05      	ldr	r3, [pc, #20]	; (8003d64 <LDL_MAC_bwToNumber+0x3c>)
 8003d4e:	60fb      	str	r3, [r7, #12]
        break;                
 8003d50:	46c0      	nop			; (mov r8, r8)
    }
    
    return retval;
 8003d52:	68fb      	ldr	r3, [r7, #12]
}
 8003d54:	0018      	movs	r0, r3
 8003d56:	46bd      	mov	sp, r7
 8003d58:	b004      	add	sp, #16
 8003d5a:	bd80      	pop	{r7, pc}
 8003d5c:	0001e848 	.word	0x0001e848
 8003d60:	0003d090 	.word	0x0003d090
 8003d64:	0007a120 	.word	0x0007a120

08003d68 <LDL_MAC_radioEvent>:

void LDL_MAC_radioEvent(struct ldl_mac *self, enum ldl_radio_event event)
{
 8003d68:	b580      	push	{r7, lr}
 8003d6a:	b082      	sub	sp, #8
 8003d6c:	af00      	add	r7, sp, #0
 8003d6e:	6078      	str	r0, [r7, #4]
 8003d70:	000a      	movs	r2, r1
 8003d72:	1cfb      	adds	r3, r7, #3
 8003d74:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(self != NULL)
    
    switch(event){
 8003d76:	1cfb      	adds	r3, r7, #3
 8003d78:	781b      	ldrb	r3, [r3, #0]
 8003d7a:	2b01      	cmp	r3, #1
 8003d7c:	d00a      	beq.n	8003d94 <LDL_MAC_radioEvent+0x2c>
 8003d7e:	2b02      	cmp	r3, #2
 8003d80:	d00e      	beq.n	8003da0 <LDL_MAC_radioEvent+0x38>
 8003d82:	2b00      	cmp	r3, #0
 8003d84:	d000      	beq.n	8003d88 <LDL_MAC_radioEvent+0x20>
    case LDL_RADIO_EVENT_RX_TIMEOUT:
        LDL_MAC_inputSignal(self, LDL_INPUT_RX_TIMEOUT);        
        break;
    case LDL_RADIO_EVENT_NONE:
    default:
        break;
 8003d86:	e011      	b.n	8003dac <LDL_MAC_radioEvent+0x44>
        LDL_MAC_inputSignal(self, LDL_INPUT_TX_COMPLETE);
 8003d88:	687b      	ldr	r3, [r7, #4]
 8003d8a:	2100      	movs	r1, #0
 8003d8c:	0018      	movs	r0, r3
 8003d8e:	f000 f903 	bl	8003f98 <LDL_MAC_inputSignal>
        break;
 8003d92:	e00b      	b.n	8003dac <LDL_MAC_radioEvent+0x44>
        LDL_MAC_inputSignal(self, LDL_INPUT_RX_READY);
 8003d94:	687b      	ldr	r3, [r7, #4]
 8003d96:	2101      	movs	r1, #1
 8003d98:	0018      	movs	r0, r3
 8003d9a:	f000 f8fd 	bl	8003f98 <LDL_MAC_inputSignal>
        break;
 8003d9e:	e005      	b.n	8003dac <LDL_MAC_radioEvent+0x44>
        LDL_MAC_inputSignal(self, LDL_INPUT_RX_TIMEOUT);        
 8003da0:	687b      	ldr	r3, [r7, #4]
 8003da2:	2102      	movs	r1, #2
 8003da4:	0018      	movs	r0, r3
 8003da6:	f000 f8f7 	bl	8003f98 <LDL_MAC_inputSignal>
        break;
 8003daa:	46c0      	nop			; (mov r8, r8)
    }     
}
 8003dac:	46c0      	nop			; (mov r8, r8)
 8003dae:	46bd      	mov	sp, r7
 8003db0:	b002      	add	sp, #8
 8003db2:	bd80      	pop	{r7, pc}

08003db4 <LDL_MAC_addChannel>:
    
    return self->ctx.maxDutyCycle;
}

bool LDL_MAC_addChannel(struct ldl_mac *self, uint8_t chIndex, uint32_t freq, uint8_t minRate, uint8_t maxRate)
{
 8003db4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003db6:	b087      	sub	sp, #28
 8003db8:	af02      	add	r7, sp, #8
 8003dba:	60f8      	str	r0, [r7, #12]
 8003dbc:	0008      	movs	r0, r1
 8003dbe:	607a      	str	r2, [r7, #4]
 8003dc0:	0019      	movs	r1, r3
 8003dc2:	250b      	movs	r5, #11
 8003dc4:	197b      	adds	r3, r7, r5
 8003dc6:	1c02      	adds	r2, r0, #0
 8003dc8:	701a      	strb	r2, [r3, #0]
 8003dca:	240a      	movs	r4, #10
 8003dcc:	193b      	adds	r3, r7, r4
 8003dce:	1c0a      	adds	r2, r1, #0
 8003dd0:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(self != NULL)
    
    LDL_DEBUG(self->app, "adding chIndex=%u freq=%"PRIu32" minRate=%u maxRate=%u", chIndex, freq, minRate, maxRate)
 8003dd2:	4b17      	ldr	r3, [pc, #92]	; (8003e30 <LDL_MAC_addChannel+0x7c>)
 8003dd4:	0018      	movs	r0, r3
 8003dd6:	f008 fd89 	bl	800c8ec <iprintf>
 8003dda:	197b      	adds	r3, r7, r5
 8003ddc:	7819      	ldrb	r1, [r3, #0]
 8003dde:	0026      	movs	r6, r4
 8003de0:	193b      	adds	r3, r7, r4
 8003de2:	781c      	ldrb	r4, [r3, #0]
 8003de4:	2320      	movs	r3, #32
 8003de6:	2208      	movs	r2, #8
 8003de8:	4694      	mov	ip, r2
 8003dea:	44bc      	add	ip, r7
 8003dec:	4463      	add	r3, ip
 8003dee:	781b      	ldrb	r3, [r3, #0]
 8003df0:	687a      	ldr	r2, [r7, #4]
 8003df2:	4810      	ldr	r0, [pc, #64]	; (8003e34 <LDL_MAC_addChannel+0x80>)
 8003df4:	9300      	str	r3, [sp, #0]
 8003df6:	0023      	movs	r3, r4
 8003df8:	f008 fd78 	bl	800c8ec <iprintf>
 8003dfc:	4b0e      	ldr	r3, [pc, #56]	; (8003e38 <LDL_MAC_addChannel+0x84>)
 8003dfe:	0018      	movs	r0, r3
 8003e00:	f008 fdee 	bl	800c9e0 <puts>
    
    return setChannel(self, chIndex, freq, minRate, maxRate);
 8003e04:	0034      	movs	r4, r6
 8003e06:	193b      	adds	r3, r7, r4
 8003e08:	781c      	ldrb	r4, [r3, #0]
 8003e0a:	687a      	ldr	r2, [r7, #4]
 8003e0c:	197b      	adds	r3, r7, r5
 8003e0e:	7819      	ldrb	r1, [r3, #0]
 8003e10:	68f8      	ldr	r0, [r7, #12]
 8003e12:	2320      	movs	r3, #32
 8003e14:	2508      	movs	r5, #8
 8003e16:	46ac      	mov	ip, r5
 8003e18:	44bc      	add	ip, r7
 8003e1a:	4463      	add	r3, ip
 8003e1c:	781b      	ldrb	r3, [r3, #0]
 8003e1e:	9300      	str	r3, [sp, #0]
 8003e20:	0023      	movs	r3, r4
 8003e22:	f002 f824 	bl	8005e6e <setChannel>
 8003e26:	0003      	movs	r3, r0
}
 8003e28:	0018      	movs	r0, r3
 8003e2a:	46bd      	mov	sp, r7
 8003e2c:	b005      	add	sp, #20
 8003e2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003e30:	0800d8e8 	.word	0x0800d8e8
 8003e34:	0800d92c 	.word	0x0800d92c
 8003e38:	0800d8e4 	.word	0x0800d8e4

08003e3c <LDL_MAC_timerSet>:
    
    return unmaskChannel(self->ctx.chMask, sizeof(self->ctx.chMask), self->region, chIndex);
}

void LDL_MAC_timerSet(struct ldl_mac *self, enum ldl_timer_inst timer, uint32_t timeout)
{
 8003e3c:	b590      	push	{r4, r7, lr}
 8003e3e:	b089      	sub	sp, #36	; 0x24
 8003e40:	af00      	add	r7, sp, #0
 8003e42:	60f8      	str	r0, [r7, #12]
 8003e44:	607a      	str	r2, [r7, #4]
 8003e46:	240b      	movs	r4, #11
 8003e48:	193b      	adds	r3, r7, r4
 8003e4a:	1c0a      	adds	r2, r1, #0
 8003e4c:	701a      	strb	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8003e4e:	f3ef 8310 	mrs	r3, PRIMASK
 8003e52:	61bb      	str	r3, [r7, #24]
  return(result);
 8003e54:	69bb      	ldr	r3, [r7, #24]
    LDL_SYSTEM_ENTER_CRITICAL(self->app)
 8003e56:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 8003e58:	b672      	cpsid	i
   
    self->timers[timer].time = LDL_System_ticks(self->app) + (timeout & INT32_MAX);
 8003e5a:	68fa      	ldr	r2, [r7, #12]
 8003e5c:	2393      	movs	r3, #147	; 0x93
 8003e5e:	009b      	lsls	r3, r3, #2
 8003e60:	58d3      	ldr	r3, [r2, r3]
 8003e62:	0018      	movs	r0, r3
 8003e64:	f006 f834 	bl	8009ed0 <LDL_System_ticks>
 8003e68:	0001      	movs	r1, r0
 8003e6a:	687b      	ldr	r3, [r7, #4]
 8003e6c:	005b      	lsls	r3, r3, #1
 8003e6e:	085a      	lsrs	r2, r3, #1
 8003e70:	193b      	adds	r3, r7, r4
 8003e72:	781b      	ldrb	r3, [r3, #0]
 8003e74:	188a      	adds	r2, r1, r2
 8003e76:	68f9      	ldr	r1, [r7, #12]
 8003e78:	3345      	adds	r3, #69	; 0x45
 8003e7a:	00db      	lsls	r3, r3, #3
 8003e7c:	18cb      	adds	r3, r1, r3
 8003e7e:	3304      	adds	r3, #4
 8003e80:	601a      	str	r2, [r3, #0]
    self->timers[timer].armed = true;
 8003e82:	193b      	adds	r3, r7, r4
 8003e84:	781b      	ldrb	r3, [r3, #0]
 8003e86:	68fa      	ldr	r2, [r7, #12]
 8003e88:	3345      	adds	r3, #69	; 0x45
 8003e8a:	00db      	lsls	r3, r3, #3
 8003e8c:	18d3      	adds	r3, r2, r3
 8003e8e:	3308      	adds	r3, #8
 8003e90:	2201      	movs	r2, #1
 8003e92:	701a      	strb	r2, [r3, #0]
    
    LDL_SYSTEM_LEAVE_CRITICAL(self->app)
 8003e94:	697b      	ldr	r3, [r7, #20]
 8003e96:	61fb      	str	r3, [r7, #28]
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003e98:	69fb      	ldr	r3, [r7, #28]
 8003e9a:	f383 8810 	msr	PRIMASK, r3
}
 8003e9e:	46c0      	nop			; (mov r8, r8)
 8003ea0:	46bd      	mov	sp, r7
 8003ea2:	b009      	add	sp, #36	; 0x24
 8003ea4:	bd90      	pop	{r4, r7, pc}
	...

08003ea8 <LDL_MAC_timerCheck>:
    
    LDL_SYSTEM_LEAVE_CRITICAL(self->app)
}

bool LDL_MAC_timerCheck(struct ldl_mac *self, enum ldl_timer_inst timer, uint32_t *error)
{
 8003ea8:	b580      	push	{r7, lr}
 8003eaa:	b08a      	sub	sp, #40	; 0x28
 8003eac:	af00      	add	r7, sp, #0
 8003eae:	60f8      	str	r0, [r7, #12]
 8003eb0:	607a      	str	r2, [r7, #4]
 8003eb2:	200b      	movs	r0, #11
 8003eb4:	183b      	adds	r3, r7, r0
 8003eb6:	1c0a      	adds	r2, r1, #0
 8003eb8:	701a      	strb	r2, [r3, #0]
    bool retval = false;
 8003eba:	2327      	movs	r3, #39	; 0x27
 8003ebc:	18fb      	adds	r3, r7, r3
 8003ebe:	2200      	movs	r2, #0
 8003ec0:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8003ec2:	f3ef 8310 	mrs	r3, PRIMASK
 8003ec6:	61fb      	str	r3, [r7, #28]
  return(result);
 8003ec8:	69fb      	ldr	r3, [r7, #28]
    uint32_t time;
    
    LDL_SYSTEM_ENTER_CRITICAL(self->app)
 8003eca:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 8003ecc:	b672      	cpsid	i
        
    if(self->timers[timer].armed){
 8003ece:	183b      	adds	r3, r7, r0
 8003ed0:	781b      	ldrb	r3, [r3, #0]
 8003ed2:	68fa      	ldr	r2, [r7, #12]
 8003ed4:	3345      	adds	r3, #69	; 0x45
 8003ed6:	00db      	lsls	r3, r3, #3
 8003ed8:	18d3      	adds	r3, r2, r3
 8003eda:	3308      	adds	r3, #8
 8003edc:	781b      	ldrb	r3, [r3, #0]
 8003ede:	2b00      	cmp	r3, #0
 8003ee0:	d038      	beq.n	8003f54 <LDL_MAC_timerCheck+0xac>
        
        time = LDL_System_ticks(self->app);
 8003ee2:	68fa      	ldr	r2, [r7, #12]
 8003ee4:	2393      	movs	r3, #147	; 0x93
 8003ee6:	009b      	lsls	r3, r3, #2
 8003ee8:	58d3      	ldr	r3, [r2, r3]
 8003eea:	0018      	movs	r0, r3
 8003eec:	f005 fff0 	bl	8009ed0 <LDL_System_ticks>
 8003ef0:	0003      	movs	r3, r0
 8003ef2:	623b      	str	r3, [r7, #32]
        
        if(timerDelta(self->timers[timer].time, time) < INT32_MAX){
 8003ef4:	230b      	movs	r3, #11
 8003ef6:	18fb      	adds	r3, r7, r3
 8003ef8:	781b      	ldrb	r3, [r3, #0]
 8003efa:	68fa      	ldr	r2, [r7, #12]
 8003efc:	3345      	adds	r3, #69	; 0x45
 8003efe:	00db      	lsls	r3, r3, #3
 8003f00:	18d3      	adds	r3, r2, r3
 8003f02:	3304      	adds	r3, #4
 8003f04:	681b      	ldr	r3, [r3, #0]
 8003f06:	6a3a      	ldr	r2, [r7, #32]
 8003f08:	0011      	movs	r1, r2
 8003f0a:	0018      	movs	r0, r3
 8003f0c:	f002 f9b8 	bl	8006280 <timerDelta>
 8003f10:	0002      	movs	r2, r0
 8003f12:	4b16      	ldr	r3, [pc, #88]	; (8003f6c <LDL_MAC_timerCheck+0xc4>)
 8003f14:	429a      	cmp	r2, r3
 8003f16:	d81d      	bhi.n	8003f54 <LDL_MAC_timerCheck+0xac>
    
            self->timers[timer].armed = false;            
 8003f18:	210b      	movs	r1, #11
 8003f1a:	187b      	adds	r3, r7, r1
 8003f1c:	781b      	ldrb	r3, [r3, #0]
 8003f1e:	68fa      	ldr	r2, [r7, #12]
 8003f20:	3345      	adds	r3, #69	; 0x45
 8003f22:	00db      	lsls	r3, r3, #3
 8003f24:	18d3      	adds	r3, r2, r3
 8003f26:	3308      	adds	r3, #8
 8003f28:	2200      	movs	r2, #0
 8003f2a:	701a      	strb	r2, [r3, #0]
            *error = timerDelta(self->timers[timer].time, time);
 8003f2c:	187b      	adds	r3, r7, r1
 8003f2e:	781b      	ldrb	r3, [r3, #0]
 8003f30:	68fa      	ldr	r2, [r7, #12]
 8003f32:	3345      	adds	r3, #69	; 0x45
 8003f34:	00db      	lsls	r3, r3, #3
 8003f36:	18d3      	adds	r3, r2, r3
 8003f38:	3304      	adds	r3, #4
 8003f3a:	681b      	ldr	r3, [r3, #0]
 8003f3c:	6a3a      	ldr	r2, [r7, #32]
 8003f3e:	0011      	movs	r1, r2
 8003f40:	0018      	movs	r0, r3
 8003f42:	f002 f99d 	bl	8006280 <timerDelta>
 8003f46:	0002      	movs	r2, r0
 8003f48:	687b      	ldr	r3, [r7, #4]
 8003f4a:	601a      	str	r2, [r3, #0]
            retval = true;
 8003f4c:	2327      	movs	r3, #39	; 0x27
 8003f4e:	18fb      	adds	r3, r7, r3
 8003f50:	2201      	movs	r2, #1
 8003f52:	701a      	strb	r2, [r3, #0]
        }
    }    
    
    LDL_SYSTEM_LEAVE_CRITICAL(self->app)
 8003f54:	697b      	ldr	r3, [r7, #20]
 8003f56:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003f58:	69bb      	ldr	r3, [r7, #24]
 8003f5a:	f383 8810 	msr	PRIMASK, r3
    
    return retval;
 8003f5e:	2327      	movs	r3, #39	; 0x27
 8003f60:	18fb      	adds	r3, r7, r3
 8003f62:	781b      	ldrb	r3, [r3, #0]
}
 8003f64:	0018      	movs	r0, r3
 8003f66:	46bd      	mov	sp, r7
 8003f68:	b00a      	add	sp, #40	; 0x28
 8003f6a:	bd80      	pop	{r7, pc}
 8003f6c:	7ffffffe 	.word	0x7ffffffe

08003f70 <LDL_MAC_timerClear>:

void LDL_MAC_timerClear(struct ldl_mac *self, enum ldl_timer_inst timer)
{
 8003f70:	b580      	push	{r7, lr}
 8003f72:	b082      	sub	sp, #8
 8003f74:	af00      	add	r7, sp, #0
 8003f76:	6078      	str	r0, [r7, #4]
 8003f78:	000a      	movs	r2, r1
 8003f7a:	1cfb      	adds	r3, r7, #3
 8003f7c:	701a      	strb	r2, [r3, #0]
    self->timers[timer].armed = false;
 8003f7e:	1cfb      	adds	r3, r7, #3
 8003f80:	781b      	ldrb	r3, [r3, #0]
 8003f82:	687a      	ldr	r2, [r7, #4]
 8003f84:	3345      	adds	r3, #69	; 0x45
 8003f86:	00db      	lsls	r3, r3, #3
 8003f88:	18d3      	adds	r3, r2, r3
 8003f8a:	3308      	adds	r3, #8
 8003f8c:	2200      	movs	r2, #0
 8003f8e:	701a      	strb	r2, [r3, #0]
}
 8003f90:	46c0      	nop			; (mov r8, r8)
 8003f92:	46bd      	mov	sp, r7
 8003f94:	b002      	add	sp, #8
 8003f96:	bd80      	pop	{r7, pc}

08003f98 <LDL_MAC_inputSignal>:
    
    return retval;
}

void LDL_MAC_inputSignal(struct ldl_mac *self, enum ldl_input_type type)
{
 8003f98:	b580      	push	{r7, lr}
 8003f9a:	b086      	sub	sp, #24
 8003f9c:	af00      	add	r7, sp, #0
 8003f9e:	6078      	str	r0, [r7, #4]
 8003fa0:	000a      	movs	r2, r1
 8003fa2:	1cfb      	adds	r3, r7, #3
 8003fa4:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8003fa6:	f3ef 8310 	mrs	r3, PRIMASK
 8003faa:	617b      	str	r3, [r7, #20]
  return(result);
 8003fac:	697b      	ldr	r3, [r7, #20]
    LDL_SYSTEM_ENTER_CRITICAL(self->app)
 8003fae:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("cpsid i" : : : "memory");
 8003fb0:	b672      	cpsid	i
    
    if(self->inputs.state == 0U){
 8003fb2:	687b      	ldr	r3, [r7, #4]
 8003fb4:	4a16      	ldr	r2, [pc, #88]	; (8004010 <LDL_MAC_inputSignal+0x78>)
 8003fb6:	5c9b      	ldrb	r3, [r3, r2]
 8003fb8:	2b00      	cmp	r3, #0
 8003fba:	d120      	bne.n	8003ffe <LDL_MAC_inputSignal+0x66>
    
        if((self->inputs.armed & (1U << type)) > 0U){
 8003fbc:	687a      	ldr	r2, [r7, #4]
 8003fbe:	2389      	movs	r3, #137	; 0x89
 8003fc0:	009b      	lsls	r3, r3, #2
 8003fc2:	5cd3      	ldrb	r3, [r2, r3]
 8003fc4:	001a      	movs	r2, r3
 8003fc6:	1cfb      	adds	r3, r7, #3
 8003fc8:	781b      	ldrb	r3, [r3, #0]
 8003fca:	40da      	lsrs	r2, r3
 8003fcc:	0013      	movs	r3, r2
 8003fce:	2201      	movs	r2, #1
 8003fd0:	4013      	ands	r3, r2
 8003fd2:	d014      	beq.n	8003ffe <LDL_MAC_inputSignal+0x66>
    
            self->inputs.time = LDL_System_ticks(self->app);
 8003fd4:	687a      	ldr	r2, [r7, #4]
 8003fd6:	2393      	movs	r3, #147	; 0x93
 8003fd8:	009b      	lsls	r3, r3, #2
 8003fda:	58d3      	ldr	r3, [r2, r3]
 8003fdc:	0018      	movs	r0, r3
 8003fde:	f005 ff77 	bl	8009ed0 <LDL_System_ticks>
 8003fe2:	0001      	movs	r1, r0
 8003fe4:	687a      	ldr	r2, [r7, #4]
 8003fe6:	238a      	movs	r3, #138	; 0x8a
 8003fe8:	009b      	lsls	r3, r3, #2
 8003fea:	50d1      	str	r1, [r2, r3]
            self->inputs.state = (1U << type);
 8003fec:	1cfb      	adds	r3, r7, #3
 8003fee:	781b      	ldrb	r3, [r3, #0]
 8003ff0:	2201      	movs	r2, #1
 8003ff2:	409a      	lsls	r2, r3
 8003ff4:	0013      	movs	r3, r2
 8003ff6:	b2d9      	uxtb	r1, r3
 8003ff8:	687b      	ldr	r3, [r7, #4]
 8003ffa:	4a05      	ldr	r2, [pc, #20]	; (8004010 <LDL_MAC_inputSignal+0x78>)
 8003ffc:	5499      	strb	r1, [r3, r2]
        }
    }
    
    LDL_SYSTEM_LEAVE_CRITICAL(self->app)
 8003ffe:	68fb      	ldr	r3, [r7, #12]
 8004000:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004002:	693b      	ldr	r3, [r7, #16]
 8004004:	f383 8810 	msr	PRIMASK, r3
}
 8004008:	46c0      	nop			; (mov r8, r8)
 800400a:	46bd      	mov	sp, r7
 800400c:	b006      	add	sp, #24
 800400e:	bd80      	pop	{r7, pc}
 8004010:	00000225 	.word	0x00000225

08004014 <LDL_MAC_inputArm>:

void LDL_MAC_inputArm(struct ldl_mac *self, enum ldl_input_type type)
{
 8004014:	b580      	push	{r7, lr}
 8004016:	b086      	sub	sp, #24
 8004018:	af00      	add	r7, sp, #0
 800401a:	6078      	str	r0, [r7, #4]
 800401c:	000a      	movs	r2, r1
 800401e:	1cfb      	adds	r3, r7, #3
 8004020:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8004022:	f3ef 8310 	mrs	r3, PRIMASK
 8004026:	613b      	str	r3, [r7, #16]
  return(result);
 8004028:	693b      	ldr	r3, [r7, #16]
    LDL_SYSTEM_ENTER_CRITICAL(self->app) 
 800402a:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("cpsid i" : : : "memory");
 800402c:	b672      	cpsid	i
    
    self->inputs.armed |= (1U << type);
 800402e:	687a      	ldr	r2, [r7, #4]
 8004030:	2389      	movs	r3, #137	; 0x89
 8004032:	009b      	lsls	r3, r3, #2
 8004034:	5cd2      	ldrb	r2, [r2, r3]
 8004036:	1cfb      	adds	r3, r7, #3
 8004038:	781b      	ldrb	r3, [r3, #0]
 800403a:	2101      	movs	r1, #1
 800403c:	4099      	lsls	r1, r3
 800403e:	000b      	movs	r3, r1
 8004040:	b2db      	uxtb	r3, r3
 8004042:	4313      	orrs	r3, r2
 8004044:	b2d9      	uxtb	r1, r3
 8004046:	687a      	ldr	r2, [r7, #4]
 8004048:	2389      	movs	r3, #137	; 0x89
 800404a:	009b      	lsls	r3, r3, #2
 800404c:	54d1      	strb	r1, [r2, r3]
    
    LDL_SYSTEM_LEAVE_CRITICAL(self->app)     
 800404e:	68fb      	ldr	r3, [r7, #12]
 8004050:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004052:	697b      	ldr	r3, [r7, #20]
 8004054:	f383 8810 	msr	PRIMASK, r3
}
 8004058:	46c0      	nop			; (mov r8, r8)
 800405a:	46bd      	mov	sp, r7
 800405c:	b006      	add	sp, #24
 800405e:	bd80      	pop	{r7, pc}

08004060 <LDL_MAC_inputCheck>:

bool LDL_MAC_inputCheck(const struct ldl_mac *self, enum ldl_input_type type, uint32_t *error)
{
 8004060:	b590      	push	{r4, r7, lr}
 8004062:	b089      	sub	sp, #36	; 0x24
 8004064:	af00      	add	r7, sp, #0
 8004066:	60f8      	str	r0, [r7, #12]
 8004068:	607a      	str	r2, [r7, #4]
 800406a:	200b      	movs	r0, #11
 800406c:	183b      	adds	r3, r7, r0
 800406e:	1c0a      	adds	r2, r1, #0
 8004070:	701a      	strb	r2, [r3, #0]
    bool retval = false;
 8004072:	231f      	movs	r3, #31
 8004074:	18fb      	adds	r3, r7, r3
 8004076:	2200      	movs	r2, #0
 8004078:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 800407a:	f3ef 8310 	mrs	r3, PRIMASK
 800407e:	61bb      	str	r3, [r7, #24]
  return(result);
 8004080:	69bb      	ldr	r3, [r7, #24]
    
    LDL_SYSTEM_ENTER_CRITICAL(self->app)     
 8004082:	613b      	str	r3, [r7, #16]
  __ASM volatile ("cpsid i" : : : "memory");
 8004084:	b672      	cpsid	i
    
    if((self->inputs.state & (1U << type)) > 0U){
 8004086:	68fb      	ldr	r3, [r7, #12]
 8004088:	4a16      	ldr	r2, [pc, #88]	; (80040e4 <LDL_MAC_inputCheck+0x84>)
 800408a:	5c9b      	ldrb	r3, [r3, r2]
 800408c:	001a      	movs	r2, r3
 800408e:	183b      	adds	r3, r7, r0
 8004090:	781b      	ldrb	r3, [r3, #0]
 8004092:	40da      	lsrs	r2, r3
 8004094:	0013      	movs	r3, r2
 8004096:	2201      	movs	r2, #1
 8004098:	4013      	ands	r3, r2
 800409a:	d016      	beq.n	80040ca <LDL_MAC_inputCheck+0x6a>
        
        *error = timerDelta(self->inputs.time, LDL_System_ticks(self->app));
 800409c:	68fa      	ldr	r2, [r7, #12]
 800409e:	238a      	movs	r3, #138	; 0x8a
 80040a0:	009b      	lsls	r3, r3, #2
 80040a2:	58d4      	ldr	r4, [r2, r3]
 80040a4:	68fa      	ldr	r2, [r7, #12]
 80040a6:	2393      	movs	r3, #147	; 0x93
 80040a8:	009b      	lsls	r3, r3, #2
 80040aa:	58d3      	ldr	r3, [r2, r3]
 80040ac:	0018      	movs	r0, r3
 80040ae:	f005 ff0f 	bl	8009ed0 <LDL_System_ticks>
 80040b2:	0003      	movs	r3, r0
 80040b4:	0019      	movs	r1, r3
 80040b6:	0020      	movs	r0, r4
 80040b8:	f002 f8e2 	bl	8006280 <timerDelta>
 80040bc:	0002      	movs	r2, r0
 80040be:	687b      	ldr	r3, [r7, #4]
 80040c0:	601a      	str	r2, [r3, #0]
        retval = true;
 80040c2:	231f      	movs	r3, #31
 80040c4:	18fb      	adds	r3, r7, r3
 80040c6:	2201      	movs	r2, #1
 80040c8:	701a      	strb	r2, [r3, #0]
    }
    
    LDL_SYSTEM_LEAVE_CRITICAL(self->app)    
 80040ca:	693b      	ldr	r3, [r7, #16]
 80040cc:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80040ce:	697b      	ldr	r3, [r7, #20]
 80040d0:	f383 8810 	msr	PRIMASK, r3
    
    return retval;
 80040d4:	231f      	movs	r3, #31
 80040d6:	18fb      	adds	r3, r7, r3
 80040d8:	781b      	ldrb	r3, [r3, #0]
}
 80040da:	0018      	movs	r0, r3
 80040dc:	46bd      	mov	sp, r7
 80040de:	b009      	add	sp, #36	; 0x24
 80040e0:	bd90      	pop	{r4, r7, pc}
 80040e2:	46c0      	nop			; (mov r8, r8)
 80040e4:	00000225 	.word	0x00000225

080040e8 <LDL_MAC_inputClear>:

void LDL_MAC_inputClear(struct ldl_mac *self)
{
 80040e8:	b580      	push	{r7, lr}
 80040ea:	b086      	sub	sp, #24
 80040ec:	af00      	add	r7, sp, #0
 80040ee:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 80040f0:	f3ef 8310 	mrs	r3, PRIMASK
 80040f4:	613b      	str	r3, [r7, #16]
  return(result);
 80040f6:	693b      	ldr	r3, [r7, #16]
    LDL_SYSTEM_ENTER_CRITICAL(self->app)     
 80040f8:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("cpsid i" : : : "memory");
 80040fa:	b672      	cpsid	i
    
    self->inputs.state = 0U;
 80040fc:	687b      	ldr	r3, [r7, #4]
 80040fe:	4a08      	ldr	r2, [pc, #32]	; (8004120 <LDL_MAC_inputClear+0x38>)
 8004100:	2100      	movs	r1, #0
 8004102:	5499      	strb	r1, [r3, r2]
    self->inputs.armed = 0U;
 8004104:	687a      	ldr	r2, [r7, #4]
 8004106:	2389      	movs	r3, #137	; 0x89
 8004108:	009b      	lsls	r3, r3, #2
 800410a:	2100      	movs	r1, #0
 800410c:	54d1      	strb	r1, [r2, r3]
    
    LDL_SYSTEM_LEAVE_CRITICAL(self->app)   
 800410e:	68fb      	ldr	r3, [r7, #12]
 8004110:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004112:	697b      	ldr	r3, [r7, #20]
 8004114:	f383 8810 	msr	PRIMASK, r3
}
 8004118:	46c0      	nop			; (mov r8, r8)
 800411a:	46bd      	mov	sp, r7
 800411c:	b006      	add	sp, #24
 800411e:	bd80      	pop	{r7, pc}
 8004120:	00000225 	.word	0x00000225

08004124 <externalDataCommand>:
}

/* static functions ***************************************************/

static bool externalDataCommand(struct ldl_mac *self, bool confirmed, uint8_t port, const void *data, uint8_t len, const struct ldl_mac_data_opts *opts)
{
 8004124:	b5b0      	push	{r4, r5, r7, lr}
 8004126:	b09e      	sub	sp, #120	; 0x78
 8004128:	af02      	add	r7, sp, #8
 800412a:	60f8      	str	r0, [r7, #12]
 800412c:	0008      	movs	r0, r1
 800412e:	0011      	movs	r1, r2
 8004130:	607b      	str	r3, [r7, #4]
 8004132:	230b      	movs	r3, #11
 8004134:	18fb      	adds	r3, r7, r3
 8004136:	1c02      	adds	r2, r0, #0
 8004138:	701a      	strb	r2, [r3, #0]
 800413a:	230a      	movs	r3, #10
 800413c:	18fb      	adds	r3, r7, r3
 800413e:	1c0a      	adds	r2, r1, #0
 8004140:	701a      	strb	r2, [r3, #0]
    bool retval = false;
 8004142:	236f      	movs	r3, #111	; 0x6f
 8004144:	18fb      	adds	r3, r7, r3
 8004146:	2200      	movs	r2, #0
 8004148:	701a      	strb	r2, [r3, #0]
    enum ldl_spreading_factor sf;    
    struct ldl_frame_data f;
    struct ldl_stream s;
    uint8_t macs[30U]; // large enough for all possible MAC commands
                        
    self->errno = LDL_ERRNO_NONE;
 800414a:	68fb      	ldr	r3, [r7, #12]
 800414c:	2200      	movs	r2, #0
 800414e:	709a      	strb	r2, [r3, #2]

    if(self->state == LDL_STATE_IDLE){
 8004150:	68fb      	ldr	r3, [r7, #12]
 8004152:	781b      	ldrb	r3, [r3, #0]
 8004154:	2b06      	cmp	r3, #6
 8004156:	d001      	beq.n	800415c <externalDataCommand+0x38>
 8004158:	f000 fbe1 	bl	800491e <externalDataCommand+0x7fa>
        
        if(self->ctx.joined){
 800415c:	68fa      	ldr	r2, [r7, #12]
 800415e:	2381      	movs	r3, #129	; 0x81
 8004160:	009b      	lsls	r3, r3, #2
 8004162:	5cd3      	ldrb	r3, [r2, r3]
 8004164:	2b00      	cmp	r3, #0
 8004166:	d101      	bne.n	800416c <externalDataCommand+0x48>
 8004168:	f000 fbd5 	bl	8004916 <externalDataCommand+0x7f2>
        
            if((port > 0U) && (port <= 223U)){    
 800416c:	230a      	movs	r3, #10
 800416e:	18fb      	adds	r3, r7, r3
 8004170:	781b      	ldrb	r3, [r3, #0]
 8004172:	2b00      	cmp	r3, #0
 8004174:	d101      	bne.n	800417a <externalDataCommand+0x56>
 8004176:	f000 fbca 	bl	800490e <externalDataCommand+0x7ea>
 800417a:	230a      	movs	r3, #10
 800417c:	18fb      	adds	r3, r7, r3
 800417e:	781b      	ldrb	r3, [r3, #0]
 8004180:	2bdf      	cmp	r3, #223	; 0xdf
 8004182:	d901      	bls.n	8004188 <externalDataCommand+0x64>
 8004184:	f000 fbc3 	bl	800490e <externalDataCommand+0x7ea>
                
                if(self->band[LDL_BAND_GLOBAL] == 0UL){
 8004188:	68fa      	ldr	r2, [r7, #12]
 800418a:	2394      	movs	r3, #148	; 0x94
 800418c:	005b      	lsls	r3, r3, #1
 800418e:	58d3      	ldr	r3, [r2, r3]
 8004190:	2b00      	cmp	r3, #0
 8004192:	d001      	beq.n	8004198 <externalDataCommand+0x74>
 8004194:	f000 fbb7 	bl	8004906 <externalDataCommand+0x7e2>
                
                    if(selectChannel(self, self->ctx.rate, self->tx.chIndex, 0UL, &self->tx.chIndex, &self->tx.freq)){
 8004198:	68fa      	ldr	r2, [r7, #12]
 800419a:	23f6      	movs	r3, #246	; 0xf6
 800419c:	33ff      	adds	r3, #255	; 0xff
 800419e:	5cd1      	ldrb	r1, [r2, r3]
 80041a0:	68fa      	ldr	r2, [r7, #12]
 80041a2:	23a6      	movs	r3, #166	; 0xa6
 80041a4:	005b      	lsls	r3, r3, #1
 80041a6:	5cd4      	ldrb	r4, [r2, r3]
 80041a8:	68fb      	ldr	r3, [r7, #12]
 80041aa:	334d      	adds	r3, #77	; 0x4d
 80041ac:	33ff      	adds	r3, #255	; 0xff
 80041ae:	68fa      	ldr	r2, [r7, #12]
 80041b0:	3245      	adds	r2, #69	; 0x45
 80041b2:	32ff      	adds	r2, #255	; 0xff
 80041b4:	68f8      	ldr	r0, [r7, #12]
 80041b6:	9201      	str	r2, [sp, #4]
 80041b8:	9300      	str	r3, [sp, #0]
 80041ba:	2300      	movs	r3, #0
 80041bc:	0022      	movs	r2, r4
 80041be:	f001 fb7d 	bl	80058bc <selectChannel>
 80041c2:	1e03      	subs	r3, r0, #0
 80041c4:	d100      	bne.n	80041c8 <externalDataCommand+0xa4>
 80041c6:	e39a      	b.n	80048fe <externalDataCommand+0x7da>
                     
                        LDL_Region_convertRate(self->region, self->ctx.rate, &sf, &bw, &maxPayload);
 80041c8:	68fa      	ldr	r2, [r7, #12]
 80041ca:	2391      	movs	r3, #145	; 0x91
 80041cc:	009b      	lsls	r3, r3, #2
 80041ce:	5cd0      	ldrb	r0, [r2, r3]
 80041d0:	68fa      	ldr	r2, [r7, #12]
 80041d2:	23f6      	movs	r3, #246	; 0xf6
 80041d4:	33ff      	adds	r3, #255	; 0xff
 80041d6:	5cd1      	ldrb	r1, [r2, r3]
 80041d8:	2366      	movs	r3, #102	; 0x66
 80041da:	18fc      	adds	r4, r7, r3
 80041dc:	2365      	movs	r3, #101	; 0x65
 80041de:	18fa      	adds	r2, r7, r3
 80041e0:	2367      	movs	r3, #103	; 0x67
 80041e2:	18fb      	adds	r3, r7, r3
 80041e4:	9300      	str	r3, [sp, #0]
 80041e6:	0023      	movs	r3, r4
 80041e8:	f004 fbb4 	bl	8008954 <LDL_Region_convertRate>
                                            
                        if(opts == NULL){
 80041ec:	2384      	movs	r3, #132	; 0x84
 80041ee:	18fb      	adds	r3, r7, r3
 80041f0:	681b      	ldr	r3, [r3, #0]
 80041f2:	2b00      	cmp	r3, #0
 80041f4:	d10a      	bne.n	800420c <externalDataCommand+0xe8>
                            
                            (void)memset(&self->opts, 0, sizeof(self->opts));
 80041f6:	68fb      	ldr	r3, [r7, #12]
 80041f8:	229a      	movs	r2, #154	; 0x9a
 80041fa:	0092      	lsls	r2, r2, #2
 80041fc:	4694      	mov	ip, r2
 80041fe:	4463      	add	r3, ip
 8004200:	2204      	movs	r2, #4
 8004202:	2100      	movs	r1, #0
 8004204:	0018      	movs	r0, r3
 8004206:	f008 fb68 	bl	800c8da <memset>
 800420a:	e00b      	b.n	8004224 <externalDataCommand+0x100>
                        }
                        else{
                            
                            (void)memcpy(&self->opts, opts, sizeof(self->opts));
 800420c:	68fb      	ldr	r3, [r7, #12]
 800420e:	229a      	movs	r2, #154	; 0x9a
 8004210:	0092      	lsls	r2, r2, #2
 8004212:	4694      	mov	ip, r2
 8004214:	4463      	add	r3, ip
 8004216:	2284      	movs	r2, #132	; 0x84
 8004218:	18ba      	adds	r2, r7, r2
 800421a:	6811      	ldr	r1, [r2, #0]
 800421c:	2204      	movs	r2, #4
 800421e:	0018      	movs	r0, r3
 8004220:	f008 fb52 	bl	800c8c8 <memcpy>
                        }

                        self->opts.nbTrans = self->opts.nbTrans & 0xfU;
 8004224:	68fa      	ldr	r2, [r7, #12]
 8004226:	239a      	movs	r3, #154	; 0x9a
 8004228:	009b      	lsls	r3, r3, #2
 800422a:	5cd3      	ldrb	r3, [r2, r3]
 800422c:	220f      	movs	r2, #15
 800422e:	4013      	ands	r3, r2
 8004230:	b2d9      	uxtb	r1, r3
 8004232:	68fa      	ldr	r2, [r7, #12]
 8004234:	239a      	movs	r3, #154	; 0x9a
 8004236:	009b      	lsls	r3, r3, #2
 8004238:	54d1      	strb	r1, [r2, r3]
                        
                        {
                            self->trials = 0U;
 800423a:	68fa      	ldr	r2, [r7, #12]
 800423c:	2399      	movs	r3, #153	; 0x99
 800423e:	009b      	lsls	r3, r3, #2
 8004240:	2100      	movs	r1, #0
 8004242:	50d1      	str	r1, [r2, r3]
                            
                            self->tx.rate = self->ctx.rate;
 8004244:	68fa      	ldr	r2, [r7, #12]
 8004246:	23f6      	movs	r3, #246	; 0xf6
 8004248:	33ff      	adds	r3, #255	; 0xff
 800424a:	5cd1      	ldrb	r1, [r2, r3]
 800424c:	68fa      	ldr	r2, [r7, #12]
 800424e:	234e      	movs	r3, #78	; 0x4e
 8004250:	33ff      	adds	r3, #255	; 0xff
 8004252:	54d1      	strb	r1, [r2, r3]
                            self->tx.power = self->ctx.power;
 8004254:	68fa      	ldr	r2, [r7, #12]
 8004256:	23fb      	movs	r3, #251	; 0xfb
 8004258:	005b      	lsls	r3, r3, #1
 800425a:	5cd1      	ldrb	r1, [r2, r3]
 800425c:	68fa      	ldr	r2, [r7, #12]
 800425e:	23a7      	movs	r3, #167	; 0xa7
 8004260:	005b      	lsls	r3, r3, #1
 8004262:	54d1      	strb	r1, [r2, r3]

                            (void)memset(&f, 0, sizeof(f));
 8004264:	2340      	movs	r3, #64	; 0x40
 8004266:	18fb      	adds	r3, r7, r3
 8004268:	2224      	movs	r2, #36	; 0x24
 800426a:	2100      	movs	r1, #0
 800426c:	0018      	movs	r0, r3
 800426e:	f008 fb34 	bl	800c8da <memset>
                            
                            self->op = confirmed ? LDL_OP_DATA_CONFIRMED : LDL_OP_DATA_UNCONFIRMED;
 8004272:	230b      	movs	r3, #11
 8004274:	18fb      	adds	r3, r7, r3
 8004276:	781b      	ldrb	r3, [r3, #0]
 8004278:	2b00      	cmp	r3, #0
 800427a:	d001      	beq.n	8004280 <externalDataCommand+0x15c>
 800427c:	2204      	movs	r2, #4
 800427e:	e000      	b.n	8004282 <externalDataCommand+0x15e>
 8004280:	2203      	movs	r2, #3
 8004282:	68fb      	ldr	r3, [r7, #12]
 8004284:	705a      	strb	r2, [r3, #1]
                            
                            f.type = confirmed ? FRAME_TYPE_DATA_CONFIRMED_UP : FRAME_TYPE_DATA_UNCONFIRMED_UP;
 8004286:	230b      	movs	r3, #11
 8004288:	18fb      	adds	r3, r7, r3
 800428a:	781b      	ldrb	r3, [r3, #0]
 800428c:	2b00      	cmp	r3, #0
 800428e:	d001      	beq.n	8004294 <externalDataCommand+0x170>
 8004290:	2204      	movs	r2, #4
 8004292:	e000      	b.n	8004296 <externalDataCommand+0x172>
 8004294:	2202      	movs	r2, #2
 8004296:	2140      	movs	r1, #64	; 0x40
 8004298:	187b      	adds	r3, r7, r1
 800429a:	701a      	strb	r2, [r3, #0]
                            f.devAddr = self->ctx.devAddr;
 800429c:	68fa      	ldr	r2, [r7, #12]
 800429e:	23b2      	movs	r3, #178	; 0xb2
 80042a0:	005b      	lsls	r3, r3, #1
 80042a2:	58d2      	ldr	r2, [r2, r3]
 80042a4:	187b      	adds	r3, r7, r1
 80042a6:	605a      	str	r2, [r3, #4]
                            f.counter = self->ctx.up;
 80042a8:	68fa      	ldr	r2, [r7, #12]
 80042aa:	23ae      	movs	r3, #174	; 0xae
 80042ac:	005b      	lsls	r3, r3, #1
 80042ae:	58d3      	ldr	r3, [r2, r3]
 80042b0:	b29a      	uxth	r2, r3
 80042b2:	187b      	adds	r3, r7, r1
 80042b4:	811a      	strh	r2, [r3, #8]
                            f.adr = self->ctx.adr;
 80042b6:	68fb      	ldr	r3, [r7, #12]
 80042b8:	4ac2      	ldr	r2, [pc, #776]	; (80045c4 <externalDataCommand+0x4a0>)
 80042ba:	5c9a      	ldrb	r2, [r3, r2]
 80042bc:	187b      	adds	r3, r7, r1
 80042be:	72da      	strb	r2, [r3, #11]
                            f.adrAckReq = self->adrAckReq;
 80042c0:	68fb      	ldr	r3, [r7, #12]
 80042c2:	4ac1      	ldr	r2, [pc, #772]	; (80045c8 <externalDataCommand+0x4a4>)
 80042c4:	5c9a      	ldrb	r2, [r3, r2]
 80042c6:	187b      	adds	r3, r7, r1
 80042c8:	731a      	strb	r2, [r3, #12]
                            f.port = port;
 80042ca:	187b      	adds	r3, r7, r1
 80042cc:	220a      	movs	r2, #10
 80042ce:	18ba      	adds	r2, r7, r2
 80042d0:	7812      	ldrb	r2, [r2, #0]
 80042d2:	755a      	strb	r2, [r3, #21]
                            
                            /* 1.1 has to awkwardly re-calculate the MIC when a frame is retried on a 
                             * different channel and the counter is a parameter */
                            self->tx.counter = self->ctx.up;
 80042d4:	68fa      	ldr	r2, [r7, #12]
 80042d6:	23ae      	movs	r3, #174	; 0xae
 80042d8:	005b      	lsls	r3, r3, #1
 80042da:	58d1      	ldr	r1, [r2, r3]
 80042dc:	68fa      	ldr	r2, [r7, #12]
 80042de:	23a4      	movs	r3, #164	; 0xa4
 80042e0:	005b      	lsls	r3, r3, #1
 80042e2:	50d1      	str	r1, [r2, r3]
                            
                            self->ctx.up++;
 80042e4:	68fa      	ldr	r2, [r7, #12]
 80042e6:	23ae      	movs	r3, #174	; 0xae
 80042e8:	005b      	lsls	r3, r3, #1
 80042ea:	58d3      	ldr	r3, [r2, r3]
 80042ec:	1c59      	adds	r1, r3, #1
 80042ee:	68fa      	ldr	r2, [r7, #12]
 80042f0:	23ae      	movs	r3, #174	; 0xae
 80042f2:	005b      	lsls	r3, r3, #1
 80042f4:	50d1      	str	r1, [r2, r3]

                            /* serialise pending MAC commands */
                            {
                                LDL_Stream_init(&s, macs, sizeof(macs));
 80042f6:	2314      	movs	r3, #20
 80042f8:	18f9      	adds	r1, r7, r3
 80042fa:	2334      	movs	r3, #52	; 0x34
 80042fc:	18fb      	adds	r3, r7, r3
 80042fe:	221e      	movs	r2, #30
 8004300:	0018      	movs	r0, r3
 8004302:	f005 f87e 	bl	8009402 <LDL_Stream_init>
                                
                                LDL_DEBUG(self->app, "preparing data frame")
 8004306:	4bb1      	ldr	r3, [pc, #708]	; (80045cc <externalDataCommand+0x4a8>)
 8004308:	0018      	movs	r0, r3
 800430a:	f008 faef 	bl	800c8ec <iprintf>
 800430e:	4bb0      	ldr	r3, [pc, #704]	; (80045d0 <externalDataCommand+0x4ac>)
 8004310:	0018      	movs	r0, r3
 8004312:	f008 faeb 	bl	800c8ec <iprintf>
 8004316:	4baf      	ldr	r3, [pc, #700]	; (80045d4 <externalDataCommand+0x4b0>)
 8004318:	0018      	movs	r0, r3
 800431a:	f008 fb61 	bl	800c9e0 <puts>
                                
                                /* sticky commands */
                                
                                if(commandIsPending(self, LDL_CMD_REKEY)){
 800431e:	68fb      	ldr	r3, [r7, #12]
 8004320:	2109      	movs	r1, #9
 8004322:	0018      	movs	r0, r3
 8004324:	f002 fb22 	bl	800696c <commandIsPending>
 8004328:	1e03      	subs	r3, r0, #0
 800432a:	d01d      	beq.n	8004368 <externalDataCommand+0x244>
                                    
                                    struct ldl_rekey_ind ind = {
                                        .version = self->ctx.version
 800432c:	68fb      	ldr	r3, [r7, #12]
 800432e:	4aaa      	ldr	r2, [pc, #680]	; (80045d8 <externalDataCommand+0x4b4>)
 8004330:	5c9a      	ldrb	r2, [r3, r2]
                                    struct ldl_rekey_ind ind = {
 8004332:	2110      	movs	r1, #16
 8004334:	187b      	adds	r3, r7, r1
 8004336:	701a      	strb	r2, [r3, #0]
                                    };
                                    
                                    LDL_MAC_putRekeyInd(&s, &ind);
 8004338:	187a      	adds	r2, r7, r1
 800433a:	2334      	movs	r3, #52	; 0x34
 800433c:	18fb      	adds	r3, r7, r3
 800433e:	0011      	movs	r1, r2
 8004340:	0018      	movs	r0, r3
 8004342:	f002 fcbc 	bl	8006cbe <LDL_MAC_putRekeyInd>
                                    
                                    LDL_DEBUG(self->app, "adding rekey_ind: version=%u", self->ctx.version)
 8004346:	4ba1      	ldr	r3, [pc, #644]	; (80045cc <externalDataCommand+0x4a8>)
 8004348:	0018      	movs	r0, r3
 800434a:	f008 facf 	bl	800c8ec <iprintf>
 800434e:	68fb      	ldr	r3, [r7, #12]
 8004350:	4aa1      	ldr	r2, [pc, #644]	; (80045d8 <externalDataCommand+0x4b4>)
 8004352:	5c9b      	ldrb	r3, [r3, r2]
 8004354:	001a      	movs	r2, r3
 8004356:	4ba1      	ldr	r3, [pc, #644]	; (80045dc <externalDataCommand+0x4b8>)
 8004358:	0011      	movs	r1, r2
 800435a:	0018      	movs	r0, r3
 800435c:	f008 fac6 	bl	800c8ec <iprintf>
 8004360:	4b9c      	ldr	r3, [pc, #624]	; (80045d4 <externalDataCommand+0x4b0>)
 8004362:	0018      	movs	r0, r3
 8004364:	f008 fb3c 	bl	800c9e0 <puts>
                                }                            
                                
                                if(commandIsPending(self, LDL_CMD_RX_PARAM_SETUP)){
 8004368:	68fb      	ldr	r3, [r7, #12]
 800436a:	2103      	movs	r1, #3
 800436c:	0018      	movs	r0, r3
 800436e:	f002 fafd 	bl	800696c <commandIsPending>
 8004372:	1e03      	subs	r3, r0, #0
 8004374:	d02c      	beq.n	80043d0 <externalDataCommand+0x2ac>
                                    
                                    LDL_MAC_putRXParamSetupAns(&s, &self->ctx.rx_param_setup_ans);
 8004376:	68fb      	ldr	r3, [r7, #12]
 8004378:	4a99      	ldr	r2, [pc, #612]	; (80045e0 <externalDataCommand+0x4bc>)
 800437a:	189a      	adds	r2, r3, r2
 800437c:	2334      	movs	r3, #52	; 0x34
 800437e:	18fb      	adds	r3, r7, r3
 8004380:	0011      	movs	r1, r2
 8004382:	0018      	movs	r0, r3
 8004384:	f002 fbc4 	bl	8006b10 <LDL_MAC_putRXParamSetupAns>
                                    
                                    LDL_DEBUG(self->app, "adding rx_param_setup_ans: rx1DROffsetOK=%s rx2DataRate=%s rx2Freq=%s",                
 8004388:	4b90      	ldr	r3, [pc, #576]	; (80045cc <externalDataCommand+0x4a8>)
 800438a:	0018      	movs	r0, r3
 800438c:	f008 faae 	bl	800c8ec <iprintf>
 8004390:	68fb      	ldr	r3, [r7, #12]
 8004392:	4a93      	ldr	r2, [pc, #588]	; (80045e0 <externalDataCommand+0x4bc>)
 8004394:	5c9b      	ldrb	r3, [r3, r2]
 8004396:	2b00      	cmp	r3, #0
 8004398:	d001      	beq.n	800439e <externalDataCommand+0x27a>
 800439a:	4992      	ldr	r1, [pc, #584]	; (80045e4 <externalDataCommand+0x4c0>)
 800439c:	e000      	b.n	80043a0 <externalDataCommand+0x27c>
 800439e:	4992      	ldr	r1, [pc, #584]	; (80045e8 <externalDataCommand+0x4c4>)
 80043a0:	68fb      	ldr	r3, [r7, #12]
 80043a2:	4a92      	ldr	r2, [pc, #584]	; (80045ec <externalDataCommand+0x4c8>)
 80043a4:	5c9b      	ldrb	r3, [r3, r2]
 80043a6:	2b00      	cmp	r3, #0
 80043a8:	d001      	beq.n	80043ae <externalDataCommand+0x28a>
 80043aa:	4a8e      	ldr	r2, [pc, #568]	; (80045e4 <externalDataCommand+0x4c0>)
 80043ac:	e000      	b.n	80043b0 <externalDataCommand+0x28c>
 80043ae:	4a8e      	ldr	r2, [pc, #568]	; (80045e8 <externalDataCommand+0x4c4>)
 80043b0:	68f8      	ldr	r0, [r7, #12]
 80043b2:	2384      	movs	r3, #132	; 0x84
 80043b4:	009b      	lsls	r3, r3, #2
 80043b6:	5cc3      	ldrb	r3, [r0, r3]
 80043b8:	2b00      	cmp	r3, #0
 80043ba:	d001      	beq.n	80043c0 <externalDataCommand+0x29c>
 80043bc:	4b89      	ldr	r3, [pc, #548]	; (80045e4 <externalDataCommand+0x4c0>)
 80043be:	e000      	b.n	80043c2 <externalDataCommand+0x29e>
 80043c0:	4b89      	ldr	r3, [pc, #548]	; (80045e8 <externalDataCommand+0x4c4>)
 80043c2:	488b      	ldr	r0, [pc, #556]	; (80045f0 <externalDataCommand+0x4cc>)
 80043c4:	f008 fa92 	bl	800c8ec <iprintf>
 80043c8:	4b82      	ldr	r3, [pc, #520]	; (80045d4 <externalDataCommand+0x4b0>)
 80043ca:	0018      	movs	r0, r3
 80043cc:	f008 fb08 	bl	800c9e0 <puts>
                                        self->ctx.rx_param_setup_ans.rx2DataRateOK ? "true" : "false",
                                        self->ctx.rx_param_setup_ans.channelOK ? "true" : "false"       
                                    )                                    
                                }
                                
                                if(commandIsPending(self, LDL_CMD_DL_CHANNEL)){
 80043d0:	68fb      	ldr	r3, [r7, #12]
 80043d2:	2108      	movs	r1, #8
 80043d4:	0018      	movs	r0, r3
 80043d6:	f002 fac9 	bl	800696c <commandIsPending>
 80043da:	1e03      	subs	r3, r0, #0
 80043dc:	d024      	beq.n	8004428 <externalDataCommand+0x304>
                                    
                                    LDL_MAC_putDLChannelAns(&s, &self->ctx.dl_channel_ans);
 80043de:	68fb      	ldr	r3, [r7, #12]
 80043e0:	4a84      	ldr	r2, [pc, #528]	; (80045f4 <externalDataCommand+0x4d0>)
 80043e2:	189a      	adds	r2, r3, r2
 80043e4:	2334      	movs	r3, #52	; 0x34
 80043e6:	18fb      	adds	r3, r7, r3
 80043e8:	0011      	movs	r1, r2
 80043ea:	0018      	movs	r0, r3
 80043ec:	f002 fc17 	bl	8006c1e <LDL_MAC_putDLChannelAns>
                                    
                                    LDL_DEBUG(self->app, "adding dl_channel_ans: uplinkFreqOK=%s channelFreqOK=%s",
 80043f0:	4b76      	ldr	r3, [pc, #472]	; (80045cc <externalDataCommand+0x4a8>)
 80043f2:	0018      	movs	r0, r3
 80043f4:	f008 fa7a 	bl	800c8ec <iprintf>
 80043f8:	68fb      	ldr	r3, [r7, #12]
 80043fa:	4a7e      	ldr	r2, [pc, #504]	; (80045f4 <externalDataCommand+0x4d0>)
 80043fc:	5c9b      	ldrb	r3, [r3, r2]
 80043fe:	2b00      	cmp	r3, #0
 8004400:	d001      	beq.n	8004406 <externalDataCommand+0x2e2>
 8004402:	4b78      	ldr	r3, [pc, #480]	; (80045e4 <externalDataCommand+0x4c0>)
 8004404:	e000      	b.n	8004408 <externalDataCommand+0x2e4>
 8004406:	4b78      	ldr	r3, [pc, #480]	; (80045e8 <externalDataCommand+0x4c4>)
 8004408:	68fa      	ldr	r2, [r7, #12]
 800440a:	497b      	ldr	r1, [pc, #492]	; (80045f8 <externalDataCommand+0x4d4>)
 800440c:	5c52      	ldrb	r2, [r2, r1]
 800440e:	2a00      	cmp	r2, #0
 8004410:	d001      	beq.n	8004416 <externalDataCommand+0x2f2>
 8004412:	4a74      	ldr	r2, [pc, #464]	; (80045e4 <externalDataCommand+0x4c0>)
 8004414:	e000      	b.n	8004418 <externalDataCommand+0x2f4>
 8004416:	4a74      	ldr	r2, [pc, #464]	; (80045e8 <externalDataCommand+0x4c4>)
 8004418:	4878      	ldr	r0, [pc, #480]	; (80045fc <externalDataCommand+0x4d8>)
 800441a:	0019      	movs	r1, r3
 800441c:	f008 fa66 	bl	800c8ec <iprintf>
 8004420:	4b6c      	ldr	r3, [pc, #432]	; (80045d4 <externalDataCommand+0x4b0>)
 8004422:	0018      	movs	r0, r3
 8004424:	f008 fadc 	bl	800c9e0 <puts>
                                        self->ctx.dl_channel_ans.uplinkFreqOK ? "true" : "false",
                                        self->ctx.dl_channel_ans.channelFreqOK ? "true" : "false"
                                    )                                    
                                }
                                
                                if(commandIsPending(self, LDL_CMD_RX_TIMING_SETUP)){
 8004428:	68fb      	ldr	r3, [r7, #12]
 800442a:	2106      	movs	r1, #6
 800442c:	0018      	movs	r0, r3
 800442e:	f002 fa9d 	bl	800696c <commandIsPending>
 8004432:	1e03      	subs	r3, r0, #0
 8004434:	d010      	beq.n	8004458 <externalDataCommand+0x334>
                                    
                                    LDL_MAC_putRXTimingSetupAns(&s);
 8004436:	2334      	movs	r3, #52	; 0x34
 8004438:	18fb      	adds	r3, r7, r3
 800443a:	0018      	movs	r0, r3
 800443c:	f002 fc1b 	bl	8006c76 <LDL_MAC_putRXTimingSetupAns>
                                    LDL_DEBUG(self->app, "adding rx_timing_setup_ans")
 8004440:	4b62      	ldr	r3, [pc, #392]	; (80045cc <externalDataCommand+0x4a8>)
 8004442:	0018      	movs	r0, r3
 8004444:	f008 fa52 	bl	800c8ec <iprintf>
 8004448:	4b6d      	ldr	r3, [pc, #436]	; (8004600 <externalDataCommand+0x4dc>)
 800444a:	0018      	movs	r0, r3
 800444c:	f008 fa4e 	bl	800c8ec <iprintf>
 8004450:	4b60      	ldr	r3, [pc, #384]	; (80045d4 <externalDataCommand+0x4b0>)
 8004452:	0018      	movs	r0, r3
 8004454:	f008 fac4 	bl	800c9e0 <puts>
                                }
                            
                                /* single shot commands */                                
                                
                                if(commandIsPending(self, LDL_CMD_LINK_ADR)){
 8004458:	68fb      	ldr	r3, [r7, #12]
 800445a:	2101      	movs	r1, #1
 800445c:	0018      	movs	r0, r3
 800445e:	f002 fa85 	bl	800696c <commandIsPending>
 8004462:	1e03      	subs	r3, r0, #0
 8004464:	d031      	beq.n	80044ca <externalDataCommand+0x3a6>
                                    
                                    LDL_MAC_putLinkADRAns(&s, &self->ctx.link_adr_ans);                                
 8004466:	68fb      	ldr	r3, [r7, #12]
 8004468:	4a66      	ldr	r2, [pc, #408]	; (8004604 <externalDataCommand+0x4e0>)
 800446a:	189a      	adds	r2, r3, r2
 800446c:	2334      	movs	r3, #52	; 0x34
 800446e:	18fb      	adds	r3, r7, r3
 8004470:	0011      	movs	r1, r2
 8004472:	0018      	movs	r0, r3
 8004474:	f002 fb05 	bl	8006a82 <LDL_MAC_putLinkADRAns>
                                    clearPendingCommand(self, LDL_CMD_LINK_ADR);
 8004478:	68fb      	ldr	r3, [r7, #12]
 800447a:	2101      	movs	r1, #1
 800447c:	0018      	movs	r0, r3
 800447e:	f002 fa8f 	bl	80069a0 <clearPendingCommand>
                                    
                                    LDL_DEBUG(self->app, "adding link_adr_ans: powerOK=%s dataRateOK=%s channelMaskOK=%s",
 8004482:	4b52      	ldr	r3, [pc, #328]	; (80045cc <externalDataCommand+0x4a8>)
 8004484:	0018      	movs	r0, r3
 8004486:	f008 fa31 	bl	800c8ec <iprintf>
 800448a:	68fa      	ldr	r2, [r7, #12]
 800448c:	2385      	movs	r3, #133	; 0x85
 800448e:	009b      	lsls	r3, r3, #2
 8004490:	5cd3      	ldrb	r3, [r2, r3]
 8004492:	2b00      	cmp	r3, #0
 8004494:	d001      	beq.n	800449a <externalDataCommand+0x376>
 8004496:	4953      	ldr	r1, [pc, #332]	; (80045e4 <externalDataCommand+0x4c0>)
 8004498:	e000      	b.n	800449c <externalDataCommand+0x378>
 800449a:	4953      	ldr	r1, [pc, #332]	; (80045e8 <externalDataCommand+0x4c4>)
 800449c:	68fb      	ldr	r3, [r7, #12]
 800449e:	4a59      	ldr	r2, [pc, #356]	; (8004604 <externalDataCommand+0x4e0>)
 80044a0:	5c9b      	ldrb	r3, [r3, r2]
 80044a2:	2b00      	cmp	r3, #0
 80044a4:	d001      	beq.n	80044aa <externalDataCommand+0x386>
 80044a6:	4a4f      	ldr	r2, [pc, #316]	; (80045e4 <externalDataCommand+0x4c0>)
 80044a8:	e000      	b.n	80044ac <externalDataCommand+0x388>
 80044aa:	4a4f      	ldr	r2, [pc, #316]	; (80045e8 <externalDataCommand+0x4c4>)
 80044ac:	68fb      	ldr	r3, [r7, #12]
 80044ae:	4856      	ldr	r0, [pc, #344]	; (8004608 <externalDataCommand+0x4e4>)
 80044b0:	5c1b      	ldrb	r3, [r3, r0]
 80044b2:	2b00      	cmp	r3, #0
 80044b4:	d001      	beq.n	80044ba <externalDataCommand+0x396>
 80044b6:	4b4b      	ldr	r3, [pc, #300]	; (80045e4 <externalDataCommand+0x4c0>)
 80044b8:	e000      	b.n	80044bc <externalDataCommand+0x398>
 80044ba:	4b4b      	ldr	r3, [pc, #300]	; (80045e8 <externalDataCommand+0x4c4>)
 80044bc:	4853      	ldr	r0, [pc, #332]	; (800460c <externalDataCommand+0x4e8>)
 80044be:	f008 fa15 	bl	800c8ec <iprintf>
 80044c2:	4b44      	ldr	r3, [pc, #272]	; (80045d4 <externalDataCommand+0x4b0>)
 80044c4:	0018      	movs	r0, r3
 80044c6:	f008 fa8b 	bl	800c9e0 <puts>
                                        self->ctx.link_adr_ans.powerOK ? "true" : "false", 
                                        self->ctx.link_adr_ans.channelMaskOK ? "true" : "false"
                                    )                                    
                                }
                                
                                if(commandIsPending(self, LDL_CMD_DEV_STATUS)){
 80044ca:	68fb      	ldr	r3, [r7, #12]
 80044cc:	2104      	movs	r1, #4
 80044ce:	0018      	movs	r0, r3
 80044d0:	f002 fa4c 	bl	800696c <commandIsPending>
 80044d4:	1e03      	subs	r3, r0, #0
 80044d6:	d021      	beq.n	800451c <externalDataCommand+0x3f8>
                                    
                                    LDL_MAC_putDevStatusAns(&s, &self->ctx.dev_status_ans);                                
 80044d8:	68fb      	ldr	r3, [r7, #12]
 80044da:	4a4d      	ldr	r2, [pc, #308]	; (8004610 <externalDataCommand+0x4ec>)
 80044dc:	189a      	adds	r2, r3, r2
 80044de:	2334      	movs	r3, #52	; 0x34
 80044e0:	18fb      	adds	r3, r7, r3
 80044e2:	0011      	movs	r1, r2
 80044e4:	0018      	movs	r0, r3
 80044e6:	f002 fb48 	bl	8006b7a <LDL_MAC_putDevStatusAns>
                                    clearPendingCommand(self, LDL_CMD_DEV_STATUS);
 80044ea:	68fb      	ldr	r3, [r7, #12]
 80044ec:	2104      	movs	r1, #4
 80044ee:	0018      	movs	r0, r3
 80044f0:	f002 fa56 	bl	80069a0 <clearPendingCommand>
                                    
                                    LDL_DEBUG(self->app, "adding dev_status_ans: battery=%u margin=%i",
 80044f4:	4b35      	ldr	r3, [pc, #212]	; (80045cc <externalDataCommand+0x4a8>)
 80044f6:	0018      	movs	r0, r3
 80044f8:	f008 f9f8 	bl	800c8ec <iprintf>
 80044fc:	68fb      	ldr	r3, [r7, #12]
 80044fe:	4a44      	ldr	r2, [pc, #272]	; (8004610 <externalDataCommand+0x4ec>)
 8004500:	5c9b      	ldrb	r3, [r3, r2]
 8004502:	0019      	movs	r1, r3
 8004504:	68fb      	ldr	r3, [r7, #12]
 8004506:	4a43      	ldr	r2, [pc, #268]	; (8004614 <externalDataCommand+0x4f0>)
 8004508:	569b      	ldrsb	r3, [r3, r2]
 800450a:	001a      	movs	r2, r3
 800450c:	4b42      	ldr	r3, [pc, #264]	; (8004618 <externalDataCommand+0x4f4>)
 800450e:	0018      	movs	r0, r3
 8004510:	f008 f9ec 	bl	800c8ec <iprintf>
 8004514:	4b2f      	ldr	r3, [pc, #188]	; (80045d4 <externalDataCommand+0x4b0>)
 8004516:	0018      	movs	r0, r3
 8004518:	f008 fa62 	bl	800c9e0 <puts>
                                        self->ctx.dev_status_ans.battery,
                                        self->ctx.dev_status_ans.margin
                                    )                                                                        
                                }
                                
                                if(commandIsPending(self, LDL_CMD_NEW_CHANNEL)){
 800451c:	68fb      	ldr	r3, [r7, #12]
 800451e:	2105      	movs	r1, #5
 8004520:	0018      	movs	r0, r3
 8004522:	f002 fa23 	bl	800696c <commandIsPending>
 8004526:	1e03      	subs	r3, r0, #0
 8004528:	d02b      	beq.n	8004582 <externalDataCommand+0x45e>
                                    
                                    LDL_MAC_putNewChannelAns(&s, &self->ctx.new_channel_ans);                                
 800452a:	68fb      	ldr	r3, [r7, #12]
 800452c:	2286      	movs	r2, #134	; 0x86
 800452e:	0092      	lsls	r2, r2, #2
 8004530:	189a      	adds	r2, r3, r2
 8004532:	2334      	movs	r3, #52	; 0x34
 8004534:	18fb      	adds	r3, r7, r3
 8004536:	0011      	movs	r1, r2
 8004538:	0018      	movs	r0, r3
 800453a:	f002 fb44 	bl	8006bc6 <LDL_MAC_putNewChannelAns>
                                    clearPendingCommand(self, LDL_CMD_NEW_CHANNEL);
 800453e:	68fb      	ldr	r3, [r7, #12]
 8004540:	2105      	movs	r1, #5
 8004542:	0018      	movs	r0, r3
 8004544:	f002 fa2c 	bl	80069a0 <clearPendingCommand>
                                    
                                    LDL_DEBUG(self->app, "adding new_channel_ans: dataRateRangeOK=%s channelFreqOK=%s", 
 8004548:	4b20      	ldr	r3, [pc, #128]	; (80045cc <externalDataCommand+0x4a8>)
 800454a:	0018      	movs	r0, r3
 800454c:	f008 f9ce 	bl	800c8ec <iprintf>
 8004550:	68fa      	ldr	r2, [r7, #12]
 8004552:	2386      	movs	r3, #134	; 0x86
 8004554:	009b      	lsls	r3, r3, #2
 8004556:	5cd3      	ldrb	r3, [r2, r3]
 8004558:	2b00      	cmp	r3, #0
 800455a:	d001      	beq.n	8004560 <externalDataCommand+0x43c>
 800455c:	4b21      	ldr	r3, [pc, #132]	; (80045e4 <externalDataCommand+0x4c0>)
 800455e:	e000      	b.n	8004562 <externalDataCommand+0x43e>
 8004560:	4b21      	ldr	r3, [pc, #132]	; (80045e8 <externalDataCommand+0x4c4>)
 8004562:	68fa      	ldr	r2, [r7, #12]
 8004564:	492d      	ldr	r1, [pc, #180]	; (800461c <externalDataCommand+0x4f8>)
 8004566:	5c52      	ldrb	r2, [r2, r1]
 8004568:	2a00      	cmp	r2, #0
 800456a:	d001      	beq.n	8004570 <externalDataCommand+0x44c>
 800456c:	4a1d      	ldr	r2, [pc, #116]	; (80045e4 <externalDataCommand+0x4c0>)
 800456e:	e000      	b.n	8004572 <externalDataCommand+0x44e>
 8004570:	4a1d      	ldr	r2, [pc, #116]	; (80045e8 <externalDataCommand+0x4c4>)
 8004572:	482b      	ldr	r0, [pc, #172]	; (8004620 <externalDataCommand+0x4fc>)
 8004574:	0019      	movs	r1, r3
 8004576:	f008 f9b9 	bl	800c8ec <iprintf>
 800457a:	4b16      	ldr	r3, [pc, #88]	; (80045d4 <externalDataCommand+0x4b0>)
 800457c:	0018      	movs	r0, r3
 800457e:	f008 fa2f 	bl	800c9e0 <puts>
                                        self->ctx.new_channel_ans.dataRateRangeOK ? "true" : "false",
                                        self->ctx.new_channel_ans.channelFreqOK ? "true" : "false"
                                    )                                    
                                }
                                
                                if(commandIsPending(self, LDL_CMD_REJOIN_PARAM_SETUP)){
 8004582:	68fb      	ldr	r3, [r7, #12]
 8004584:	210d      	movs	r1, #13
 8004586:	0018      	movs	r0, r3
 8004588:	f002 f9f0 	bl	800696c <commandIsPending>
 800458c:	1e03      	subs	r3, r0, #0
 800458e:	d055      	beq.n	800463c <externalDataCommand+0x518>
                                    
                                    LDL_MAC_putRejoinParamSetupAns(&s, &self->ctx.rejoin_param_setup_ans);                                
 8004590:	68fb      	ldr	r3, [r7, #12]
 8004592:	4a24      	ldr	r2, [pc, #144]	; (8004624 <externalDataCommand+0x500>)
 8004594:	189a      	adds	r2, r3, r2
 8004596:	2334      	movs	r3, #52	; 0x34
 8004598:	18fb      	adds	r3, r7, r3
 800459a:	0011      	movs	r1, r2
 800459c:	0018      	movs	r0, r3
 800459e:	f002 fbcc 	bl	8006d3a <LDL_MAC_putRejoinParamSetupAns>
                                    clearPendingCommand(self, LDL_CMD_REJOIN_PARAM_SETUP);
 80045a2:	68fb      	ldr	r3, [r7, #12]
 80045a4:	210d      	movs	r1, #13
 80045a6:	0018      	movs	r0, r3
 80045a8:	f002 f9fa 	bl	80069a0 <clearPendingCommand>
                                    
                                    LDL_DEBUG(self->app, "adding rejoin_param_setup_ans: timeOK=%s", 
 80045ac:	4b07      	ldr	r3, [pc, #28]	; (80045cc <externalDataCommand+0x4a8>)
 80045ae:	0018      	movs	r0, r3
 80045b0:	f008 f99c 	bl	800c8ec <iprintf>
 80045b4:	68fb      	ldr	r3, [r7, #12]
 80045b6:	4a1b      	ldr	r2, [pc, #108]	; (8004624 <externalDataCommand+0x500>)
 80045b8:	5c9b      	ldrb	r3, [r3, r2]
 80045ba:	2b00      	cmp	r3, #0
 80045bc:	d034      	beq.n	8004628 <externalDataCommand+0x504>
 80045be:	4b09      	ldr	r3, [pc, #36]	; (80045e4 <externalDataCommand+0x4c0>)
 80045c0:	e033      	b.n	800462a <externalDataCommand+0x506>
 80045c2:	46c0      	nop			; (mov r8, r8)
 80045c4:	00000205 	.word	0x00000205
 80045c8:	00000255 	.word	0x00000255
 80045cc:	0800d8e8 	.word	0x0800d8e8
 80045d0:	0800d960 	.word	0x0800d960
 80045d4:	0800d8e4 	.word	0x0800d8e4
 80045d8:	00000206 	.word	0x00000206
 80045dc:	0800d978 	.word	0x0800d978
 80045e0:	0000020e 	.word	0x0000020e
 80045e4:	0800d998 	.word	0x0800d998
 80045e8:	0800d9a0 	.word	0x0800d9a0
 80045ec:	0000020f 	.word	0x0000020f
 80045f0:	0800d9a8 	.word	0x0800d9a8
 80045f4:	00000211 	.word	0x00000211
 80045f8:	00000212 	.word	0x00000212
 80045fc:	0800d9f0 	.word	0x0800d9f0
 8004600:	0800da28 	.word	0x0800da28
 8004604:	00000213 	.word	0x00000213
 8004608:	00000215 	.word	0x00000215
 800460c:	0800da44 	.word	0x0800da44
 8004610:	00000216 	.word	0x00000216
 8004614:	00000217 	.word	0x00000217
 8004618:	0800da84 	.word	0x0800da84
 800461c:	00000219 	.word	0x00000219
 8004620:	0800dab0 	.word	0x0800dab0
 8004624:	0000021a 	.word	0x0000021a
 8004628:	4bc2      	ldr	r3, [pc, #776]	; (8004934 <externalDataCommand+0x810>)
 800462a:	4ac3      	ldr	r2, [pc, #780]	; (8004938 <externalDataCommand+0x814>)
 800462c:	0019      	movs	r1, r3
 800462e:	0010      	movs	r0, r2
 8004630:	f008 f95c 	bl	800c8ec <iprintf>
 8004634:	4bc1      	ldr	r3, [pc, #772]	; (800493c <externalDataCommand+0x818>)
 8004636:	0018      	movs	r0, r3
 8004638:	f008 f9d2 	bl	800c9e0 <puts>
                                        self->ctx.rejoin_param_setup_ans.timeOK ? "true" : "false"
                                    )
                                }
                                
                                if(commandIsPending(self, LDL_CMD_ADR_PARAM_SETUP)){
 800463c:	68fb      	ldr	r3, [r7, #12]
 800463e:	210a      	movs	r1, #10
 8004640:	0018      	movs	r0, r3
 8004642:	f002 f993 	bl	800696c <commandIsPending>
 8004646:	1e03      	subs	r3, r0, #0
 8004648:	d015      	beq.n	8004676 <externalDataCommand+0x552>
                                    
                                    LDL_MAC_putADRParamSetupAns(&s);                                
 800464a:	2334      	movs	r3, #52	; 0x34
 800464c:	18fb      	adds	r3, r7, r3
 800464e:	0018      	movs	r0, r3
 8004650:	f002 fb4f 	bl	8006cf2 <LDL_MAC_putADRParamSetupAns>
                                    clearPendingCommand(self, LDL_CMD_ADR_PARAM_SETUP);
 8004654:	68fb      	ldr	r3, [r7, #12]
 8004656:	210a      	movs	r1, #10
 8004658:	0018      	movs	r0, r3
 800465a:	f002 f9a1 	bl	80069a0 <clearPendingCommand>
                                    
                                    LDL_DEBUG(self->app, "adding adr_param_setup_ans")
 800465e:	4bb8      	ldr	r3, [pc, #736]	; (8004940 <externalDataCommand+0x81c>)
 8004660:	0018      	movs	r0, r3
 8004662:	f008 f943 	bl	800c8ec <iprintf>
 8004666:	4bb7      	ldr	r3, [pc, #732]	; (8004944 <externalDataCommand+0x820>)
 8004668:	0018      	movs	r0, r3
 800466a:	f008 f93f 	bl	800c8ec <iprintf>
 800466e:	4bb3      	ldr	r3, [pc, #716]	; (800493c <externalDataCommand+0x818>)
 8004670:	0018      	movs	r0, r3
 8004672:	f008 f9b5 	bl	800c9e0 <puts>
                                }
                                
                                if(commandIsPending(self, LDL_CMD_TX_PARAM_SETUP)){
 8004676:	68fb      	ldr	r3, [r7, #12]
 8004678:	2107      	movs	r1, #7
 800467a:	0018      	movs	r0, r3
 800467c:	f002 f976 	bl	800696c <commandIsPending>
 8004680:	1e03      	subs	r3, r0, #0
 8004682:	d015      	beq.n	80046b0 <externalDataCommand+0x58c>
                                    
                                    LDL_MAC_putTXParamSetupAns(&s);                                
 8004684:	2334      	movs	r3, #52	; 0x34
 8004686:	18fb      	adds	r3, r7, r3
 8004688:	0018      	movs	r0, r3
 800468a:	f002 fb06 	bl	8006c9a <LDL_MAC_putTXParamSetupAns>
                                    clearPendingCommand(self, LDL_CMD_TX_PARAM_SETUP);
 800468e:	68fb      	ldr	r3, [r7, #12]
 8004690:	2107      	movs	r1, #7
 8004692:	0018      	movs	r0, r3
 8004694:	f002 f984 	bl	80069a0 <clearPendingCommand>
                                    
                                    LDL_DEBUG(self->app, "adding tx_param_setup_ans")
 8004698:	4ba9      	ldr	r3, [pc, #676]	; (8004940 <externalDataCommand+0x81c>)
 800469a:	0018      	movs	r0, r3
 800469c:	f008 f926 	bl	800c8ec <iprintf>
 80046a0:	4ba9      	ldr	r3, [pc, #676]	; (8004948 <externalDataCommand+0x824>)
 80046a2:	0018      	movs	r0, r3
 80046a4:	f008 f922 	bl	800c8ec <iprintf>
 80046a8:	4ba4      	ldr	r3, [pc, #656]	; (800493c <externalDataCommand+0x818>)
 80046aa:	0018      	movs	r0, r3
 80046ac:	f008 f998 	bl	800c9e0 <puts>
                                }
                                
                                if(commandIsPending(self, LDL_CMD_DUTY_CYCLE)){
 80046b0:	68fb      	ldr	r3, [r7, #12]
 80046b2:	2102      	movs	r1, #2
 80046b4:	0018      	movs	r0, r3
 80046b6:	f002 f959 	bl	800696c <commandIsPending>
 80046ba:	1e03      	subs	r3, r0, #0
 80046bc:	d015      	beq.n	80046ea <externalDataCommand+0x5c6>
                                    
                                    LDL_MAC_putDutyCycleAns(&s);                                
 80046be:	2334      	movs	r3, #52	; 0x34
 80046c0:	18fb      	adds	r3, r7, r3
 80046c2:	0018      	movs	r0, r3
 80046c4:	f002 fa12 	bl	8006aec <LDL_MAC_putDutyCycleAns>
                                    clearPendingCommand(self, LDL_CMD_DUTY_CYCLE);
 80046c8:	68fb      	ldr	r3, [r7, #12]
 80046ca:	2102      	movs	r1, #2
 80046cc:	0018      	movs	r0, r3
 80046ce:	f002 f967 	bl	80069a0 <clearPendingCommand>
                                    
                                    LDL_DEBUG(self->app, "adding duty_cycle_ans")
 80046d2:	4b9b      	ldr	r3, [pc, #620]	; (8004940 <externalDataCommand+0x81c>)
 80046d4:	0018      	movs	r0, r3
 80046d6:	f008 f909 	bl	800c8ec <iprintf>
 80046da:	4b9c      	ldr	r3, [pc, #624]	; (800494c <externalDataCommand+0x828>)
 80046dc:	0018      	movs	r0, r3
 80046de:	f008 f905 	bl	800c8ec <iprintf>
 80046e2:	4b96      	ldr	r3, [pc, #600]	; (800493c <externalDataCommand+0x818>)
 80046e4:	0018      	movs	r0, r3
 80046e6:	f008 f97b 	bl	800c9e0 <puts>
                                }                                
#ifndef LDL_DISABLE_CHECK    
                                if(self->opts.check){
 80046ea:	68fb      	ldr	r3, [r7, #12]
 80046ec:	4a98      	ldr	r2, [pc, #608]	; (8004950 <externalDataCommand+0x82c>)
 80046ee:	5c9b      	ldrb	r3, [r3, r2]
 80046f0:	2b00      	cmp	r3, #0
 80046f2:	d010      	beq.n	8004716 <externalDataCommand+0x5f2>

                                    LDL_MAC_putLinkCheckReq(&s);
 80046f4:	2334      	movs	r3, #52	; 0x34
 80046f6:	18fb      	adds	r3, r7, r3
 80046f8:	0018      	movs	r0, r3
 80046fa:	f002 f9b0 	bl	8006a5e <LDL_MAC_putLinkCheckReq>
                                    LDL_DEBUG(self->app, "adding link_check_req")
 80046fe:	4b90      	ldr	r3, [pc, #576]	; (8004940 <externalDataCommand+0x81c>)
 8004700:	0018      	movs	r0, r3
 8004702:	f008 f8f3 	bl	800c8ec <iprintf>
 8004706:	4b93      	ldr	r3, [pc, #588]	; (8004954 <externalDataCommand+0x830>)
 8004708:	0018      	movs	r0, r3
 800470a:	f008 f8ef 	bl	800c8ec <iprintf>
 800470e:	4b8b      	ldr	r3, [pc, #556]	; (800493c <externalDataCommand+0x818>)
 8004710:	0018      	movs	r0, r3
 8004712:	f008 f965 	bl	800c9e0 <puts>
                                }                   
#endif        
#ifndef LDL_DISABLE_DEVICE_TIME    
                                if(self->opts.getTime){
 8004716:	68fb      	ldr	r3, [r7, #12]
 8004718:	4a8f      	ldr	r2, [pc, #572]	; (8004958 <externalDataCommand+0x834>)
 800471a:	5c9b      	ldrb	r3, [r3, r2]
 800471c:	2b00      	cmp	r3, #0
 800471e:	d010      	beq.n	8004742 <externalDataCommand+0x61e>
                                
                                    LDL_MAC_putDeviceTimeReq(&s);
 8004720:	2334      	movs	r3, #52	; 0x34
 8004722:	18fb      	adds	r3, r7, r3
 8004724:	0018      	movs	r0, r3
 8004726:	f002 faf6 	bl	8006d16 <LDL_MAC_putDeviceTimeReq>
                                    LDL_DEBUG(self->app, "adding device_time_req")
 800472a:	4b85      	ldr	r3, [pc, #532]	; (8004940 <externalDataCommand+0x81c>)
 800472c:	0018      	movs	r0, r3
 800472e:	f008 f8dd 	bl	800c8ec <iprintf>
 8004732:	4b8a      	ldr	r3, [pc, #552]	; (800495c <externalDataCommand+0x838>)
 8004734:	0018      	movs	r0, r3
 8004736:	f008 f8d9 	bl	800c8ec <iprintf>
 800473a:	4b80      	ldr	r3, [pc, #512]	; (800493c <externalDataCommand+0x818>)
 800473c:	0018      	movs	r0, r3
 800473e:	f008 f94f 	bl	800c9e0 <puts>
                                }             
#endif                              
                            }

                            LDL_DEBUG(self->app, "%uB data %uB mac", len, LDL_Stream_tell(&s))
 8004742:	4b7f      	ldr	r3, [pc, #508]	; (8004940 <externalDataCommand+0x81c>)
 8004744:	0018      	movs	r0, r3
 8004746:	f008 f8d1 	bl	800c8ec <iprintf>
 800474a:	2380      	movs	r3, #128	; 0x80
 800474c:	18fb      	adds	r3, r7, r3
 800474e:	781c      	ldrb	r4, [r3, #0]
 8004750:	2534      	movs	r5, #52	; 0x34
 8004752:	197b      	adds	r3, r7, r5
 8004754:	0018      	movs	r0, r3
 8004756:	f004 ff0a 	bl	800956e <LDL_Stream_tell>
 800475a:	0003      	movs	r3, r0
 800475c:	001a      	movs	r2, r3
 800475e:	4b80      	ldr	r3, [pc, #512]	; (8004960 <externalDataCommand+0x83c>)
 8004760:	0021      	movs	r1, r4
 8004762:	0018      	movs	r0, r3
 8004764:	f008 f8c2 	bl	800c8ec <iprintf>
 8004768:	4b74      	ldr	r3, [pc, #464]	; (800493c <externalDataCommand+0x818>)
 800476a:	0018      	movs	r0, r3
 800476c:	f008 f938 	bl	800c9e0 <puts>

                            /* MAC commands won't fit into Fopts; frame becomes a port 0 data frame (and application loses) */
                            if((LDL_Stream_tell(&s) > 15U) || (LDL_Frame_dataOverhead() + len + LDL_Stream_tell(&s)) > maxPayload){
 8004770:	197b      	adds	r3, r7, r5
 8004772:	0018      	movs	r0, r3
 8004774:	f004 fefb 	bl	800956e <LDL_Stream_tell>
 8004778:	0003      	movs	r3, r0
 800477a:	2b0f      	cmp	r3, #15
 800477c:	d813      	bhi.n	80047a6 <externalDataCommand+0x682>
 800477e:	f7fd ffc2 	bl	8002706 <LDL_Frame_dataOverhead>
 8004782:	0003      	movs	r3, r0
 8004784:	001a      	movs	r2, r3
 8004786:	2380      	movs	r3, #128	; 0x80
 8004788:	18fb      	adds	r3, r7, r3
 800478a:	781b      	ldrb	r3, [r3, #0]
 800478c:	18d4      	adds	r4, r2, r3
 800478e:	2334      	movs	r3, #52	; 0x34
 8004790:	18fb      	adds	r3, r7, r3
 8004792:	0018      	movs	r0, r3
 8004794:	f004 feeb 	bl	800956e <LDL_Stream_tell>
 8004798:	0003      	movs	r3, r0
 800479a:	18e3      	adds	r3, r4, r3
 800479c:	2267      	movs	r2, #103	; 0x67
 800479e:	18ba      	adds	r2, r7, r2
 80047a0:	7812      	ldrb	r2, [r2, #0]
 80047a2:	4293      	cmp	r3, r2
 80047a4:	dd3e      	ble.n	8004824 <externalDataCommand+0x700>
                                
                                LDL_DEBUG(self->app, "MAC commands and data too large for frame; MAC commands prioritised")
 80047a6:	4b66      	ldr	r3, [pc, #408]	; (8004940 <externalDataCommand+0x81c>)
 80047a8:	0018      	movs	r0, r3
 80047aa:	f008 f89f 	bl	800c8ec <iprintf>
 80047ae:	4b6d      	ldr	r3, [pc, #436]	; (8004964 <externalDataCommand+0x840>)
 80047b0:	0018      	movs	r0, r3
 80047b2:	f008 f89b 	bl	800c8ec <iprintf>
 80047b6:	4b61      	ldr	r3, [pc, #388]	; (800493c <externalDataCommand+0x818>)
 80047b8:	0018      	movs	r0, r3
 80047ba:	f008 f911 	bl	800c9e0 <puts>
                                
                                f.type = FRAME_TYPE_DATA_UNCONFIRMED_UP;
 80047be:	2340      	movs	r3, #64	; 0x40
 80047c0:	18fb      	adds	r3, r7, r3
 80047c2:	2202      	movs	r2, #2
 80047c4:	701a      	strb	r2, [r3, #0]
                                self->op = LDL_OP_DATA_UNCONFIRMED;
 80047c6:	68fb      	ldr	r3, [r7, #12]
 80047c8:	2203      	movs	r2, #3
 80047ca:	705a      	strb	r2, [r3, #1]
                                
                                if(LDL_Stream_tell(&s) < 16U){
 80047cc:	2334      	movs	r3, #52	; 0x34
 80047ce:	18fb      	adds	r3, r7, r3
 80047d0:	0018      	movs	r0, r3
 80047d2:	f004 fecc 	bl	800956e <LDL_Stream_tell>
 80047d6:	0003      	movs	r3, r0
 80047d8:	2b0f      	cmp	r3, #15
 80047da:	d80e      	bhi.n	80047fa <externalDataCommand+0x6d6>
                                 
                                    f.opts = macs;
 80047dc:	2440      	movs	r4, #64	; 0x40
 80047de:	193b      	adds	r3, r7, r4
 80047e0:	2214      	movs	r2, #20
 80047e2:	18ba      	adds	r2, r7, r2
 80047e4:	611a      	str	r2, [r3, #16]
                                    f.optsLen = LDL_Stream_tell(&s);
 80047e6:	2334      	movs	r3, #52	; 0x34
 80047e8:	18fb      	adds	r3, r7, r3
 80047ea:	0018      	movs	r0, r3
 80047ec:	f004 febf 	bl	800956e <LDL_Stream_tell>
 80047f0:	0003      	movs	r3, r0
 80047f2:	001a      	movs	r2, r3
 80047f4:	193b      	adds	r3, r7, r4
 80047f6:	751a      	strb	r2, [r3, #20]
 80047f8:	e010      	b.n	800481c <externalDataCommand+0x6f8>
                                }
                                else{
                                    
                                    f.port = 0U;
 80047fa:	2440      	movs	r4, #64	; 0x40
 80047fc:	193b      	adds	r3, r7, r4
 80047fe:	2200      	movs	r2, #0
 8004800:	755a      	strb	r2, [r3, #21]
                                    f.data = macs;
 8004802:	193b      	adds	r3, r7, r4
 8004804:	2214      	movs	r2, #20
 8004806:	18ba      	adds	r2, r7, r2
 8004808:	619a      	str	r2, [r3, #24]
                                    f.dataLen = LDL_Stream_tell(&s);
 800480a:	2334      	movs	r3, #52	; 0x34
 800480c:	18fb      	adds	r3, r7, r3
 800480e:	0018      	movs	r0, r3
 8004810:	f004 fead 	bl	800956e <LDL_Stream_tell>
 8004814:	0003      	movs	r3, r0
 8004816:	001a      	movs	r2, r3
 8004818:	193b      	adds	r3, r7, r4
 800481a:	771a      	strb	r2, [r3, #28]
                                }
                                
                                /* provide reason for failure to application */
                                self->errno = LDL_ERRNO_MACPRIORITY;
 800481c:	68fb      	ldr	r3, [r7, #12]
 800481e:	2209      	movs	r2, #9
 8004820:	709a      	strb	r2, [r3, #2]
 8004822:	e019      	b.n	8004858 <externalDataCommand+0x734>
                            }
                            /* mac commands fit into fopts */
                            else{
                                
                                f.opts = macs;
 8004824:	2440      	movs	r4, #64	; 0x40
 8004826:	193b      	adds	r3, r7, r4
 8004828:	2214      	movs	r2, #20
 800482a:	18ba      	adds	r2, r7, r2
 800482c:	611a      	str	r2, [r3, #16]
                                f.optsLen = LDL_Stream_tell(&s);
 800482e:	2334      	movs	r3, #52	; 0x34
 8004830:	18fb      	adds	r3, r7, r3
 8004832:	0018      	movs	r0, r3
 8004834:	f004 fe9b 	bl	800956e <LDL_Stream_tell>
 8004838:	0003      	movs	r3, r0
 800483a:	001a      	movs	r2, r3
 800483c:	193b      	adds	r3, r7, r4
 800483e:	751a      	strb	r2, [r3, #20]
                                
                                f.data = data;
 8004840:	193b      	adds	r3, r7, r4
 8004842:	687a      	ldr	r2, [r7, #4]
 8004844:	619a      	str	r2, [r3, #24]
                                f.dataLen = len;
 8004846:	193b      	adds	r3, r7, r4
 8004848:	2280      	movs	r2, #128	; 0x80
 800484a:	18ba      	adds	r2, r7, r2
 800484c:	7812      	ldrb	r2, [r2, #0]
 800484e:	771a      	strb	r2, [r3, #28]
                                
                                /* indicate success to application */
                                retval = true;
 8004850:	236f      	movs	r3, #111	; 0x6f
 8004852:	18fb      	adds	r3, r7, r3
 8004854:	2201      	movs	r2, #1
 8004856:	701a      	strb	r2, [r3, #0]
                            }
                            
                            self->bufferLen = LDL_OPS_prepareData(self, &f, self->buffer, sizeof(self->buffer));                            
 8004858:	68fb      	ldr	r3, [r7, #12]
 800485a:	3313      	adds	r3, #19
 800485c:	001a      	movs	r2, r3
 800485e:	2340      	movs	r3, #64	; 0x40
 8004860:	18f9      	adds	r1, r7, r3
 8004862:	68f8      	ldr	r0, [r7, #12]
 8004864:	23ff      	movs	r3, #255	; 0xff
 8004866:	f002 fd81 	bl	800736c <LDL_OPS_prepareData>
 800486a:	0003      	movs	r3, r0
 800486c:	0019      	movs	r1, r3
 800486e:	68fa      	ldr	r2, [r7, #12]
 8004870:	2389      	movs	r3, #137	; 0x89
 8004872:	005b      	lsls	r3, r3, #1
 8004874:	54d1      	strb	r1, [r2, r3]
                            
                            LDL_OPS_micDataFrame(self, self->buffer, self->bufferLen);                                    
 8004876:	68fb      	ldr	r3, [r7, #12]
 8004878:	3313      	adds	r3, #19
 800487a:	0019      	movs	r1, r3
 800487c:	68fa      	ldr	r2, [r7, #12]
 800487e:	2389      	movs	r3, #137	; 0x89
 8004880:	005b      	lsls	r3, r3, #1
 8004882:	5cd2      	ldrb	r2, [r2, r3]
 8004884:	68fb      	ldr	r3, [r7, #12]
 8004886:	0018      	movs	r0, r3
 8004888:	f002 fde0 	bl	800744c <LDL_OPS_micDataFrame>
                        }
                        
                        self->state = LDL_STATE_WAIT_TX;
 800488c:	68fb      	ldr	r3, [r7, #12]
 800488e:	2207      	movs	r2, #7
 8004890:	701a      	strb	r2, [r3, #0]
                        
                        uint32_t send_delay = 0U;
 8004892:	2300      	movs	r3, #0
 8004894:	66bb      	str	r3, [r7, #104]	; 0x68
                        
                        if(self->opts.dither > 0U){
 8004896:	68fb      	ldr	r3, [r7, #12]
 8004898:	4a33      	ldr	r2, [pc, #204]	; (8004968 <externalDataCommand+0x844>)
 800489a:	5c9b      	ldrb	r3, [r3, r2]
 800489c:	2b00      	cmp	r3, #0
 800489e:	d015      	beq.n	80048cc <externalDataCommand+0x7a8>
                            
                            send_delay = (rand32(self->app) % ((uint32_t)self->opts.dither * LDL_System_tps()));
 80048a0:	68fa      	ldr	r2, [r7, #12]
 80048a2:	2393      	movs	r3, #147	; 0x93
 80048a4:	009b      	lsls	r3, r3, #2
 80048a6:	58d3      	ldr	r3, [r2, r3]
 80048a8:	0018      	movs	r0, r3
 80048aa:	f002 f805 	bl	80068b8 <rand32>
 80048ae:	0005      	movs	r5, r0
 80048b0:	68fb      	ldr	r3, [r7, #12]
 80048b2:	4a2d      	ldr	r2, [pc, #180]	; (8004968 <externalDataCommand+0x844>)
 80048b4:	5c9b      	ldrb	r3, [r3, r2]
 80048b6:	001c      	movs	r4, r3
 80048b8:	f005 fb15 	bl	8009ee6 <LDL_System_tps>
 80048bc:	0003      	movs	r3, r0
 80048be:	4363      	muls	r3, r4
 80048c0:	0019      	movs	r1, r3
 80048c2:	0028      	movs	r0, r5
 80048c4:	f7fb fca6 	bl	8000214 <__aeabi_uidivmod>
 80048c8:	000b      	movs	r3, r1
 80048ca:	66bb      	str	r3, [r7, #104]	; 0x68
                        }
                        
                        self->service_start_time = timeNow(self) + (send_delay / LDL_System_tps());            
 80048cc:	68fb      	ldr	r3, [r7, #12]
 80048ce:	0018      	movs	r0, r3
 80048d0:	f001 fc68 	bl	80061a4 <timeNow>
 80048d4:	0004      	movs	r4, r0
 80048d6:	f005 fb06 	bl	8009ee6 <LDL_System_tps>
 80048da:	0003      	movs	r3, r0
 80048dc:	0019      	movs	r1, r3
 80048de:	6eb8      	ldr	r0, [r7, #104]	; 0x68
 80048e0:	f7fb fc12 	bl	8000108 <__udivsi3>
 80048e4:	0003      	movs	r3, r0
 80048e6:	18e1      	adds	r1, r4, r3
 80048e8:	68fa      	ldr	r2, [r7, #12]
 80048ea:	2398      	movs	r3, #152	; 0x98
 80048ec:	009b      	lsls	r3, r3, #2
 80048ee:	50d1      	str	r1, [r2, r3]
                                    
                        LDL_MAC_timerSet(self, LDL_TIMER_WAITA, send_delay);                        
 80048f0:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80048f2:	68fb      	ldr	r3, [r7, #12]
 80048f4:	2100      	movs	r1, #0
 80048f6:	0018      	movs	r0, r3
 80048f8:	f7ff faa0 	bl	8003e3c <LDL_MAC_timerSet>
                if(self->band[LDL_BAND_GLOBAL] == 0UL){
 80048fc:	e012      	b.n	8004924 <externalDataCommand+0x800>
                    }
                    else{
                        
                        self->errno = LDL_ERRNO_NOCHANNEL;
 80048fe:	68fb      	ldr	r3, [r7, #12]
 8004900:	2201      	movs	r2, #1
 8004902:	709a      	strb	r2, [r3, #2]
                if(self->band[LDL_BAND_GLOBAL] == 0UL){
 8004904:	e00e      	b.n	8004924 <externalDataCommand+0x800>
                    }                
                }
                else{
                    
                    self->errno = LDL_ERRNO_NOCHANNEL;
 8004906:	68fb      	ldr	r3, [r7, #12]
 8004908:	2201      	movs	r2, #1
 800490a:	709a      	strb	r2, [r3, #2]
                if(self->band[LDL_BAND_GLOBAL] == 0UL){
 800490c:	e00a      	b.n	8004924 <externalDataCommand+0x800>
                }
            }
            else{
                
                self->errno = LDL_ERRNO_PORT;
 800490e:	68fb      	ldr	r3, [r7, #12]
 8004910:	2204      	movs	r2, #4
 8004912:	709a      	strb	r2, [r3, #2]
 8004914:	e006      	b.n	8004924 <externalDataCommand+0x800>
            }
        }
        else{
            
            self->errno = LDL_ERRNO_NOTJOINED;
 8004916:	68fb      	ldr	r3, [r7, #12]
 8004918:	2206      	movs	r2, #6
 800491a:	709a      	strb	r2, [r3, #2]
 800491c:	e002      	b.n	8004924 <externalDataCommand+0x800>
        }
    }
    else{
        
        self->errno = LDL_ERRNO_BUSY;
 800491e:	68fb      	ldr	r3, [r7, #12]
 8004920:	2205      	movs	r2, #5
 8004922:	709a      	strb	r2, [r3, #2]
    }
            
    return retval;
 8004924:	236f      	movs	r3, #111	; 0x6f
 8004926:	18fb      	adds	r3, r7, r3
 8004928:	781b      	ldrb	r3, [r3, #0]
}
 800492a:	0018      	movs	r0, r3
 800492c:	46bd      	mov	sp, r7
 800492e:	b01c      	add	sp, #112	; 0x70
 8004930:	bdb0      	pop	{r4, r5, r7, pc}
 8004932:	46c0      	nop			; (mov r8, r8)
 8004934:	0800d9a0 	.word	0x0800d9a0
 8004938:	0800daec 	.word	0x0800daec
 800493c:	0800d8e4 	.word	0x0800d8e4
 8004940:	0800d8e8 	.word	0x0800d8e8
 8004944:	0800db18 	.word	0x0800db18
 8004948:	0800db34 	.word	0x0800db34
 800494c:	0800db50 	.word	0x0800db50
 8004950:	00000269 	.word	0x00000269
 8004954:	0800db68 	.word	0x0800db68
 8004958:	0000026a 	.word	0x0000026a
 800495c:	0800db80 	.word	0x0800db80
 8004960:	0800db98 	.word	0x0800db98
 8004964:	0800dbac 	.word	0x0800dbac
 8004968:	0000026b 	.word	0x0000026b

0800496c <adaptRate>:

static void adaptRate(struct ldl_mac *self)
{
 800496c:	b580      	push	{r7, lr}
 800496e:	b082      	sub	sp, #8
 8004970:	af00      	add	r7, sp, #0
 8004972:	6078      	str	r0, [r7, #4]
    self->adrAckReq = false;
 8004974:	687b      	ldr	r3, [r7, #4]
 8004976:	4a5d      	ldr	r2, [pc, #372]	; (8004aec <adaptRate+0x180>)
 8004978:	2100      	movs	r1, #0
 800497a:	5499      	strb	r1, [r3, r2]
    
    if(self->ctx.adr){
 800497c:	687b      	ldr	r3, [r7, #4]
 800497e:	4a5c      	ldr	r2, [pc, #368]	; (8004af0 <adaptRate+0x184>)
 8004980:	5c9b      	ldrb	r3, [r3, r2]
 8004982:	2b00      	cmp	r3, #0
 8004984:	d100      	bne.n	8004988 <adaptRate+0x1c>
 8004986:	e0ac      	b.n	8004ae2 <adaptRate+0x176>
                
        if(self->adrAckCounter < UINT8_MAX){
 8004988:	687a      	ldr	r2, [r7, #4]
 800498a:	2395      	movs	r3, #149	; 0x95
 800498c:	009b      	lsls	r3, r3, #2
 800498e:	5cd3      	ldrb	r3, [r2, r3]
 8004990:	2bff      	cmp	r3, #255	; 0xff
 8004992:	d100      	bne.n	8004996 <adaptRate+0x2a>
 8004994:	e0a5      	b.n	8004ae2 <adaptRate+0x176>
            
            if(self->adrAckCounter >= self->ctx.adr_ack_limit){
 8004996:	687a      	ldr	r2, [r7, #4]
 8004998:	2395      	movs	r3, #149	; 0x95
 800499a:	009b      	lsls	r3, r3, #2
 800499c:	5cd3      	ldrb	r3, [r2, r3]
 800499e:	b29a      	uxth	r2, r3
 80049a0:	6879      	ldr	r1, [r7, #4]
 80049a2:	2382      	movs	r3, #130	; 0x82
 80049a4:	009b      	lsls	r3, r3, #2
 80049a6:	5acb      	ldrh	r3, [r1, r3]
 80049a8:	429a      	cmp	r2, r3
 80049aa:	d200      	bcs.n	80049ae <adaptRate+0x42>
 80049ac:	e08f      	b.n	8004ace <adaptRate+0x162>
                
                self->adrAckReq = true;
 80049ae:	687b      	ldr	r3, [r7, #4]
 80049b0:	4a4e      	ldr	r2, [pc, #312]	; (8004aec <adaptRate+0x180>)
 80049b2:	2101      	movs	r1, #1
 80049b4:	5499      	strb	r1, [r3, r2]
            
                LDL_DEBUG(self->app, "adr: adrAckCounter=%u (past ADRAckLimit)", self->adrAckCounter)
 80049b6:	4b4f      	ldr	r3, [pc, #316]	; (8004af4 <adaptRate+0x188>)
 80049b8:	0018      	movs	r0, r3
 80049ba:	f007 ff97 	bl	800c8ec <iprintf>
 80049be:	687a      	ldr	r2, [r7, #4]
 80049c0:	2395      	movs	r3, #149	; 0x95
 80049c2:	009b      	lsls	r3, r3, #2
 80049c4:	5cd3      	ldrb	r3, [r2, r3]
 80049c6:	001a      	movs	r2, r3
 80049c8:	4b4b      	ldr	r3, [pc, #300]	; (8004af8 <adaptRate+0x18c>)
 80049ca:	0011      	movs	r1, r2
 80049cc:	0018      	movs	r0, r3
 80049ce:	f007 ff8d 	bl	800c8ec <iprintf>
 80049d2:	4b4a      	ldr	r3, [pc, #296]	; (8004afc <adaptRate+0x190>)
 80049d4:	0018      	movs	r0, r3
 80049d6:	f008 f803 	bl	800c9e0 <puts>
            
                if(self->adrAckCounter >= (self->ctx.adr_ack_limit + self->ctx.adr_ack_delay)){
 80049da:	687a      	ldr	r2, [r7, #4]
 80049dc:	2395      	movs	r3, #149	; 0x95
 80049de:	009b      	lsls	r3, r3, #2
 80049e0:	5cd3      	ldrb	r3, [r2, r3]
 80049e2:	0019      	movs	r1, r3
 80049e4:	687a      	ldr	r2, [r7, #4]
 80049e6:	2382      	movs	r3, #130	; 0x82
 80049e8:	009b      	lsls	r3, r3, #2
 80049ea:	5ad3      	ldrh	r3, [r2, r3]
 80049ec:	0018      	movs	r0, r3
 80049ee:	687b      	ldr	r3, [r7, #4]
 80049f0:	4a43      	ldr	r2, [pc, #268]	; (8004b00 <adaptRate+0x194>)
 80049f2:	5a9b      	ldrh	r3, [r3, r2]
 80049f4:	18c3      	adds	r3, r0, r3
 80049f6:	4299      	cmp	r1, r3
 80049f8:	db69      	blt.n	8004ace <adaptRate+0x162>
                
                    if(((self->adrAckCounter - (self->ctx.adr_ack_limit + self->ctx.adr_ack_delay)) % self->ctx.adr_ack_delay) == 0U){
 80049fa:	687a      	ldr	r2, [r7, #4]
 80049fc:	2395      	movs	r3, #149	; 0x95
 80049fe:	009b      	lsls	r3, r3, #2
 8004a00:	5cd3      	ldrb	r3, [r2, r3]
 8004a02:	0019      	movs	r1, r3
 8004a04:	687a      	ldr	r2, [r7, #4]
 8004a06:	2382      	movs	r3, #130	; 0x82
 8004a08:	009b      	lsls	r3, r3, #2
 8004a0a:	5ad3      	ldrh	r3, [r2, r3]
 8004a0c:	0018      	movs	r0, r3
 8004a0e:	687b      	ldr	r3, [r7, #4]
 8004a10:	4a3b      	ldr	r2, [pc, #236]	; (8004b00 <adaptRate+0x194>)
 8004a12:	5a9b      	ldrh	r3, [r3, r2]
 8004a14:	18c3      	adds	r3, r0, r3
 8004a16:	1ac8      	subs	r0, r1, r3
 8004a18:	687b      	ldr	r3, [r7, #4]
 8004a1a:	4a39      	ldr	r2, [pc, #228]	; (8004b00 <adaptRate+0x194>)
 8004a1c:	5a9b      	ldrh	r3, [r3, r2]
 8004a1e:	0019      	movs	r1, r3
 8004a20:	f7fb fce2 	bl	80003e8 <__aeabi_idivmod>
 8004a24:	1e0b      	subs	r3, r1, #0
 8004a26:	d152      	bne.n	8004ace <adaptRate+0x162>
                
                        if(self->ctx.power == 0U){
 8004a28:	687a      	ldr	r2, [r7, #4]
 8004a2a:	23fb      	movs	r3, #251	; 0xfb
 8004a2c:	005b      	lsls	r3, r3, #1
 8004a2e:	5cd3      	ldrb	r3, [r2, r3]
 8004a30:	2b00      	cmp	r3, #0
 8004a32:	d13b      	bne.n	8004aac <adaptRate+0x140>
                
                            if(self->ctx.rate > LDL_DEFAULT_RATE){
 8004a34:	687a      	ldr	r2, [r7, #4]
 8004a36:	23f6      	movs	r3, #246	; 0xf6
 8004a38:	33ff      	adds	r3, #255	; 0xff
 8004a3a:	5cd3      	ldrb	r3, [r2, r3]
 8004a3c:	2b01      	cmp	r3, #1
 8004a3e:	d91c      	bls.n	8004a7a <adaptRate+0x10e>
                                                            
                                self->ctx.rate--;
 8004a40:	687a      	ldr	r2, [r7, #4]
 8004a42:	23f6      	movs	r3, #246	; 0xf6
 8004a44:	33ff      	adds	r3, #255	; 0xff
 8004a46:	5cd3      	ldrb	r3, [r2, r3]
 8004a48:	3b01      	subs	r3, #1
 8004a4a:	b2d9      	uxtb	r1, r3
 8004a4c:	687a      	ldr	r2, [r7, #4]
 8004a4e:	23f6      	movs	r3, #246	; 0xf6
 8004a50:	33ff      	adds	r3, #255	; 0xff
 8004a52:	54d1      	strb	r1, [r2, r3]
                                LDL_DEBUG(self->app, "adr: rate reduced to %u", self->ctx.rate)
 8004a54:	4b27      	ldr	r3, [pc, #156]	; (8004af4 <adaptRate+0x188>)
 8004a56:	0018      	movs	r0, r3
 8004a58:	f007 ff48 	bl	800c8ec <iprintf>
 8004a5c:	687a      	ldr	r2, [r7, #4]
 8004a5e:	23f6      	movs	r3, #246	; 0xf6
 8004a60:	33ff      	adds	r3, #255	; 0xff
 8004a62:	5cd3      	ldrb	r3, [r2, r3]
 8004a64:	001a      	movs	r2, r3
 8004a66:	4b27      	ldr	r3, [pc, #156]	; (8004b04 <adaptRate+0x198>)
 8004a68:	0011      	movs	r1, r2
 8004a6a:	0018      	movs	r0, r3
 8004a6c:	f007 ff3e 	bl	800c8ec <iprintf>
 8004a70:	4b22      	ldr	r3, [pc, #136]	; (8004afc <adaptRate+0x190>)
 8004a72:	0018      	movs	r0, r3
 8004a74:	f007 ffb4 	bl	800c9e0 <puts>
 8004a78:	e029      	b.n	8004ace <adaptRate+0x162>
                            }
                            else{
                                
                                LDL_DEBUG(self->app, "adr: all channels unmasked")
 8004a7a:	4b1e      	ldr	r3, [pc, #120]	; (8004af4 <adaptRate+0x188>)
 8004a7c:	0018      	movs	r0, r3
 8004a7e:	f007 ff35 	bl	800c8ec <iprintf>
 8004a82:	4b21      	ldr	r3, [pc, #132]	; (8004b08 <adaptRate+0x19c>)
 8004a84:	0018      	movs	r0, r3
 8004a86:	f007 ff31 	bl	800c8ec <iprintf>
 8004a8a:	4b1c      	ldr	r3, [pc, #112]	; (8004afc <adaptRate+0x190>)
 8004a8c:	0018      	movs	r0, r3
 8004a8e:	f007 ffa7 	bl	800c9e0 <puts>
                                
                                unmaskAllChannels(self->ctx.chMask, sizeof(self->ctx.chMask));
 8004a92:	687b      	ldr	r3, [r7, #4]
 8004a94:	33ed      	adds	r3, #237	; 0xed
 8004a96:	33ff      	adds	r3, #255	; 0xff
 8004a98:	2109      	movs	r1, #9
 8004a9a:	0018      	movs	r0, r3
 8004a9c:	f001 fabe 	bl	800601c <unmaskAllChannels>
                                
                                self->adrAckCounter = UINT8_MAX;
 8004aa0:	687a      	ldr	r2, [r7, #4]
 8004aa2:	2395      	movs	r3, #149	; 0x95
 8004aa4:	009b      	lsls	r3, r3, #2
 8004aa6:	21ff      	movs	r1, #255	; 0xff
 8004aa8:	54d1      	strb	r1, [r2, r3]
 8004aaa:	e010      	b.n	8004ace <adaptRate+0x162>
                            }
                        }
                        else{
                            
                            LDL_DEBUG(self->app, "adr: full power enabled")
 8004aac:	4b11      	ldr	r3, [pc, #68]	; (8004af4 <adaptRate+0x188>)
 8004aae:	0018      	movs	r0, r3
 8004ab0:	f007 ff1c 	bl	800c8ec <iprintf>
 8004ab4:	4b15      	ldr	r3, [pc, #84]	; (8004b0c <adaptRate+0x1a0>)
 8004ab6:	0018      	movs	r0, r3
 8004ab8:	f007 ff18 	bl	800c8ec <iprintf>
 8004abc:	4b0f      	ldr	r3, [pc, #60]	; (8004afc <adaptRate+0x190>)
 8004abe:	0018      	movs	r0, r3
 8004ac0:	f007 ff8e 	bl	800c9e0 <puts>
                            self->ctx.power = 0U;
 8004ac4:	687a      	ldr	r2, [r7, #4]
 8004ac6:	23fb      	movs	r3, #251	; 0xfb
 8004ac8:	005b      	lsls	r3, r3, #1
 8004aca:	2100      	movs	r1, #0
 8004acc:	54d1      	strb	r1, [r2, r3]
                        }
                    }
                }    
            }
                
            self->adrAckCounter++;            
 8004ace:	687a      	ldr	r2, [r7, #4]
 8004ad0:	2395      	movs	r3, #149	; 0x95
 8004ad2:	009b      	lsls	r3, r3, #2
 8004ad4:	5cd3      	ldrb	r3, [r2, r3]
 8004ad6:	3301      	adds	r3, #1
 8004ad8:	b2d9      	uxtb	r1, r3
 8004ada:	687a      	ldr	r2, [r7, #4]
 8004adc:	2395      	movs	r3, #149	; 0x95
 8004ade:	009b      	lsls	r3, r3, #2
 8004ae0:	54d1      	strb	r1, [r2, r3]
        }        
    }
}
 8004ae2:	46c0      	nop			; (mov r8, r8)
 8004ae4:	46bd      	mov	sp, r7
 8004ae6:	b002      	add	sp, #8
 8004ae8:	bd80      	pop	{r7, pc}
 8004aea:	46c0      	nop			; (mov r8, r8)
 8004aec:	00000255 	.word	0x00000255
 8004af0:	00000205 	.word	0x00000205
 8004af4:	0800d8e8 	.word	0x0800d8e8
 8004af8:	0800dbf0 	.word	0x0800dbf0
 8004afc:	0800d8e4 	.word	0x0800d8e4
 8004b00:	0000020a 	.word	0x0000020a
 8004b04:	0800dc1c 	.word	0x0800dc1c
 8004b08:	0800dc34 	.word	0x0800dc34
 8004b0c:	0800dc50 	.word	0x0800dc50

08004b10 <transmitTime>:

static uint32_t transmitTime(enum ldl_signal_bandwidth bw, enum ldl_spreading_factor sf, uint8_t size, bool crc)
{
 8004b10:	b5b0      	push	{r4, r5, r7, lr}
 8004b12:	b08a      	sub	sp, #40	; 0x28
 8004b14:	af00      	add	r7, sp, #0
 8004b16:	0005      	movs	r5, r0
 8004b18:	000c      	movs	r4, r1
 8004b1a:	0010      	movs	r0, r2
 8004b1c:	0019      	movs	r1, r3
 8004b1e:	1dfb      	adds	r3, r7, #7
 8004b20:	1c2a      	adds	r2, r5, #0
 8004b22:	701a      	strb	r2, [r3, #0]
 8004b24:	1dbb      	adds	r3, r7, #6
 8004b26:	1c22      	adds	r2, r4, #0
 8004b28:	701a      	strb	r2, [r3, #0]
 8004b2a:	1d7b      	adds	r3, r7, #5
 8004b2c:	1c02      	adds	r2, r0, #0
 8004b2e:	701a      	strb	r2, [r3, #0]
 8004b30:	1d3b      	adds	r3, r7, #4
 8004b32:	1c0a      	adds	r2, r1, #0
 8004b34:	701a      	strb	r2, [r3, #0]
    uint32_t denom;
    uint32_t Npayload;
    uint32_t Tpayload;
    
    /* optimise this mode according to the datasheet */
    lowDataRateOptimize = ((bw == LDL_BW_125) && ((sf == LDL_SF_11) || (sf == LDL_SF_12))) ? true : false;    
 8004b36:	1dfb      	adds	r3, r7, #7
 8004b38:	781b      	ldrb	r3, [r3, #0]
 8004b3a:	2b00      	cmp	r3, #0
 8004b3c:	d109      	bne.n	8004b52 <transmitTime+0x42>
 8004b3e:	1dbb      	adds	r3, r7, #6
 8004b40:	781b      	ldrb	r3, [r3, #0]
 8004b42:	2b0b      	cmp	r3, #11
 8004b44:	d003      	beq.n	8004b4e <transmitTime+0x3e>
 8004b46:	1dbb      	adds	r3, r7, #6
 8004b48:	781b      	ldrb	r3, [r3, #0]
 8004b4a:	2b0c      	cmp	r3, #12
 8004b4c:	d101      	bne.n	8004b52 <transmitTime+0x42>
 8004b4e:	2201      	movs	r2, #1
 8004b50:	e000      	b.n	8004b54 <transmitTime+0x44>
 8004b52:	2200      	movs	r2, #0
 8004b54:	2327      	movs	r3, #39	; 0x27
 8004b56:	18fb      	adds	r3, r7, r3
 8004b58:	701a      	strb	r2, [r3, #0]
 8004b5a:	781a      	ldrb	r2, [r3, #0]
 8004b5c:	2101      	movs	r1, #1
 8004b5e:	400a      	ands	r2, r1
 8004b60:	701a      	strb	r2, [r3, #0]
    
    /* lorawan always uses a header */
    header = true; 
 8004b62:	2326      	movs	r3, #38	; 0x26
 8004b64:	18fb      	adds	r3, r7, r3
 8004b66:	2201      	movs	r2, #1
 8004b68:	701a      	strb	r2, [r3, #0]

    Ts = symbolPeriod(sf, bw);
 8004b6a:	1dfb      	adds	r3, r7, #7
 8004b6c:	781a      	ldrb	r2, [r3, #0]
 8004b6e:	1dbb      	adds	r3, r7, #6
 8004b70:	781b      	ldrb	r3, [r3, #0]
 8004b72:	0011      	movs	r1, r2
 8004b74:	0018      	movs	r0, r3
 8004b76:	f000 f856 	bl	8004c26 <symbolPeriod>
 8004b7a:	0003      	movs	r3, r0
 8004b7c:	623b      	str	r3, [r7, #32]
    Tpreamble = (Ts * 12UL) +  (Ts / 4UL);
 8004b7e:	6a3a      	ldr	r2, [r7, #32]
 8004b80:	0013      	movs	r3, r2
 8004b82:	005b      	lsls	r3, r3, #1
 8004b84:	189b      	adds	r3, r3, r2
 8004b86:	009b      	lsls	r3, r3, #2
 8004b88:	001a      	movs	r2, r3
 8004b8a:	6a3b      	ldr	r3, [r7, #32]
 8004b8c:	089b      	lsrs	r3, r3, #2
 8004b8e:	18d3      	adds	r3, r2, r3
 8004b90:	61fb      	str	r3, [r7, #28]

    numerator = (8UL * (uint32_t)size) - (4UL * (uint32_t)sf) + 28UL + ( crc ? 16UL : 0UL ) - ( header ? 20UL : 0UL );
 8004b92:	1d7b      	adds	r3, r7, #5
 8004b94:	781b      	ldrb	r3, [r3, #0]
 8004b96:	005a      	lsls	r2, r3, #1
 8004b98:	1dbb      	adds	r3, r7, #6
 8004b9a:	781b      	ldrb	r3, [r3, #0]
 8004b9c:	1ad3      	subs	r3, r2, r3
 8004b9e:	3307      	adds	r3, #7
 8004ba0:	009a      	lsls	r2, r3, #2
 8004ba2:	1d3b      	adds	r3, r7, #4
 8004ba4:	781b      	ldrb	r3, [r3, #0]
 8004ba6:	2b00      	cmp	r3, #0
 8004ba8:	d001      	beq.n	8004bae <transmitTime+0x9e>
 8004baa:	2310      	movs	r3, #16
 8004bac:	e000      	b.n	8004bb0 <transmitTime+0xa0>
 8004bae:	2300      	movs	r3, #0
 8004bb0:	189a      	adds	r2, r3, r2
 8004bb2:	2326      	movs	r3, #38	; 0x26
 8004bb4:	18fb      	adds	r3, r7, r3
 8004bb6:	781b      	ldrb	r3, [r3, #0]
 8004bb8:	2b00      	cmp	r3, #0
 8004bba:	d001      	beq.n	8004bc0 <transmitTime+0xb0>
 8004bbc:	2314      	movs	r3, #20
 8004bbe:	e000      	b.n	8004bc2 <transmitTime+0xb2>
 8004bc0:	2300      	movs	r3, #0
 8004bc2:	1ad3      	subs	r3, r2, r3
 8004bc4:	61bb      	str	r3, [r7, #24]
    denom = 4UL * ((uint32_t)sf - ( lowDataRateOptimize ? 2UL : 0UL ));
 8004bc6:	1dbb      	adds	r3, r7, #6
 8004bc8:	781a      	ldrb	r2, [r3, #0]
 8004bca:	2327      	movs	r3, #39	; 0x27
 8004bcc:	18fb      	adds	r3, r7, r3
 8004bce:	781b      	ldrb	r3, [r3, #0]
 8004bd0:	2b00      	cmp	r3, #0
 8004bd2:	d001      	beq.n	8004bd8 <transmitTime+0xc8>
 8004bd4:	2302      	movs	r3, #2
 8004bd6:	e000      	b.n	8004bda <transmitTime+0xca>
 8004bd8:	2300      	movs	r3, #0
 8004bda:	1ad3      	subs	r3, r2, r3
 8004bdc:	009b      	lsls	r3, r3, #2
 8004bde:	617b      	str	r3, [r7, #20]

    Npayload = 8UL + ((((numerator / denom) + (((numerator % denom) != 0UL) ? 1UL : 0UL)) * ((uint32_t)CR_5 + 4UL)));
 8004be0:	6979      	ldr	r1, [r7, #20]
 8004be2:	69b8      	ldr	r0, [r7, #24]
 8004be4:	f7fb fa90 	bl	8000108 <__udivsi3>
 8004be8:	0003      	movs	r3, r0
 8004bea:	001c      	movs	r4, r3
 8004bec:	69bb      	ldr	r3, [r7, #24]
 8004bee:	6979      	ldr	r1, [r7, #20]
 8004bf0:	0018      	movs	r0, r3
 8004bf2:	f7fb fb0f 	bl	8000214 <__aeabi_uidivmod>
 8004bf6:	1e0b      	subs	r3, r1, #0
 8004bf8:	d001      	beq.n	8004bfe <transmitTime+0xee>
 8004bfa:	2301      	movs	r3, #1
 8004bfc:	e000      	b.n	8004c00 <transmitTime+0xf0>
 8004bfe:	2300      	movs	r3, #0
 8004c00:	191a      	adds	r2, r3, r4
 8004c02:	0013      	movs	r3, r2
 8004c04:	009b      	lsls	r3, r3, #2
 8004c06:	189b      	adds	r3, r3, r2
 8004c08:	3308      	adds	r3, #8
 8004c0a:	613b      	str	r3, [r7, #16]

    Tpayload = Npayload * Ts;
 8004c0c:	693b      	ldr	r3, [r7, #16]
 8004c0e:	6a3a      	ldr	r2, [r7, #32]
 8004c10:	4353      	muls	r3, r2
 8004c12:	60fb      	str	r3, [r7, #12]

    Tpacket = Tpreamble + Tpayload;
 8004c14:	69fa      	ldr	r2, [r7, #28]
 8004c16:	68fb      	ldr	r3, [r7, #12]
 8004c18:	18d3      	adds	r3, r2, r3
 8004c1a:	60bb      	str	r3, [r7, #8]

    return Tpacket;
 8004c1c:	68bb      	ldr	r3, [r7, #8]
}
 8004c1e:	0018      	movs	r0, r3
 8004c20:	46bd      	mov	sp, r7
 8004c22:	b00a      	add	sp, #40	; 0x28
 8004c24:	bdb0      	pop	{r4, r5, r7, pc}

08004c26 <symbolPeriod>:

static uint32_t symbolPeriod(enum ldl_spreading_factor sf, enum ldl_signal_bandwidth bw)
{
 8004c26:	b590      	push	{r4, r7, lr}
 8004c28:	b083      	sub	sp, #12
 8004c2a:	af00      	add	r7, sp, #0
 8004c2c:	0002      	movs	r2, r0
 8004c2e:	1dfb      	adds	r3, r7, #7
 8004c30:	701a      	strb	r2, [r3, #0]
 8004c32:	1dbb      	adds	r3, r7, #6
 8004c34:	1c0a      	adds	r2, r1, #0
 8004c36:	701a      	strb	r2, [r3, #0]
    return ((((uint32_t)1U) << sf) * LDL_System_tps()) / LDL_MAC_bwToNumber(bw);
 8004c38:	f005 f955 	bl	8009ee6 <LDL_System_tps>
 8004c3c:	0002      	movs	r2, r0
 8004c3e:	1dfb      	adds	r3, r7, #7
 8004c40:	781b      	ldrb	r3, [r3, #0]
 8004c42:	409a      	lsls	r2, r3
 8004c44:	0014      	movs	r4, r2
 8004c46:	1dbb      	adds	r3, r7, #6
 8004c48:	781b      	ldrb	r3, [r3, #0]
 8004c4a:	0018      	movs	r0, r3
 8004c4c:	f7ff f86c 	bl	8003d28 <LDL_MAC_bwToNumber>
 8004c50:	0003      	movs	r3, r0
 8004c52:	0019      	movs	r1, r3
 8004c54:	0020      	movs	r0, r4
 8004c56:	f7fb fa57 	bl	8000108 <__udivsi3>
 8004c5a:	0003      	movs	r3, r0
}
 8004c5c:	0018      	movs	r0, r3
 8004c5e:	46bd      	mov	sp, r7
 8004c60:	b003      	add	sp, #12
 8004c62:	bd90      	pop	{r4, r7, pc}

08004c64 <extraSymbols>:

static uint8_t extraSymbols(uint32_t xtal_error, uint32_t symbol_period)
{
 8004c64:	b590      	push	{r4, r7, lr}
 8004c66:	b083      	sub	sp, #12
 8004c68:	af00      	add	r7, sp, #0
 8004c6a:	6078      	str	r0, [r7, #4]
 8004c6c:	6039      	str	r1, [r7, #0]
    return (xtal_error / symbol_period) + (((xtal_error % symbol_period) > 0U) ? 1U : 0U);        
 8004c6e:	6839      	ldr	r1, [r7, #0]
 8004c70:	6878      	ldr	r0, [r7, #4]
 8004c72:	f7fb fa49 	bl	8000108 <__udivsi3>
 8004c76:	0003      	movs	r3, r0
 8004c78:	b2dc      	uxtb	r4, r3
 8004c7a:	687b      	ldr	r3, [r7, #4]
 8004c7c:	6839      	ldr	r1, [r7, #0]
 8004c7e:	0018      	movs	r0, r3
 8004c80:	f7fb fac8 	bl	8000214 <__aeabi_uidivmod>
 8004c84:	1e0b      	subs	r3, r1, #0
 8004c86:	d001      	beq.n	8004c8c <extraSymbols+0x28>
 8004c88:	2301      	movs	r3, #1
 8004c8a:	e000      	b.n	8004c8e <extraSymbols+0x2a>
 8004c8c:	2300      	movs	r3, #0
 8004c8e:	191b      	adds	r3, r3, r4
 8004c90:	b2db      	uxtb	r3, r3
}
 8004c92:	0018      	movs	r0, r3
 8004c94:	46bd      	mov	sp, r7
 8004c96:	b003      	add	sp, #12
 8004c98:	bd90      	pop	{r4, r7, pc}
	...

08004c9c <processCommands>:

static void processCommands(struct ldl_mac *self, const uint8_t *in, uint8_t len)
{
 8004c9c:	b5b0      	push	{r4, r5, r7, lr}
 8004c9e:	b09e      	sub	sp, #120	; 0x78
 8004ca0:	af02      	add	r7, sp, #8
 8004ca2:	60f8      	str	r0, [r7, #12]
 8004ca4:	60b9      	str	r1, [r7, #8]
 8004ca6:	1dfb      	adds	r3, r7, #7
 8004ca8:	701a      	strb	r2, [r3, #0]
        
        _NO_ADR,
        _ADR_OK,
        _ADR_BAD
        
    } adr_state = _NO_ADR;
 8004caa:	236f      	movs	r3, #111	; 0x6f
 8004cac:	18fb      	adds	r3, r7, r3
 8004cae:	2200      	movs	r2, #0
 8004cb0:	701a      	strb	r2, [r3, #0]
    
    /* these things can be rolled back */
    nbTrans = self->ctx.nbTrans;
 8004cb2:	236d      	movs	r3, #109	; 0x6d
 8004cb4:	18fb      	adds	r3, r7, r3
 8004cb6:	68f9      	ldr	r1, [r7, #12]
 8004cb8:	22fc      	movs	r2, #252	; 0xfc
 8004cba:	0052      	lsls	r2, r2, #1
 8004cbc:	5c8a      	ldrb	r2, [r1, r2]
 8004cbe:	701a      	strb	r2, [r3, #0]
    power = self->ctx.power;
 8004cc0:	236c      	movs	r3, #108	; 0x6c
 8004cc2:	18fb      	adds	r3, r7, r3
 8004cc4:	68f9      	ldr	r1, [r7, #12]
 8004cc6:	22fb      	movs	r2, #251	; 0xfb
 8004cc8:	0052      	lsls	r2, r2, #1
 8004cca:	5c8a      	ldrb	r2, [r1, r2]
 8004ccc:	701a      	strb	r2, [r3, #0]
    rate = self->ctx.rate;
 8004cce:	236b      	movs	r3, #107	; 0x6b
 8004cd0:	18fb      	adds	r3, r7, r3
 8004cd2:	68f9      	ldr	r1, [r7, #12]
 8004cd4:	22f6      	movs	r2, #246	; 0xf6
 8004cd6:	32ff      	adds	r2, #255	; 0xff
 8004cd8:	5c8a      	ldrb	r2, [r1, r2]
 8004cda:	701a      	strb	r2, [r3, #0]
    (void)memcpy(&chMask, self->ctx.chMask, sizeof(chMask));
 8004cdc:	68fb      	ldr	r3, [r7, #12]
 8004cde:	33ed      	adds	r3, #237	; 0xed
 8004ce0:	33ff      	adds	r3, #255	; 0xff
 8004ce2:	2244      	movs	r2, #68	; 0x44
 8004ce4:	18ba      	adds	r2, r7, r2
 8004ce6:	0010      	movs	r0, r2
 8004ce8:	0019      	movs	r1, r3
 8004cea:	2309      	movs	r3, #9
 8004cec:	001a      	movs	r2, r3
 8004cee:	f007 fdeb 	bl	800c8c8 <memcpy>
    
    LDL_Stream_initReadOnly(&s_in, in, len);
 8004cf2:	1dfb      	adds	r3, r7, #7
 8004cf4:	781a      	ldrb	r2, [r3, #0]
 8004cf6:	68b9      	ldr	r1, [r7, #8]
 8004cf8:	2350      	movs	r3, #80	; 0x50
 8004cfa:	18fb      	adds	r3, r7, r3
 8004cfc:	0018      	movs	r0, r3
 8004cfe:	f004 fb9b 	bl	8009438 <LDL_Stream_initReadOnly>
    
    self->ctx.link_adr_ans.channelMaskOK = true;
 8004d02:	68fb      	ldr	r3, [r7, #12]
 8004d04:	4ad4      	ldr	r2, [pc, #848]	; (8005058 <processCommands+0x3bc>)
 8004d06:	2101      	movs	r1, #1
 8004d08:	5499      	strb	r1, [r3, r2]
    
    while(LDL_MAC_getDownCommand(&s_in, &cmd)){
 8004d0a:	f000 fcdb 	bl	80056c4 <processCommands+0xa28>
        
        switch(cmd.type){
 8004d0e:	2334      	movs	r3, #52	; 0x34
 8004d10:	18fb      	adds	r3, r7, r3
 8004d12:	781b      	ldrb	r3, [r3, #0]
 8004d14:	2b0d      	cmp	r3, #13
 8004d16:	d804      	bhi.n	8004d22 <processCommands+0x86>
 8004d18:	009a      	lsls	r2, r3, #2
 8004d1a:	4bd0      	ldr	r3, [pc, #832]	; (800505c <processCommands+0x3c0>)
 8004d1c:	18d3      	adds	r3, r2, r3
 8004d1e:	681b      	ldr	r3, [r3, #0]
 8004d20:	469f      	mov	pc, r3
        default:
            LDL_DEBUG(self->app, "not handling type %u", cmd.type)
 8004d22:	4bcf      	ldr	r3, [pc, #828]	; (8005060 <processCommands+0x3c4>)
 8004d24:	0018      	movs	r0, r3
 8004d26:	f007 fde1 	bl	800c8ec <iprintf>
 8004d2a:	2334      	movs	r3, #52	; 0x34
 8004d2c:	18fb      	adds	r3, r7, r3
 8004d2e:	781b      	ldrb	r3, [r3, #0]
 8004d30:	001a      	movs	r2, r3
 8004d32:	4bcc      	ldr	r3, [pc, #816]	; (8005064 <processCommands+0x3c8>)
 8004d34:	0011      	movs	r1, r2
 8004d36:	0018      	movs	r0, r3
 8004d38:	f007 fdd8 	bl	800c8ec <iprintf>
 8004d3c:	4bca      	ldr	r3, [pc, #808]	; (8005068 <processCommands+0x3cc>)
 8004d3e:	0018      	movs	r0, r3
 8004d40:	f007 fe4e 	bl	800c9e0 <puts>
 8004d44:	226f      	movs	r2, #111	; 0x6f
 8004d46:	18bb      	adds	r3, r7, r2
 8004d48:	18ba      	adds	r2, r7, r2
 8004d4a:	7812      	ldrb	r2, [r2, #0]
 8004d4c:	701a      	strb	r2, [r3, #0]
            break;     
 8004d4e:	f000 fcb9 	bl	80056c4 <processCommands+0xa28>
#ifndef LDL_DISABLE_CHECK                                   
        case LDL_CMD_LINK_CHECK:                
        {                
            union ldl_mac_response_arg arg;
            const struct ldl_link_check_ans *ans = &cmd.fields.linkCheck;
 8004d52:	2334      	movs	r3, #52	; 0x34
 8004d54:	18fb      	adds	r3, r7, r3
 8004d56:	3304      	adds	r3, #4
 8004d58:	65fb      	str	r3, [r7, #92]	; 0x5c
            
            arg.link_status.margin = ans->margin;
 8004d5a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004d5c:	781b      	ldrb	r3, [r3, #0]
 8004d5e:	b25a      	sxtb	r2, r3
 8004d60:	2420      	movs	r4, #32
 8004d62:	193b      	adds	r3, r7, r4
 8004d64:	701a      	strb	r2, [r3, #0]
            arg.link_status.gwCount = ans->gwCount;            
 8004d66:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004d68:	785a      	ldrb	r2, [r3, #1]
 8004d6a:	193b      	adds	r3, r7, r4
 8004d6c:	705a      	strb	r2, [r3, #1]
            
            LDL_DEBUG(self->app, "link_check_ans: margin=%u gwCount=%u", 
 8004d6e:	4bbc      	ldr	r3, [pc, #752]	; (8005060 <processCommands+0x3c4>)
 8004d70:	0018      	movs	r0, r3
 8004d72:	f007 fdbb 	bl	800c8ec <iprintf>
 8004d76:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004d78:	781b      	ldrb	r3, [r3, #0]
 8004d7a:	0019      	movs	r1, r3
 8004d7c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004d7e:	785b      	ldrb	r3, [r3, #1]
 8004d80:	001a      	movs	r2, r3
 8004d82:	4bba      	ldr	r3, [pc, #744]	; (800506c <processCommands+0x3d0>)
 8004d84:	0018      	movs	r0, r3
 8004d86:	f007 fdb1 	bl	800c8ec <iprintf>
 8004d8a:	4bb7      	ldr	r3, [pc, #732]	; (8005068 <processCommands+0x3cc>)
 8004d8c:	0018      	movs	r0, r3
 8004d8e:	f007 fe27 	bl	800c9e0 <puts>
                ans->margin,
                ans->gwCount             
            )
            
            self->handler(self->app, LDL_MAC_LINK_STATUS, &arg);                                                             
 8004d92:	68fa      	ldr	r2, [r7, #12]
 8004d94:	2392      	movs	r3, #146	; 0x92
 8004d96:	009b      	lsls	r3, r3, #2
 8004d98:	58d3      	ldr	r3, [r2, r3]
 8004d9a:	68f9      	ldr	r1, [r7, #12]
 8004d9c:	2293      	movs	r2, #147	; 0x93
 8004d9e:	0092      	lsls	r2, r2, #2
 8004da0:	5888      	ldr	r0, [r1, r2]
 8004da2:	193a      	adds	r2, r7, r4
 8004da4:	2109      	movs	r1, #9
 8004da6:	4798      	blx	r3
 8004da8:	226f      	movs	r2, #111	; 0x6f
 8004daa:	18bb      	adds	r3, r7, r2
 8004dac:	18ba      	adds	r2, r7, r2
 8004dae:	7812      	ldrb	r2, [r2, #0]
 8004db0:	701a      	strb	r2, [r3, #0]
        }
            break;
 8004db2:	f000 fc87 	bl	80056c4 <processCommands+0xa28>
#endif                            
        case LDL_CMD_LINK_ADR:              
        {
            const struct ldl_link_adr_req *req = &cmd.fields.linkADR;
 8004db6:	2334      	movs	r3, #52	; 0x34
 8004db8:	18fb      	adds	r3, r7, r3
 8004dba:	3304      	adds	r3, #4
 8004dbc:	663b      	str	r3, [r7, #96]	; 0x60
            
            LDL_DEBUG(self->app, "link_adr_req: dataRate=%u txPower=%u chMask=%04x chMaskCntl=%u nbTrans=%u",
 8004dbe:	4ba8      	ldr	r3, [pc, #672]	; (8005060 <processCommands+0x3c4>)
 8004dc0:	0018      	movs	r0, r3
 8004dc2:	f007 fd93 	bl	800c8ec <iprintf>
 8004dc6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004dc8:	781b      	ldrb	r3, [r3, #0]
 8004dca:	0019      	movs	r1, r3
 8004dcc:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004dce:	785b      	ldrb	r3, [r3, #1]
 8004dd0:	001c      	movs	r4, r3
 8004dd2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004dd4:	885b      	ldrh	r3, [r3, #2]
 8004dd6:	001d      	movs	r5, r3
 8004dd8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004dda:	791b      	ldrb	r3, [r3, #4]
 8004ddc:	001a      	movs	r2, r3
 8004dde:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004de0:	795b      	ldrb	r3, [r3, #5]
 8004de2:	48a3      	ldr	r0, [pc, #652]	; (8005070 <processCommands+0x3d4>)
 8004de4:	9301      	str	r3, [sp, #4]
 8004de6:	9200      	str	r2, [sp, #0]
 8004de8:	002b      	movs	r3, r5
 8004dea:	0022      	movs	r2, r4
 8004dec:	f007 fd7e 	bl	800c8ec <iprintf>
 8004df0:	4b9d      	ldr	r3, [pc, #628]	; (8005068 <processCommands+0x3cc>)
 8004df2:	0018      	movs	r0, r3
 8004df4:	f007 fdf4 	bl	800c9e0 <puts>
            
            uint8_t i;
            
            /* this is against the standard but we simply ignore any additional 
             * blocks after the first one */
            if(!commandIsPending(self, LDL_CMD_LINK_ADR)){
 8004df8:	68fb      	ldr	r3, [r7, #12]
 8004dfa:	2101      	movs	r1, #1
 8004dfc:	0018      	movs	r0, r3
 8004dfe:	f001 fdb5 	bl	800696c <commandIsPending>
 8004e02:	0003      	movs	r3, r0
 8004e04:	001a      	movs	r2, r3
 8004e06:	2301      	movs	r3, #1
 8004e08:	4053      	eors	r3, r2
 8004e0a:	b2db      	uxtb	r3, r3
 8004e0c:	2b00      	cmp	r3, #0
 8004e0e:	d100      	bne.n	8004e12 <processCommands+0x176>
 8004e10:	e18a      	b.n	8005128 <processCommands+0x48c>
            
                if(LDL_Region_isDynamic(self->region)){
 8004e12:	68fa      	ldr	r2, [r7, #12]
 8004e14:	2391      	movs	r3, #145	; 0x91
 8004e16:	009b      	lsls	r3, r3, #2
 8004e18:	5cd3      	ldrb	r3, [r2, r3]
 8004e1a:	0018      	movs	r0, r3
 8004e1c:	f003 fe9a 	bl	8008b54 <LDL_Region_isDynamic>
 8004e20:	1e03      	subs	r3, r0, #0
 8004e22:	d04d      	beq.n	8004ec0 <processCommands+0x224>
                    
                    switch(req->channelMaskControl){
 8004e24:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004e26:	791b      	ldrb	r3, [r3, #4]
 8004e28:	2b00      	cmp	r3, #0
 8004e2a:	d002      	beq.n	8004e32 <processCommands+0x196>
 8004e2c:	2b06      	cmp	r3, #6
 8004e2e:	d039      	beq.n	8004ea4 <processCommands+0x208>
 8004e30:	e040      	b.n	8004eb4 <processCommands+0x218>
                    case 0U:
                    
                        /* mask/unmask channels 0..15 */
                        for(i=0U; i < (sizeof(req->channelMask)*8U); i++){
 8004e32:	236e      	movs	r3, #110	; 0x6e
 8004e34:	18fb      	adds	r3, r7, r3
 8004e36:	2200      	movs	r2, #0
 8004e38:	701a      	strb	r2, [r3, #0]
 8004e3a:	e02d      	b.n	8004e98 <processCommands+0x1fc>
                            
                            if((req->channelMask & (1U << i)) > 0U){
 8004e3c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004e3e:	885b      	ldrh	r3, [r3, #2]
 8004e40:	001a      	movs	r2, r3
 8004e42:	236e      	movs	r3, #110	; 0x6e
 8004e44:	18fb      	adds	r3, r7, r3
 8004e46:	781b      	ldrb	r3, [r3, #0]
 8004e48:	40da      	lsrs	r2, r3
 8004e4a:	0013      	movs	r3, r2
 8004e4c:	2201      	movs	r2, #1
 8004e4e:	4013      	ands	r3, r2
 8004e50:	d00e      	beq.n	8004e70 <processCommands+0x1d4>
                                
                                (void)unmaskChannel(self->ctx.chMask, sizeof(self->ctx.chMask), self->region, i);
 8004e52:	68fb      	ldr	r3, [r7, #12]
 8004e54:	33ed      	adds	r3, #237	; 0xed
 8004e56:	33ff      	adds	r3, #255	; 0xff
 8004e58:	0018      	movs	r0, r3
 8004e5a:	68fa      	ldr	r2, [r7, #12]
 8004e5c:	2391      	movs	r3, #145	; 0x91
 8004e5e:	009b      	lsls	r3, r3, #2
 8004e60:	5cd2      	ldrb	r2, [r2, r3]
 8004e62:	236e      	movs	r3, #110	; 0x6e
 8004e64:	18fb      	adds	r3, r7, r3
 8004e66:	781b      	ldrb	r3, [r3, #0]
 8004e68:	2109      	movs	r1, #9
 8004e6a:	f001 f88f 	bl	8005f8c <unmaskChannel>
 8004e6e:	e00d      	b.n	8004e8c <processCommands+0x1f0>
                            }
                            else{
                                
                                (void)maskChannel(self->ctx.chMask, sizeof(self->ctx.chMask), self->region, i);
 8004e70:	68fb      	ldr	r3, [r7, #12]
 8004e72:	33ed      	adds	r3, #237	; 0xed
 8004e74:	33ff      	adds	r3, #255	; 0xff
 8004e76:	0018      	movs	r0, r3
 8004e78:	68fa      	ldr	r2, [r7, #12]
 8004e7a:	2391      	movs	r3, #145	; 0x91
 8004e7c:	009b      	lsls	r3, r3, #2
 8004e7e:	5cd2      	ldrb	r2, [r2, r3]
 8004e80:	236e      	movs	r3, #110	; 0x6e
 8004e82:	18fb      	adds	r3, r7, r3
 8004e84:	781b      	ldrb	r3, [r3, #0]
 8004e86:	2109      	movs	r1, #9
 8004e88:	f001 f83a 	bl	8005f00 <maskChannel>
                        for(i=0U; i < (sizeof(req->channelMask)*8U); i++){
 8004e8c:	216e      	movs	r1, #110	; 0x6e
 8004e8e:	187b      	adds	r3, r7, r1
 8004e90:	781a      	ldrb	r2, [r3, #0]
 8004e92:	187b      	adds	r3, r7, r1
 8004e94:	3201      	adds	r2, #1
 8004e96:	701a      	strb	r2, [r3, #0]
 8004e98:	236e      	movs	r3, #110	; 0x6e
 8004e9a:	18fb      	adds	r3, r7, r3
 8004e9c:	781b      	ldrb	r3, [r3, #0]
 8004e9e:	2b0f      	cmp	r3, #15
 8004ea0:	d9cc      	bls.n	8004e3c <processCommands+0x1a0>
                            }
                        }
                        break;            
 8004ea2:	e08b      	b.n	8004fbc <processCommands+0x320>
                        
                    case 6U:
                    
                        unmaskAllChannels(self->ctx.chMask, sizeof(self->ctx.chMask));
 8004ea4:	68fb      	ldr	r3, [r7, #12]
 8004ea6:	33ed      	adds	r3, #237	; 0xed
 8004ea8:	33ff      	adds	r3, #255	; 0xff
 8004eaa:	2109      	movs	r1, #9
 8004eac:	0018      	movs	r0, r3
 8004eae:	f001 f8b5 	bl	800601c <unmaskAllChannels>
                        break;           
 8004eb2:	e083      	b.n	8004fbc <processCommands+0x320>
                         
                    default:
                        self->ctx.link_adr_ans.channelMaskOK = false;
 8004eb4:	68fb      	ldr	r3, [r7, #12]
 8004eb6:	4a68      	ldr	r2, [pc, #416]	; (8005058 <processCommands+0x3bc>)
 8004eb8:	2100      	movs	r1, #0
 8004eba:	5499      	strb	r1, [r3, r2]
                        break;
 8004ebc:	46c0      	nop			; (mov r8, r8)
 8004ebe:	e07d      	b.n	8004fbc <processCommands+0x320>
                    }
                }
                else{
                    
                    switch(req->channelMaskControl){
 8004ec0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004ec2:	791b      	ldrb	r3, [r3, #4]
 8004ec4:	3b06      	subs	r3, #6
 8004ec6:	2b01      	cmp	r3, #1
 8004ec8:	d831      	bhi.n	8004f2e <processCommands+0x292>
                    case 7U:     /* all 125KHz off */
                    
                        /* fixme: there is probably a more robust way to do this...right
                         * now we only support US and AU fixed channel plans so this works.
                         * */
                        for(i=0U; i < 64U; i++){
 8004eca:	236e      	movs	r3, #110	; 0x6e
 8004ecc:	18fb      	adds	r3, r7, r3
 8004ece:	2200      	movs	r2, #0
 8004ed0:	701a      	strb	r2, [r3, #0]
 8004ed2:	e026      	b.n	8004f22 <processCommands+0x286>
                            
                            if(req->channelMaskControl == 6U){
 8004ed4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004ed6:	791b      	ldrb	r3, [r3, #4]
 8004ed8:	2b06      	cmp	r3, #6
 8004eda:	d10e      	bne.n	8004efa <processCommands+0x25e>
                                
                                (void)unmaskChannel(self->ctx.chMask, sizeof(self->ctx.chMask), self->region, i);
 8004edc:	68fb      	ldr	r3, [r7, #12]
 8004ede:	33ed      	adds	r3, #237	; 0xed
 8004ee0:	33ff      	adds	r3, #255	; 0xff
 8004ee2:	0018      	movs	r0, r3
 8004ee4:	68fa      	ldr	r2, [r7, #12]
 8004ee6:	2391      	movs	r3, #145	; 0x91
 8004ee8:	009b      	lsls	r3, r3, #2
 8004eea:	5cd2      	ldrb	r2, [r2, r3]
 8004eec:	236e      	movs	r3, #110	; 0x6e
 8004eee:	18fb      	adds	r3, r7, r3
 8004ef0:	781b      	ldrb	r3, [r3, #0]
 8004ef2:	2109      	movs	r1, #9
 8004ef4:	f001 f84a 	bl	8005f8c <unmaskChannel>
 8004ef8:	e00d      	b.n	8004f16 <processCommands+0x27a>
                            }
                            else{
                                
                                (void)maskChannel(self->ctx.chMask, sizeof(self->ctx.chMask), self->region, i);
 8004efa:	68fb      	ldr	r3, [r7, #12]
 8004efc:	33ed      	adds	r3, #237	; 0xed
 8004efe:	33ff      	adds	r3, #255	; 0xff
 8004f00:	0018      	movs	r0, r3
 8004f02:	68fa      	ldr	r2, [r7, #12]
 8004f04:	2391      	movs	r3, #145	; 0x91
 8004f06:	009b      	lsls	r3, r3, #2
 8004f08:	5cd2      	ldrb	r2, [r2, r3]
 8004f0a:	236e      	movs	r3, #110	; 0x6e
 8004f0c:	18fb      	adds	r3, r7, r3
 8004f0e:	781b      	ldrb	r3, [r3, #0]
 8004f10:	2109      	movs	r1, #9
 8004f12:	f000 fff5 	bl	8005f00 <maskChannel>
                        for(i=0U; i < 64U; i++){
 8004f16:	216e      	movs	r1, #110	; 0x6e
 8004f18:	187b      	adds	r3, r7, r1
 8004f1a:	781a      	ldrb	r2, [r3, #0]
 8004f1c:	187b      	adds	r3, r7, r1
 8004f1e:	3201      	adds	r2, #1
 8004f20:	701a      	strb	r2, [r3, #0]
 8004f22:	236e      	movs	r3, #110	; 0x6e
 8004f24:	18fb      	adds	r3, r7, r3
 8004f26:	781b      	ldrb	r3, [r3, #0]
 8004f28:	2b3f      	cmp	r3, #63	; 0x3f
 8004f2a:	d9d3      	bls.n	8004ed4 <processCommands+0x238>
                            }            
                        }                                  
                        break;
 8004f2c:	e046      	b.n	8004fbc <processCommands+0x320>
                        
                    default:
                        
                        for(i=0U; i < (sizeof(req->channelMask)*8U); i++){
 8004f2e:	236e      	movs	r3, #110	; 0x6e
 8004f30:	18fb      	adds	r3, r7, r3
 8004f32:	2200      	movs	r2, #0
 8004f34:	701a      	strb	r2, [r3, #0]
 8004f36:	e03b      	b.n	8004fb0 <processCommands+0x314>
                            
                            if((req->channelMask & (1U << i)) > 0U){
 8004f38:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004f3a:	885b      	ldrh	r3, [r3, #2]
 8004f3c:	001a      	movs	r2, r3
 8004f3e:	236e      	movs	r3, #110	; 0x6e
 8004f40:	18fb      	adds	r3, r7, r3
 8004f42:	781b      	ldrb	r3, [r3, #0]
 8004f44:	40da      	lsrs	r2, r3
 8004f46:	0013      	movs	r3, r2
 8004f48:	2201      	movs	r2, #1
 8004f4a:	4013      	ands	r3, r2
 8004f4c:	d015      	beq.n	8004f7a <processCommands+0x2de>
                                
                                (void)unmaskChannel(self->ctx.chMask, sizeof(self->ctx.chMask), self->region, (req->channelMaskControl * 16U) + i);
 8004f4e:	68fb      	ldr	r3, [r7, #12]
 8004f50:	33ed      	adds	r3, #237	; 0xed
 8004f52:	33ff      	adds	r3, #255	; 0xff
 8004f54:	0018      	movs	r0, r3
 8004f56:	68fa      	ldr	r2, [r7, #12]
 8004f58:	2391      	movs	r3, #145	; 0x91
 8004f5a:	009b      	lsls	r3, r3, #2
 8004f5c:	5cd1      	ldrb	r1, [r2, r3]
 8004f5e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004f60:	791b      	ldrb	r3, [r3, #4]
 8004f62:	011b      	lsls	r3, r3, #4
 8004f64:	b2da      	uxtb	r2, r3
 8004f66:	236e      	movs	r3, #110	; 0x6e
 8004f68:	18fb      	adds	r3, r7, r3
 8004f6a:	781b      	ldrb	r3, [r3, #0]
 8004f6c:	18d3      	adds	r3, r2, r3
 8004f6e:	b2db      	uxtb	r3, r3
 8004f70:	000a      	movs	r2, r1
 8004f72:	2109      	movs	r1, #9
 8004f74:	f001 f80a 	bl	8005f8c <unmaskChannel>
 8004f78:	e014      	b.n	8004fa4 <processCommands+0x308>
                            }
                            else{
                                
                                (void)maskChannel(self->ctx.chMask, sizeof(self->ctx.chMask), self->region, (req->channelMaskControl * 16U) + i);
 8004f7a:	68fb      	ldr	r3, [r7, #12]
 8004f7c:	33ed      	adds	r3, #237	; 0xed
 8004f7e:	33ff      	adds	r3, #255	; 0xff
 8004f80:	0018      	movs	r0, r3
 8004f82:	68fa      	ldr	r2, [r7, #12]
 8004f84:	2391      	movs	r3, #145	; 0x91
 8004f86:	009b      	lsls	r3, r3, #2
 8004f88:	5cd1      	ldrb	r1, [r2, r3]
 8004f8a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004f8c:	791b      	ldrb	r3, [r3, #4]
 8004f8e:	011b      	lsls	r3, r3, #4
 8004f90:	b2da      	uxtb	r2, r3
 8004f92:	236e      	movs	r3, #110	; 0x6e
 8004f94:	18fb      	adds	r3, r7, r3
 8004f96:	781b      	ldrb	r3, [r3, #0]
 8004f98:	18d3      	adds	r3, r2, r3
 8004f9a:	b2db      	uxtb	r3, r3
 8004f9c:	000a      	movs	r2, r1
 8004f9e:	2109      	movs	r1, #9
 8004fa0:	f000 ffae 	bl	8005f00 <maskChannel>
                        for(i=0U; i < (sizeof(req->channelMask)*8U); i++){
 8004fa4:	216e      	movs	r1, #110	; 0x6e
 8004fa6:	187b      	adds	r3, r7, r1
 8004fa8:	781a      	ldrb	r2, [r3, #0]
 8004faa:	187b      	adds	r3, r7, r1
 8004fac:	3201      	adds	r2, #1
 8004fae:	701a      	strb	r2, [r3, #0]
 8004fb0:	236e      	movs	r3, #110	; 0x6e
 8004fb2:	18fb      	adds	r3, r7, r3
 8004fb4:	781b      	ldrb	r3, [r3, #0]
 8004fb6:	2b0f      	cmp	r3, #15
 8004fb8:	d9be      	bls.n	8004f38 <processCommands+0x29c>
                            }
                        }
                        break;
 8004fba:	46c0      	nop			; (mov r8, r8)
                    }            
                }
                
                if(!LDL_MAC_peekNextCommand(&s_in, &next_cmd) || (next_cmd != LDL_CMD_LINK_ADR)){
 8004fbc:	2333      	movs	r3, #51	; 0x33
 8004fbe:	18fa      	adds	r2, r7, r3
 8004fc0:	2350      	movs	r3, #80	; 0x50
 8004fc2:	18fb      	adds	r3, r7, r3
 8004fc4:	0011      	movs	r1, r2
 8004fc6:	0018      	movs	r0, r3
 8004fc8:	f001 fd24 	bl	8006a14 <LDL_MAC_peekNextCommand>
 8004fcc:	0003      	movs	r3, r0
 8004fce:	001a      	movs	r2, r3
 8004fd0:	2301      	movs	r3, #1
 8004fd2:	4053      	eors	r3, r2
 8004fd4:	b2db      	uxtb	r3, r3
 8004fd6:	2b00      	cmp	r3, #0
 8004fd8:	d105      	bne.n	8004fe6 <processCommands+0x34a>
 8004fda:	2333      	movs	r3, #51	; 0x33
 8004fdc:	18fb      	adds	r3, r7, r3
 8004fde:	781b      	ldrb	r3, [r3, #0]
 8004fe0:	2b01      	cmp	r3, #1
 8004fe2:	d100      	bne.n	8004fe6 <processCommands+0x34a>
 8004fe4:	e36e      	b.n	80056c4 <processCommands+0xa28>
                 
                    self->ctx.link_adr_ans.dataRateOK = true;
 8004fe6:	68fa      	ldr	r2, [r7, #12]
 8004fe8:	2385      	movs	r3, #133	; 0x85
 8004fea:	009b      	lsls	r3, r3, #2
 8004fec:	2101      	movs	r1, #1
 8004fee:	54d1      	strb	r1, [r2, r3]
                    self->ctx.link_adr_ans.powerOK = true;
 8004ff0:	68fb      	ldr	r3, [r7, #12]
 8004ff2:	4a20      	ldr	r2, [pc, #128]	; (8005074 <processCommands+0x3d8>)
 8004ff4:	2101      	movs	r1, #1
 8004ff6:	5499      	strb	r1, [r3, r2]
                 
                    /* nbTrans setting 0 means keep existing */
                    if(req->nbTrans > 0U){
 8004ff8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8004ffa:	795b      	ldrb	r3, [r3, #5]
 8004ffc:	2b00      	cmp	r3, #0
 8004ffe:	d013      	beq.n	8005028 <processCommands+0x38c>
                    
                        self->ctx.nbTrans = req->nbTrans & 0xfU;
 8005000:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8005002:	795b      	ldrb	r3, [r3, #5]
 8005004:	220f      	movs	r2, #15
 8005006:	4013      	ands	r3, r2
 8005008:	b2d9      	uxtb	r1, r3
 800500a:	68fa      	ldr	r2, [r7, #12]
 800500c:	23fc      	movs	r3, #252	; 0xfc
 800500e:	005b      	lsls	r3, r3, #1
 8005010:	54d1      	strb	r1, [r2, r3]
                        
                        if(self->ctx.nbTrans > LDL_REDUNDANCY_MAX){
 8005012:	68fa      	ldr	r2, [r7, #12]
 8005014:	23fc      	movs	r3, #252	; 0xfc
 8005016:	005b      	lsls	r3, r3, #1
 8005018:	5cd3      	ldrb	r3, [r2, r3]
 800501a:	2b0f      	cmp	r3, #15
 800501c:	d904      	bls.n	8005028 <processCommands+0x38c>
                            
                            self->ctx.nbTrans = LDL_REDUNDANCY_MAX;
 800501e:	68fa      	ldr	r2, [r7, #12]
 8005020:	23fc      	movs	r3, #252	; 0xfc
 8005022:	005b      	lsls	r3, r3, #1
 8005024:	210f      	movs	r1, #15
 8005026:	54d1      	strb	r1, [r2, r3]
                        }
                    }
                    
                    /* ignore rate setting 16 */
                    if(req->dataRate < 0xfU){            
 8005028:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800502a:	781b      	ldrb	r3, [r3, #0]
 800502c:	2b0e      	cmp	r3, #14
 800502e:	d828      	bhi.n	8005082 <processCommands+0x3e6>
                        
                        // todo: need to pin out of range to maximum
                        if(rateSettingIsValid(self->region, req->dataRate)){
 8005030:	68fa      	ldr	r2, [r7, #12]
 8005032:	2391      	movs	r3, #145	; 0x91
 8005034:	009b      	lsls	r3, r3, #2
 8005036:	5cd2      	ldrb	r2, [r2, r3]
 8005038:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800503a:	781b      	ldrb	r3, [r3, #0]
 800503c:	0019      	movs	r1, r3
 800503e:	0010      	movs	r0, r2
 8005040:	f001 f872 	bl	8006128 <rateSettingIsValid>
 8005044:	1e03      	subs	r3, r0, #0
 8005046:	d017      	beq.n	8005078 <processCommands+0x3dc>
                        
                            self->ctx.rate = req->dataRate;            
 8005048:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800504a:	7819      	ldrb	r1, [r3, #0]
 800504c:	68fa      	ldr	r2, [r7, #12]
 800504e:	23f6      	movs	r3, #246	; 0xf6
 8005050:	33ff      	adds	r3, #255	; 0xff
 8005052:	54d1      	strb	r1, [r2, r3]
 8005054:	e015      	b.n	8005082 <processCommands+0x3e6>
 8005056:	46c0      	nop			; (mov r8, r8)
 8005058:	00000215 	.word	0x00000215
 800505c:	0800e4e4 	.word	0x0800e4e4
 8005060:	0800d8e8 	.word	0x0800d8e8
 8005064:	0800dc68 	.word	0x0800dc68
 8005068:	0800d8e4 	.word	0x0800d8e4
 800506c:	0800dc80 	.word	0x0800dc80
 8005070:	0800dca8 	.word	0x0800dca8
 8005074:	00000213 	.word	0x00000213
                        }
                        else{
                                            
                            self->ctx.link_adr_ans.dataRateOK = false;
 8005078:	68fa      	ldr	r2, [r7, #12]
 800507a:	2385      	movs	r3, #133	; 0x85
 800507c:	009b      	lsls	r3, r3, #2
 800507e:	2100      	movs	r1, #0
 8005080:	54d1      	strb	r1, [r2, r3]
                        }
                    }
                    
                    /* ignore power setting 16 */
                    if(req->txPower < 0xfU){            
 8005082:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8005084:	785b      	ldrb	r3, [r3, #1]
 8005086:	2b0e      	cmp	r3, #14
 8005088:	d816      	bhi.n	80050b8 <processCommands+0x41c>
                        
                        if(LDL_Region_validateTXPower(self->region, req->txPower)){
 800508a:	68fa      	ldr	r2, [r7, #12]
 800508c:	2391      	movs	r3, #145	; 0x91
 800508e:	009b      	lsls	r3, r3, #2
 8005090:	5cd2      	ldrb	r2, [r2, r3]
 8005092:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8005094:	785b      	ldrb	r3, [r3, #1]
 8005096:	0019      	movs	r1, r3
 8005098:	0010      	movs	r0, r2
 800509a:	f003 ff9a 	bl	8008fd2 <LDL_Region_validateTXPower>
 800509e:	1e03      	subs	r3, r0, #0
 80050a0:	d006      	beq.n	80050b0 <processCommands+0x414>
                        
                            self->ctx.power = req->txPower;        
 80050a2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80050a4:	7859      	ldrb	r1, [r3, #1]
 80050a6:	68fa      	ldr	r2, [r7, #12]
 80050a8:	23fb      	movs	r3, #251	; 0xfb
 80050aa:	005b      	lsls	r3, r3, #1
 80050ac:	54d1      	strb	r1, [r2, r3]
 80050ae:	e003      	b.n	80050b8 <processCommands+0x41c>
                        }
                        else{
                         
                            self->ctx.link_adr_ans.powerOK = false;
 80050b0:	68fb      	ldr	r3, [r7, #12]
 80050b2:	4ae7      	ldr	r2, [pc, #924]	; (8005450 <processCommands+0x7b4>)
 80050b4:	2100      	movs	r1, #0
 80050b6:	5499      	strb	r1, [r3, r2]
                        }        
                    }   
                 
                    /* do not allow server to mask all channels */
                    if(allChannelsAreMasked(self->ctx.chMask, sizeof(self->ctx.chMask))){ 
 80050b8:	68fb      	ldr	r3, [r7, #12]
 80050ba:	33ed      	adds	r3, #237	; 0xed
 80050bc:	33ff      	adds	r3, #255	; 0xff
 80050be:	2109      	movs	r1, #9
 80050c0:	0018      	movs	r0, r3
 80050c2:	f001 f800 	bl	80060c6 <allChannelsAreMasked>
 80050c6:	1e03      	subs	r3, r0, #0
 80050c8:	d00f      	beq.n	80050ea <processCommands+0x44e>
                        
                        LDL_INFO(self->app, "server attempted to mask all channels")
 80050ca:	4be2      	ldr	r3, [pc, #904]	; (8005454 <processCommands+0x7b8>)
 80050cc:	0018      	movs	r0, r3
 80050ce:	f007 fc0d 	bl	800c8ec <iprintf>
 80050d2:	4be1      	ldr	r3, [pc, #900]	; (8005458 <processCommands+0x7bc>)
 80050d4:	0018      	movs	r0, r3
 80050d6:	f007 fc09 	bl	800c8ec <iprintf>
 80050da:	4be0      	ldr	r3, [pc, #896]	; (800545c <processCommands+0x7c0>)
 80050dc:	0018      	movs	r0, r3
 80050de:	f007 fc7f 	bl	800c9e0 <puts>
                        self->ctx.link_adr_ans.channelMaskOK = false;
 80050e2:	68fb      	ldr	r3, [r7, #12]
 80050e4:	4ade      	ldr	r2, [pc, #888]	; (8005460 <processCommands+0x7c4>)
 80050e6:	2100      	movs	r1, #0
 80050e8:	5499      	strb	r1, [r3, r2]
                    }
                 
                    if(self->ctx.link_adr_ans.dataRateOK && self->ctx.link_adr_ans.powerOK && self->ctx.link_adr_ans.channelMaskOK){
 80050ea:	68fa      	ldr	r2, [r7, #12]
 80050ec:	2385      	movs	r3, #133	; 0x85
 80050ee:	009b      	lsls	r3, r3, #2
 80050f0:	5cd3      	ldrb	r3, [r2, r3]
 80050f2:	2b00      	cmp	r3, #0
 80050f4:	d00e      	beq.n	8005114 <processCommands+0x478>
 80050f6:	68fb      	ldr	r3, [r7, #12]
 80050f8:	4ad5      	ldr	r2, [pc, #852]	; (8005450 <processCommands+0x7b4>)
 80050fa:	5c9b      	ldrb	r3, [r3, r2]
 80050fc:	2b00      	cmp	r3, #0
 80050fe:	d009      	beq.n	8005114 <processCommands+0x478>
 8005100:	68fb      	ldr	r3, [r7, #12]
 8005102:	4ad7      	ldr	r2, [pc, #860]	; (8005460 <processCommands+0x7c4>)
 8005104:	5c9b      	ldrb	r3, [r3, r2]
 8005106:	2b00      	cmp	r3, #0
 8005108:	d004      	beq.n	8005114 <processCommands+0x478>
                        
                        adr_state = _ADR_OK;
 800510a:	236f      	movs	r3, #111	; 0x6f
 800510c:	18fb      	adds	r3, r7, r3
 800510e:	2201      	movs	r2, #1
 8005110:	701a      	strb	r2, [r3, #0]
 8005112:	e003      	b.n	800511c <processCommands+0x480>
                    }
                    else{
                        
                        adr_state = _ADR_BAD;
 8005114:	236f      	movs	r3, #111	; 0x6f
 8005116:	18fb      	adds	r3, r7, r3
 8005118:	2202      	movs	r2, #2
 800511a:	701a      	strb	r2, [r3, #0]
                    }
                   
                 
                    
                 
                    setPendingCommand(self, LDL_CMD_LINK_ADR);
 800511c:	68fb      	ldr	r3, [r7, #12]
 800511e:	2101      	movs	r1, #1
 8005120:	0018      	movs	r0, r3
 8005122:	f001 fc5c 	bl	80069de <setPendingCommand>
 8005126:	e2cd      	b.n	80056c4 <processCommands+0xa28>
                }                
            }            
            else{
                
                LDL_DEBUG(self->app, "ignoring multiple link_adr_req contiguous blocks")
 8005128:	4bce      	ldr	r3, [pc, #824]	; (8005464 <processCommands+0x7c8>)
 800512a:	0018      	movs	r0, r3
 800512c:	f007 fbde 	bl	800c8ec <iprintf>
 8005130:	4bcd      	ldr	r3, [pc, #820]	; (8005468 <processCommands+0x7cc>)
 8005132:	0018      	movs	r0, r3
 8005134:	f007 fbda 	bl	800c8ec <iprintf>
 8005138:	4bc8      	ldr	r3, [pc, #800]	; (800545c <processCommands+0x7c0>)
 800513a:	0018      	movs	r0, r3
 800513c:	f007 fc50 	bl	800c9e0 <puts>
            }
        }
            break;
 8005140:	e2c0      	b.n	80056c4 <processCommands+0xa28>
        
        case LDL_CMD_DUTY_CYCLE:
         
            LDL_DEBUG(self->app, "duty_cycle_req: %u", cmd.fields.dutyCycle.maxDutyCycle)
 8005142:	4bc8      	ldr	r3, [pc, #800]	; (8005464 <processCommands+0x7c8>)
 8005144:	0018      	movs	r0, r3
 8005146:	f007 fbd1 	bl	800c8ec <iprintf>
 800514a:	2434      	movs	r4, #52	; 0x34
 800514c:	193b      	adds	r3, r7, r4
 800514e:	791b      	ldrb	r3, [r3, #4]
 8005150:	001a      	movs	r2, r3
 8005152:	4bc6      	ldr	r3, [pc, #792]	; (800546c <processCommands+0x7d0>)
 8005154:	0011      	movs	r1, r2
 8005156:	0018      	movs	r0, r3
 8005158:	f007 fbc8 	bl	800c8ec <iprintf>
 800515c:	4bbf      	ldr	r3, [pc, #764]	; (800545c <processCommands+0x7c0>)
 800515e:	0018      	movs	r0, r3
 8005160:	f007 fc3e 	bl	800c9e0 <puts>
        
            self->ctx.maxDutyCycle = cmd.fields.dutyCycle.maxDutyCycle;                        
 8005164:	193b      	adds	r3, r7, r4
 8005166:	7919      	ldrb	r1, [r3, #4]
 8005168:	68fa      	ldr	r2, [r7, #12]
 800516a:	23f8      	movs	r3, #248	; 0xf8
 800516c:	33ff      	adds	r3, #255	; 0xff
 800516e:	54d1      	strb	r1, [r2, r3]
            
            setPendingCommand(self, LDL_CMD_DUTY_CYCLE);
 8005170:	68fb      	ldr	r3, [r7, #12]
 8005172:	2102      	movs	r1, #2
 8005174:	0018      	movs	r0, r3
 8005176:	f001 fc32 	bl	80069de <setPendingCommand>
 800517a:	226f      	movs	r2, #111	; 0x6f
 800517c:	18bb      	adds	r3, r7, r2
 800517e:	18ba      	adds	r2, r7, r2
 8005180:	7812      	ldrb	r2, [r2, #0]
 8005182:	701a      	strb	r2, [r3, #0]
            break;
 8005184:	e29e      	b.n	80056c4 <processCommands+0xa28>
        
        case LDL_CMD_RX_PARAM_SETUP:     
        {
            const struct ldl_rx_param_setup_req *req = &cmd.fields.rxParamSetup;
 8005186:	2334      	movs	r3, #52	; 0x34
 8005188:	18fb      	adds	r3, r7, r3
 800518a:	3304      	adds	r3, #4
 800518c:	667b      	str	r3, [r7, #100]	; 0x64
            
            LDL_DEBUG(self->app, "rx_param_setup_req: rx1DROffset=%u rx2DataRate=%u freq=%"PRIu32,
 800518e:	4bb5      	ldr	r3, [pc, #724]	; (8005464 <processCommands+0x7c8>)
 8005190:	0018      	movs	r0, r3
 8005192:	f007 fbab 	bl	800c8ec <iprintf>
 8005196:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8005198:	781b      	ldrb	r3, [r3, #0]
 800519a:	0019      	movs	r1, r3
 800519c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800519e:	785b      	ldrb	r3, [r3, #1]
 80051a0:	001a      	movs	r2, r3
 80051a2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80051a4:	685b      	ldr	r3, [r3, #4]
 80051a6:	48b2      	ldr	r0, [pc, #712]	; (8005470 <processCommands+0x7d4>)
 80051a8:	f007 fba0 	bl	800c8ec <iprintf>
 80051ac:	4bab      	ldr	r3, [pc, #684]	; (800545c <processCommands+0x7c0>)
 80051ae:	0018      	movs	r0, r3
 80051b0:	f007 fc16 	bl	800c9e0 <puts>
                req->freq
            )
            
            // todo: validation
            
            self->ctx.rx1DROffset = req->rx1DROffset;
 80051b4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80051b6:	7819      	ldrb	r1, [r3, #0]
 80051b8:	68fa      	ldr	r2, [r7, #12]
 80051ba:	23fa      	movs	r3, #250	; 0xfa
 80051bc:	33ff      	adds	r3, #255	; 0xff
 80051be:	54d1      	strb	r1, [r2, r3]
            self->ctx.rx2DataRate = req->rx2DataRate;
 80051c0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80051c2:	7859      	ldrb	r1, [r3, #1]
 80051c4:	68fa      	ldr	r2, [r7, #12]
 80051c6:	23fc      	movs	r3, #252	; 0xfc
 80051c8:	33ff      	adds	r3, #255	; 0xff
 80051ca:	54d1      	strb	r1, [r2, r3]
            self->ctx.rx2Freq = req->freq;
 80051cc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80051ce:	6859      	ldr	r1, [r3, #4]
 80051d0:	68fa      	ldr	r2, [r7, #12]
 80051d2:	2380      	movs	r3, #128	; 0x80
 80051d4:	009b      	lsls	r3, r3, #2
 80051d6:	50d1      	str	r1, [r2, r3]
            
            self->ctx.rx_param_setup_ans.rx1DROffsetOK = true;
 80051d8:	68fb      	ldr	r3, [r7, #12]
 80051da:	4aa6      	ldr	r2, [pc, #664]	; (8005474 <processCommands+0x7d8>)
 80051dc:	2101      	movs	r1, #1
 80051de:	5499      	strb	r1, [r3, r2]
            self->ctx.rx_param_setup_ans.rx2DataRateOK = true;
 80051e0:	68fb      	ldr	r3, [r7, #12]
 80051e2:	4aa5      	ldr	r2, [pc, #660]	; (8005478 <processCommands+0x7dc>)
 80051e4:	2101      	movs	r1, #1
 80051e6:	5499      	strb	r1, [r3, r2]
            self->ctx.rx_param_setup_ans.channelOK = true;       
 80051e8:	68fa      	ldr	r2, [r7, #12]
 80051ea:	2384      	movs	r3, #132	; 0x84
 80051ec:	009b      	lsls	r3, r3, #2
 80051ee:	2101      	movs	r1, #1
 80051f0:	54d1      	strb	r1, [r2, r3]
            
            setPendingCommand(self, LDL_CMD_RX_PARAM_SETUP);
 80051f2:	68fb      	ldr	r3, [r7, #12]
 80051f4:	2103      	movs	r1, #3
 80051f6:	0018      	movs	r0, r3
 80051f8:	f001 fbf1 	bl	80069de <setPendingCommand>
 80051fc:	226f      	movs	r2, #111	; 0x6f
 80051fe:	18bb      	adds	r3, r7, r2
 8005200:	18ba      	adds	r2, r7, r2
 8005202:	7812      	ldrb	r2, [r2, #0]
 8005204:	701a      	strb	r2, [r3, #0]
        }
            break;
 8005206:	e25d      	b.n	80056c4 <processCommands+0xa28>
        
        case LDL_CMD_DEV_STATUS:
        {
            LDL_DEBUG(self->app, "dev_status_req")
 8005208:	4b96      	ldr	r3, [pc, #600]	; (8005464 <processCommands+0x7c8>)
 800520a:	0018      	movs	r0, r3
 800520c:	f007 fb6e 	bl	800c8ec <iprintf>
 8005210:	4b9a      	ldr	r3, [pc, #616]	; (800547c <processCommands+0x7e0>)
 8005212:	0018      	movs	r0, r3
 8005214:	f007 fb6a 	bl	800c8ec <iprintf>
 8005218:	4b90      	ldr	r3, [pc, #576]	; (800545c <processCommands+0x7c0>)
 800521a:	0018      	movs	r0, r3
 800521c:	f007 fbe0 	bl	800c9e0 <puts>
            
            self->ctx.dev_status_ans.battery = LDL_System_getBatteryLevel(self->app);
 8005220:	68fa      	ldr	r2, [r7, #12]
 8005222:	2393      	movs	r3, #147	; 0x93
 8005224:	009b      	lsls	r3, r3, #2
 8005226:	58d3      	ldr	r3, [r2, r3]
 8005228:	0018      	movs	r0, r3
 800522a:	f004 fb92 	bl	8009952 <LDL_System_getBatteryLevel>
 800522e:	0003      	movs	r3, r0
 8005230:	0019      	movs	r1, r3
 8005232:	68fb      	ldr	r3, [r7, #12]
 8005234:	4a92      	ldr	r2, [pc, #584]	; (8005480 <processCommands+0x7e4>)
 8005236:	5499      	strb	r1, [r3, r2]
            
            self->ctx.dev_status_ans.margin = (int8_t)(self->margin / 100);
 8005238:	68fa      	ldr	r2, [r7, #12]
 800523a:	239f      	movs	r3, #159	; 0x9f
 800523c:	005b      	lsls	r3, r3, #1
 800523e:	5ed3      	ldrsh	r3, [r2, r3]
 8005240:	2164      	movs	r1, #100	; 0x64
 8005242:	0018      	movs	r0, r3
 8005244:	f7fa ffea 	bl	800021c <__divsi3>
 8005248:	0003      	movs	r3, r0
 800524a:	b21b      	sxth	r3, r3
 800524c:	b259      	sxtb	r1, r3
 800524e:	68fb      	ldr	r3, [r7, #12]
 8005250:	4a8c      	ldr	r2, [pc, #560]	; (8005484 <processCommands+0x7e8>)
 8005252:	5499      	strb	r1, [r3, r2]
            
            if(self->ctx.dev_status_ans.margin > 31){
 8005254:	68fb      	ldr	r3, [r7, #12]
 8005256:	4a8b      	ldr	r2, [pc, #556]	; (8005484 <processCommands+0x7e8>)
 8005258:	569b      	ldrsb	r3, [r3, r2]
 800525a:	2b1f      	cmp	r3, #31
 800525c:	dd04      	ble.n	8005268 <processCommands+0x5cc>
            
                self->ctx.dev_status_ans.margin = 31;
 800525e:	68fb      	ldr	r3, [r7, #12]
 8005260:	4a88      	ldr	r2, [pc, #544]	; (8005484 <processCommands+0x7e8>)
 8005262:	211f      	movs	r1, #31
 8005264:	5499      	strb	r1, [r3, r2]
 8005266:	e008      	b.n	800527a <processCommands+0x5de>
            }
            else if(self->ctx.dev_status_ans.margin < -32){
 8005268:	68fb      	ldr	r3, [r7, #12]
 800526a:	4a86      	ldr	r2, [pc, #536]	; (8005484 <processCommands+0x7e8>)
 800526c:	569b      	ldrsb	r3, [r3, r2]
 800526e:	3320      	adds	r3, #32
 8005270:	da03      	bge.n	800527a <processCommands+0x5de>
                
                self->ctx.dev_status_ans.margin = -32;
 8005272:	68fb      	ldr	r3, [r7, #12]
 8005274:	4a83      	ldr	r2, [pc, #524]	; (8005484 <processCommands+0x7e8>)
 8005276:	21e0      	movs	r1, #224	; 0xe0
 8005278:	5499      	strb	r1, [r3, r2]
            }
             
            setPendingCommand(self, LDL_CMD_DEV_STATUS);
 800527a:	68fb      	ldr	r3, [r7, #12]
 800527c:	2104      	movs	r1, #4
 800527e:	0018      	movs	r0, r3
 8005280:	f001 fbad 	bl	80069de <setPendingCommand>
 8005284:	226f      	movs	r2, #111	; 0x6f
 8005286:	18bb      	adds	r3, r7, r2
 8005288:	18ba      	adds	r2, r7, r2
 800528a:	7812      	ldrb	r2, [r2, #0]
 800528c:	701a      	strb	r2, [r3, #0]
        }
            break;
 800528e:	e219      	b.n	80056c4 <processCommands+0xa28>
            
        case LDL_CMD_NEW_CHANNEL:    
                    
            LDL_DEBUG(self->app, "new_channel_req: chIndex=%u freq=%"PRIu32" maxDR=%u minDR=%u",
 8005290:	4b74      	ldr	r3, [pc, #464]	; (8005464 <processCommands+0x7c8>)
 8005292:	0018      	movs	r0, r3
 8005294:	f007 fb2a 	bl	800c8ec <iprintf>
 8005298:	2034      	movs	r0, #52	; 0x34
 800529a:	183b      	adds	r3, r7, r0
 800529c:	791b      	ldrb	r3, [r3, #4]
 800529e:	0019      	movs	r1, r3
 80052a0:	183b      	adds	r3, r7, r0
 80052a2:	689a      	ldr	r2, [r3, #8]
 80052a4:	183b      	adds	r3, r7, r0
 80052a6:	7b1b      	ldrb	r3, [r3, #12]
 80052a8:	001c      	movs	r4, r3
 80052aa:	183b      	adds	r3, r7, r0
 80052ac:	7b5b      	ldrb	r3, [r3, #13]
 80052ae:	4876      	ldr	r0, [pc, #472]	; (8005488 <processCommands+0x7ec>)
 80052b0:	9300      	str	r3, [sp, #0]
 80052b2:	0023      	movs	r3, r4
 80052b4:	f007 fb1a 	bl	800c8ec <iprintf>
 80052b8:	4b68      	ldr	r3, [pc, #416]	; (800545c <processCommands+0x7c0>)
 80052ba:	0018      	movs	r0, r3
 80052bc:	f007 fb90 	bl	800c9e0 <puts>
                cmd.fields.newChannel.freq,
                cmd.fields.newChannel.maxDR,
                cmd.fields.newChannel.minDR
            )
        
            if(LDL_Region_isDynamic(self->region)){
 80052c0:	68fa      	ldr	r2, [r7, #12]
 80052c2:	2391      	movs	r3, #145	; 0x91
 80052c4:	009b      	lsls	r3, r3, #2
 80052c6:	5cd3      	ldrb	r3, [r2, r3]
 80052c8:	0018      	movs	r0, r3
 80052ca:	f003 fc43 	bl	8008b54 <LDL_Region_isDynamic>
 80052ce:	1e03      	subs	r3, r0, #0
 80052d0:	d041      	beq.n	8005356 <processCommands+0x6ba>
            
                self->ctx.new_channel_ans.dataRateRangeOK = LDL_Region_validateRate(self->region, cmd.fields.newChannel.chIndex, cmd.fields.newChannel.minDR, cmd.fields.newChannel.maxDR);        
 80052d2:	68fa      	ldr	r2, [r7, #12]
 80052d4:	2391      	movs	r3, #145	; 0x91
 80052d6:	009b      	lsls	r3, r3, #2
 80052d8:	5cd0      	ldrb	r0, [r2, r3]
 80052da:	2434      	movs	r4, #52	; 0x34
 80052dc:	193b      	adds	r3, r7, r4
 80052de:	7919      	ldrb	r1, [r3, #4]
 80052e0:	193b      	adds	r3, r7, r4
 80052e2:	7b5a      	ldrb	r2, [r3, #13]
 80052e4:	193b      	adds	r3, r7, r4
 80052e6:	7b1b      	ldrb	r3, [r3, #12]
 80052e8:	f003 fd74 	bl	8008dd4 <LDL_Region_validateRate>
 80052ec:	0003      	movs	r3, r0
 80052ee:	0019      	movs	r1, r3
 80052f0:	68fa      	ldr	r2, [r7, #12]
 80052f2:	2386      	movs	r3, #134	; 0x86
 80052f4:	009b      	lsls	r3, r3, #2
 80052f6:	54d1      	strb	r1, [r2, r3]
                self->ctx.new_channel_ans.channelFreqOK = LDL_Region_validateFreq(self->region, cmd.fields.newChannel.chIndex, cmd.fields.newChannel.freq);
 80052f8:	68fa      	ldr	r2, [r7, #12]
 80052fa:	2391      	movs	r3, #145	; 0x91
 80052fc:	009b      	lsls	r3, r3, #2
 80052fe:	5cd0      	ldrb	r0, [r2, r3]
 8005300:	193b      	adds	r3, r7, r4
 8005302:	7919      	ldrb	r1, [r3, #4]
 8005304:	193b      	adds	r3, r7, r4
 8005306:	689b      	ldr	r3, [r3, #8]
 8005308:	001a      	movs	r2, r3
 800530a:	f003 fda0 	bl	8008e4e <LDL_Region_validateFreq>
 800530e:	0003      	movs	r3, r0
 8005310:	0019      	movs	r1, r3
 8005312:	68fb      	ldr	r3, [r7, #12]
 8005314:	4a5d      	ldr	r2, [pc, #372]	; (800548c <processCommands+0x7f0>)
 8005316:	5499      	strb	r1, [r3, r2]
                
                if(self->ctx.new_channel_ans.dataRateRangeOK && self->ctx.new_channel_ans.channelFreqOK){
 8005318:	68fa      	ldr	r2, [r7, #12]
 800531a:	2386      	movs	r3, #134	; 0x86
 800531c:	009b      	lsls	r3, r3, #2
 800531e:	5cd3      	ldrb	r3, [r2, r3]
 8005320:	2b00      	cmp	r3, #0
 8005322:	d012      	beq.n	800534a <processCommands+0x6ae>
 8005324:	68fb      	ldr	r3, [r7, #12]
 8005326:	4a59      	ldr	r2, [pc, #356]	; (800548c <processCommands+0x7f0>)
 8005328:	5c9b      	ldrb	r3, [r3, r2]
 800532a:	2b00      	cmp	r3, #0
 800532c:	d00d      	beq.n	800534a <processCommands+0x6ae>
                    
                    (void)setChannel(self, cmd.fields.newChannel.chIndex, cmd.fields.newChannel.freq, cmd.fields.newChannel.minDR, cmd.fields.newChannel.maxDR);                        
 800532e:	2034      	movs	r0, #52	; 0x34
 8005330:	183b      	adds	r3, r7, r0
 8005332:	7919      	ldrb	r1, [r3, #4]
 8005334:	183b      	adds	r3, r7, r0
 8005336:	689a      	ldr	r2, [r3, #8]
 8005338:	183b      	adds	r3, r7, r0
 800533a:	7b5c      	ldrb	r4, [r3, #13]
 800533c:	183b      	adds	r3, r7, r0
 800533e:	7b1b      	ldrb	r3, [r3, #12]
 8005340:	68f8      	ldr	r0, [r7, #12]
 8005342:	9300      	str	r3, [sp, #0]
 8005344:	0023      	movs	r3, r4
 8005346:	f000 fd92 	bl	8005e6e <setChannel>
                }            

                setPendingCommand(self, LDL_CMD_NEW_CHANNEL);
 800534a:	68fb      	ldr	r3, [r7, #12]
 800534c:	2105      	movs	r1, #5
 800534e:	0018      	movs	r0, r3
 8005350:	f001 fb45 	bl	80069de <setPendingCommand>
 8005354:	e00b      	b.n	800536e <processCommands+0x6d2>
            }
            else{
                
                LDL_DEBUG(self->app, "new_channel_req not processed in this region")                
 8005356:	4b43      	ldr	r3, [pc, #268]	; (8005464 <processCommands+0x7c8>)
 8005358:	0018      	movs	r0, r3
 800535a:	f007 fac7 	bl	800c8ec <iprintf>
 800535e:	4b4c      	ldr	r3, [pc, #304]	; (8005490 <processCommands+0x7f4>)
 8005360:	0018      	movs	r0, r3
 8005362:	f007 fac3 	bl	800c8ec <iprintf>
 8005366:	4b3d      	ldr	r3, [pc, #244]	; (800545c <processCommands+0x7c0>)
 8005368:	0018      	movs	r0, r3
 800536a:	f007 fb39 	bl	800c9e0 <puts>
 800536e:	226f      	movs	r2, #111	; 0x6f
 8005370:	18bb      	adds	r3, r7, r2
 8005372:	18ba      	adds	r2, r7, r2
 8005374:	7812      	ldrb	r2, [r2, #0]
 8005376:	701a      	strb	r2, [r3, #0]
            }
            break; 
 8005378:	e1a4      	b.n	80056c4 <processCommands+0xa28>
                   
        case LDL_CMD_DL_CHANNEL:            
            
            LDL_DEBUG(self->app, "dl_channel_req: chIndex=%u freq=%"PRIu32,
 800537a:	4b3a      	ldr	r3, [pc, #232]	; (8005464 <processCommands+0x7c8>)
 800537c:	0018      	movs	r0, r3
 800537e:	f007 fab5 	bl	800c8ec <iprintf>
 8005382:	2234      	movs	r2, #52	; 0x34
 8005384:	18bb      	adds	r3, r7, r2
 8005386:	791b      	ldrb	r3, [r3, #4]
 8005388:	0019      	movs	r1, r3
 800538a:	18bb      	adds	r3, r7, r2
 800538c:	689a      	ldr	r2, [r3, #8]
 800538e:	4b41      	ldr	r3, [pc, #260]	; (8005494 <processCommands+0x7f8>)
 8005390:	0018      	movs	r0, r3
 8005392:	f007 faab 	bl	800c8ec <iprintf>
 8005396:	4b31      	ldr	r3, [pc, #196]	; (800545c <processCommands+0x7c0>)
 8005398:	0018      	movs	r0, r3
 800539a:	f007 fb21 	bl	800c9e0 <puts>
                cmd.fields.dlChannel.chIndex,
                cmd.fields.dlChannel.freq
            )

            if(LDL_Region_isDynamic(self->region)){
 800539e:	68fa      	ldr	r2, [r7, #12]
 80053a0:	2391      	movs	r3, #145	; 0x91
 80053a2:	009b      	lsls	r3, r3, #2
 80053a4:	5cd3      	ldrb	r3, [r2, r3]
 80053a6:	0018      	movs	r0, r3
 80053a8:	f003 fbd4 	bl	8008b54 <LDL_Region_isDynamic>
 80053ac:	1e03      	subs	r3, r0, #0
 80053ae:	d01a      	beq.n	80053e6 <processCommands+0x74a>

#ifdef LDL_DISABLE_CMD_DL_CHANNEL                            
                self->ctx.dl_channel_ans.uplinkFreqOK = false;
                self->ctx.dl_channel_ans.channelFreqOK = false;
#else
                self->ctx.dl_channel_ans.uplinkFreqOK = true;
 80053b0:	68fb      	ldr	r3, [r7, #12]
 80053b2:	4a39      	ldr	r2, [pc, #228]	; (8005498 <processCommands+0x7fc>)
 80053b4:	2101      	movs	r1, #1
 80053b6:	5499      	strb	r1, [r3, r2]
                self->ctx.dl_channel_ans.channelFreqOK = LDL_Region_validateFreq(self->region, cmd.fields.dlChannel.chIndex, cmd.fields.dlChannel.freq);
 80053b8:	68fa      	ldr	r2, [r7, #12]
 80053ba:	2391      	movs	r3, #145	; 0x91
 80053bc:	009b      	lsls	r3, r3, #2
 80053be:	5cd0      	ldrb	r0, [r2, r3]
 80053c0:	2234      	movs	r2, #52	; 0x34
 80053c2:	18bb      	adds	r3, r7, r2
 80053c4:	7919      	ldrb	r1, [r3, #4]
 80053c6:	18bb      	adds	r3, r7, r2
 80053c8:	689b      	ldr	r3, [r3, #8]
 80053ca:	001a      	movs	r2, r3
 80053cc:	f003 fd3f 	bl	8008e4e <LDL_Region_validateFreq>
 80053d0:	0003      	movs	r3, r0
 80053d2:	0019      	movs	r1, r3
 80053d4:	68fb      	ldr	r3, [r7, #12]
 80053d6:	4a31      	ldr	r2, [pc, #196]	; (800549c <processCommands+0x800>)
 80053d8:	5499      	strb	r1, [r3, r2]
#endif                
                setPendingCommand(self, LDL_CMD_DL_CHANNEL);
 80053da:	68fb      	ldr	r3, [r7, #12]
 80053dc:	2108      	movs	r1, #8
 80053de:	0018      	movs	r0, r3
 80053e0:	f001 fafd 	bl	80069de <setPendingCommand>
 80053e4:	e00b      	b.n	80053fe <processCommands+0x762>
            }
            else{
                
                LDL_DEBUG(self->app, "dl_channel_req not processed in this region")                
 80053e6:	4b1f      	ldr	r3, [pc, #124]	; (8005464 <processCommands+0x7c8>)
 80053e8:	0018      	movs	r0, r3
 80053ea:	f007 fa7f 	bl	800c8ec <iprintf>
 80053ee:	4b2c      	ldr	r3, [pc, #176]	; (80054a0 <processCommands+0x804>)
 80053f0:	0018      	movs	r0, r3
 80053f2:	f007 fa7b 	bl	800c8ec <iprintf>
 80053f6:	4b19      	ldr	r3, [pc, #100]	; (800545c <processCommands+0x7c0>)
 80053f8:	0018      	movs	r0, r3
 80053fa:	f007 faf1 	bl	800c9e0 <puts>
 80053fe:	226f      	movs	r2, #111	; 0x6f
 8005400:	18bb      	adds	r3, r7, r2
 8005402:	18ba      	adds	r2, r7, r2
 8005404:	7812      	ldrb	r2, [r2, #0]
 8005406:	701a      	strb	r2, [r3, #0]
            }
            break;
 8005408:	e15c      	b.n	80056c4 <processCommands+0xa28>
        
        case LDL_CMD_RX_TIMING_SETUP:

            LDL_DEBUG(self->app, "rx_timing_setup_req: delay=%u",
 800540a:	4b16      	ldr	r3, [pc, #88]	; (8005464 <processCommands+0x7c8>)
 800540c:	0018      	movs	r0, r3
 800540e:	f007 fa6d 	bl	800c8ec <iprintf>
 8005412:	2434      	movs	r4, #52	; 0x34
 8005414:	193b      	adds	r3, r7, r4
 8005416:	791b      	ldrb	r3, [r3, #4]
 8005418:	001a      	movs	r2, r3
 800541a:	4b22      	ldr	r3, [pc, #136]	; (80054a4 <processCommands+0x808>)
 800541c:	0011      	movs	r1, r2
 800541e:	0018      	movs	r0, r3
 8005420:	f007 fa64 	bl	800c8ec <iprintf>
 8005424:	4b0d      	ldr	r3, [pc, #52]	; (800545c <processCommands+0x7c0>)
 8005426:	0018      	movs	r0, r3
 8005428:	f007 fada 	bl	800c9e0 <puts>
                cmd.fields.rxTimingSetup.delay
            )
            
            self->ctx.rx1Delay = cmd.fields.rxTimingSetup.delay;
 800542c:	193b      	adds	r3, r7, r4
 800542e:	7919      	ldrb	r1, [r3, #4]
 8005430:	68fa      	ldr	r2, [r7, #12]
 8005432:	23fd      	movs	r3, #253	; 0xfd
 8005434:	005b      	lsls	r3, r3, #1
 8005436:	54d1      	strb	r1, [r2, r3]
            
            setPendingCommand(self, LDL_CMD_RX_TIMING_SETUP);
 8005438:	68fb      	ldr	r3, [r7, #12]
 800543a:	2106      	movs	r1, #6
 800543c:	0018      	movs	r0, r3
 800543e:	f001 face 	bl	80069de <setPendingCommand>
 8005442:	226f      	movs	r2, #111	; 0x6f
 8005444:	18bb      	adds	r3, r7, r2
 8005446:	18ba      	adds	r2, r7, r2
 8005448:	7812      	ldrb	r2, [r2, #0]
 800544a:	701a      	strb	r2, [r3, #0]
            break;
 800544c:	e13a      	b.n	80056c4 <processCommands+0xa28>
 800544e:	46c0      	nop			; (mov r8, r8)
 8005450:	00000213 	.word	0x00000213
 8005454:	0800d8c8 	.word	0x0800d8c8
 8005458:	0800dcf4 	.word	0x0800dcf4
 800545c:	0800d8e4 	.word	0x0800d8e4
 8005460:	00000215 	.word	0x00000215
 8005464:	0800d8e8 	.word	0x0800d8e8
 8005468:	0800dd1c 	.word	0x0800dd1c
 800546c:	0800dd50 	.word	0x0800dd50
 8005470:	0800dd64 	.word	0x0800dd64
 8005474:	0000020e 	.word	0x0000020e
 8005478:	0000020f 	.word	0x0000020f
 800547c:	0800dda0 	.word	0x0800dda0
 8005480:	00000216 	.word	0x00000216
 8005484:	00000217 	.word	0x00000217
 8005488:	0800ddb0 	.word	0x0800ddb0
 800548c:	00000219 	.word	0x00000219
 8005490:	0800dde8 	.word	0x0800dde8
 8005494:	0800de18 	.word	0x0800de18
 8005498:	00000211 	.word	0x00000211
 800549c:	00000212 	.word	0x00000212
 80054a0:	0800de3c 	.word	0x0800de3c
 80054a4:	0800de68 	.word	0x0800de68
        
        case LDL_CMD_TX_PARAM_SETUP:        
                         
            LDL_DEBUG(self->app, "tx_param_setup_req: downlinkDwellTime=%s uplinkDwellTime=%s maxEIRP=%u",
 80054a8:	4ba7      	ldr	r3, [pc, #668]	; (8005748 <processCommands+0xaac>)
 80054aa:	0018      	movs	r0, r3
 80054ac:	f007 fa1e 	bl	800c8ec <iprintf>
 80054b0:	2334      	movs	r3, #52	; 0x34
 80054b2:	18fb      	adds	r3, r7, r3
 80054b4:	791b      	ldrb	r3, [r3, #4]
 80054b6:	2b00      	cmp	r3, #0
 80054b8:	d001      	beq.n	80054be <processCommands+0x822>
 80054ba:	49a4      	ldr	r1, [pc, #656]	; (800574c <processCommands+0xab0>)
 80054bc:	e000      	b.n	80054c0 <processCommands+0x824>
 80054be:	49a4      	ldr	r1, [pc, #656]	; (8005750 <processCommands+0xab4>)
 80054c0:	2334      	movs	r3, #52	; 0x34
 80054c2:	18fb      	adds	r3, r7, r3
 80054c4:	795b      	ldrb	r3, [r3, #5]
 80054c6:	2b00      	cmp	r3, #0
 80054c8:	d001      	beq.n	80054ce <processCommands+0x832>
 80054ca:	4aa0      	ldr	r2, [pc, #640]	; (800574c <processCommands+0xab0>)
 80054cc:	e000      	b.n	80054d0 <processCommands+0x834>
 80054ce:	4aa0      	ldr	r2, [pc, #640]	; (8005750 <processCommands+0xab4>)
 80054d0:	2334      	movs	r3, #52	; 0x34
 80054d2:	18fb      	adds	r3, r7, r3
 80054d4:	799b      	ldrb	r3, [r3, #6]
 80054d6:	489f      	ldr	r0, [pc, #636]	; (8005754 <processCommands+0xab8>)
 80054d8:	f007 fa08 	bl	800c8ec <iprintf>
 80054dc:	4b9e      	ldr	r3, [pc, #632]	; (8005758 <processCommands+0xabc>)
 80054de:	0018      	movs	r0, r3
 80054e0:	f007 fa7e 	bl	800c9e0 <puts>
                cmd.fields.txParamSetup.downlinkDwell ? "true" : "false",
                cmd.fields.txParamSetup.uplinkDwell ? "true" : "false",
                cmd.fields.txParamSetup.maxEIRP
            )    
        
            if(LDL_Region_isDynamic(self->region)){
 80054e4:	68fa      	ldr	r2, [r7, #12]
 80054e6:	2391      	movs	r3, #145	; 0x91
 80054e8:	009b      	lsls	r3, r3, #2
 80054ea:	5cd3      	ldrb	r3, [r2, r3]
 80054ec:	0018      	movs	r0, r3
 80054ee:	f003 fb31 	bl	8008b54 <LDL_Region_isDynamic>
 80054f2:	1e03      	subs	r3, r0, #0
 80054f4:	d005      	beq.n	8005502 <processCommands+0x866>
                
                setPendingCommand(self, LDL_CMD_TX_PARAM_SETUP);
 80054f6:	68fb      	ldr	r3, [r7, #12]
 80054f8:	2107      	movs	r1, #7
 80054fa:	0018      	movs	r0, r3
 80054fc:	f001 fa6f 	bl	80069de <setPendingCommand>
 8005500:	e00b      	b.n	800551a <processCommands+0x87e>
            }
            else{
                
                LDL_DEBUG(self->app, "tx_param_setup_req not processed in this region")
 8005502:	4b91      	ldr	r3, [pc, #580]	; (8005748 <processCommands+0xaac>)
 8005504:	0018      	movs	r0, r3
 8005506:	f007 f9f1 	bl	800c8ec <iprintf>
 800550a:	4b94      	ldr	r3, [pc, #592]	; (800575c <processCommands+0xac0>)
 800550c:	0018      	movs	r0, r3
 800550e:	f007 f9ed 	bl	800c8ec <iprintf>
 8005512:	4b91      	ldr	r3, [pc, #580]	; (8005758 <processCommands+0xabc>)
 8005514:	0018      	movs	r0, r3
 8005516:	f007 fa63 	bl	800c9e0 <puts>
 800551a:	226f      	movs	r2, #111	; 0x6f
 800551c:	18bb      	adds	r3, r7, r2
 800551e:	18ba      	adds	r2, r7, r2
 8005520:	7812      	ldrb	r2, [r2, #0]
 8005522:	701a      	strb	r2, [r3, #0]
            }
            break;
 8005524:	e0ce      	b.n	80056c4 <processCommands+0xa28>
#ifndef LDL_DISABLE_DEVICE_TIME
        case LDL_CMD_DEVICE_TIME:
        {
            union ldl_mac_response_arg arg;
            
            arg.device_time.seconds = cmd.fields.deviceTime.seconds;
 8005526:	2134      	movs	r1, #52	; 0x34
 8005528:	187b      	adds	r3, r7, r1
 800552a:	685a      	ldr	r2, [r3, #4]
 800552c:	2410      	movs	r4, #16
 800552e:	193b      	adds	r3, r7, r4
 8005530:	601a      	str	r2, [r3, #0]
            arg.device_time.fractions = cmd.fields.deviceTime.fractions;
 8005532:	187b      	adds	r3, r7, r1
 8005534:	7a1a      	ldrb	r2, [r3, #8]
 8005536:	193b      	adds	r3, r7, r4
 8005538:	711a      	strb	r2, [r3, #4]
            
            LDL_DEBUG(self->app, "device_time_ans: seconds=%"PRIu32" fractions=%u", 
 800553a:	4b83      	ldr	r3, [pc, #524]	; (8005748 <processCommands+0xaac>)
 800553c:	0018      	movs	r0, r3
 800553e:	f007 f9d5 	bl	800c8ec <iprintf>
 8005542:	193b      	adds	r3, r7, r4
 8005544:	6819      	ldr	r1, [r3, #0]
 8005546:	193b      	adds	r3, r7, r4
 8005548:	791b      	ldrb	r3, [r3, #4]
 800554a:	001a      	movs	r2, r3
 800554c:	4b84      	ldr	r3, [pc, #528]	; (8005760 <processCommands+0xac4>)
 800554e:	0018      	movs	r0, r3
 8005550:	f007 f9cc 	bl	800c8ec <iprintf>
 8005554:	4b80      	ldr	r3, [pc, #512]	; (8005758 <processCommands+0xabc>)
 8005556:	0018      	movs	r0, r3
 8005558:	f007 fa42 	bl	800c9e0 <puts>
                arg.device_time.seconds,
                arg.device_time.fractions             
            )
            
            self->handler(self->app, LDL_MAC_DEVICE_TIME, &arg);                                                                                     
 800555c:	68fa      	ldr	r2, [r7, #12]
 800555e:	2392      	movs	r3, #146	; 0x92
 8005560:	009b      	lsls	r3, r3, #2
 8005562:	58d3      	ldr	r3, [r2, r3]
 8005564:	68f9      	ldr	r1, [r7, #12]
 8005566:	2293      	movs	r2, #147	; 0x93
 8005568:	0092      	lsls	r2, r2, #2
 800556a:	5888      	ldr	r0, [r1, r2]
 800556c:	193a      	adds	r2, r7, r4
 800556e:	2110      	movs	r1, #16
 8005570:	4798      	blx	r3
 8005572:	226f      	movs	r2, #111	; 0x6f
 8005574:	18bb      	adds	r3, r7, r2
 8005576:	18ba      	adds	r2, r7, r2
 8005578:	7812      	ldrb	r2, [r2, #0]
 800557a:	701a      	strb	r2, [r3, #0]
        }
            break;
 800557c:	e0a2      	b.n	80056c4 <processCommands+0xa28>
#endif            
        case LDL_CMD_ADR_PARAM_SETUP:
        
            LDL_DEBUG(self->app, "adr_param_setup: limit_exp=%u delay_exp=%u", 
 800557e:	4b72      	ldr	r3, [pc, #456]	; (8005748 <processCommands+0xaac>)
 8005580:	0018      	movs	r0, r3
 8005582:	f007 f9b3 	bl	800c8ec <iprintf>
 8005586:	2034      	movs	r0, #52	; 0x34
 8005588:	183b      	adds	r3, r7, r0
 800558a:	791b      	ldrb	r3, [r3, #4]
 800558c:	0019      	movs	r1, r3
 800558e:	0004      	movs	r4, r0
 8005590:	183b      	adds	r3, r7, r0
 8005592:	795b      	ldrb	r3, [r3, #5]
 8005594:	001a      	movs	r2, r3
 8005596:	4b73      	ldr	r3, [pc, #460]	; (8005764 <processCommands+0xac8>)
 8005598:	0018      	movs	r0, r3
 800559a:	f007 f9a7 	bl	800c8ec <iprintf>
 800559e:	4b6e      	ldr	r3, [pc, #440]	; (8005758 <processCommands+0xabc>)
 80055a0:	0018      	movs	r0, r3
 80055a2:	f007 fa1d 	bl	800c9e0 <puts>
                cmd.fields.adrParamSetup.limit_exp,
                cmd.fields.adrParamSetup.delay_exp        
            )
            
            self->ctx.adr_ack_limit = (1U << cmd.fields.adrParamSetup.limit_exp);
 80055a6:	0020      	movs	r0, r4
 80055a8:	183b      	adds	r3, r7, r0
 80055aa:	791b      	ldrb	r3, [r3, #4]
 80055ac:	001a      	movs	r2, r3
 80055ae:	2301      	movs	r3, #1
 80055b0:	4093      	lsls	r3, r2
 80055b2:	b299      	uxth	r1, r3
 80055b4:	68fa      	ldr	r2, [r7, #12]
 80055b6:	2382      	movs	r3, #130	; 0x82
 80055b8:	009b      	lsls	r3, r3, #2
 80055ba:	52d1      	strh	r1, [r2, r3]
            self->ctx.adr_ack_delay = (1U << cmd.fields.adrParamSetup.delay_exp);
 80055bc:	183b      	adds	r3, r7, r0
 80055be:	795b      	ldrb	r3, [r3, #5]
 80055c0:	001a      	movs	r2, r3
 80055c2:	2301      	movs	r3, #1
 80055c4:	4093      	lsls	r3, r2
 80055c6:	b299      	uxth	r1, r3
 80055c8:	68fb      	ldr	r3, [r7, #12]
 80055ca:	4a67      	ldr	r2, [pc, #412]	; (8005768 <processCommands+0xacc>)
 80055cc:	5299      	strh	r1, [r3, r2]
            
            setPendingCommand(self, LDL_CMD_ADR_PARAM_SETUP);            
 80055ce:	68fb      	ldr	r3, [r7, #12]
 80055d0:	210a      	movs	r1, #10
 80055d2:	0018      	movs	r0, r3
 80055d4:	f001 fa03 	bl	80069de <setPendingCommand>
 80055d8:	226f      	movs	r2, #111	; 0x6f
 80055da:	18bb      	adds	r3, r7, r2
 80055dc:	18ba      	adds	r2, r7, r2
 80055de:	7812      	ldrb	r2, [r2, #0]
 80055e0:	701a      	strb	r2, [r3, #0]
            break;
 80055e2:	e06f      	b.n	80056c4 <processCommands+0xa28>
            
        case LDL_CMD_REKEY:
        
            LDL_DEBUG(self->app, "rekey_conf: version=%u", cmd.fields.rekey.version)
 80055e4:	4b58      	ldr	r3, [pc, #352]	; (8005748 <processCommands+0xaac>)
 80055e6:	0018      	movs	r0, r3
 80055e8:	f007 f980 	bl	800c8ec <iprintf>
 80055ec:	2434      	movs	r4, #52	; 0x34
 80055ee:	193b      	adds	r3, r7, r4
 80055f0:	791b      	ldrb	r3, [r3, #4]
 80055f2:	001a      	movs	r2, r3
 80055f4:	4b5d      	ldr	r3, [pc, #372]	; (800576c <processCommands+0xad0>)
 80055f6:	0011      	movs	r1, r2
 80055f8:	0018      	movs	r0, r3
 80055fa:	f007 f977 	bl	800c8ec <iprintf>
 80055fe:	4b56      	ldr	r3, [pc, #344]	; (8005758 <processCommands+0xabc>)
 8005600:	0018      	movs	r0, r3
 8005602:	f007 f9ed 	bl	800c9e0 <puts>
        
            /* The server version must be greater than 0 (0 is not allowed), and smaller or equal (<=) to the
             * device’s LoRaWAN version. Therefore for a LoRaWAN1.1 device the only valid value is 1. If
             * the server’s version is invalid the device SHALL discard the RekeyConf command and
             * retransmit the RekeyInd in the next uplink frame */
            if(cmd.fields.rekey.version == self->ctx.version){
 8005606:	193b      	adds	r3, r7, r4
 8005608:	791a      	ldrb	r2, [r3, #4]
 800560a:	68fb      	ldr	r3, [r7, #12]
 800560c:	4958      	ldr	r1, [pc, #352]	; (8005770 <processCommands+0xad4>)
 800560e:	5c5b      	ldrb	r3, [r3, r1]
 8005610:	429a      	cmp	r2, r3
 8005612:	d104      	bne.n	800561e <processCommands+0x982>
                
                clearPendingCommand(self, LDL_CMD_REKEY);
 8005614:	68fb      	ldr	r3, [r7, #12]
 8005616:	2109      	movs	r1, #9
 8005618:	0018      	movs	r0, r3
 800561a:	f001 f9c1 	bl	80069a0 <clearPendingCommand>
 800561e:	226f      	movs	r2, #111	; 0x6f
 8005620:	18bb      	adds	r3, r7, r2
 8005622:	18ba      	adds	r2, r7, r2
 8005624:	7812      	ldrb	r2, [r2, #0]
 8005626:	701a      	strb	r2, [r3, #0]
            }
            break;
 8005628:	e04c      	b.n	80056c4 <processCommands+0xa28>
            
        case LDL_CMD_FORCE_REJOIN:
                
            LDL_DEBUG(self->app, "force_rejoin_req: max_retries=%u rejoin_type=%u period=% dr=%u",
 800562a:	4b47      	ldr	r3, [pc, #284]	; (8005748 <processCommands+0xaac>)
 800562c:	0018      	movs	r0, r3
 800562e:	f007 f95d 	bl	800c8ec <iprintf>
 8005632:	2034      	movs	r0, #52	; 0x34
 8005634:	183b      	adds	r3, r7, r0
 8005636:	795b      	ldrb	r3, [r3, #5]
 8005638:	0019      	movs	r1, r3
 800563a:	183b      	adds	r3, r7, r0
 800563c:	799b      	ldrb	r3, [r3, #6]
 800563e:	001a      	movs	r2, r3
 8005640:	183b      	adds	r3, r7, r0
 8005642:	791b      	ldrb	r3, [r3, #4]
 8005644:	001c      	movs	r4, r3
 8005646:	183b      	adds	r3, r7, r0
 8005648:	79db      	ldrb	r3, [r3, #7]
 800564a:	484a      	ldr	r0, [pc, #296]	; (8005774 <processCommands+0xad8>)
 800564c:	9300      	str	r3, [sp, #0]
 800564e:	0023      	movs	r3, r4
 8005650:	f007 f94c 	bl	800c8ec <iprintf>
 8005654:	4b40      	ldr	r3, [pc, #256]	; (8005758 <processCommands+0xabc>)
 8005656:	0018      	movs	r0, r3
 8005658:	f007 f9c2 	bl	800c9e0 <puts>
                cmd.fields.forceRejoin.rejoin_type,
                cmd.fields.forceRejoin.period,
                cmd.fields.forceRejoin.dr
            )
        
            LDL_DEBUG(self->app, "force rejoin not implemented")
 800565c:	4b3a      	ldr	r3, [pc, #232]	; (8005748 <processCommands+0xaac>)
 800565e:	0018      	movs	r0, r3
 8005660:	f007 f944 	bl	800c8ec <iprintf>
 8005664:	4b44      	ldr	r3, [pc, #272]	; (8005778 <processCommands+0xadc>)
 8005666:	0018      	movs	r0, r3
 8005668:	f007 f940 	bl	800c8ec <iprintf>
 800566c:	4b3a      	ldr	r3, [pc, #232]	; (8005758 <processCommands+0xabc>)
 800566e:	0018      	movs	r0, r3
 8005670:	f007 f9b6 	bl	800c9e0 <puts>
 8005674:	226f      	movs	r2, #111	; 0x6f
 8005676:	18bb      	adds	r3, r7, r2
 8005678:	18ba      	adds	r2, r7, r2
 800567a:	7812      	ldrb	r2, [r2, #0]
 800567c:	701a      	strb	r2, [r3, #0]
        
            /* no reply - you are meant to start doing a rejoin */
                
            break;
 800567e:	e021      	b.n	80056c4 <processCommands+0xa28>
            
        case LDL_CMD_REJOIN_PARAM_SETUP:
        
            LDL_DEBUG(self->app, "rejoin_param_setup_req: maxTimeN=%u maxCountN=%u",
 8005680:	4b31      	ldr	r3, [pc, #196]	; (8005748 <processCommands+0xaac>)
 8005682:	0018      	movs	r0, r3
 8005684:	f007 f932 	bl	800c8ec <iprintf>
 8005688:	2234      	movs	r2, #52	; 0x34
 800568a:	18bb      	adds	r3, r7, r2
 800568c:	791b      	ldrb	r3, [r3, #4]
 800568e:	0019      	movs	r1, r3
 8005690:	18bb      	adds	r3, r7, r2
 8005692:	795b      	ldrb	r3, [r3, #5]
 8005694:	001a      	movs	r2, r3
 8005696:	4b39      	ldr	r3, [pc, #228]	; (800577c <processCommands+0xae0>)
 8005698:	0018      	movs	r0, r3
 800569a:	f007 f927 	bl	800c8ec <iprintf>
 800569e:	4b2e      	ldr	r3, [pc, #184]	; (8005758 <processCommands+0xabc>)
 80056a0:	0018      	movs	r0, r3
 80056a2:	f007 f99d 	bl	800c9e0 <puts>
                cmd.fields.rejoinParamSetup.maxTimeN,
                cmd.fields.rejoinParamSetup.maxCountN
            )
            
            self->ctx.rejoin_param_setup_ans.timeOK = false;
 80056a6:	68fb      	ldr	r3, [r7, #12]
 80056a8:	4a35      	ldr	r2, [pc, #212]	; (8005780 <processCommands+0xae4>)
 80056aa:	2100      	movs	r1, #0
 80056ac:	5499      	strb	r1, [r3, r2]
            setPendingCommand(self, LDL_CMD_REJOIN_PARAM_SETUP);        
 80056ae:	68fb      	ldr	r3, [r7, #12]
 80056b0:	210d      	movs	r1, #13
 80056b2:	0018      	movs	r0, r3
 80056b4:	f001 f993 	bl	80069de <setPendingCommand>
 80056b8:	226f      	movs	r2, #111	; 0x6f
 80056ba:	18bb      	adds	r3, r7, r2
 80056bc:	18ba      	adds	r2, r7, r2
 80056be:	7812      	ldrb	r2, [r2, #0]
 80056c0:	701a      	strb	r2, [r3, #0]
            break;        
 80056c2:	46c0      	nop			; (mov r8, r8)
    while(LDL_MAC_getDownCommand(&s_in, &cmd)){
 80056c4:	2334      	movs	r3, #52	; 0x34
 80056c6:	18fa      	adds	r2, r7, r3
 80056c8:	2350      	movs	r3, #80	; 0x50
 80056ca:	18fb      	adds	r3, r7, r3
 80056cc:	0011      	movs	r1, r2
 80056ce:	0018      	movs	r0, r3
 80056d0:	f001 fb4e 	bl	8006d70 <LDL_MAC_getDownCommand>
 80056d4:	1e03      	subs	r3, r0, #0
 80056d6:	d001      	beq.n	80056dc <processCommands+0xa40>
 80056d8:	f7ff fb19 	bl	8004d0e <processCommands+0x72>
        }
    }
    
    /* roll back ADR request if not successful */
    if(adr_state == _ADR_BAD){
 80056dc:	236f      	movs	r3, #111	; 0x6f
 80056de:	18fb      	adds	r3, r7, r3
 80056e0:	781b      	ldrb	r3, [r3, #0]
 80056e2:	2b02      	cmp	r3, #2
 80056e4:	d12c      	bne.n	8005740 <processCommands+0xaa4>
        
        LDL_DEBUG(self->app, "bad ADR setting; rollback")
 80056e6:	4b18      	ldr	r3, [pc, #96]	; (8005748 <processCommands+0xaac>)
 80056e8:	0018      	movs	r0, r3
 80056ea:	f007 f8ff 	bl	800c8ec <iprintf>
 80056ee:	4b25      	ldr	r3, [pc, #148]	; (8005784 <processCommands+0xae8>)
 80056f0:	0018      	movs	r0, r3
 80056f2:	f007 f8fb 	bl	800c8ec <iprintf>
 80056f6:	4b18      	ldr	r3, [pc, #96]	; (8005758 <processCommands+0xabc>)
 80056f8:	0018      	movs	r0, r3
 80056fa:	f007 f971 	bl	800c9e0 <puts>
        
        (void)memcpy(self->ctx.chMask, chMask, sizeof(self->ctx.chMask));
 80056fe:	68fb      	ldr	r3, [r7, #12]
 8005700:	33ed      	adds	r3, #237	; 0xed
 8005702:	33ff      	adds	r3, #255	; 0xff
 8005704:	001a      	movs	r2, r3
 8005706:	2344      	movs	r3, #68	; 0x44
 8005708:	18fb      	adds	r3, r7, r3
 800570a:	0010      	movs	r0, r2
 800570c:	0019      	movs	r1, r3
 800570e:	2309      	movs	r3, #9
 8005710:	001a      	movs	r2, r3
 8005712:	f007 f8d9 	bl	800c8c8 <memcpy>
        
        self->ctx.rate = rate;
 8005716:	68fa      	ldr	r2, [r7, #12]
 8005718:	236b      	movs	r3, #107	; 0x6b
 800571a:	18f9      	adds	r1, r7, r3
 800571c:	23f6      	movs	r3, #246	; 0xf6
 800571e:	33ff      	adds	r3, #255	; 0xff
 8005720:	7809      	ldrb	r1, [r1, #0]
 8005722:	54d1      	strb	r1, [r2, r3]
        self->ctx.power = power;
 8005724:	68fa      	ldr	r2, [r7, #12]
 8005726:	236c      	movs	r3, #108	; 0x6c
 8005728:	18f9      	adds	r1, r7, r3
 800572a:	23fb      	movs	r3, #251	; 0xfb
 800572c:	005b      	lsls	r3, r3, #1
 800572e:	7809      	ldrb	r1, [r1, #0]
 8005730:	54d1      	strb	r1, [r2, r3]
        self->ctx.nbTrans = nbTrans;
 8005732:	68fa      	ldr	r2, [r7, #12]
 8005734:	236d      	movs	r3, #109	; 0x6d
 8005736:	18f9      	adds	r1, r7, r3
 8005738:	23fc      	movs	r3, #252	; 0xfc
 800573a:	005b      	lsls	r3, r3, #1
 800573c:	7809      	ldrb	r1, [r1, #0]
 800573e:	54d1      	strb	r1, [r2, r3]
    }    
}
 8005740:	46c0      	nop			; (mov r8, r8)
 8005742:	46bd      	mov	sp, r7
 8005744:	b01c      	add	sp, #112	; 0x70
 8005746:	bdb0      	pop	{r4, r5, r7, pc}
 8005748:	0800d8e8 	.word	0x0800d8e8
 800574c:	0800d998 	.word	0x0800d998
 8005750:	0800d9a0 	.word	0x0800d9a0
 8005754:	0800de88 	.word	0x0800de88
 8005758:	0800d8e4 	.word	0x0800d8e4
 800575c:	0800ded0 	.word	0x0800ded0
 8005760:	0800df00 	.word	0x0800df00
 8005764:	0800df2c 	.word	0x0800df2c
 8005768:	0000020a 	.word	0x0000020a
 800576c:	0800df58 	.word	0x0800df58
 8005770:	00000206 	.word	0x00000206
 8005774:	0800df70 	.word	0x0800df70
 8005778:	0800dfb0 	.word	0x0800dfb0
 800577c:	0800dfd0 	.word	0x0800dfd0
 8005780:	0000021a 	.word	0x0000021a
 8005784:	0800e004 	.word	0x0800e004

08005788 <registerTime>:

static void registerTime(struct ldl_mac *self, uint32_t freq, uint32_t airTime)
{
 8005788:	b580      	push	{r7, lr}
 800578a:	b086      	sub	sp, #24
 800578c:	af00      	add	r7, sp, #0
 800578e:	60f8      	str	r0, [r7, #12]
 8005790:	60b9      	str	r1, [r7, #8]
 8005792:	607a      	str	r2, [r7, #4]
    uint8_t band;
    uint32_t offtime;
    
    if(LDL_Region_getBand(self->region, freq, &band)){
 8005794:	68fa      	ldr	r2, [r7, #12]
 8005796:	2391      	movs	r3, #145	; 0x91
 8005798:	009b      	lsls	r3, r3, #2
 800579a:	5cd3      	ldrb	r3, [r2, r3]
 800579c:	2213      	movs	r2, #19
 800579e:	18ba      	adds	r2, r7, r2
 80057a0:	68b9      	ldr	r1, [r7, #8]
 80057a2:	0018      	movs	r0, r3
 80057a4:	f003 f95c 	bl	8008a60 <LDL_Region_getBand>
 80057a8:	1e03      	subs	r3, r0, #0
 80057aa:	d04d      	beq.n	8005848 <registerTime+0xc0>
    
        offtime = LDL_Region_getOffTimeFactor(self->region, band);
 80057ac:	68fa      	ldr	r2, [r7, #12]
 80057ae:	2391      	movs	r3, #145	; 0x91
 80057b0:	009b      	lsls	r3, r3, #2
 80057b2:	5cd2      	ldrb	r2, [r2, r3]
 80057b4:	2313      	movs	r3, #19
 80057b6:	18fb      	adds	r3, r7, r3
 80057b8:	781b      	ldrb	r3, [r3, #0]
 80057ba:	0019      	movs	r1, r3
 80057bc:	0010      	movs	r0, r2
 80057be:	f003 fadd 	bl	8008d7c <LDL_Region_getOffTimeFactor>
 80057c2:	0003      	movs	r3, r0
 80057c4:	617b      	str	r3, [r7, #20]
    
        if(offtime > 0U){
 80057c6:	697b      	ldr	r3, [r7, #20]
 80057c8:	2b00      	cmp	r3, #0
 80057ca:	d03d      	beq.n	8005848 <registerTime+0xc0>
        
            LDL_PEDANTIC( band < LDL_BAND_MAX )
            
            offtime = ticksToMS(airTime) * offtime;
 80057cc:	687b      	ldr	r3, [r7, #4]
 80057ce:	0018      	movs	r0, r3
 80057d0:	f001 f808 	bl	80067e4 <ticksToMS>
 80057d4:	0002      	movs	r2, r0
 80057d6:	697b      	ldr	r3, [r7, #20]
 80057d8:	4353      	muls	r3, r2
 80057da:	617b      	str	r3, [r7, #20]
            
            if((self->band[band] + offtime) < self->band[band]){
 80057dc:	2113      	movs	r1, #19
 80057de:	187b      	adds	r3, r7, r1
 80057e0:	781b      	ldrb	r3, [r3, #0]
 80057e2:	68fa      	ldr	r2, [r7, #12]
 80057e4:	3344      	adds	r3, #68	; 0x44
 80057e6:	009b      	lsls	r3, r3, #2
 80057e8:	18d3      	adds	r3, r2, r3
 80057ea:	3304      	adds	r3, #4
 80057ec:	681a      	ldr	r2, [r3, #0]
 80057ee:	697b      	ldr	r3, [r7, #20]
 80057f0:	18d2      	adds	r2, r2, r3
 80057f2:	187b      	adds	r3, r7, r1
 80057f4:	781b      	ldrb	r3, [r3, #0]
 80057f6:	68f9      	ldr	r1, [r7, #12]
 80057f8:	3344      	adds	r3, #68	; 0x44
 80057fa:	009b      	lsls	r3, r3, #2
 80057fc:	18cb      	adds	r3, r1, r3
 80057fe:	3304      	adds	r3, #4
 8005800:	681b      	ldr	r3, [r3, #0]
 8005802:	429a      	cmp	r2, r3
 8005804:	d20b      	bcs.n	800581e <registerTime+0x96>
                
                self->band[band] = UINT32_MAX;
 8005806:	2313      	movs	r3, #19
 8005808:	18fb      	adds	r3, r7, r3
 800580a:	781b      	ldrb	r3, [r3, #0]
 800580c:	68fa      	ldr	r2, [r7, #12]
 800580e:	3344      	adds	r3, #68	; 0x44
 8005810:	009b      	lsls	r3, r3, #2
 8005812:	18d3      	adds	r3, r2, r3
 8005814:	3304      	adds	r3, #4
 8005816:	2201      	movs	r2, #1
 8005818:	4252      	negs	r2, r2
 800581a:	601a      	str	r2, [r3, #0]
 800581c:	e014      	b.n	8005848 <registerTime+0xc0>
            }
            else{
                
                self->band[band] += offtime; 
 800581e:	2113      	movs	r1, #19
 8005820:	187b      	adds	r3, r7, r1
 8005822:	781b      	ldrb	r3, [r3, #0]
 8005824:	68fa      	ldr	r2, [r7, #12]
 8005826:	3344      	adds	r3, #68	; 0x44
 8005828:	009b      	lsls	r3, r3, #2
 800582a:	18d3      	adds	r3, r2, r3
 800582c:	3304      	adds	r3, #4
 800582e:	681a      	ldr	r2, [r3, #0]
 8005830:	187b      	adds	r3, r7, r1
 8005832:	781b      	ldrb	r3, [r3, #0]
 8005834:	0018      	movs	r0, r3
 8005836:	697b      	ldr	r3, [r7, #20]
 8005838:	18d2      	adds	r2, r2, r3
 800583a:	68f9      	ldr	r1, [r7, #12]
 800583c:	0003      	movs	r3, r0
 800583e:	3344      	adds	r3, #68	; 0x44
 8005840:	009b      	lsls	r3, r3, #2
 8005842:	18cb      	adds	r3, r1, r3
 8005844:	3304      	adds	r3, #4
 8005846:	601a      	str	r2, [r3, #0]
            }
        }
    }
    
    if((self->op != LDL_OP_JOINING) && (self->ctx.maxDutyCycle > 0U)){
 8005848:	68fb      	ldr	r3, [r7, #12]
 800584a:	785b      	ldrb	r3, [r3, #1]
 800584c:	2b01      	cmp	r3, #1
 800584e:	d031      	beq.n	80058b4 <registerTime+0x12c>
 8005850:	68fa      	ldr	r2, [r7, #12]
 8005852:	23f8      	movs	r3, #248	; 0xf8
 8005854:	33ff      	adds	r3, #255	; 0xff
 8005856:	5cd3      	ldrb	r3, [r2, r3]
 8005858:	2b00      	cmp	r3, #0
 800585a:	d02b      	beq.n	80058b4 <registerTime+0x12c>
        
        offtime = ticksToMS(airTime) * ( 1UL << (self->ctx.maxDutyCycle & 0xfU));
 800585c:	687b      	ldr	r3, [r7, #4]
 800585e:	0018      	movs	r0, r3
 8005860:	f000 ffc0 	bl	80067e4 <ticksToMS>
 8005864:	0001      	movs	r1, r0
 8005866:	68fa      	ldr	r2, [r7, #12]
 8005868:	23f8      	movs	r3, #248	; 0xf8
 800586a:	33ff      	adds	r3, #255	; 0xff
 800586c:	5cd3      	ldrb	r3, [r2, r3]
 800586e:	001a      	movs	r2, r3
 8005870:	230f      	movs	r3, #15
 8005872:	4013      	ands	r3, r2
 8005874:	4099      	lsls	r1, r3
 8005876:	000b      	movs	r3, r1
 8005878:	617b      	str	r3, [r7, #20]
        
        if((self->band[LDL_BAND_GLOBAL] + offtime) < self->band[LDL_BAND_GLOBAL]){
 800587a:	68fa      	ldr	r2, [r7, #12]
 800587c:	2394      	movs	r3, #148	; 0x94
 800587e:	005b      	lsls	r3, r3, #1
 8005880:	58d2      	ldr	r2, [r2, r3]
 8005882:	697b      	ldr	r3, [r7, #20]
 8005884:	18d2      	adds	r2, r2, r3
 8005886:	68f9      	ldr	r1, [r7, #12]
 8005888:	2394      	movs	r3, #148	; 0x94
 800588a:	005b      	lsls	r3, r3, #1
 800588c:	58cb      	ldr	r3, [r1, r3]
 800588e:	429a      	cmp	r2, r3
 8005890:	d206      	bcs.n	80058a0 <registerTime+0x118>
            
            self->band[LDL_BAND_GLOBAL] = UINT32_MAX;
 8005892:	68fa      	ldr	r2, [r7, #12]
 8005894:	2394      	movs	r3, #148	; 0x94
 8005896:	005b      	lsls	r3, r3, #1
 8005898:	2101      	movs	r1, #1
 800589a:	4249      	negs	r1, r1
 800589c:	50d1      	str	r1, [r2, r3]
        else{
            
            self->band[LDL_BAND_GLOBAL] += offtime; 
        }
    }
}    
 800589e:	e009      	b.n	80058b4 <registerTime+0x12c>
            self->band[LDL_BAND_GLOBAL] += offtime; 
 80058a0:	68fa      	ldr	r2, [r7, #12]
 80058a2:	2394      	movs	r3, #148	; 0x94
 80058a4:	005b      	lsls	r3, r3, #1
 80058a6:	58d2      	ldr	r2, [r2, r3]
 80058a8:	697b      	ldr	r3, [r7, #20]
 80058aa:	18d1      	adds	r1, r2, r3
 80058ac:	68fa      	ldr	r2, [r7, #12]
 80058ae:	2394      	movs	r3, #148	; 0x94
 80058b0:	005b      	lsls	r3, r3, #1
 80058b2:	50d1      	str	r1, [r2, r3]
}    
 80058b4:	46c0      	nop			; (mov r8, r8)
 80058b6:	46bd      	mov	sp, r7
 80058b8:	b006      	add	sp, #24
 80058ba:	bd80      	pop	{r7, pc}

080058bc <selectChannel>:

static bool selectChannel(const struct ldl_mac *self, uint8_t rate, uint8_t prevChIndex, uint32_t limit, uint8_t *chIndex, uint32_t *freq)
{
 80058bc:	b590      	push	{r4, r7, lr}
 80058be:	b08d      	sub	sp, #52	; 0x34
 80058c0:	af02      	add	r7, sp, #8
 80058c2:	60f8      	str	r0, [r7, #12]
 80058c4:	0008      	movs	r0, r1
 80058c6:	0011      	movs	r1, r2
 80058c8:	607b      	str	r3, [r7, #4]
 80058ca:	230b      	movs	r3, #11
 80058cc:	18fb      	adds	r3, r7, r3
 80058ce:	1c02      	adds	r2, r0, #0
 80058d0:	701a      	strb	r2, [r3, #0]
 80058d2:	230a      	movs	r3, #10
 80058d4:	18fb      	adds	r3, r7, r3
 80058d6:	1c0a      	adds	r2, r1, #0
 80058d8:	701a      	strb	r2, [r3, #0]
    bool retval = false;
 80058da:	2327      	movs	r3, #39	; 0x27
 80058dc:	18fb      	adds	r3, r7, r3
 80058de:	2200      	movs	r2, #0
 80058e0:	701a      	strb	r2, [r3, #0]
    uint8_t i;    
    uint8_t selection;    
    uint8_t available = 0U;
 80058e2:	2325      	movs	r3, #37	; 0x25
 80058e4:	18fb      	adds	r3, r7, r3
 80058e6:	2200      	movs	r2, #0
 80058e8:	701a      	strb	r2, [r3, #0]
    uint8_t j = 0U;
 80058ea:	2324      	movs	r3, #36	; 0x24
 80058ec:	18fb      	adds	r3, r7, r3
 80058ee:	2200      	movs	r2, #0
 80058f0:	701a      	strb	r2, [r3, #0]
    uint8_t minRate;
    uint8_t maxRate;    
    uint8_t except = UINT8_MAX;
 80058f2:	2323      	movs	r3, #35	; 0x23
 80058f4:	18fb      	adds	r3, r7, r3
 80058f6:	22ff      	movs	r2, #255	; 0xff
 80058f8:	701a      	strb	r2, [r3, #0]
    
    uint8_t mask[sizeof(self->ctx.chMask)];
    
    (void)memset(mask, 0, sizeof(mask));
 80058fa:	2314      	movs	r3, #20
 80058fc:	18fb      	adds	r3, r7, r3
 80058fe:	2209      	movs	r2, #9
 8005900:	2100      	movs	r1, #0
 8005902:	0018      	movs	r0, r3
 8005904:	f006 ffe9 	bl	800c8da <memset>
    
    /* count number of available channels for this rate */
    for(i=0U; i < LDL_Region_numChannels(self->region); i++){
 8005908:	2326      	movs	r3, #38	; 0x26
 800590a:	18fb      	adds	r3, r7, r3
 800590c:	2200      	movs	r2, #0
 800590e:	701a      	strb	r2, [r3, #0]
 8005910:	e032      	b.n	8005978 <selectChannel+0xbc>
        
        if(isAvailable(self, i, rate, limit)){
 8005912:	687c      	ldr	r4, [r7, #4]
 8005914:	230b      	movs	r3, #11
 8005916:	18fb      	adds	r3, r7, r3
 8005918:	781a      	ldrb	r2, [r3, #0]
 800591a:	2326      	movs	r3, #38	; 0x26
 800591c:	18fb      	adds	r3, r7, r3
 800591e:	7819      	ldrb	r1, [r3, #0]
 8005920:	68f8      	ldr	r0, [r7, #12]
 8005922:	0023      	movs	r3, r4
 8005924:	f000 f8c2 	bl	8005aac <isAvailable>
 8005928:	1e03      	subs	r3, r0, #0
 800592a:	d01f      	beq.n	800596c <selectChannel+0xb0>
        
            if(i == prevChIndex){
 800592c:	2326      	movs	r3, #38	; 0x26
 800592e:	18fa      	adds	r2, r7, r3
 8005930:	230a      	movs	r3, #10
 8005932:	18fb      	adds	r3, r7, r3
 8005934:	7812      	ldrb	r2, [r2, #0]
 8005936:	781b      	ldrb	r3, [r3, #0]
 8005938:	429a      	cmp	r2, r3
 800593a:	d105      	bne.n	8005948 <selectChannel+0x8c>
                
                except = i;
 800593c:	2323      	movs	r3, #35	; 0x23
 800593e:	18fb      	adds	r3, r7, r3
 8005940:	2226      	movs	r2, #38	; 0x26
 8005942:	18ba      	adds	r2, r7, r2
 8005944:	7812      	ldrb	r2, [r2, #0]
 8005946:	701a      	strb	r2, [r3, #0]
            }
        
            (void)maskChannel(mask, sizeof(mask), self->region, i);        
 8005948:	68fa      	ldr	r2, [r7, #12]
 800594a:	2391      	movs	r3, #145	; 0x91
 800594c:	009b      	lsls	r3, r3, #2
 800594e:	5cd2      	ldrb	r2, [r2, r3]
 8005950:	2326      	movs	r3, #38	; 0x26
 8005952:	18fb      	adds	r3, r7, r3
 8005954:	781b      	ldrb	r3, [r3, #0]
 8005956:	2114      	movs	r1, #20
 8005958:	1878      	adds	r0, r7, r1
 800595a:	2109      	movs	r1, #9
 800595c:	f000 fad0 	bl	8005f00 <maskChannel>
            available++;            
 8005960:	2125      	movs	r1, #37	; 0x25
 8005962:	187b      	adds	r3, r7, r1
 8005964:	781a      	ldrb	r2, [r3, #0]
 8005966:	187b      	adds	r3, r7, r1
 8005968:	3201      	adds	r2, #1
 800596a:	701a      	strb	r2, [r3, #0]
    for(i=0U; i < LDL_Region_numChannels(self->region); i++){
 800596c:	2126      	movs	r1, #38	; 0x26
 800596e:	187b      	adds	r3, r7, r1
 8005970:	781a      	ldrb	r2, [r3, #0]
 8005972:	187b      	adds	r3, r7, r1
 8005974:	3201      	adds	r2, #1
 8005976:	701a      	strb	r2, [r3, #0]
 8005978:	68fa      	ldr	r2, [r7, #12]
 800597a:	2391      	movs	r3, #145	; 0x91
 800597c:	009b      	lsls	r3, r3, #2
 800597e:	5cd3      	ldrb	r3, [r2, r3]
 8005980:	0018      	movs	r0, r3
 8005982:	f003 f910 	bl	8008ba6 <LDL_Region_numChannels>
 8005986:	0003      	movs	r3, r0
 8005988:	001a      	movs	r2, r3
 800598a:	2326      	movs	r3, #38	; 0x26
 800598c:	18fb      	adds	r3, r7, r3
 800598e:	781b      	ldrb	r3, [r3, #0]
 8005990:	4293      	cmp	r3, r2
 8005992:	d3be      	bcc.n	8005912 <selectChannel+0x56>
        }            
    }
        
    if(available > 0U){
 8005994:	2325      	movs	r3, #37	; 0x25
 8005996:	18fb      	adds	r3, r7, r3
 8005998:	781b      	ldrb	r3, [r3, #0]
 800599a:	2b00      	cmp	r3, #0
 800599c:	d100      	bne.n	80059a0 <selectChannel+0xe4>
 800599e:	e07e      	b.n	8005a9e <selectChannel+0x1e2>
    
        if(except != UINT8_MAX){
 80059a0:	2323      	movs	r3, #35	; 0x23
 80059a2:	18fb      	adds	r3, r7, r3
 80059a4:	781b      	ldrb	r3, [r3, #0]
 80059a6:	2bff      	cmp	r3, #255	; 0xff
 80059a8:	d00f      	beq.n	80059ca <selectChannel+0x10e>
    
            if(available == 1U){
 80059aa:	2325      	movs	r3, #37	; 0x25
 80059ac:	18fb      	adds	r3, r7, r3
 80059ae:	781b      	ldrb	r3, [r3, #0]
 80059b0:	2b01      	cmp	r3, #1
 80059b2:	d104      	bne.n	80059be <selectChannel+0x102>
                
                except = UINT8_MAX;
 80059b4:	2323      	movs	r3, #35	; 0x23
 80059b6:	18fb      	adds	r3, r7, r3
 80059b8:	22ff      	movs	r2, #255	; 0xff
 80059ba:	701a      	strb	r2, [r3, #0]
 80059bc:	e005      	b.n	80059ca <selectChannel+0x10e>
            }
            else{
                
                available--;
 80059be:	2125      	movs	r1, #37	; 0x25
 80059c0:	187b      	adds	r3, r7, r1
 80059c2:	781a      	ldrb	r2, [r3, #0]
 80059c4:	187b      	adds	r3, r7, r1
 80059c6:	3a01      	subs	r2, #1
 80059c8:	701a      	strb	r2, [r3, #0]
            }
        }
    
        selection = LDL_System_rand(self->app) % available;
 80059ca:	68fa      	ldr	r2, [r7, #12]
 80059cc:	2393      	movs	r3, #147	; 0x93
 80059ce:	009b      	lsls	r3, r3, #2
 80059d0:	58d3      	ldr	r3, [r2, r3]
 80059d2:	0018      	movs	r0, r3
 80059d4:	f003 ffb1 	bl	800993a <LDL_System_rand>
 80059d8:	0003      	movs	r3, r0
 80059da:	001a      	movs	r2, r3
 80059dc:	2322      	movs	r3, #34	; 0x22
 80059de:	18fc      	adds	r4, r7, r3
 80059e0:	2325      	movs	r3, #37	; 0x25
 80059e2:	18fb      	adds	r3, r7, r3
 80059e4:	781b      	ldrb	r3, [r3, #0]
 80059e6:	0019      	movs	r1, r3
 80059e8:	0010      	movs	r0, r2
 80059ea:	f7fa fc13 	bl	8000214 <__aeabi_uidivmod>
 80059ee:	000b      	movs	r3, r1
 80059f0:	7023      	strb	r3, [r4, #0]
        
        for(i=0U; i < LDL_Region_numChannels(self->region); i++){
 80059f2:	2326      	movs	r3, #38	; 0x26
 80059f4:	18fb      	adds	r3, r7, r3
 80059f6:	2200      	movs	r2, #0
 80059f8:	701a      	strb	r2, [r3, #0]
 80059fa:	e042      	b.n	8005a82 <selectChannel+0x1c6>
        
            if(channelIsMasked(mask, sizeof(mask), self->region, i)){
 80059fc:	68fa      	ldr	r2, [r7, #12]
 80059fe:	2391      	movs	r3, #145	; 0x91
 8005a00:	009b      	lsls	r3, r3, #2
 8005a02:	5cd2      	ldrb	r2, [r2, r3]
 8005a04:	2326      	movs	r3, #38	; 0x26
 8005a06:	18fb      	adds	r3, r7, r3
 8005a08:	781b      	ldrb	r3, [r3, #0]
 8005a0a:	2114      	movs	r1, #20
 8005a0c:	1878      	adds	r0, r7, r1
 8005a0e:	2109      	movs	r1, #9
 8005a10:	f000 fb16 	bl	8006040 <channelIsMasked>
 8005a14:	1e03      	subs	r3, r0, #0
 8005a16:	d02e      	beq.n	8005a76 <selectChannel+0x1ba>
        
                if(except != i){
 8005a18:	2323      	movs	r3, #35	; 0x23
 8005a1a:	18fa      	adds	r2, r7, r3
 8005a1c:	2326      	movs	r3, #38	; 0x26
 8005a1e:	18fb      	adds	r3, r7, r3
 8005a20:	7812      	ldrb	r2, [r2, #0]
 8005a22:	781b      	ldrb	r3, [r3, #0]
 8005a24:	429a      	cmp	r2, r3
 8005a26:	d026      	beq.n	8005a76 <selectChannel+0x1ba>
            
                    if(selection == j){
 8005a28:	2322      	movs	r3, #34	; 0x22
 8005a2a:	18fa      	adds	r2, r7, r3
 8005a2c:	2324      	movs	r3, #36	; 0x24
 8005a2e:	18fb      	adds	r3, r7, r3
 8005a30:	7812      	ldrb	r2, [r2, #0]
 8005a32:	781b      	ldrb	r3, [r3, #0]
 8005a34:	429a      	cmp	r2, r3
 8005a36:	d118      	bne.n	8005a6a <selectChannel+0x1ae>
                        
                        if(getChannel(self, i, freq, &minRate, &maxRate)){
 8005a38:	2321      	movs	r3, #33	; 0x21
 8005a3a:	18fc      	adds	r4, r7, r3
 8005a3c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8005a3e:	2326      	movs	r3, #38	; 0x26
 8005a40:	18fb      	adds	r3, r7, r3
 8005a42:	7819      	ldrb	r1, [r3, #0]
 8005a44:	68f8      	ldr	r0, [r7, #12]
 8005a46:	2320      	movs	r3, #32
 8005a48:	18fb      	adds	r3, r7, r3
 8005a4a:	9300      	str	r3, [sp, #0]
 8005a4c:	0023      	movs	r3, r4
 8005a4e:	f000 f9a5 	bl	8005d9c <getChannel>
 8005a52:	1e03      	subs	r3, r0, #0
 8005a54:	d009      	beq.n	8005a6a <selectChannel+0x1ae>
                            
                            *chIndex = i;
 8005a56:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8005a58:	2226      	movs	r2, #38	; 0x26
 8005a5a:	18ba      	adds	r2, r7, r2
 8005a5c:	7812      	ldrb	r2, [r2, #0]
 8005a5e:	701a      	strb	r2, [r3, #0]
                            retval = true;
 8005a60:	2327      	movs	r3, #39	; 0x27
 8005a62:	18fb      	adds	r3, r7, r3
 8005a64:	2201      	movs	r2, #1
 8005a66:	701a      	strb	r2, [r3, #0]
                            break;
 8005a68:	e019      	b.n	8005a9e <selectChannel+0x1e2>
                        }                        
                    }
            
                    j++;            
 8005a6a:	2124      	movs	r1, #36	; 0x24
 8005a6c:	187b      	adds	r3, r7, r1
 8005a6e:	781a      	ldrb	r2, [r3, #0]
 8005a70:	187b      	adds	r3, r7, r1
 8005a72:	3201      	adds	r2, #1
 8005a74:	701a      	strb	r2, [r3, #0]
        for(i=0U; i < LDL_Region_numChannels(self->region); i++){
 8005a76:	2126      	movs	r1, #38	; 0x26
 8005a78:	187b      	adds	r3, r7, r1
 8005a7a:	781a      	ldrb	r2, [r3, #0]
 8005a7c:	187b      	adds	r3, r7, r1
 8005a7e:	3201      	adds	r2, #1
 8005a80:	701a      	strb	r2, [r3, #0]
 8005a82:	68fa      	ldr	r2, [r7, #12]
 8005a84:	2391      	movs	r3, #145	; 0x91
 8005a86:	009b      	lsls	r3, r3, #2
 8005a88:	5cd3      	ldrb	r3, [r2, r3]
 8005a8a:	0018      	movs	r0, r3
 8005a8c:	f003 f88b 	bl	8008ba6 <LDL_Region_numChannels>
 8005a90:	0003      	movs	r3, r0
 8005a92:	001a      	movs	r2, r3
 8005a94:	2326      	movs	r3, #38	; 0x26
 8005a96:	18fb      	adds	r3, r7, r3
 8005a98:	781b      	ldrb	r3, [r3, #0]
 8005a9a:	4293      	cmp	r3, r2
 8005a9c:	d3ae      	bcc.n	80059fc <selectChannel+0x140>
                }
            }            
        }        
    }
    
    return retval;
 8005a9e:	2327      	movs	r3, #39	; 0x27
 8005aa0:	18fb      	adds	r3, r7, r3
 8005aa2:	781b      	ldrb	r3, [r3, #0]
}
 8005aa4:	0018      	movs	r0, r3
 8005aa6:	46bd      	mov	sp, r7
 8005aa8:	b00b      	add	sp, #44	; 0x2c
 8005aaa:	bd90      	pop	{r4, r7, pc}

08005aac <isAvailable>:

static bool isAvailable(const struct ldl_mac *self, uint8_t chIndex, uint8_t rate, uint32_t limit)
{
 8005aac:	b590      	push	{r4, r7, lr}
 8005aae:	b08b      	sub	sp, #44	; 0x2c
 8005ab0:	af02      	add	r7, sp, #8
 8005ab2:	60f8      	str	r0, [r7, #12]
 8005ab4:	0008      	movs	r0, r1
 8005ab6:	0011      	movs	r1, r2
 8005ab8:	607b      	str	r3, [r7, #4]
 8005aba:	240b      	movs	r4, #11
 8005abc:	193b      	adds	r3, r7, r4
 8005abe:	1c02      	adds	r2, r0, #0
 8005ac0:	701a      	strb	r2, [r3, #0]
 8005ac2:	230a      	movs	r3, #10
 8005ac4:	18fb      	adds	r3, r7, r3
 8005ac6:	1c0a      	adds	r2, r1, #0
 8005ac8:	701a      	strb	r2, [r3, #0]
    bool retval = false;
 8005aca:	231f      	movs	r3, #31
 8005acc:	18fb      	adds	r3, r7, r3
 8005ace:	2200      	movs	r2, #0
 8005ad0:	701a      	strb	r2, [r3, #0]
    uint32_t freq;
    uint8_t minRate;    
    uint8_t maxRate;    
    uint8_t band;
    
    if(!channelIsMasked(self->ctx.chMask, sizeof(self->ctx.chMask), self->region, chIndex)){
 8005ad2:	68fb      	ldr	r3, [r7, #12]
 8005ad4:	33ed      	adds	r3, #237	; 0xed
 8005ad6:	33ff      	adds	r3, #255	; 0xff
 8005ad8:	0018      	movs	r0, r3
 8005ada:	68fa      	ldr	r2, [r7, #12]
 8005adc:	2391      	movs	r3, #145	; 0x91
 8005ade:	009b      	lsls	r3, r3, #2
 8005ae0:	5cd2      	ldrb	r2, [r2, r3]
 8005ae2:	193b      	adds	r3, r7, r4
 8005ae4:	781b      	ldrb	r3, [r3, #0]
 8005ae6:	2109      	movs	r1, #9
 8005ae8:	f000 faaa 	bl	8006040 <channelIsMasked>
 8005aec:	0003      	movs	r3, r0
 8005aee:	001a      	movs	r2, r3
 8005af0:	2301      	movs	r3, #1
 8005af2:	4053      	eors	r3, r2
 8005af4:	b2db      	uxtb	r3, r3
 8005af6:	2b00      	cmp	r3, #0
 8005af8:	d03b      	beq.n	8005b72 <isAvailable+0xc6>
    
        if(getChannel(self, chIndex, &freq, &minRate, &maxRate)){
 8005afa:	2317      	movs	r3, #23
 8005afc:	18fc      	adds	r4, r7, r3
 8005afe:	2318      	movs	r3, #24
 8005b00:	18fa      	adds	r2, r7, r3
 8005b02:	230b      	movs	r3, #11
 8005b04:	18fb      	adds	r3, r7, r3
 8005b06:	7819      	ldrb	r1, [r3, #0]
 8005b08:	68f8      	ldr	r0, [r7, #12]
 8005b0a:	2316      	movs	r3, #22
 8005b0c:	18fb      	adds	r3, r7, r3
 8005b0e:	9300      	str	r3, [sp, #0]
 8005b10:	0023      	movs	r3, r4
 8005b12:	f000 f943 	bl	8005d9c <getChannel>
 8005b16:	1e03      	subs	r3, r0, #0
 8005b18:	d02b      	beq.n	8005b72 <isAvailable+0xc6>
            
            if((rate >= minRate) && (rate <= maxRate)){
 8005b1a:	2317      	movs	r3, #23
 8005b1c:	18fb      	adds	r3, r7, r3
 8005b1e:	781b      	ldrb	r3, [r3, #0]
 8005b20:	220a      	movs	r2, #10
 8005b22:	18ba      	adds	r2, r7, r2
 8005b24:	7812      	ldrb	r2, [r2, #0]
 8005b26:	429a      	cmp	r2, r3
 8005b28:	d323      	bcc.n	8005b72 <isAvailable+0xc6>
 8005b2a:	2316      	movs	r3, #22
 8005b2c:	18fb      	adds	r3, r7, r3
 8005b2e:	781b      	ldrb	r3, [r3, #0]
 8005b30:	220a      	movs	r2, #10
 8005b32:	18ba      	adds	r2, r7, r2
 8005b34:	7812      	ldrb	r2, [r2, #0]
 8005b36:	429a      	cmp	r2, r3
 8005b38:	d81b      	bhi.n	8005b72 <isAvailable+0xc6>
            
                if(LDL_Region_getBand(self->region, freq, &band)){
 8005b3a:	68fa      	ldr	r2, [r7, #12]
 8005b3c:	2391      	movs	r3, #145	; 0x91
 8005b3e:	009b      	lsls	r3, r3, #2
 8005b40:	5cd3      	ldrb	r3, [r2, r3]
 8005b42:	69b9      	ldr	r1, [r7, #24]
 8005b44:	2215      	movs	r2, #21
 8005b46:	18ba      	adds	r2, r7, r2
 8005b48:	0018      	movs	r0, r3
 8005b4a:	f002 ff89 	bl	8008a60 <LDL_Region_getBand>
 8005b4e:	1e03      	subs	r3, r0, #0
 8005b50:	d00f      	beq.n	8005b72 <isAvailable+0xc6>
                
                    LDL_PEDANTIC( band < LDL_BAND_MAX )
                
                    if(self->band[band] <= limit){
 8005b52:	2315      	movs	r3, #21
 8005b54:	18fb      	adds	r3, r7, r3
 8005b56:	781b      	ldrb	r3, [r3, #0]
 8005b58:	68fa      	ldr	r2, [r7, #12]
 8005b5a:	3344      	adds	r3, #68	; 0x44
 8005b5c:	009b      	lsls	r3, r3, #2
 8005b5e:	18d3      	adds	r3, r2, r3
 8005b60:	3304      	adds	r3, #4
 8005b62:	681b      	ldr	r3, [r3, #0]
 8005b64:	687a      	ldr	r2, [r7, #4]
 8005b66:	429a      	cmp	r2, r3
 8005b68:	d303      	bcc.n	8005b72 <isAvailable+0xc6>
                
                        retval = true;              
 8005b6a:	231f      	movs	r3, #31
 8005b6c:	18fb      	adds	r3, r7, r3
 8005b6e:	2201      	movs	r2, #1
 8005b70:	701a      	strb	r2, [r3, #0]
                }
            }
        }
    }
    
    return retval;
 8005b72:	231f      	movs	r3, #31
 8005b74:	18fb      	adds	r3, r7, r3
 8005b76:	781b      	ldrb	r3, [r3, #0]
}
 8005b78:	0018      	movs	r0, r3
 8005b7a:	46bd      	mov	sp, r7
 8005b7c:	b009      	add	sp, #36	; 0x24
 8005b7e:	bd90      	pop	{r4, r7, pc}

08005b80 <msUntilAvailable>:

static bool msUntilAvailable(const struct ldl_mac *self, uint8_t chIndex, uint8_t rate, uint32_t *ms)
{
 8005b80:	b590      	push	{r4, r7, lr}
 8005b82:	b08b      	sub	sp, #44	; 0x2c
 8005b84:	af02      	add	r7, sp, #8
 8005b86:	60f8      	str	r0, [r7, #12]
 8005b88:	0008      	movs	r0, r1
 8005b8a:	0011      	movs	r1, r2
 8005b8c:	607b      	str	r3, [r7, #4]
 8005b8e:	240b      	movs	r4, #11
 8005b90:	193b      	adds	r3, r7, r4
 8005b92:	1c02      	adds	r2, r0, #0
 8005b94:	701a      	strb	r2, [r3, #0]
 8005b96:	230a      	movs	r3, #10
 8005b98:	18fb      	adds	r3, r7, r3
 8005b9a:	1c0a      	adds	r2, r1, #0
 8005b9c:	701a      	strb	r2, [r3, #0]
    bool retval = false;
 8005b9e:	231f      	movs	r3, #31
 8005ba0:	18fb      	adds	r3, r7, r3
 8005ba2:	2200      	movs	r2, #0
 8005ba4:	701a      	strb	r2, [r3, #0]
    uint32_t freq;
    uint8_t minRate;    
    uint8_t maxRate;    
    uint8_t band;
    
    if(!channelIsMasked(self->ctx.chMask, sizeof(self->ctx.chMask), self->region, chIndex)){
 8005ba6:	68fb      	ldr	r3, [r7, #12]
 8005ba8:	33ed      	adds	r3, #237	; 0xed
 8005baa:	33ff      	adds	r3, #255	; 0xff
 8005bac:	0018      	movs	r0, r3
 8005bae:	68fa      	ldr	r2, [r7, #12]
 8005bb0:	2391      	movs	r3, #145	; 0x91
 8005bb2:	009b      	lsls	r3, r3, #2
 8005bb4:	5cd2      	ldrb	r2, [r2, r3]
 8005bb6:	193b      	adds	r3, r7, r4
 8005bb8:	781b      	ldrb	r3, [r3, #0]
 8005bba:	2109      	movs	r1, #9
 8005bbc:	f000 fa40 	bl	8006040 <channelIsMasked>
 8005bc0:	0003      	movs	r3, r0
 8005bc2:	001a      	movs	r2, r3
 8005bc4:	2301      	movs	r3, #1
 8005bc6:	4053      	eors	r3, r2
 8005bc8:	b2db      	uxtb	r3, r3
 8005bca:	2b00      	cmp	r3, #0
 8005bcc:	d042      	beq.n	8005c54 <msUntilAvailable+0xd4>
    
        if(getChannel(self, chIndex, &freq, &minRate, &maxRate)){
 8005bce:	2317      	movs	r3, #23
 8005bd0:	18fc      	adds	r4, r7, r3
 8005bd2:	2318      	movs	r3, #24
 8005bd4:	18fa      	adds	r2, r7, r3
 8005bd6:	230b      	movs	r3, #11
 8005bd8:	18fb      	adds	r3, r7, r3
 8005bda:	7819      	ldrb	r1, [r3, #0]
 8005bdc:	68f8      	ldr	r0, [r7, #12]
 8005bde:	2316      	movs	r3, #22
 8005be0:	18fb      	adds	r3, r7, r3
 8005be2:	9300      	str	r3, [sp, #0]
 8005be4:	0023      	movs	r3, r4
 8005be6:	f000 f8d9 	bl	8005d9c <getChannel>
 8005bea:	1e03      	subs	r3, r0, #0
 8005bec:	d032      	beq.n	8005c54 <msUntilAvailable+0xd4>
            
            if((rate >= minRate) && (rate <= maxRate)){
 8005bee:	2317      	movs	r3, #23
 8005bf0:	18fb      	adds	r3, r7, r3
 8005bf2:	781b      	ldrb	r3, [r3, #0]
 8005bf4:	220a      	movs	r2, #10
 8005bf6:	18ba      	adds	r2, r7, r2
 8005bf8:	7812      	ldrb	r2, [r2, #0]
 8005bfa:	429a      	cmp	r2, r3
 8005bfc:	d32a      	bcc.n	8005c54 <msUntilAvailable+0xd4>
 8005bfe:	2316      	movs	r3, #22
 8005c00:	18fb      	adds	r3, r7, r3
 8005c02:	781b      	ldrb	r3, [r3, #0]
 8005c04:	220a      	movs	r2, #10
 8005c06:	18ba      	adds	r2, r7, r2
 8005c08:	7812      	ldrb	r2, [r2, #0]
 8005c0a:	429a      	cmp	r2, r3
 8005c0c:	d822      	bhi.n	8005c54 <msUntilAvailable+0xd4>
            
                if(LDL_Region_getBand(self->region, freq, &band)){
 8005c0e:	68fa      	ldr	r2, [r7, #12]
 8005c10:	2391      	movs	r3, #145	; 0x91
 8005c12:	009b      	lsls	r3, r3, #2
 8005c14:	5cd3      	ldrb	r3, [r2, r3]
 8005c16:	69b9      	ldr	r1, [r7, #24]
 8005c18:	2215      	movs	r2, #21
 8005c1a:	18ba      	adds	r2, r7, r2
 8005c1c:	0018      	movs	r0, r3
 8005c1e:	f002 ff1f 	bl	8008a60 <LDL_Region_getBand>
 8005c22:	1e03      	subs	r3, r0, #0
 8005c24:	d016      	beq.n	8005c54 <msUntilAvailable+0xd4>
                
                    LDL_PEDANTIC( band < LDL_BAND_MAX )
                
                    *ms = (self->band[band] > self->band[LDL_BAND_GLOBAL]) ? self->band[band] : self->band[LDL_BAND_GLOBAL];
 8005c26:	68fa      	ldr	r2, [r7, #12]
 8005c28:	2394      	movs	r3, #148	; 0x94
 8005c2a:	005b      	lsls	r3, r3, #1
 8005c2c:	58d1      	ldr	r1, [r2, r3]
 8005c2e:	2315      	movs	r3, #21
 8005c30:	18fb      	adds	r3, r7, r3
 8005c32:	781b      	ldrb	r3, [r3, #0]
 8005c34:	68fa      	ldr	r2, [r7, #12]
 8005c36:	3344      	adds	r3, #68	; 0x44
 8005c38:	009b      	lsls	r3, r3, #2
 8005c3a:	18d3      	adds	r3, r2, r3
 8005c3c:	3304      	adds	r3, #4
 8005c3e:	681a      	ldr	r2, [r3, #0]
 8005c40:	000b      	movs	r3, r1
 8005c42:	4293      	cmp	r3, r2
 8005c44:	d200      	bcs.n	8005c48 <msUntilAvailable+0xc8>
 8005c46:	0013      	movs	r3, r2
 8005c48:	687a      	ldr	r2, [r7, #4]
 8005c4a:	6013      	str	r3, [r2, #0]
                    
                    retval = true;                
 8005c4c:	231f      	movs	r3, #31
 8005c4e:	18fb      	adds	r3, r7, r3
 8005c50:	2201      	movs	r2, #1
 8005c52:	701a      	strb	r2, [r3, #0]
                }
            }
        }
    }
    
    return retval;
 8005c54:	231f      	movs	r3, #31
 8005c56:	18fb      	adds	r3, r7, r3
 8005c58:	781b      	ldrb	r3, [r3, #0]
}
 8005c5a:	0018      	movs	r0, r3
 8005c5c:	46bd      	mov	sp, r7
 8005c5e:	b009      	add	sp, #36	; 0x24
 8005c60:	bd90      	pop	{r4, r7, pc}
	...

08005c64 <restoreDefaults>:

static void restoreDefaults(struct ldl_mac *self, bool keep)
{
 8005c64:	b580      	push	{r7, lr}
 8005c66:	b082      	sub	sp, #8
 8005c68:	af00      	add	r7, sp, #0
 8005c6a:	6078      	str	r0, [r7, #4]
 8005c6c:	000a      	movs	r2, r1
 8005c6e:	1cfb      	adds	r3, r7, #3
 8005c70:	701a      	strb	r2, [r3, #0]
    if(!keep){
 8005c72:	1cfb      	adds	r3, r7, #3
 8005c74:	781b      	ldrb	r3, [r3, #0]
 8005c76:	2201      	movs	r2, #1
 8005c78:	4053      	eors	r3, r2
 8005c7a:	b2db      	uxtb	r3, r3
 8005c7c:	2b00      	cmp	r3, #0
 8005c7e:	d011      	beq.n	8005ca4 <restoreDefaults+0x40>
        
        (void)memset(&self->ctx, 0, sizeof(self->ctx));
 8005c80:	687b      	ldr	r3, [r7, #4]
 8005c82:	335d      	adds	r3, #93	; 0x5d
 8005c84:	33ff      	adds	r3, #255	; 0xff
 8005c86:	22c0      	movs	r2, #192	; 0xc0
 8005c88:	2100      	movs	r1, #0
 8005c8a:	0018      	movs	r0, r3
 8005c8c:	f006 fe25 	bl	800c8da <memset>
        self->ctx.rate = LDL_DEFAULT_RATE;    
 8005c90:	687a      	ldr	r2, [r7, #4]
 8005c92:	23f6      	movs	r3, #246	; 0xf6
 8005c94:	33ff      	adds	r3, #255	; 0xff
 8005c96:	2101      	movs	r1, #1
 8005c98:	54d1      	strb	r1, [r2, r3]
        self->ctx.adr = true;        
 8005c9a:	687b      	ldr	r3, [r7, #4]
 8005c9c:	4a3c      	ldr	r2, [pc, #240]	; (8005d90 <restoreDefaults+0x12c>)
 8005c9e:	2101      	movs	r1, #1
 8005ca0:	5499      	strb	r1, [r3, r2]
 8005ca2:	e023      	b.n	8005cec <restoreDefaults+0x88>
    }
    else{
        
        self->ctx.up = 0U;
 8005ca4:	687a      	ldr	r2, [r7, #4]
 8005ca6:	23ae      	movs	r3, #174	; 0xae
 8005ca8:	005b      	lsls	r3, r3, #1
 8005caa:	2100      	movs	r1, #0
 8005cac:	50d1      	str	r1, [r2, r3]
        self->ctx.nwkDown = 0U;
 8005cae:	687a      	ldr	r2, [r7, #4]
 8005cb0:	23b1      	movs	r3, #177	; 0xb1
 8005cb2:	005b      	lsls	r3, r3, #1
 8005cb4:	2100      	movs	r1, #0
 8005cb6:	52d1      	strh	r1, [r2, r3]
        self->ctx.appDown = 0U;
 8005cb8:	687a      	ldr	r2, [r7, #4]
 8005cba:	23b0      	movs	r3, #176	; 0xb0
 8005cbc:	005b      	lsls	r3, r3, #1
 8005cbe:	2100      	movs	r1, #0
 8005cc0:	52d1      	strh	r1, [r2, r3]
        
        (void)memset(self->ctx.chConfig, 0, sizeof(self->ctx.chConfig));
 8005cc2:	687b      	ldr	r3, [r7, #4]
 8005cc4:	336d      	adds	r3, #109	; 0x6d
 8005cc6:	33ff      	adds	r3, #255	; 0xff
 8005cc8:	2280      	movs	r2, #128	; 0x80
 8005cca:	2100      	movs	r1, #0
 8005ccc:	0018      	movs	r0, r3
 8005cce:	f006 fe04 	bl	800c8da <memset>
        (void)memset(self->ctx.chMask, 0, sizeof(self->ctx.chMask));        
 8005cd2:	687b      	ldr	r3, [r7, #4]
 8005cd4:	33ed      	adds	r3, #237	; 0xed
 8005cd6:	33ff      	adds	r3, #255	; 0xff
 8005cd8:	2209      	movs	r2, #9
 8005cda:	2100      	movs	r1, #0
 8005cdc:	0018      	movs	r0, r3
 8005cde:	f006 fdfc 	bl	800c8da <memset>
        self->ctx.joined = false;        
 8005ce2:	687a      	ldr	r2, [r7, #4]
 8005ce4:	2381      	movs	r3, #129	; 0x81
 8005ce6:	009b      	lsls	r3, r3, #2
 8005ce8:	2100      	movs	r1, #0
 8005cea:	54d1      	strb	r1, [r2, r3]
    }
    
    LDL_Region_getDefaultChannels(self->region, self);    
 8005cec:	687a      	ldr	r2, [r7, #4]
 8005cee:	2391      	movs	r3, #145	; 0x91
 8005cf0:	009b      	lsls	r3, r3, #2
 8005cf2:	5cd3      	ldrb	r3, [r2, r3]
 8005cf4:	687a      	ldr	r2, [r7, #4]
 8005cf6:	0011      	movs	r1, r2
 8005cf8:	0018      	movs	r0, r3
 8005cfa:	f002 ff65 	bl	8008bc8 <LDL_Region_getDefaultChannels>
    
    self->ctx.rx1DROffset = LDL_Region_getRX1Offset(self->region);
 8005cfe:	687a      	ldr	r2, [r7, #4]
 8005d00:	2391      	movs	r3, #145	; 0x91
 8005d02:	009b      	lsls	r3, r3, #2
 8005d04:	5cd3      	ldrb	r3, [r2, r3]
 8005d06:	0018      	movs	r0, r3
 8005d08:	f003 f936 	bl	8008f78 <LDL_Region_getRX1Offset>
 8005d0c:	0003      	movs	r3, r0
 8005d0e:	0019      	movs	r1, r3
 8005d10:	687a      	ldr	r2, [r7, #4]
 8005d12:	23fa      	movs	r3, #250	; 0xfa
 8005d14:	33ff      	adds	r3, #255	; 0xff
 8005d16:	54d1      	strb	r1, [r2, r3]
    self->ctx.rx1Delay = LDL_Region_getRX1Delay(self->region);
 8005d18:	687a      	ldr	r2, [r7, #4]
 8005d1a:	2391      	movs	r3, #145	; 0x91
 8005d1c:	009b      	lsls	r3, r3, #2
 8005d1e:	5cd3      	ldrb	r3, [r2, r3]
 8005d20:	0018      	movs	r0, r3
 8005d22:	f003 f913 	bl	8008f4c <LDL_Region_getRX1Delay>
 8005d26:	0003      	movs	r3, r0
 8005d28:	0019      	movs	r1, r3
 8005d2a:	687a      	ldr	r2, [r7, #4]
 8005d2c:	23fd      	movs	r3, #253	; 0xfd
 8005d2e:	005b      	lsls	r3, r3, #1
 8005d30:	54d1      	strb	r1, [r2, r3]
    self->ctx.rx2DataRate = LDL_Region_getRX2Rate(self->region);
 8005d32:	687a      	ldr	r2, [r7, #4]
 8005d34:	2391      	movs	r3, #145	; 0x91
 8005d36:	009b      	lsls	r3, r3, #2
 8005d38:	5cd3      	ldrb	r3, [r2, r3]
 8005d3a:	0018      	movs	r0, r3
 8005d3c:	f003 f938 	bl	8008fb0 <LDL_Region_getRX2Rate>
 8005d40:	0003      	movs	r3, r0
 8005d42:	0019      	movs	r1, r3
 8005d44:	687a      	ldr	r2, [r7, #4]
 8005d46:	23fc      	movs	r3, #252	; 0xfc
 8005d48:	33ff      	adds	r3, #255	; 0xff
 8005d4a:	54d1      	strb	r1, [r2, r3]
    self->ctx.rx2Freq = LDL_Region_getRX2Freq(self->region);    
 8005d4c:	687a      	ldr	r2, [r7, #4]
 8005d4e:	2391      	movs	r3, #145	; 0x91
 8005d50:	009b      	lsls	r3, r3, #2
 8005d52:	5cd3      	ldrb	r3, [r2, r3]
 8005d54:	0018      	movs	r0, r3
 8005d56:	f003 f91b 	bl	8008f90 <LDL_Region_getRX2Freq>
 8005d5a:	0001      	movs	r1, r0
 8005d5c:	687a      	ldr	r2, [r7, #4]
 8005d5e:	2380      	movs	r3, #128	; 0x80
 8005d60:	009b      	lsls	r3, r3, #2
 8005d62:	50d1      	str	r1, [r2, r3]
    self->ctx.version = 0U;
 8005d64:	687b      	ldr	r3, [r7, #4]
 8005d66:	4a0b      	ldr	r2, [pc, #44]	; (8005d94 <restoreDefaults+0x130>)
 8005d68:	2100      	movs	r1, #0
 8005d6a:	5499      	strb	r1, [r3, r2]

    self->ctx.adr_ack_limit = ADRAckLimit;
 8005d6c:	687a      	ldr	r2, [r7, #4]
 8005d6e:	2382      	movs	r3, #130	; 0x82
 8005d70:	009b      	lsls	r3, r3, #2
 8005d72:	2140      	movs	r1, #64	; 0x40
 8005d74:	52d1      	strh	r1, [r2, r3]
    self->ctx.adr_ack_delay = ADRAckDelay;
 8005d76:	687b      	ldr	r3, [r7, #4]
 8005d78:	4a07      	ldr	r2, [pc, #28]	; (8005d98 <restoreDefaults+0x134>)
 8005d7a:	2120      	movs	r1, #32
 8005d7c:	5299      	strh	r1, [r3, r2]
    
    self->ctx.pending_cmds = 0U;
 8005d7e:	687a      	ldr	r2, [r7, #4]
 8005d80:	2383      	movs	r3, #131	; 0x83
 8005d82:	009b      	lsls	r3, r3, #2
 8005d84:	2100      	movs	r1, #0
 8005d86:	52d1      	strh	r1, [r2, r3]
}
 8005d88:	46c0      	nop			; (mov r8, r8)
 8005d8a:	46bd      	mov	sp, r7
 8005d8c:	b002      	add	sp, #8
 8005d8e:	bd80      	pop	{r7, pc}
 8005d90:	00000205 	.word	0x00000205
 8005d94:	00000206 	.word	0x00000206
 8005d98:	0000020a 	.word	0x0000020a

08005d9c <getChannel>:

static bool getChannel(const struct ldl_mac *self, uint8_t chIndex, uint32_t *freq, uint8_t *minRate, uint8_t *maxRate)
{
 8005d9c:	b5b0      	push	{r4, r5, r7, lr}
 8005d9e:	b088      	sub	sp, #32
 8005da0:	af02      	add	r7, sp, #8
 8005da2:	60f8      	str	r0, [r7, #12]
 8005da4:	607a      	str	r2, [r7, #4]
 8005da6:	603b      	str	r3, [r7, #0]
 8005da8:	230b      	movs	r3, #11
 8005daa:	18fb      	adds	r3, r7, r3
 8005dac:	1c0a      	adds	r2, r1, #0
 8005dae:	701a      	strb	r2, [r3, #0]
    bool retval;
    const struct ldl_mac_channel *chConfig;
    
    retval = false;
 8005db0:	2317      	movs	r3, #23
 8005db2:	18fb      	adds	r3, r7, r3
 8005db4:	2200      	movs	r2, #0
 8005db6:	701a      	strb	r2, [r3, #0]
    
    if(LDL_Region_isDynamic(self->region)){
 8005db8:	68fa      	ldr	r2, [r7, #12]
 8005dba:	2391      	movs	r3, #145	; 0x91
 8005dbc:	009b      	lsls	r3, r3, #2
 8005dbe:	5cd3      	ldrb	r3, [r2, r3]
 8005dc0:	0018      	movs	r0, r3
 8005dc2:	f002 fec7 	bl	8008b54 <LDL_Region_isDynamic>
 8005dc6:	1e03      	subs	r3, r0, #0
 8005dc8:	d038      	beq.n	8005e3c <getChannel+0xa0>
        
        if(chIndex < LDL_Region_numChannels(self->region)){
 8005dca:	68fa      	ldr	r2, [r7, #12]
 8005dcc:	2391      	movs	r3, #145	; 0x91
 8005dce:	009b      	lsls	r3, r3, #2
 8005dd0:	5cd3      	ldrb	r3, [r2, r3]
 8005dd2:	0018      	movs	r0, r3
 8005dd4:	f002 fee7 	bl	8008ba6 <LDL_Region_numChannels>
 8005dd8:	0003      	movs	r3, r0
 8005dda:	001a      	movs	r2, r3
 8005ddc:	230b      	movs	r3, #11
 8005dde:	18fb      	adds	r3, r7, r3
 8005de0:	781b      	ldrb	r3, [r3, #0]
 8005de2:	4293      	cmp	r3, r2
 8005de4:	d23c      	bcs.n	8005e60 <getChannel+0xc4>
            
            if(chIndex < sizeof(self->ctx.chConfig)/sizeof(*self->ctx.chConfig)){
 8005de6:	230b      	movs	r3, #11
 8005de8:	18fb      	adds	r3, r7, r3
 8005dea:	781b      	ldrb	r3, [r3, #0]
 8005dec:	2b0f      	cmp	r3, #15
 8005dee:	d837      	bhi.n	8005e60 <getChannel+0xc4>
            
                chConfig = &self->ctx.chConfig[chIndex];
 8005df0:	230b      	movs	r3, #11
 8005df2:	18fb      	adds	r3, r7, r3
 8005df4:	781b      	ldrb	r3, [r3, #0]
 8005df6:	332d      	adds	r3, #45	; 0x2d
 8005df8:	00db      	lsls	r3, r3, #3
 8005dfa:	68fa      	ldr	r2, [r7, #12]
 8005dfc:	18d3      	adds	r3, r2, r3
 8005dfe:	3304      	adds	r3, #4
 8005e00:	613b      	str	r3, [r7, #16]
                
                *freq = (chConfig->freqAndRate >> 8) * 100U;
 8005e02:	693b      	ldr	r3, [r7, #16]
 8005e04:	681b      	ldr	r3, [r3, #0]
 8005e06:	0a1b      	lsrs	r3, r3, #8
 8005e08:	2264      	movs	r2, #100	; 0x64
 8005e0a:	435a      	muls	r2, r3
 8005e0c:	687b      	ldr	r3, [r7, #4]
 8005e0e:	601a      	str	r2, [r3, #0]
                *minRate = (chConfig->freqAndRate >> 4) & 0xfU;
 8005e10:	693b      	ldr	r3, [r7, #16]
 8005e12:	681b      	ldr	r3, [r3, #0]
 8005e14:	091b      	lsrs	r3, r3, #4
 8005e16:	b2db      	uxtb	r3, r3
 8005e18:	220f      	movs	r2, #15
 8005e1a:	4013      	ands	r3, r2
 8005e1c:	b2da      	uxtb	r2, r3
 8005e1e:	683b      	ldr	r3, [r7, #0]
 8005e20:	701a      	strb	r2, [r3, #0]
                *maxRate = chConfig->freqAndRate & 0xfU;
 8005e22:	693b      	ldr	r3, [r7, #16]
 8005e24:	681b      	ldr	r3, [r3, #0]
 8005e26:	b2db      	uxtb	r3, r3
 8005e28:	220f      	movs	r2, #15
 8005e2a:	4013      	ands	r3, r2
 8005e2c:	b2da      	uxtb	r2, r3
 8005e2e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005e30:	701a      	strb	r2, [r3, #0]
                
                retval = true;
 8005e32:	2317      	movs	r3, #23
 8005e34:	18fb      	adds	r3, r7, r3
 8005e36:	2201      	movs	r2, #1
 8005e38:	701a      	strb	r2, [r3, #0]
 8005e3a:	e011      	b.n	8005e60 <getChannel+0xc4>
            }
        }        
    }
    else{
        
        retval = LDL_Region_getChannel(self->region, chIndex, freq, minRate, maxRate);                        
 8005e3c:	68fa      	ldr	r2, [r7, #12]
 8005e3e:	2391      	movs	r3, #145	; 0x91
 8005e40:	009b      	lsls	r3, r3, #2
 8005e42:	5cd0      	ldrb	r0, [r2, r3]
 8005e44:	2317      	movs	r3, #23
 8005e46:	18fc      	adds	r4, r7, r3
 8005e48:	683d      	ldr	r5, [r7, #0]
 8005e4a:	687a      	ldr	r2, [r7, #4]
 8005e4c:	230b      	movs	r3, #11
 8005e4e:	18fb      	adds	r3, r7, r3
 8005e50:	7819      	ldrb	r1, [r3, #0]
 8005e52:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005e54:	9300      	str	r3, [sp, #0]
 8005e56:	002b      	movs	r3, r5
 8005e58:	f002 fe8d 	bl	8008b76 <LDL_Region_getChannel>
 8005e5c:	0003      	movs	r3, r0
 8005e5e:	7023      	strb	r3, [r4, #0]
    }
     
    return retval;
 8005e60:	2317      	movs	r3, #23
 8005e62:	18fb      	adds	r3, r7, r3
 8005e64:	781b      	ldrb	r3, [r3, #0]
}
 8005e66:	0018      	movs	r0, r3
 8005e68:	46bd      	mov	sp, r7
 8005e6a:	b006      	add	sp, #24
 8005e6c:	bdb0      	pop	{r4, r5, r7, pc}

08005e6e <setChannel>:

static bool setChannel(struct ldl_mac *self, uint8_t chIndex, uint32_t freq, uint8_t minRate, uint8_t maxRate)
{
 8005e6e:	b590      	push	{r4, r7, lr}
 8005e70:	b087      	sub	sp, #28
 8005e72:	af00      	add	r7, sp, #0
 8005e74:	60f8      	str	r0, [r7, #12]
 8005e76:	0008      	movs	r0, r1
 8005e78:	607a      	str	r2, [r7, #4]
 8005e7a:	0019      	movs	r1, r3
 8005e7c:	240b      	movs	r4, #11
 8005e7e:	193b      	adds	r3, r7, r4
 8005e80:	1c02      	adds	r2, r0, #0
 8005e82:	701a      	strb	r2, [r3, #0]
 8005e84:	230a      	movs	r3, #10
 8005e86:	18fb      	adds	r3, r7, r3
 8005e88:	1c0a      	adds	r2, r1, #0
 8005e8a:	701a      	strb	r2, [r3, #0]
    bool retval;
    
    retval = false;
 8005e8c:	2317      	movs	r3, #23
 8005e8e:	18fb      	adds	r3, r7, r3
 8005e90:	2200      	movs	r2, #0
 8005e92:	701a      	strb	r2, [r3, #0]
    
    if(chIndex < LDL_Region_numChannels(self->region)){
 8005e94:	68fa      	ldr	r2, [r7, #12]
 8005e96:	2391      	movs	r3, #145	; 0x91
 8005e98:	009b      	lsls	r3, r3, #2
 8005e9a:	5cd3      	ldrb	r3, [r2, r3]
 8005e9c:	0018      	movs	r0, r3
 8005e9e:	f002 fe82 	bl	8008ba6 <LDL_Region_numChannels>
 8005ea2:	0003      	movs	r3, r0
 8005ea4:	001a      	movs	r2, r3
 8005ea6:	193b      	adds	r3, r7, r4
 8005ea8:	781b      	ldrb	r3, [r3, #0]
 8005eaa:	4293      	cmp	r3, r2
 8005eac:	d221      	bcs.n	8005ef2 <setChannel+0x84>
        
        if(chIndex < sizeof(self->ctx.chConfig)/sizeof(*self->ctx.chConfig)){
 8005eae:	230b      	movs	r3, #11
 8005eb0:	18fb      	adds	r3, r7, r3
 8005eb2:	781b      	ldrb	r3, [r3, #0]
 8005eb4:	2b0f      	cmp	r3, #15
 8005eb6:	d81c      	bhi.n	8005ef2 <setChannel+0x84>
        
            self->ctx.chConfig[chIndex].freqAndRate = ((freq/100U) << 8) | ((minRate << 4) & 0xfU) | (maxRate & 0xfU);
 8005eb8:	687b      	ldr	r3, [r7, #4]
 8005eba:	2164      	movs	r1, #100	; 0x64
 8005ebc:	0018      	movs	r0, r3
 8005ebe:	f7fa f923 	bl	8000108 <__udivsi3>
 8005ec2:	0003      	movs	r3, r0
 8005ec4:	0219      	lsls	r1, r3, #8
 8005ec6:	2320      	movs	r3, #32
 8005ec8:	2208      	movs	r2, #8
 8005eca:	4694      	mov	ip, r2
 8005ecc:	44bc      	add	ip, r7
 8005ece:	4463      	add	r3, ip
 8005ed0:	781b      	ldrb	r3, [r3, #0]
 8005ed2:	220f      	movs	r2, #15
 8005ed4:	401a      	ands	r2, r3
 8005ed6:	230b      	movs	r3, #11
 8005ed8:	18fb      	adds	r3, r7, r3
 8005eda:	781b      	ldrb	r3, [r3, #0]
 8005edc:	430a      	orrs	r2, r1
 8005ede:	68f9      	ldr	r1, [r7, #12]
 8005ee0:	332d      	adds	r3, #45	; 0x2d
 8005ee2:	00db      	lsls	r3, r3, #3
 8005ee4:	18cb      	adds	r3, r1, r3
 8005ee6:	3304      	adds	r3, #4
 8005ee8:	601a      	str	r2, [r3, #0]
            retval = true;
 8005eea:	2317      	movs	r3, #23
 8005eec:	18fb      	adds	r3, r7, r3
 8005eee:	2201      	movs	r2, #1
 8005ef0:	701a      	strb	r2, [r3, #0]
        }        
    }
    
    return retval;
 8005ef2:	2317      	movs	r3, #23
 8005ef4:	18fb      	adds	r3, r7, r3
 8005ef6:	781b      	ldrb	r3, [r3, #0]
}
 8005ef8:	0018      	movs	r0, r3
 8005efa:	46bd      	mov	sp, r7
 8005efc:	b007      	add	sp, #28
 8005efe:	bd90      	pop	{r4, r7, pc}

08005f00 <maskChannel>:

static bool maskChannel(uint8_t *mask, uint8_t max, enum ldl_region region, uint8_t chIndex)
{
 8005f00:	b590      	push	{r4, r7, lr}
 8005f02:	b085      	sub	sp, #20
 8005f04:	af00      	add	r7, sp, #0
 8005f06:	6078      	str	r0, [r7, #4]
 8005f08:	000c      	movs	r4, r1
 8005f0a:	0010      	movs	r0, r2
 8005f0c:	0019      	movs	r1, r3
 8005f0e:	1cfb      	adds	r3, r7, #3
 8005f10:	1c22      	adds	r2, r4, #0
 8005f12:	701a      	strb	r2, [r3, #0]
 8005f14:	1cbb      	adds	r3, r7, #2
 8005f16:	1c02      	adds	r2, r0, #0
 8005f18:	701a      	strb	r2, [r3, #0]
 8005f1a:	1c7b      	adds	r3, r7, #1
 8005f1c:	1c0a      	adds	r2, r1, #0
 8005f1e:	701a      	strb	r2, [r3, #0]
    bool retval = false;
 8005f20:	230f      	movs	r3, #15
 8005f22:	18fb      	adds	r3, r7, r3
 8005f24:	2200      	movs	r2, #0
 8005f26:	701a      	strb	r2, [r3, #0]
    
    if(chIndex < LDL_Region_numChannels(region)){
 8005f28:	1cbb      	adds	r3, r7, #2
 8005f2a:	781b      	ldrb	r3, [r3, #0]
 8005f2c:	0018      	movs	r0, r3
 8005f2e:	f002 fe3a 	bl	8008ba6 <LDL_Region_numChannels>
 8005f32:	0003      	movs	r3, r0
 8005f34:	001a      	movs	r2, r3
 8005f36:	1c7b      	adds	r3, r7, #1
 8005f38:	781b      	ldrb	r3, [r3, #0]
 8005f3a:	4293      	cmp	r3, r2
 8005f3c:	d21f      	bcs.n	8005f7e <maskChannel+0x7e>
        
        if(chIndex < (max*8U)){
 8005f3e:	1c7b      	adds	r3, r7, #1
 8005f40:	781a      	ldrb	r2, [r3, #0]
 8005f42:	1cfb      	adds	r3, r7, #3
 8005f44:	781b      	ldrb	r3, [r3, #0]
 8005f46:	00db      	lsls	r3, r3, #3
 8005f48:	429a      	cmp	r2, r3
 8005f4a:	d218      	bcs.n	8005f7e <maskChannel+0x7e>
    
            mask[chIndex / 8U] |= (1U << (chIndex % 8U));
 8005f4c:	1c7b      	adds	r3, r7, #1
 8005f4e:	781b      	ldrb	r3, [r3, #0]
 8005f50:	08db      	lsrs	r3, r3, #3
 8005f52:	b2d8      	uxtb	r0, r3
 8005f54:	0002      	movs	r2, r0
 8005f56:	687b      	ldr	r3, [r7, #4]
 8005f58:	189b      	adds	r3, r3, r2
 8005f5a:	7819      	ldrb	r1, [r3, #0]
 8005f5c:	1c7b      	adds	r3, r7, #1
 8005f5e:	781b      	ldrb	r3, [r3, #0]
 8005f60:	2207      	movs	r2, #7
 8005f62:	4013      	ands	r3, r2
 8005f64:	2201      	movs	r2, #1
 8005f66:	409a      	lsls	r2, r3
 8005f68:	0013      	movs	r3, r2
 8005f6a:	b2da      	uxtb	r2, r3
 8005f6c:	687b      	ldr	r3, [r7, #4]
 8005f6e:	181b      	adds	r3, r3, r0
 8005f70:	430a      	orrs	r2, r1
 8005f72:	b2d2      	uxtb	r2, r2
 8005f74:	701a      	strb	r2, [r3, #0]
            retval = true;
 8005f76:	230f      	movs	r3, #15
 8005f78:	18fb      	adds	r3, r7, r3
 8005f7a:	2201      	movs	r2, #1
 8005f7c:	701a      	strb	r2, [r3, #0]
        }
    }
    
    return retval;
 8005f7e:	230f      	movs	r3, #15
 8005f80:	18fb      	adds	r3, r7, r3
 8005f82:	781b      	ldrb	r3, [r3, #0]
}
 8005f84:	0018      	movs	r0, r3
 8005f86:	46bd      	mov	sp, r7
 8005f88:	b005      	add	sp, #20
 8005f8a:	bd90      	pop	{r4, r7, pc}

08005f8c <unmaskChannel>:

static bool unmaskChannel(uint8_t *mask, uint8_t max, enum ldl_region region, uint8_t chIndex)
{
 8005f8c:	b590      	push	{r4, r7, lr}
 8005f8e:	b085      	sub	sp, #20
 8005f90:	af00      	add	r7, sp, #0
 8005f92:	6078      	str	r0, [r7, #4]
 8005f94:	000c      	movs	r4, r1
 8005f96:	0010      	movs	r0, r2
 8005f98:	0019      	movs	r1, r3
 8005f9a:	1cfb      	adds	r3, r7, #3
 8005f9c:	1c22      	adds	r2, r4, #0
 8005f9e:	701a      	strb	r2, [r3, #0]
 8005fa0:	1cbb      	adds	r3, r7, #2
 8005fa2:	1c02      	adds	r2, r0, #0
 8005fa4:	701a      	strb	r2, [r3, #0]
 8005fa6:	1c7b      	adds	r3, r7, #1
 8005fa8:	1c0a      	adds	r2, r1, #0
 8005faa:	701a      	strb	r2, [r3, #0]
    bool retval = false;
 8005fac:	230f      	movs	r3, #15
 8005fae:	18fb      	adds	r3, r7, r3
 8005fb0:	2200      	movs	r2, #0
 8005fb2:	701a      	strb	r2, [r3, #0]
    
    if(chIndex < LDL_Region_numChannels(region)){
 8005fb4:	1cbb      	adds	r3, r7, #2
 8005fb6:	781b      	ldrb	r3, [r3, #0]
 8005fb8:	0018      	movs	r0, r3
 8005fba:	f002 fdf4 	bl	8008ba6 <LDL_Region_numChannels>
 8005fbe:	0003      	movs	r3, r0
 8005fc0:	001a      	movs	r2, r3
 8005fc2:	1c7b      	adds	r3, r7, #1
 8005fc4:	781b      	ldrb	r3, [r3, #0]
 8005fc6:	4293      	cmp	r3, r2
 8005fc8:	d221      	bcs.n	800600e <unmaskChannel+0x82>
    
        if(chIndex < (max*8U)){
 8005fca:	1c7b      	adds	r3, r7, #1
 8005fcc:	781a      	ldrb	r2, [r3, #0]
 8005fce:	1cfb      	adds	r3, r7, #3
 8005fd0:	781b      	ldrb	r3, [r3, #0]
 8005fd2:	00db      	lsls	r3, r3, #3
 8005fd4:	429a      	cmp	r2, r3
 8005fd6:	d21a      	bcs.n	800600e <unmaskChannel+0x82>
    
            mask[chIndex / 8U] &= ~(1U << (chIndex % 8U));
 8005fd8:	1c7b      	adds	r3, r7, #1
 8005fda:	781b      	ldrb	r3, [r3, #0]
 8005fdc:	08db      	lsrs	r3, r3, #3
 8005fde:	b2d8      	uxtb	r0, r3
 8005fe0:	0002      	movs	r2, r0
 8005fe2:	687b      	ldr	r3, [r7, #4]
 8005fe4:	189b      	adds	r3, r3, r2
 8005fe6:	781a      	ldrb	r2, [r3, #0]
 8005fe8:	1c7b      	adds	r3, r7, #1
 8005fea:	781b      	ldrb	r3, [r3, #0]
 8005fec:	2107      	movs	r1, #7
 8005fee:	400b      	ands	r3, r1
 8005ff0:	2101      	movs	r1, #1
 8005ff2:	4099      	lsls	r1, r3
 8005ff4:	000b      	movs	r3, r1
 8005ff6:	b2db      	uxtb	r3, r3
 8005ff8:	43db      	mvns	r3, r3
 8005ffa:	b2d9      	uxtb	r1, r3
 8005ffc:	687b      	ldr	r3, [r7, #4]
 8005ffe:	181b      	adds	r3, r3, r0
 8006000:	400a      	ands	r2, r1
 8006002:	b2d2      	uxtb	r2, r2
 8006004:	701a      	strb	r2, [r3, #0]
            retval = true;
 8006006:	230f      	movs	r3, #15
 8006008:	18fb      	adds	r3, r7, r3
 800600a:	2201      	movs	r2, #1
 800600c:	701a      	strb	r2, [r3, #0]
        }
    }
    
    return retval;
 800600e:	230f      	movs	r3, #15
 8006010:	18fb      	adds	r3, r7, r3
 8006012:	781b      	ldrb	r3, [r3, #0]
}
 8006014:	0018      	movs	r0, r3
 8006016:	46bd      	mov	sp, r7
 8006018:	b005      	add	sp, #20
 800601a:	bd90      	pop	{r4, r7, pc}

0800601c <unmaskAllChannels>:

static void unmaskAllChannels(uint8_t *mask, uint8_t max)
{
 800601c:	b580      	push	{r7, lr}
 800601e:	b082      	sub	sp, #8
 8006020:	af00      	add	r7, sp, #0
 8006022:	6078      	str	r0, [r7, #4]
 8006024:	000a      	movs	r2, r1
 8006026:	1cfb      	adds	r3, r7, #3
 8006028:	701a      	strb	r2, [r3, #0]
    (void)memset(mask, 0, max);    
 800602a:	1cfb      	adds	r3, r7, #3
 800602c:	781a      	ldrb	r2, [r3, #0]
 800602e:	687b      	ldr	r3, [r7, #4]
 8006030:	2100      	movs	r1, #0
 8006032:	0018      	movs	r0, r3
 8006034:	f006 fc51 	bl	800c8da <memset>
}
 8006038:	46c0      	nop			; (mov r8, r8)
 800603a:	46bd      	mov	sp, r7
 800603c:	b002      	add	sp, #8
 800603e:	bd80      	pop	{r7, pc}

08006040 <channelIsMasked>:

static bool channelIsMasked(const uint8_t *mask, uint8_t max, enum ldl_region region, uint8_t chIndex)
{
 8006040:	b590      	push	{r4, r7, lr}
 8006042:	b085      	sub	sp, #20
 8006044:	af00      	add	r7, sp, #0
 8006046:	6078      	str	r0, [r7, #4]
 8006048:	000c      	movs	r4, r1
 800604a:	0010      	movs	r0, r2
 800604c:	0019      	movs	r1, r3
 800604e:	1cfb      	adds	r3, r7, #3
 8006050:	1c22      	adds	r2, r4, #0
 8006052:	701a      	strb	r2, [r3, #0]
 8006054:	1cbb      	adds	r3, r7, #2
 8006056:	1c02      	adds	r2, r0, #0
 8006058:	701a      	strb	r2, [r3, #0]
 800605a:	1c7b      	adds	r3, r7, #1
 800605c:	1c0a      	adds	r2, r1, #0
 800605e:	701a      	strb	r2, [r3, #0]
    bool retval = false;
 8006060:	230f      	movs	r3, #15
 8006062:	18fb      	adds	r3, r7, r3
 8006064:	2200      	movs	r2, #0
 8006066:	701a      	strb	r2, [r3, #0]
    
    if(chIndex < LDL_Region_numChannels(region)){
 8006068:	1cbb      	adds	r3, r7, #2
 800606a:	781b      	ldrb	r3, [r3, #0]
 800606c:	0018      	movs	r0, r3
 800606e:	f002 fd9a 	bl	8008ba6 <LDL_Region_numChannels>
 8006072:	0003      	movs	r3, r0
 8006074:	001a      	movs	r2, r3
 8006076:	1c7b      	adds	r3, r7, #1
 8006078:	781b      	ldrb	r3, [r3, #0]
 800607a:	4293      	cmp	r3, r2
 800607c:	d21c      	bcs.n	80060b8 <channelIsMasked+0x78>
        
        if(chIndex < (max*8U)){
 800607e:	1c7b      	adds	r3, r7, #1
 8006080:	781a      	ldrb	r2, [r3, #0]
 8006082:	1cfb      	adds	r3, r7, #3
 8006084:	781b      	ldrb	r3, [r3, #0]
 8006086:	00db      	lsls	r3, r3, #3
 8006088:	429a      	cmp	r2, r3
 800608a:	d215      	bcs.n	80060b8 <channelIsMasked+0x78>
        
            retval = ((mask[chIndex / 8U] & (1U << (chIndex % 8U))) > 0U);        
 800608c:	1c7b      	adds	r3, r7, #1
 800608e:	781b      	ldrb	r3, [r3, #0]
 8006090:	08db      	lsrs	r3, r3, #3
 8006092:	b2db      	uxtb	r3, r3
 8006094:	001a      	movs	r2, r3
 8006096:	687b      	ldr	r3, [r7, #4]
 8006098:	189b      	adds	r3, r3, r2
 800609a:	781b      	ldrb	r3, [r3, #0]
 800609c:	0019      	movs	r1, r3
 800609e:	1c7b      	adds	r3, r7, #1
 80060a0:	781b      	ldrb	r3, [r3, #0]
 80060a2:	2207      	movs	r2, #7
 80060a4:	4013      	ands	r3, r2
 80060a6:	40d9      	lsrs	r1, r3
 80060a8:	000b      	movs	r3, r1
 80060aa:	2201      	movs	r2, #1
 80060ac:	401a      	ands	r2, r3
 80060ae:	230f      	movs	r3, #15
 80060b0:	18fb      	adds	r3, r7, r3
 80060b2:	1e51      	subs	r1, r2, #1
 80060b4:	418a      	sbcs	r2, r1
 80060b6:	701a      	strb	r2, [r3, #0]
        }
    }
    
    return retval;    
 80060b8:	230f      	movs	r3, #15
 80060ba:	18fb      	adds	r3, r7, r3
 80060bc:	781b      	ldrb	r3, [r3, #0]
}
 80060be:	0018      	movs	r0, r3
 80060c0:	46bd      	mov	sp, r7
 80060c2:	b005      	add	sp, #20
 80060c4:	bd90      	pop	{r4, r7, pc}

080060c6 <allChannelsAreMasked>:

static bool allChannelsAreMasked(const uint8_t *mask, uint8_t max)
{
 80060c6:	b580      	push	{r7, lr}
 80060c8:	b084      	sub	sp, #16
 80060ca:	af00      	add	r7, sp, #0
 80060cc:	6078      	str	r0, [r7, #4]
 80060ce:	000a      	movs	r2, r1
 80060d0:	1cfb      	adds	r3, r7, #3
 80060d2:	701a      	strb	r2, [r3, #0]
    bool retval = true;
 80060d4:	230f      	movs	r3, #15
 80060d6:	18fb      	adds	r3, r7, r3
 80060d8:	2201      	movs	r2, #1
 80060da:	701a      	strb	r2, [r3, #0]
    uint8_t i;
    
    for(i=0; i < max; i++){
 80060dc:	230e      	movs	r3, #14
 80060de:	18fb      	adds	r3, r7, r3
 80060e0:	2200      	movs	r2, #0
 80060e2:	701a      	strb	r2, [r3, #0]
 80060e4:	e012      	b.n	800610c <allChannelsAreMasked+0x46>
        
        if(mask[i] != 0xffU){
 80060e6:	230e      	movs	r3, #14
 80060e8:	18fb      	adds	r3, r7, r3
 80060ea:	781b      	ldrb	r3, [r3, #0]
 80060ec:	687a      	ldr	r2, [r7, #4]
 80060ee:	18d3      	adds	r3, r2, r3
 80060f0:	781b      	ldrb	r3, [r3, #0]
 80060f2:	2bff      	cmp	r3, #255	; 0xff
 80060f4:	d004      	beq.n	8006100 <allChannelsAreMasked+0x3a>
            
            retval = false;
 80060f6:	230f      	movs	r3, #15
 80060f8:	18fb      	adds	r3, r7, r3
 80060fa:	2200      	movs	r2, #0
 80060fc:	701a      	strb	r2, [r3, #0]
            break;
 80060fe:	e00c      	b.n	800611a <allChannelsAreMasked+0x54>
    for(i=0; i < max; i++){
 8006100:	210e      	movs	r1, #14
 8006102:	187b      	adds	r3, r7, r1
 8006104:	781a      	ldrb	r2, [r3, #0]
 8006106:	187b      	adds	r3, r7, r1
 8006108:	3201      	adds	r2, #1
 800610a:	701a      	strb	r2, [r3, #0]
 800610c:	230e      	movs	r3, #14
 800610e:	18fa      	adds	r2, r7, r3
 8006110:	1cfb      	adds	r3, r7, #3
 8006112:	7812      	ldrb	r2, [r2, #0]
 8006114:	781b      	ldrb	r3, [r3, #0]
 8006116:	429a      	cmp	r2, r3
 8006118:	d3e5      	bcc.n	80060e6 <allChannelsAreMasked+0x20>
        }
    }
    
    return retval;
 800611a:	230f      	movs	r3, #15
 800611c:	18fb      	adds	r3, r7, r3
 800611e:	781b      	ldrb	r3, [r3, #0]
}
 8006120:	0018      	movs	r0, r3
 8006122:	46bd      	mov	sp, r7
 8006124:	b004      	add	sp, #16
 8006126:	bd80      	pop	{r7, pc}

08006128 <rateSettingIsValid>:

static bool rateSettingIsValid(enum ldl_region region, uint8_t rate)
{
 8006128:	b590      	push	{r4, r7, lr}
 800612a:	b085      	sub	sp, #20
 800612c:	af00      	add	r7, sp, #0
 800612e:	0002      	movs	r2, r0
 8006130:	1dfb      	adds	r3, r7, #7
 8006132:	701a      	strb	r2, [r3, #0]
 8006134:	1dbb      	adds	r3, r7, #6
 8006136:	1c0a      	adds	r2, r1, #0
 8006138:	701a      	strb	r2, [r3, #0]
    bool retval = false;
 800613a:	230f      	movs	r3, #15
 800613c:	18fb      	adds	r3, r7, r3
 800613e:	2200      	movs	r2, #0
 8006140:	701a      	strb	r2, [r3, #0]
    uint8_t i;
    
    for(i=0U; i < LDL_Region_numChannels(region); i++){
 8006142:	230e      	movs	r3, #14
 8006144:	18fb      	adds	r3, r7, r3
 8006146:	2200      	movs	r2, #0
 8006148:	701a      	strb	r2, [r3, #0]
 800614a:	e018      	b.n	800617e <rateSettingIsValid+0x56>
        
        if(LDL_Region_validateRate(region, i, rate, rate)){
 800614c:	1dbb      	adds	r3, r7, #6
 800614e:	781c      	ldrb	r4, [r3, #0]
 8006150:	1dbb      	adds	r3, r7, #6
 8006152:	781a      	ldrb	r2, [r3, #0]
 8006154:	230e      	movs	r3, #14
 8006156:	18fb      	adds	r3, r7, r3
 8006158:	7819      	ldrb	r1, [r3, #0]
 800615a:	1dfb      	adds	r3, r7, #7
 800615c:	7818      	ldrb	r0, [r3, #0]
 800615e:	0023      	movs	r3, r4
 8006160:	f002 fe38 	bl	8008dd4 <LDL_Region_validateRate>
 8006164:	1e03      	subs	r3, r0, #0
 8006166:	d004      	beq.n	8006172 <rateSettingIsValid+0x4a>
            
            retval = true;
 8006168:	230f      	movs	r3, #15
 800616a:	18fb      	adds	r3, r7, r3
 800616c:	2201      	movs	r2, #1
 800616e:	701a      	strb	r2, [r3, #0]
            break;
 8006170:	e011      	b.n	8006196 <rateSettingIsValid+0x6e>
    for(i=0U; i < LDL_Region_numChannels(region); i++){
 8006172:	210e      	movs	r1, #14
 8006174:	187b      	adds	r3, r7, r1
 8006176:	781a      	ldrb	r2, [r3, #0]
 8006178:	187b      	adds	r3, r7, r1
 800617a:	3201      	adds	r2, #1
 800617c:	701a      	strb	r2, [r3, #0]
 800617e:	1dfb      	adds	r3, r7, #7
 8006180:	781b      	ldrb	r3, [r3, #0]
 8006182:	0018      	movs	r0, r3
 8006184:	f002 fd0f 	bl	8008ba6 <LDL_Region_numChannels>
 8006188:	0003      	movs	r3, r0
 800618a:	001a      	movs	r2, r3
 800618c:	230e      	movs	r3, #14
 800618e:	18fb      	adds	r3, r7, r3
 8006190:	781b      	ldrb	r3, [r3, #0]
 8006192:	4293      	cmp	r3, r2
 8006194:	d3da      	bcc.n	800614c <rateSettingIsValid+0x24>
        }
    }
    
    return retval;
 8006196:	230f      	movs	r3, #15
 8006198:	18fb      	adds	r3, r7, r3
 800619a:	781b      	ldrb	r3, [r3, #0]
}
 800619c:	0018      	movs	r0, r3
 800619e:	46bd      	mov	sp, r7
 80061a0:	b005      	add	sp, #20
 80061a2:	bd90      	pop	{r4, r7, pc}

080061a4 <timeNow>:

static uint32_t timeNow(struct ldl_mac *self)
{
 80061a4:	b580      	push	{r7, lr}
 80061a6:	b086      	sub	sp, #24
 80061a8:	af00      	add	r7, sp, #0
 80061aa:	6078      	str	r0, [r7, #4]
    uint32_t seconds;
    uint32_t ticks;
    uint32_t since;
    uint32_t part;
    
    ticks = LDL_System_ticks(self->app);
 80061ac:	687a      	ldr	r2, [r7, #4]
 80061ae:	2393      	movs	r3, #147	; 0x93
 80061b0:	009b      	lsls	r3, r3, #2
 80061b2:	58d3      	ldr	r3, [r2, r3]
 80061b4:	0018      	movs	r0, r3
 80061b6:	f003 fe8b 	bl	8009ed0 <LDL_System_ticks>
 80061ba:	0003      	movs	r3, r0
 80061bc:	617b      	str	r3, [r7, #20]
    since = timerDelta(self->polled_time_ticks, ticks);
 80061be:	687a      	ldr	r2, [r7, #4]
 80061c0:	2397      	movs	r3, #151	; 0x97
 80061c2:	009b      	lsls	r3, r3, #2
 80061c4:	58d3      	ldr	r3, [r2, r3]
 80061c6:	697a      	ldr	r2, [r7, #20]
 80061c8:	0011      	movs	r1, r2
 80061ca:	0018      	movs	r0, r3
 80061cc:	f000 f858 	bl	8006280 <timerDelta>
 80061d0:	0003      	movs	r3, r0
 80061d2:	613b      	str	r3, [r7, #16]
    
    seconds = since / LDL_System_tps();
 80061d4:	f003 fe87 	bl	8009ee6 <LDL_System_tps>
 80061d8:	0003      	movs	r3, r0
 80061da:	0019      	movs	r1, r3
 80061dc:	6938      	ldr	r0, [r7, #16]
 80061de:	f7f9 ff93 	bl	8000108 <__udivsi3>
 80061e2:	0003      	movs	r3, r0
 80061e4:	60fb      	str	r3, [r7, #12]
    
    if(seconds > 0U){
 80061e6:	68fb      	ldr	r3, [r7, #12]
 80061e8:	2b00      	cmp	r3, #0
 80061ea:	d01a      	beq.n	8006222 <timeNow+0x7e>
    
        part = since % LDL_System_tps();        
 80061ec:	f003 fe7b 	bl	8009ee6 <LDL_System_tps>
 80061f0:	0002      	movs	r2, r0
 80061f2:	693b      	ldr	r3, [r7, #16]
 80061f4:	0011      	movs	r1, r2
 80061f6:	0018      	movs	r0, r3
 80061f8:	f7fa f80c 	bl	8000214 <__aeabi_uidivmod>
 80061fc:	000b      	movs	r3, r1
 80061fe:	60bb      	str	r3, [r7, #8]
        self->polled_time_ticks = (ticks - part);    
 8006200:	697a      	ldr	r2, [r7, #20]
 8006202:	68bb      	ldr	r3, [r7, #8]
 8006204:	1ad1      	subs	r1, r2, r3
 8006206:	687a      	ldr	r2, [r7, #4]
 8006208:	2397      	movs	r3, #151	; 0x97
 800620a:	009b      	lsls	r3, r3, #2
 800620c:	50d1      	str	r1, [r2, r3]
        self->time += seconds;
 800620e:	687a      	ldr	r2, [r7, #4]
 8006210:	2396      	movs	r3, #150	; 0x96
 8006212:	009b      	lsls	r3, r3, #2
 8006214:	58d2      	ldr	r2, [r2, r3]
 8006216:	68fb      	ldr	r3, [r7, #12]
 8006218:	18d1      	adds	r1, r2, r3
 800621a:	687a      	ldr	r2, [r7, #4]
 800621c:	2396      	movs	r3, #150	; 0x96
 800621e:	009b      	lsls	r3, r3, #2
 8006220:	50d1      	str	r1, [r2, r3]
    }
    
    return self->time;        
 8006222:	687a      	ldr	r2, [r7, #4]
 8006224:	2396      	movs	r3, #150	; 0x96
 8006226:	009b      	lsls	r3, r3, #2
 8006228:	58d3      	ldr	r3, [r2, r3]
}
 800622a:	0018      	movs	r0, r3
 800622c:	46bd      	mov	sp, r7
 800622e:	b006      	add	sp, #24
 8006230:	bd80      	pop	{r7, pc}
	...

08006234 <getRetryDuty>:

static uint32_t getRetryDuty(uint32_t seconds_since)
{
 8006234:	b580      	push	{r7, lr}
 8006236:	b084      	sub	sp, #16
 8006238:	af00      	add	r7, sp, #0
 800623a:	6078      	str	r0, [r7, #4]
    /* reset after one day */
    uint32_t delta = seconds_since % (60UL*60UL*24UL);
 800623c:	687b      	ldr	r3, [r7, #4]
 800623e:	490c      	ldr	r1, [pc, #48]	; (8006270 <getRetryDuty+0x3c>)
 8006240:	0018      	movs	r0, r3
 8006242:	f7f9 ffe7 	bl	8000214 <__aeabi_uidivmod>
 8006246:	000b      	movs	r3, r1
 8006248:	60fb      	str	r3, [r7, #12]
    
    /* 36/3600 (0.01) */
    if(delta < (60UL*60UL)){
 800624a:	68fb      	ldr	r3, [r7, #12]
 800624c:	4a09      	ldr	r2, [pc, #36]	; (8006274 <getRetryDuty+0x40>)
 800624e:	4293      	cmp	r3, r2
 8006250:	d801      	bhi.n	8006256 <getRetryDuty+0x22>
        
        return 100UL;
 8006252:	2364      	movs	r3, #100	; 0x64
 8006254:	e007      	b.n	8006266 <getRetryDuty+0x32>
    }
    /* 36/36000 (0.001) */
    else if(delta < (11UL*60UL*60UL)){
 8006256:	68fb      	ldr	r3, [r7, #12]
 8006258:	4a07      	ldr	r2, [pc, #28]	; (8006278 <getRetryDuty+0x44>)
 800625a:	4293      	cmp	r3, r2
 800625c:	d802      	bhi.n	8006264 <getRetryDuty+0x30>
     
        return 1000UL;
 800625e:	23fa      	movs	r3, #250	; 0xfa
 8006260:	009b      	lsls	r3, r3, #2
 8006262:	e000      	b.n	8006266 <getRetryDuty+0x32>
    }
    /* 8.7/86400 (0.0001) */
    else{
        
        return 10000UL;    
 8006264:	4b05      	ldr	r3, [pc, #20]	; (800627c <getRetryDuty+0x48>)
    }
}
 8006266:	0018      	movs	r0, r3
 8006268:	46bd      	mov	sp, r7
 800626a:	b004      	add	sp, #16
 800626c:	bd80      	pop	{r7, pc}
 800626e:	46c0      	nop			; (mov r8, r8)
 8006270:	00015180 	.word	0x00015180
 8006274:	00000e0f 	.word	0x00000e0f
 8006278:	00009aaf 	.word	0x00009aaf
 800627c:	00002710 	.word	0x00002710

08006280 <timerDelta>:

static uint32_t timerDelta(uint32_t timeout, uint32_t time)
{
 8006280:	b580      	push	{r7, lr}
 8006282:	b082      	sub	sp, #8
 8006284:	af00      	add	r7, sp, #0
 8006286:	6078      	str	r0, [r7, #4]
 8006288:	6039      	str	r1, [r7, #0]
    return (timeout <= time) ? (time - timeout) : (UINT32_MAX - timeout + time);
 800628a:	687a      	ldr	r2, [r7, #4]
 800628c:	683b      	ldr	r3, [r7, #0]
 800628e:	429a      	cmp	r2, r3
 8006290:	d803      	bhi.n	800629a <timerDelta+0x1a>
 8006292:	683a      	ldr	r2, [r7, #0]
 8006294:	687b      	ldr	r3, [r7, #4]
 8006296:	1ad3      	subs	r3, r2, r3
 8006298:	e003      	b.n	80062a2 <timerDelta+0x22>
 800629a:	683a      	ldr	r2, [r7, #0]
 800629c:	687b      	ldr	r3, [r7, #4]
 800629e:	1ad3      	subs	r3, r2, r3
 80062a0:	3b01      	subs	r3, #1
}
 80062a2:	0018      	movs	r0, r3
 80062a4:	46bd      	mov	sp, r7
 80062a6:	b002      	add	sp, #8
 80062a8:	bd80      	pop	{r7, pc}

080062aa <processBands>:

static void processBands(struct ldl_mac *self)
{
 80062aa:	b580      	push	{r7, lr}
 80062ac:	b086      	sub	sp, #24
 80062ae:	af00      	add	r7, sp, #0
 80062b0:	6078      	str	r0, [r7, #4]
    uint32_t since;
    uint32_t ticks;
    uint32_t diff;
    size_t i;
    
    ticks = LDL_System_ticks(self->app);
 80062b2:	687a      	ldr	r2, [r7, #4]
 80062b4:	2393      	movs	r3, #147	; 0x93
 80062b6:	009b      	lsls	r3, r3, #2
 80062b8:	58d3      	ldr	r3, [r2, r3]
 80062ba:	0018      	movs	r0, r3
 80062bc:	f003 fe08 	bl	8009ed0 <LDL_System_ticks>
 80062c0:	0003      	movs	r3, r0
 80062c2:	613b      	str	r3, [r7, #16]
    diff = timerDelta(self->polled_band_ticks, ticks);    
 80062c4:	687a      	ldr	r2, [r7, #4]
 80062c6:	2398      	movs	r3, #152	; 0x98
 80062c8:	005b      	lsls	r3, r3, #1
 80062ca:	58d3      	ldr	r3, [r2, r3]
 80062cc:	693a      	ldr	r2, [r7, #16]
 80062ce:	0011      	movs	r1, r2
 80062d0:	0018      	movs	r0, r3
 80062d2:	f7ff ffd5 	bl	8006280 <timerDelta>
 80062d6:	0003      	movs	r3, r0
 80062d8:	60fb      	str	r3, [r7, #12]
    since = diff / LDL_System_tps() * 1000UL;
 80062da:	f003 fe04 	bl	8009ee6 <LDL_System_tps>
 80062de:	0003      	movs	r3, r0
 80062e0:	0019      	movs	r1, r3
 80062e2:	68f8      	ldr	r0, [r7, #12]
 80062e4:	f7f9 ff10 	bl	8000108 <__udivsi3>
 80062e8:	0003      	movs	r3, r0
 80062ea:	001a      	movs	r2, r3
 80062ec:	0013      	movs	r3, r2
 80062ee:	015b      	lsls	r3, r3, #5
 80062f0:	1a9b      	subs	r3, r3, r2
 80062f2:	009b      	lsls	r3, r3, #2
 80062f4:	189b      	adds	r3, r3, r2
 80062f6:	00db      	lsls	r3, r3, #3
 80062f8:	60bb      	str	r3, [r7, #8]
    
    if(since > 0U){
 80062fa:	68bb      	ldr	r3, [r7, #8]
 80062fc:	2b00      	cmp	r3, #0
 80062fe:	d049      	beq.n	8006394 <processBands+0xea>
    
        self->polled_band_ticks += LDL_System_tps() / 1000U * since;
 8006300:	f003 fdf1 	bl	8009ee6 <LDL_System_tps>
 8006304:	0002      	movs	r2, r0
 8006306:	23fa      	movs	r3, #250	; 0xfa
 8006308:	0099      	lsls	r1, r3, #2
 800630a:	0010      	movs	r0, r2
 800630c:	f7f9 fefc 	bl	8000108 <__udivsi3>
 8006310:	0003      	movs	r3, r0
 8006312:	001a      	movs	r2, r3
 8006314:	68bb      	ldr	r3, [r7, #8]
 8006316:	435a      	muls	r2, r3
 8006318:	6879      	ldr	r1, [r7, #4]
 800631a:	2398      	movs	r3, #152	; 0x98
 800631c:	005b      	lsls	r3, r3, #1
 800631e:	58cb      	ldr	r3, [r1, r3]
 8006320:	18d1      	adds	r1, r2, r3
 8006322:	687a      	ldr	r2, [r7, #4]
 8006324:	2398      	movs	r3, #152	; 0x98
 8006326:	005b      	lsls	r3, r3, #1
 8006328:	50d1      	str	r1, [r2, r3]
        
        for(i=0U; i < (sizeof(self->band)/sizeof(*self->band)); i++){
 800632a:	2300      	movs	r3, #0
 800632c:	617b      	str	r3, [r7, #20]
 800632e:	e02e      	b.n	800638e <processBands+0xe4>

            if(self->band[i] > 0U){
 8006330:	687a      	ldr	r2, [r7, #4]
 8006332:	697b      	ldr	r3, [r7, #20]
 8006334:	3344      	adds	r3, #68	; 0x44
 8006336:	009b      	lsls	r3, r3, #2
 8006338:	18d3      	adds	r3, r2, r3
 800633a:	3304      	adds	r3, #4
 800633c:	681b      	ldr	r3, [r3, #0]
 800633e:	2b00      	cmp	r3, #0
 8006340:	d022      	beq.n	8006388 <processBands+0xde>
            
                if(self->band[i] < since){
 8006342:	687a      	ldr	r2, [r7, #4]
 8006344:	697b      	ldr	r3, [r7, #20]
 8006346:	3344      	adds	r3, #68	; 0x44
 8006348:	009b      	lsls	r3, r3, #2
 800634a:	18d3      	adds	r3, r2, r3
 800634c:	3304      	adds	r3, #4
 800634e:	681b      	ldr	r3, [r3, #0]
 8006350:	68ba      	ldr	r2, [r7, #8]
 8006352:	429a      	cmp	r2, r3
 8006354:	d908      	bls.n	8006368 <processBands+0xbe>
                   
                  self->band[i] = 0U;  
 8006356:	687a      	ldr	r2, [r7, #4]
 8006358:	697b      	ldr	r3, [r7, #20]
 800635a:	3344      	adds	r3, #68	; 0x44
 800635c:	009b      	lsls	r3, r3, #2
 800635e:	18d3      	adds	r3, r2, r3
 8006360:	3304      	adds	r3, #4
 8006362:	2200      	movs	r2, #0
 8006364:	601a      	str	r2, [r3, #0]
 8006366:	e00f      	b.n	8006388 <processBands+0xde>
                }
                else{
                   
                   self->band[i] -= since;
 8006368:	687a      	ldr	r2, [r7, #4]
 800636a:	697b      	ldr	r3, [r7, #20]
 800636c:	3344      	adds	r3, #68	; 0x44
 800636e:	009b      	lsls	r3, r3, #2
 8006370:	18d3      	adds	r3, r2, r3
 8006372:	3304      	adds	r3, #4
 8006374:	681a      	ldr	r2, [r3, #0]
 8006376:	68bb      	ldr	r3, [r7, #8]
 8006378:	1ad2      	subs	r2, r2, r3
 800637a:	6879      	ldr	r1, [r7, #4]
 800637c:	697b      	ldr	r3, [r7, #20]
 800637e:	3344      	adds	r3, #68	; 0x44
 8006380:	009b      	lsls	r3, r3, #2
 8006382:	18cb      	adds	r3, r1, r3
 8006384:	3304      	adds	r3, #4
 8006386:	601a      	str	r2, [r3, #0]
        for(i=0U; i < (sizeof(self->band)/sizeof(*self->band)); i++){
 8006388:	697b      	ldr	r3, [r7, #20]
 800638a:	3301      	adds	r3, #1
 800638c:	617b      	str	r3, [r7, #20]
 800638e:	697b      	ldr	r3, [r7, #20]
 8006390:	2b06      	cmp	r3, #6
 8006392:	d9cd      	bls.n	8006330 <processBands+0x86>
                }                                    
            }            
        }        
    }
}
 8006394:	46c0      	nop			; (mov r8, r8)
 8006396:	46bd      	mov	sp, r7
 8006398:	b006      	add	sp, #24
 800639a:	bd80      	pop	{r7, pc}

0800639c <nextBandEvent>:

static uint32_t nextBandEvent(const struct ldl_mac *self)
{
 800639c:	b580      	push	{r7, lr}
 800639e:	b084      	sub	sp, #16
 80063a0:	af00      	add	r7, sp, #0
 80063a2:	6078      	str	r0, [r7, #4]
    uint32_t retval = UINT32_MAX;
 80063a4:	2301      	movs	r3, #1
 80063a6:	425b      	negs	r3, r3
 80063a8:	60fb      	str	r3, [r7, #12]
    size_t i;
    
    for(i=0U; i < (sizeof(self->band)/sizeof(*self->band)); i++){
 80063aa:	2300      	movs	r3, #0
 80063ac:	60bb      	str	r3, [r7, #8]
 80063ae:	e01d      	b.n	80063ec <nextBandEvent+0x50>
        
        if(self->band[i] > 0U){
 80063b0:	687a      	ldr	r2, [r7, #4]
 80063b2:	68bb      	ldr	r3, [r7, #8]
 80063b4:	3344      	adds	r3, #68	; 0x44
 80063b6:	009b      	lsls	r3, r3, #2
 80063b8:	18d3      	adds	r3, r2, r3
 80063ba:	3304      	adds	r3, #4
 80063bc:	681b      	ldr	r3, [r3, #0]
 80063be:	2b00      	cmp	r3, #0
 80063c0:	d011      	beq.n	80063e6 <nextBandEvent+0x4a>
        
            if(self->band[i] < retval){
 80063c2:	687a      	ldr	r2, [r7, #4]
 80063c4:	68bb      	ldr	r3, [r7, #8]
 80063c6:	3344      	adds	r3, #68	; 0x44
 80063c8:	009b      	lsls	r3, r3, #2
 80063ca:	18d3      	adds	r3, r2, r3
 80063cc:	3304      	adds	r3, #4
 80063ce:	681b      	ldr	r3, [r3, #0]
 80063d0:	68fa      	ldr	r2, [r7, #12]
 80063d2:	429a      	cmp	r2, r3
 80063d4:	d907      	bls.n	80063e6 <nextBandEvent+0x4a>
                
                retval = self->band[i];
 80063d6:	687a      	ldr	r2, [r7, #4]
 80063d8:	68bb      	ldr	r3, [r7, #8]
 80063da:	3344      	adds	r3, #68	; 0x44
 80063dc:	009b      	lsls	r3, r3, #2
 80063de:	18d3      	adds	r3, r2, r3
 80063e0:	3304      	adds	r3, #4
 80063e2:	681b      	ldr	r3, [r3, #0]
 80063e4:	60fb      	str	r3, [r7, #12]
    for(i=0U; i < (sizeof(self->band)/sizeof(*self->band)); i++){
 80063e6:	68bb      	ldr	r3, [r7, #8]
 80063e8:	3301      	adds	r3, #1
 80063ea:	60bb      	str	r3, [r7, #8]
 80063ec:	68bb      	ldr	r3, [r7, #8]
 80063ee:	2b06      	cmp	r3, #6
 80063f0:	d9de      	bls.n	80063b0 <nextBandEvent+0x14>
            }        
        }
    }
    
    return retval;
 80063f2:	68fb      	ldr	r3, [r7, #12]
}
 80063f4:	0018      	movs	r0, r3
 80063f6:	46bd      	mov	sp, r7
 80063f8:	b004      	add	sp, #16
 80063fa:	bd80      	pop	{r7, pc}

080063fc <downlinkMissingHandler>:

static void downlinkMissingHandler(struct ldl_mac *self)
{
 80063fc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80063fe:	b08f      	sub	sp, #60	; 0x3c
 8006400:	af02      	add	r7, sp, #8
 8006402:	6078      	str	r0, [r7, #4]
    uint32_t delta;
    uint32_t tx_time;
    uint8_t mtu;
    uint32_t ms_until_next;
    
    (void)memset(&arg, 0, sizeof(arg));
 8006404:	2310      	movs	r3, #16
 8006406:	18fb      	adds	r3, r7, r3
 8006408:	2210      	movs	r2, #16
 800640a:	2100      	movs	r1, #0
 800640c:	0018      	movs	r0, r3
 800640e:	f006 fa64 	bl	800c8da <memset>
    
    if(self->opts.nbTrans > 0U){
 8006412:	687a      	ldr	r2, [r7, #4]
 8006414:	239a      	movs	r3, #154	; 0x9a
 8006416:	009b      	lsls	r3, r3, #2
 8006418:	5cd3      	ldrb	r3, [r2, r3]
 800641a:	2b00      	cmp	r3, #0
 800641c:	d007      	beq.n	800642e <downlinkMissingHandler+0x32>
        
        nbTrans = self->opts.nbTrans;
 800641e:	232f      	movs	r3, #47	; 0x2f
 8006420:	18fb      	adds	r3, r7, r3
 8006422:	6879      	ldr	r1, [r7, #4]
 8006424:	229a      	movs	r2, #154	; 0x9a
 8006426:	0092      	lsls	r2, r2, #2
 8006428:	5c8a      	ldrb	r2, [r1, r2]
 800642a:	701a      	strb	r2, [r3, #0]
 800642c:	e00e      	b.n	800644c <downlinkMissingHandler+0x50>
    }
    else{
        
        nbTrans = (self->ctx.nbTrans > 0) ? self->ctx.nbTrans : 1U;
 800642e:	687a      	ldr	r2, [r7, #4]
 8006430:	23fc      	movs	r3, #252	; 0xfc
 8006432:	005b      	lsls	r3, r3, #1
 8006434:	5cd3      	ldrb	r3, [r2, r3]
 8006436:	2b00      	cmp	r3, #0
 8006438:	d004      	beq.n	8006444 <downlinkMissingHandler+0x48>
 800643a:	687a      	ldr	r2, [r7, #4]
 800643c:	23fc      	movs	r3, #252	; 0xfc
 800643e:	005b      	lsls	r3, r3, #1
 8006440:	5cd2      	ldrb	r2, [r2, r3]
 8006442:	e000      	b.n	8006446 <downlinkMissingHandler+0x4a>
 8006444:	2201      	movs	r2, #1
 8006446:	232f      	movs	r3, #47	; 0x2f
 8006448:	18fb      	adds	r3, r7, r3
 800644a:	701a      	strb	r2, [r3, #0]
    }
    
    self->trials++;
 800644c:	687a      	ldr	r2, [r7, #4]
 800644e:	2399      	movs	r3, #153	; 0x99
 8006450:	009b      	lsls	r3, r3, #2
 8006452:	58d3      	ldr	r3, [r2, r3]
 8006454:	1c59      	adds	r1, r3, #1
 8006456:	687a      	ldr	r2, [r7, #4]
 8006458:	2399      	movs	r3, #153	; 0x99
 800645a:	009b      	lsls	r3, r3, #2
 800645c:	50d1      	str	r1, [r2, r3]
    
    delta = (timeNow(self) - self->service_start_time);
 800645e:	687b      	ldr	r3, [r7, #4]
 8006460:	0018      	movs	r0, r3
 8006462:	f7ff fe9f 	bl	80061a4 <timeNow>
 8006466:	0001      	movs	r1, r0
 8006468:	687a      	ldr	r2, [r7, #4]
 800646a:	2398      	movs	r3, #152	; 0x98
 800646c:	009b      	lsls	r3, r3, #2
 800646e:	58d3      	ldr	r3, [r2, r3]
 8006470:	1acb      	subs	r3, r1, r3
 8006472:	62bb      	str	r3, [r7, #40]	; 0x28
    
    LDL_Region_convertRate(self->region, self->tx.rate, &sf, &bw, &mtu);
 8006474:	687a      	ldr	r2, [r7, #4]
 8006476:	2391      	movs	r3, #145	; 0x91
 8006478:	009b      	lsls	r3, r3, #2
 800647a:	5cd0      	ldrb	r0, [r2, r3]
 800647c:	687a      	ldr	r2, [r7, #4]
 800647e:	234e      	movs	r3, #78	; 0x4e
 8006480:	33ff      	adds	r3, #255	; 0xff
 8006482:	5cd1      	ldrb	r1, [r2, r3]
 8006484:	250e      	movs	r5, #14
 8006486:	197c      	adds	r4, r7, r5
 8006488:	260f      	movs	r6, #15
 800648a:	19ba      	adds	r2, r7, r6
 800648c:	230d      	movs	r3, #13
 800648e:	18fb      	adds	r3, r7, r3
 8006490:	9300      	str	r3, [sp, #0]
 8006492:	0023      	movs	r3, r4
 8006494:	f002 fa5e 	bl	8008954 <LDL_Region_convertRate>
    
    tx_time = ticksToMS(transmitTime(bw, sf, self->bufferLen, true));
 8006498:	197b      	adds	r3, r7, r5
 800649a:	7818      	ldrb	r0, [r3, #0]
 800649c:	19bb      	adds	r3, r7, r6
 800649e:	7819      	ldrb	r1, [r3, #0]
 80064a0:	687a      	ldr	r2, [r7, #4]
 80064a2:	2389      	movs	r3, #137	; 0x89
 80064a4:	005b      	lsls	r3, r3, #1
 80064a6:	5cd2      	ldrb	r2, [r2, r3]
 80064a8:	2301      	movs	r3, #1
 80064aa:	f7fe fb31 	bl	8004b10 <transmitTime>
 80064ae:	0003      	movs	r3, r0
 80064b0:	0018      	movs	r0, r3
 80064b2:	f000 f997 	bl	80067e4 <ticksToMS>
 80064b6:	0003      	movs	r3, r0
 80064b8:	627b      	str	r3, [r7, #36]	; 0x24
        
    switch(self->op){
 80064ba:	687b      	ldr	r3, [r7, #4]
 80064bc:	785b      	ldrb	r3, [r3, #1]
 80064be:	2b03      	cmp	r3, #3
 80064c0:	d100      	bne.n	80064c4 <downlinkMissingHandler+0xc8>
 80064c2:	e080      	b.n	80065c6 <downlinkMissingHandler+0x1ca>
 80064c4:	2b04      	cmp	r3, #4
 80064c6:	d003      	beq.n	80064d0 <downlinkMissingHandler+0xd4>
 80064c8:	2b01      	cmp	r3, #1
 80064ca:	d100      	bne.n	80064ce <downlinkMissingHandler+0xd2>
 80064cc:	e110      	b.n	80066f0 <downlinkMissingHandler+0x2f4>
    default:
    case LDL_OP_NONE:
        break;
 80064ce:	e17b      	b.n	80067c8 <downlinkMissingHandler+0x3cc>
    case LDL_OP_DATA_CONFIRMED:

        if(self->trials < nbTrans){
 80064d0:	687a      	ldr	r2, [r7, #4]
 80064d2:	2399      	movs	r3, #153	; 0x99
 80064d4:	009b      	lsls	r3, r3, #2
 80064d6:	58d2      	ldr	r2, [r2, r3]
 80064d8:	232f      	movs	r3, #47	; 0x2f
 80064da:	18fb      	adds	r3, r7, r3
 80064dc:	781b      	ldrb	r3, [r3, #0]
 80064de:	429a      	cmp	r2, r3
 80064e0:	d24b      	bcs.n	800657a <downlinkMissingHandler+0x17e>

            self->band[LDL_BAND_RETRY] = tx_time * getRetryDuty(delta);
 80064e2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80064e4:	0018      	movs	r0, r3
 80064e6:	f7ff fea5 	bl	8006234 <getRetryDuty>
 80064ea:	0002      	movs	r2, r0
 80064ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80064ee:	4353      	muls	r3, r2
 80064f0:	0019      	movs	r1, r3
 80064f2:	687a      	ldr	r2, [r7, #4]
 80064f4:	2396      	movs	r3, #150	; 0x96
 80064f6:	005b      	lsls	r3, r3, #1
 80064f8:	50d1      	str	r1, [r2, r3]
            
            ms_until_next = msUntilNextChannel(self, self->tx.rate);        
 80064fa:	687a      	ldr	r2, [r7, #4]
 80064fc:	234e      	movs	r3, #78	; 0x4e
 80064fe:	33ff      	adds	r3, #255	; 0xff
 8006500:	5cd2      	ldrb	r2, [r2, r3]
 8006502:	687b      	ldr	r3, [r7, #4]
 8006504:	0011      	movs	r1, r2
 8006506:	0018      	movs	r0, r3
 8006508:	f000 f99b 	bl	8006842 <msUntilNextChannel>
 800650c:	0003      	movs	r3, r0
 800650e:	623b      	str	r3, [r7, #32]
            ms_until_next = (ms_until_next > self->band[LDL_BAND_RETRY]) ? ms_until_next : self->band[LDL_BAND_RETRY];
 8006510:	687a      	ldr	r2, [r7, #4]
 8006512:	2396      	movs	r3, #150	; 0x96
 8006514:	005b      	lsls	r3, r3, #1
 8006516:	58d2      	ldr	r2, [r2, r3]
 8006518:	6a3b      	ldr	r3, [r7, #32]
 800651a:	4293      	cmp	r3, r2
 800651c:	d200      	bcs.n	8006520 <downlinkMissingHandler+0x124>
 800651e:	0013      	movs	r3, r2
 8006520:	623b      	str	r3, [r7, #32]
            
            if(selectChannel(self, self->tx.rate, self->tx.chIndex, ms_until_next, &self->tx.chIndex, &self->tx.freq)){
 8006522:	687a      	ldr	r2, [r7, #4]
 8006524:	234e      	movs	r3, #78	; 0x4e
 8006526:	33ff      	adds	r3, #255	; 0xff
 8006528:	5cd1      	ldrb	r1, [r2, r3]
 800652a:	687a      	ldr	r2, [r7, #4]
 800652c:	23a6      	movs	r3, #166	; 0xa6
 800652e:	005b      	lsls	r3, r3, #1
 8006530:	5cd4      	ldrb	r4, [r2, r3]
 8006532:	687b      	ldr	r3, [r7, #4]
 8006534:	334d      	adds	r3, #77	; 0x4d
 8006536:	33ff      	adds	r3, #255	; 0xff
 8006538:	687a      	ldr	r2, [r7, #4]
 800653a:	3245      	adds	r2, #69	; 0x45
 800653c:	32ff      	adds	r2, #255	; 0xff
 800653e:	6a3d      	ldr	r5, [r7, #32]
 8006540:	6878      	ldr	r0, [r7, #4]
 8006542:	9201      	str	r2, [sp, #4]
 8006544:	9300      	str	r3, [sp, #0]
 8006546:	002b      	movs	r3, r5
 8006548:	0022      	movs	r2, r4
 800654a:	f7ff f9b7 	bl	80058bc <selectChannel>
 800654e:	1e03      	subs	r3, r0, #0
 8006550:	d00f      	beq.n	8006572 <downlinkMissingHandler+0x176>
                
                /* MIC must be refreshed when channel changes */
                if(self->ctx.version > 0){
 8006552:	687b      	ldr	r3, [r7, #4]
 8006554:	4a9e      	ldr	r2, [pc, #632]	; (80067d0 <downlinkMissingHandler+0x3d4>)
 8006556:	5c9b      	ldrb	r3, [r3, r2]
 8006558:	2b00      	cmp	r3, #0
 800655a:	d00a      	beq.n	8006572 <downlinkMissingHandler+0x176>
                    
                    LDL_OPS_micDataFrame(self, self->buffer, self->bufferLen);
 800655c:	687b      	ldr	r3, [r7, #4]
 800655e:	3313      	adds	r3, #19
 8006560:	0019      	movs	r1, r3
 8006562:	687a      	ldr	r2, [r7, #4]
 8006564:	2389      	movs	r3, #137	; 0x89
 8006566:	005b      	lsls	r3, r3, #1
 8006568:	5cd2      	ldrb	r2, [r2, r3]
 800656a:	687b      	ldr	r3, [r7, #4]
 800656c:	0018      	movs	r0, r3
 800656e:	f000 ff6d 	bl	800744c <LDL_OPS_micDataFrame>
                }
            }
            
            self->state = LDL_STATE_WAIT_RETRY;            
 8006572:	687b      	ldr	r3, [r7, #4]
 8006574:	220e      	movs	r2, #14
 8006576:	701a      	strb	r2, [r3, #0]
            self->handler(self->app, LDL_MAC_DATA_TIMEOUT, NULL);
#endif                  
            self->state = LDL_STATE_IDLE;
            self->op = LDL_OP_NONE;
        }
        break;
 8006578:	e126      	b.n	80067c8 <downlinkMissingHandler+0x3cc>
            adaptRate(self);
 800657a:	687b      	ldr	r3, [r7, #4]
 800657c:	0018      	movs	r0, r3
 800657e:	f7fe f9f5 	bl	800496c <adaptRate>
            self->tx.rate = self->ctx.rate;
 8006582:	687a      	ldr	r2, [r7, #4]
 8006584:	23f6      	movs	r3, #246	; 0xf6
 8006586:	33ff      	adds	r3, #255	; 0xff
 8006588:	5cd1      	ldrb	r1, [r2, r3]
 800658a:	687a      	ldr	r2, [r7, #4]
 800658c:	234e      	movs	r3, #78	; 0x4e
 800658e:	33ff      	adds	r3, #255	; 0xff
 8006590:	54d1      	strb	r1, [r2, r3]
            self->tx.power = self->ctx.power;
 8006592:	687a      	ldr	r2, [r7, #4]
 8006594:	23fb      	movs	r3, #251	; 0xfb
 8006596:	005b      	lsls	r3, r3, #1
 8006598:	5cd1      	ldrb	r1, [r2, r3]
 800659a:	687a      	ldr	r2, [r7, #4]
 800659c:	23a7      	movs	r3, #167	; 0xa7
 800659e:	005b      	lsls	r3, r3, #1
 80065a0:	54d1      	strb	r1, [r2, r3]
            self->handler(self->app, LDL_MAC_DATA_TIMEOUT, NULL);
 80065a2:	687a      	ldr	r2, [r7, #4]
 80065a4:	2392      	movs	r3, #146	; 0x92
 80065a6:	009b      	lsls	r3, r3, #2
 80065a8:	58d3      	ldr	r3, [r2, r3]
 80065aa:	6879      	ldr	r1, [r7, #4]
 80065ac:	2293      	movs	r2, #147	; 0x93
 80065ae:	0092      	lsls	r2, r2, #2
 80065b0:	5888      	ldr	r0, [r1, r2]
 80065b2:	2200      	movs	r2, #0
 80065b4:	2106      	movs	r1, #6
 80065b6:	4798      	blx	r3
            self->state = LDL_STATE_IDLE;
 80065b8:	687b      	ldr	r3, [r7, #4]
 80065ba:	2206      	movs	r2, #6
 80065bc:	701a      	strb	r2, [r3, #0]
            self->op = LDL_OP_NONE;
 80065be:	687b      	ldr	r3, [r7, #4]
 80065c0:	2200      	movs	r2, #0
 80065c2:	705a      	strb	r2, [r3, #1]
        break;
 80065c4:	e100      	b.n	80067c8 <downlinkMissingHandler+0x3cc>
        
    case LDL_OP_DATA_UNCONFIRMED:
    
        if(self->trials < nbTrans){
 80065c6:	687a      	ldr	r2, [r7, #4]
 80065c8:	2399      	movs	r3, #153	; 0x99
 80065ca:	009b      	lsls	r3, r3, #2
 80065cc:	58d2      	ldr	r2, [r2, r3]
 80065ce:	232f      	movs	r3, #47	; 0x2f
 80065d0:	18fb      	adds	r3, r7, r3
 80065d2:	781b      	ldrb	r3, [r3, #0]
 80065d4:	429a      	cmp	r2, r3
 80065d6:	d265      	bcs.n	80066a4 <downlinkMissingHandler+0x2a8>
            
            if((self->band[LDL_BAND_GLOBAL] < LDL_Region_getMaxDCycleOffLimit(self->region)) && selectChannel(self, self->tx.rate, self->tx.chIndex, LDL_Region_getMaxDCycleOffLimit(self->region), &self->tx.chIndex, &self->tx.freq)){
 80065d8:	687a      	ldr	r2, [r7, #4]
 80065da:	2394      	movs	r3, #148	; 0x94
 80065dc:	005b      	lsls	r3, r3, #1
 80065de:	58d4      	ldr	r4, [r2, r3]
 80065e0:	687a      	ldr	r2, [r7, #4]
 80065e2:	2391      	movs	r3, #145	; 0x91
 80065e4:	009b      	lsls	r3, r3, #2
 80065e6:	5cd3      	ldrb	r3, [r2, r3]
 80065e8:	0018      	movs	r0, r3
 80065ea:	f002 fd71 	bl	80090d0 <LDL_Region_getMaxDCycleOffLimit>
 80065ee:	0003      	movs	r3, r0
 80065f0:	429c      	cmp	r4, r3
 80065f2:	d239      	bcs.n	8006668 <downlinkMissingHandler+0x26c>
 80065f4:	687a      	ldr	r2, [r7, #4]
 80065f6:	234e      	movs	r3, #78	; 0x4e
 80065f8:	33ff      	adds	r3, #255	; 0xff
 80065fa:	5cd4      	ldrb	r4, [r2, r3]
 80065fc:	687a      	ldr	r2, [r7, #4]
 80065fe:	23a6      	movs	r3, #166	; 0xa6
 8006600:	005b      	lsls	r3, r3, #1
 8006602:	5cd5      	ldrb	r5, [r2, r3]
 8006604:	687a      	ldr	r2, [r7, #4]
 8006606:	2391      	movs	r3, #145	; 0x91
 8006608:	009b      	lsls	r3, r3, #2
 800660a:	5cd3      	ldrb	r3, [r2, r3]
 800660c:	0018      	movs	r0, r3
 800660e:	f002 fd5f 	bl	80090d0 <LDL_Region_getMaxDCycleOffLimit>
 8006612:	0001      	movs	r1, r0
 8006614:	687b      	ldr	r3, [r7, #4]
 8006616:	334d      	adds	r3, #77	; 0x4d
 8006618:	33ff      	adds	r3, #255	; 0xff
 800661a:	687a      	ldr	r2, [r7, #4]
 800661c:	3245      	adds	r2, #69	; 0x45
 800661e:	32ff      	adds	r2, #255	; 0xff
 8006620:	6878      	ldr	r0, [r7, #4]
 8006622:	9201      	str	r2, [sp, #4]
 8006624:	9300      	str	r3, [sp, #0]
 8006626:	000b      	movs	r3, r1
 8006628:	002a      	movs	r2, r5
 800662a:	0021      	movs	r1, r4
 800662c:	f7ff f946 	bl	80058bc <selectChannel>
 8006630:	1e03      	subs	r3, r0, #0
 8006632:	d019      	beq.n	8006668 <downlinkMissingHandler+0x26c>
            
                /* must recalculate the MIC for V1.1 since channel changes */
                if(self->ctx.version > 0){
 8006634:	687b      	ldr	r3, [r7, #4]
 8006636:	4a66      	ldr	r2, [pc, #408]	; (80067d0 <downlinkMissingHandler+0x3d4>)
 8006638:	5c9b      	ldrb	r3, [r3, r2]
 800663a:	2b00      	cmp	r3, #0
 800663c:	d00a      	beq.n	8006654 <downlinkMissingHandler+0x258>
                    
                    LDL_OPS_micDataFrame(self, self->buffer, self->bufferLen);
 800663e:	687b      	ldr	r3, [r7, #4]
 8006640:	3313      	adds	r3, #19
 8006642:	0019      	movs	r1, r3
 8006644:	687a      	ldr	r2, [r7, #4]
 8006646:	2389      	movs	r3, #137	; 0x89
 8006648:	005b      	lsls	r3, r3, #1
 800664a:	5cd2      	ldrb	r2, [r2, r3]
 800664c:	687b      	ldr	r3, [r7, #4]
 800664e:	0018      	movs	r0, r3
 8006650:	f000 fefc 	bl	800744c <LDL_OPS_micDataFrame>
                }
            
                LDL_MAC_timerSet(self, LDL_TIMER_WAITA, 0U);
 8006654:	687b      	ldr	r3, [r7, #4]
 8006656:	2200      	movs	r2, #0
 8006658:	2100      	movs	r1, #0
 800665a:	0018      	movs	r0, r3
 800665c:	f7fd fbee 	bl	8003e3c <LDL_MAC_timerSet>
                self->state = LDL_STATE_WAIT_TX;
 8006660:	687b      	ldr	r3, [r7, #4]
 8006662:	2207      	movs	r2, #7
 8006664:	701a      	strb	r2, [r3, #0]
            self->handler(self->app, LDL_MAC_DATA_COMPLETE, NULL);
#endif  
            self->state = LDL_STATE_IDLE;
            self->op = LDL_OP_NONE;                      
        }
        break;
 8006666:	e0af      	b.n	80067c8 <downlinkMissingHandler+0x3cc>
                LDL_DEBUG(self->app, "no channel available for retry")
 8006668:	4b5a      	ldr	r3, [pc, #360]	; (80067d4 <downlinkMissingHandler+0x3d8>)
 800666a:	0018      	movs	r0, r3
 800666c:	f006 f93e 	bl	800c8ec <iprintf>
 8006670:	4b59      	ldr	r3, [pc, #356]	; (80067d8 <downlinkMissingHandler+0x3dc>)
 8006672:	0018      	movs	r0, r3
 8006674:	f006 f93a 	bl	800c8ec <iprintf>
 8006678:	4b58      	ldr	r3, [pc, #352]	; (80067dc <downlinkMissingHandler+0x3e0>)
 800667a:	0018      	movs	r0, r3
 800667c:	f006 f9b0 	bl	800c9e0 <puts>
                self->handler(self->app, LDL_MAC_DATA_COMPLETE, NULL);
 8006680:	687a      	ldr	r2, [r7, #4]
 8006682:	2392      	movs	r3, #146	; 0x92
 8006684:	009b      	lsls	r3, r3, #2
 8006686:	58d3      	ldr	r3, [r2, r3]
 8006688:	6879      	ldr	r1, [r7, #4]
 800668a:	2293      	movs	r2, #147	; 0x93
 800668c:	0092      	lsls	r2, r2, #2
 800668e:	5888      	ldr	r0, [r1, r2]
 8006690:	2200      	movs	r2, #0
 8006692:	2105      	movs	r1, #5
 8006694:	4798      	blx	r3
                self->state = LDL_STATE_IDLE;
 8006696:	687b      	ldr	r3, [r7, #4]
 8006698:	2206      	movs	r2, #6
 800669a:	701a      	strb	r2, [r3, #0]
                self->op = LDL_OP_NONE;                      
 800669c:	687b      	ldr	r3, [r7, #4]
 800669e:	2200      	movs	r2, #0
 80066a0:	705a      	strb	r2, [r3, #1]
        break;
 80066a2:	e091      	b.n	80067c8 <downlinkMissingHandler+0x3cc>
            adaptRate(self);
 80066a4:	687b      	ldr	r3, [r7, #4]
 80066a6:	0018      	movs	r0, r3
 80066a8:	f7fe f960 	bl	800496c <adaptRate>
            self->tx.rate = self->ctx.rate;
 80066ac:	687a      	ldr	r2, [r7, #4]
 80066ae:	23f6      	movs	r3, #246	; 0xf6
 80066b0:	33ff      	adds	r3, #255	; 0xff
 80066b2:	5cd1      	ldrb	r1, [r2, r3]
 80066b4:	687a      	ldr	r2, [r7, #4]
 80066b6:	234e      	movs	r3, #78	; 0x4e
 80066b8:	33ff      	adds	r3, #255	; 0xff
 80066ba:	54d1      	strb	r1, [r2, r3]
            self->tx.power = self->ctx.power;
 80066bc:	687a      	ldr	r2, [r7, #4]
 80066be:	23fb      	movs	r3, #251	; 0xfb
 80066c0:	005b      	lsls	r3, r3, #1
 80066c2:	5cd1      	ldrb	r1, [r2, r3]
 80066c4:	687a      	ldr	r2, [r7, #4]
 80066c6:	23a7      	movs	r3, #167	; 0xa7
 80066c8:	005b      	lsls	r3, r3, #1
 80066ca:	54d1      	strb	r1, [r2, r3]
            self->handler(self->app, LDL_MAC_DATA_COMPLETE, NULL);
 80066cc:	687a      	ldr	r2, [r7, #4]
 80066ce:	2392      	movs	r3, #146	; 0x92
 80066d0:	009b      	lsls	r3, r3, #2
 80066d2:	58d3      	ldr	r3, [r2, r3]
 80066d4:	6879      	ldr	r1, [r7, #4]
 80066d6:	2293      	movs	r2, #147	; 0x93
 80066d8:	0092      	lsls	r2, r2, #2
 80066da:	5888      	ldr	r0, [r1, r2]
 80066dc:	2200      	movs	r2, #0
 80066de:	2105      	movs	r1, #5
 80066e0:	4798      	blx	r3
            self->state = LDL_STATE_IDLE;
 80066e2:	687b      	ldr	r3, [r7, #4]
 80066e4:	2206      	movs	r2, #6
 80066e6:	701a      	strb	r2, [r3, #0]
            self->op = LDL_OP_NONE;                      
 80066e8:	687b      	ldr	r3, [r7, #4]
 80066ea:	2200      	movs	r2, #0
 80066ec:	705a      	strb	r2, [r3, #1]
        break;
 80066ee:	e06b      	b.n	80067c8 <downlinkMissingHandler+0x3cc>

    case LDL_OP_JOINING:

        self->band[LDL_BAND_RETRY] = tx_time * getRetryDuty(delta);
 80066f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80066f2:	0018      	movs	r0, r3
 80066f4:	f7ff fd9e 	bl	8006234 <getRetryDuty>
 80066f8:	0002      	movs	r2, r0
 80066fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80066fc:	4353      	muls	r3, r2
 80066fe:	0019      	movs	r1, r3
 8006700:	687a      	ldr	r2, [r7, #4]
 8006702:	2396      	movs	r3, #150	; 0x96
 8006704:	005b      	lsls	r3, r3, #1
 8006706:	50d1      	str	r1, [r2, r3]
        
        self->tx.rate = LDL_Region_getJoinRate(self->region, self->trials);
 8006708:	687a      	ldr	r2, [r7, #4]
 800670a:	2391      	movs	r3, #145	; 0x91
 800670c:	009b      	lsls	r3, r3, #2
 800670e:	5cd0      	ldrb	r0, [r2, r3]
 8006710:	687a      	ldr	r2, [r7, #4]
 8006712:	2399      	movs	r3, #153	; 0x99
 8006714:	009b      	lsls	r3, r3, #2
 8006716:	58d3      	ldr	r3, [r2, r3]
 8006718:	0019      	movs	r1, r3
 800671a:	f002 fcb4 	bl	8009086 <LDL_Region_getJoinRate>
 800671e:	0003      	movs	r3, r0
 8006720:	0019      	movs	r1, r3
 8006722:	687a      	ldr	r2, [r7, #4]
 8006724:	234e      	movs	r3, #78	; 0x4e
 8006726:	33ff      	adds	r3, #255	; 0xff
 8006728:	54d1      	strb	r1, [r2, r3]
        
        ms_until_next = msUntilNextChannel(self, self->tx.rate);        
 800672a:	687a      	ldr	r2, [r7, #4]
 800672c:	234e      	movs	r3, #78	; 0x4e
 800672e:	33ff      	adds	r3, #255	; 0xff
 8006730:	5cd2      	ldrb	r2, [r2, r3]
 8006732:	687b      	ldr	r3, [r7, #4]
 8006734:	0011      	movs	r1, r2
 8006736:	0018      	movs	r0, r3
 8006738:	f000 f883 	bl	8006842 <msUntilNextChannel>
 800673c:	0003      	movs	r3, r0
 800673e:	623b      	str	r3, [r7, #32]
        ms_until_next = (ms_until_next > self->band[LDL_BAND_RETRY]) ? ms_until_next : self->band[LDL_BAND_RETRY];
 8006740:	687a      	ldr	r2, [r7, #4]
 8006742:	2396      	movs	r3, #150	; 0x96
 8006744:	005b      	lsls	r3, r3, #1
 8006746:	58d2      	ldr	r2, [r2, r3]
 8006748:	6a3b      	ldr	r3, [r7, #32]
 800674a:	4293      	cmp	r3, r2
 800674c:	d200      	bcs.n	8006750 <downlinkMissingHandler+0x354>
 800674e:	0013      	movs	r3, r2
 8006750:	623b      	str	r3, [r7, #32]

        if(selectChannel(self, self->tx.rate, self->tx.chIndex, ms_until_next, &self->tx.chIndex, &self->tx.freq)){
 8006752:	687a      	ldr	r2, [r7, #4]
 8006754:	234e      	movs	r3, #78	; 0x4e
 8006756:	33ff      	adds	r3, #255	; 0xff
 8006758:	5cd1      	ldrb	r1, [r2, r3]
 800675a:	687a      	ldr	r2, [r7, #4]
 800675c:	23a6      	movs	r3, #166	; 0xa6
 800675e:	005b      	lsls	r3, r3, #1
 8006760:	5cd4      	ldrb	r4, [r2, r3]
 8006762:	687b      	ldr	r3, [r7, #4]
 8006764:	334d      	adds	r3, #77	; 0x4d
 8006766:	33ff      	adds	r3, #255	; 0xff
 8006768:	687a      	ldr	r2, [r7, #4]
 800676a:	3245      	adds	r2, #69	; 0x45
 800676c:	32ff      	adds	r2, #255	; 0xff
 800676e:	6a3d      	ldr	r5, [r7, #32]
 8006770:	6878      	ldr	r0, [r7, #4]
 8006772:	9201      	str	r2, [sp, #4]
 8006774:	9300      	str	r3, [sp, #0]
 8006776:	002b      	movs	r3, r5
 8006778:	0022      	movs	r2, r4
 800677a:	f7ff f89f 	bl	80058bc <selectChannel>
 800677e:	1e03      	subs	r3, r0, #0
 8006780:	d003      	beq.n	800678a <downlinkMissingHandler+0x38e>
                
            self->state = LDL_STATE_WAIT_RETRY;        
 8006782:	687b      	ldr	r3, [r7, #4]
 8006784:	220e      	movs	r2, #14
 8006786:	701a      	strb	r2, [r3, #0]
 8006788:	e011      	b.n	80067ae <downlinkMissingHandler+0x3b2>
        }
        else{
            
            LDL_DEBUG(self->app, "no channel available for OTAA retry")
 800678a:	4b12      	ldr	r3, [pc, #72]	; (80067d4 <downlinkMissingHandler+0x3d8>)
 800678c:	0018      	movs	r0, r3
 800678e:	f006 f8ad 	bl	800c8ec <iprintf>
 8006792:	4b13      	ldr	r3, [pc, #76]	; (80067e0 <downlinkMissingHandler+0x3e4>)
 8006794:	0018      	movs	r0, r3
 8006796:	f006 f8a9 	bl	800c8ec <iprintf>
 800679a:	4b10      	ldr	r3, [pc, #64]	; (80067dc <downlinkMissingHandler+0x3e0>)
 800679c:	0018      	movs	r0, r3
 800679e:	f006 f91f 	bl	800c9e0 <puts>
            
            self->state = LDL_STATE_IDLE;
 80067a2:	687b      	ldr	r3, [r7, #4]
 80067a4:	2206      	movs	r2, #6
 80067a6:	701a      	strb	r2, [r3, #0]
            self->op = LDL_OP_NONE;                      
 80067a8:	687b      	ldr	r3, [r7, #4]
 80067aa:	2200      	movs	r2, #0
 80067ac:	705a      	strb	r2, [r3, #1]
        }
        
#ifndef LDL_DISABLE_JOIN_TIMEOUT_EVENT                               
        self->handler(self->app, LDL_MAC_JOIN_TIMEOUT, &arg);                    
 80067ae:	687a      	ldr	r2, [r7, #4]
 80067b0:	2392      	movs	r3, #146	; 0x92
 80067b2:	009b      	lsls	r3, r3, #2
 80067b4:	58d3      	ldr	r3, [r2, r3]
 80067b6:	6879      	ldr	r1, [r7, #4]
 80067b8:	2293      	movs	r2, #147	; 0x93
 80067ba:	0092      	lsls	r2, r2, #2
 80067bc:	5888      	ldr	r0, [r1, r2]
 80067be:	2210      	movs	r2, #16
 80067c0:	18ba      	adds	r2, r7, r2
 80067c2:	2104      	movs	r1, #4
 80067c4:	4798      	blx	r3
#endif                                   
        break;                    
 80067c6:	46c0      	nop			; (mov r8, r8)
    }        
}
 80067c8:	46c0      	nop			; (mov r8, r8)
 80067ca:	46bd      	mov	sp, r7
 80067cc:	b00d      	add	sp, #52	; 0x34
 80067ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80067d0:	00000206 	.word	0x00000206
 80067d4:	0800d8e8 	.word	0x0800d8e8
 80067d8:	0800e020 	.word	0x0800e020
 80067dc:	0800d8e4 	.word	0x0800d8e4
 80067e0:	0800e040 	.word	0x0800e040

080067e4 <ticksToMS>:

static uint32_t ticksToMS(uint32_t ticks)
{
 80067e4:	b590      	push	{r4, r7, lr}
 80067e6:	b083      	sub	sp, #12
 80067e8:	af00      	add	r7, sp, #0
 80067ea:	6078      	str	r0, [r7, #4]
    return ticks * 1000UL / LDL_System_tps();
 80067ec:	687a      	ldr	r2, [r7, #4]
 80067ee:	0013      	movs	r3, r2
 80067f0:	015b      	lsls	r3, r3, #5
 80067f2:	1a9b      	subs	r3, r3, r2
 80067f4:	009b      	lsls	r3, r3, #2
 80067f6:	189b      	adds	r3, r3, r2
 80067f8:	00db      	lsls	r3, r3, #3
 80067fa:	001c      	movs	r4, r3
 80067fc:	f003 fb73 	bl	8009ee6 <LDL_System_tps>
 8006800:	0003      	movs	r3, r0
 8006802:	0019      	movs	r1, r3
 8006804:	0020      	movs	r0, r4
 8006806:	f7f9 fc7f 	bl	8000108 <__udivsi3>
 800680a:	0003      	movs	r3, r0
}
 800680c:	0018      	movs	r0, r3
 800680e:	46bd      	mov	sp, r7
 8006810:	b003      	add	sp, #12
 8006812:	bd90      	pop	{r4, r7, pc}

08006814 <ticksToMSCoarse>:

static uint32_t ticksToMSCoarse(uint32_t ticks)
{
 8006814:	b580      	push	{r7, lr}
 8006816:	b082      	sub	sp, #8
 8006818:	af00      	add	r7, sp, #0
 800681a:	6078      	str	r0, [r7, #4]
    return ticks / LDL_System_tps() * 1000UL;
 800681c:	f003 fb63 	bl	8009ee6 <LDL_System_tps>
 8006820:	0003      	movs	r3, r0
 8006822:	0019      	movs	r1, r3
 8006824:	6878      	ldr	r0, [r7, #4]
 8006826:	f7f9 fc6f 	bl	8000108 <__udivsi3>
 800682a:	0003      	movs	r3, r0
 800682c:	001a      	movs	r2, r3
 800682e:	0013      	movs	r3, r2
 8006830:	015b      	lsls	r3, r3, #5
 8006832:	1a9b      	subs	r3, r3, r2
 8006834:	009b      	lsls	r3, r3, #2
 8006836:	189b      	adds	r3, r3, r2
 8006838:	00db      	lsls	r3, r3, #3
}
 800683a:	0018      	movs	r0, r3
 800683c:	46bd      	mov	sp, r7
 800683e:	b002      	add	sp, #8
 8006840:	bd80      	pop	{r7, pc}

08006842 <msUntilNextChannel>:

static uint32_t msUntilNextChannel(const struct ldl_mac *self, uint8_t rate)
{
 8006842:	b590      	push	{r4, r7, lr}
 8006844:	b087      	sub	sp, #28
 8006846:	af00      	add	r7, sp, #0
 8006848:	6078      	str	r0, [r7, #4]
 800684a:	000a      	movs	r2, r1
 800684c:	1cfb      	adds	r3, r7, #3
 800684e:	701a      	strb	r2, [r3, #0]
    uint8_t i;
    uint32_t min = UINT32_MAX;
 8006850:	2301      	movs	r3, #1
 8006852:	425b      	negs	r3, r3
 8006854:	613b      	str	r3, [r7, #16]
    uint32_t ms;
    
    for(i=0U; i < LDL_Region_numChannels(self->region); i++){
 8006856:	2317      	movs	r3, #23
 8006858:	18fb      	adds	r3, r7, r3
 800685a:	2200      	movs	r2, #0
 800685c:	701a      	strb	r2, [r3, #0]
 800685e:	e018      	b.n	8006892 <msUntilNextChannel+0x50>
        
        if(msUntilAvailable(self, i, rate, &ms)){
 8006860:	230c      	movs	r3, #12
 8006862:	18fc      	adds	r4, r7, r3
 8006864:	1cfb      	adds	r3, r7, #3
 8006866:	781a      	ldrb	r2, [r3, #0]
 8006868:	2317      	movs	r3, #23
 800686a:	18fb      	adds	r3, r7, r3
 800686c:	7819      	ldrb	r1, [r3, #0]
 800686e:	6878      	ldr	r0, [r7, #4]
 8006870:	0023      	movs	r3, r4
 8006872:	f7ff f985 	bl	8005b80 <msUntilAvailable>
 8006876:	1e03      	subs	r3, r0, #0
 8006878:	d005      	beq.n	8006886 <msUntilNextChannel+0x44>
            
            if(ms < min){
 800687a:	68fb      	ldr	r3, [r7, #12]
 800687c:	693a      	ldr	r2, [r7, #16]
 800687e:	429a      	cmp	r2, r3
 8006880:	d901      	bls.n	8006886 <msUntilNextChannel+0x44>
                
                min = ms;
 8006882:	68fb      	ldr	r3, [r7, #12]
 8006884:	613b      	str	r3, [r7, #16]
    for(i=0U; i < LDL_Region_numChannels(self->region); i++){
 8006886:	2117      	movs	r1, #23
 8006888:	187b      	adds	r3, r7, r1
 800688a:	781a      	ldrb	r2, [r3, #0]
 800688c:	187b      	adds	r3, r7, r1
 800688e:	3201      	adds	r2, #1
 8006890:	701a      	strb	r2, [r3, #0]
 8006892:	687a      	ldr	r2, [r7, #4]
 8006894:	2391      	movs	r3, #145	; 0x91
 8006896:	009b      	lsls	r3, r3, #2
 8006898:	5cd3      	ldrb	r3, [r2, r3]
 800689a:	0018      	movs	r0, r3
 800689c:	f002 f983 	bl	8008ba6 <LDL_Region_numChannels>
 80068a0:	0003      	movs	r3, r0
 80068a2:	001a      	movs	r2, r3
 80068a4:	2317      	movs	r3, #23
 80068a6:	18fb      	adds	r3, r7, r3
 80068a8:	781b      	ldrb	r3, [r3, #0]
 80068aa:	4293      	cmp	r3, r2
 80068ac:	d3d8      	bcc.n	8006860 <msUntilNextChannel+0x1e>
            }
        }
    }
    
    return min;
 80068ae:	693b      	ldr	r3, [r7, #16]
}
 80068b0:	0018      	movs	r0, r3
 80068b2:	46bd      	mov	sp, r7
 80068b4:	b007      	add	sp, #28
 80068b6:	bd90      	pop	{r4, r7, pc}

080068b8 <rand32>:

static uint32_t rand32(void *app)
{
 80068b8:	b580      	push	{r7, lr}
 80068ba:	b084      	sub	sp, #16
 80068bc:	af00      	add	r7, sp, #0
 80068be:	6078      	str	r0, [r7, #4]
    uint32_t retval;
    
    retval = LDL_System_rand(app);
 80068c0:	687b      	ldr	r3, [r7, #4]
 80068c2:	0018      	movs	r0, r3
 80068c4:	f003 f839 	bl	800993a <LDL_System_rand>
 80068c8:	0003      	movs	r3, r0
 80068ca:	60fb      	str	r3, [r7, #12]
    retval <<= 8;
 80068cc:	68fb      	ldr	r3, [r7, #12]
 80068ce:	021b      	lsls	r3, r3, #8
 80068d0:	60fb      	str	r3, [r7, #12]
    retval |= LDL_System_rand(app);
 80068d2:	687b      	ldr	r3, [r7, #4]
 80068d4:	0018      	movs	r0, r3
 80068d6:	f003 f830 	bl	800993a <LDL_System_rand>
 80068da:	0003      	movs	r3, r0
 80068dc:	001a      	movs	r2, r3
 80068de:	68fb      	ldr	r3, [r7, #12]
 80068e0:	4313      	orrs	r3, r2
 80068e2:	60fb      	str	r3, [r7, #12]
    retval <<= 8;
 80068e4:	68fb      	ldr	r3, [r7, #12]
 80068e6:	021b      	lsls	r3, r3, #8
 80068e8:	60fb      	str	r3, [r7, #12]
    retval |= LDL_System_rand(app);
 80068ea:	687b      	ldr	r3, [r7, #4]
 80068ec:	0018      	movs	r0, r3
 80068ee:	f003 f824 	bl	800993a <LDL_System_rand>
 80068f2:	0003      	movs	r3, r0
 80068f4:	001a      	movs	r2, r3
 80068f6:	68fb      	ldr	r3, [r7, #12]
 80068f8:	4313      	orrs	r3, r2
 80068fa:	60fb      	str	r3, [r7, #12]
    retval <<= 8;
 80068fc:	68fb      	ldr	r3, [r7, #12]
 80068fe:	021b      	lsls	r3, r3, #8
 8006900:	60fb      	str	r3, [r7, #12]
    retval |= LDL_System_rand(app);
 8006902:	687b      	ldr	r3, [r7, #4]
 8006904:	0018      	movs	r0, r3
 8006906:	f003 f818 	bl	800993a <LDL_System_rand>
 800690a:	0003      	movs	r3, r0
 800690c:	001a      	movs	r2, r3
 800690e:	68fb      	ldr	r3, [r7, #12]
 8006910:	4313      	orrs	r3, r2
 8006912:	60fb      	str	r3, [r7, #12]
    
    return retval;
 8006914:	68fb      	ldr	r3, [r7, #12]
}
 8006916:	0018      	movs	r0, r3
 8006918:	46bd      	mov	sp, r7
 800691a:	b004      	add	sp, #16
 800691c:	bd80      	pop	{r7, pc}

0800691e <pushSessionUpdate>:

#ifndef LDL_DISABLE_SESSION_UPDATE
static void pushSessionUpdate(struct ldl_mac *self)
{
 800691e:	b590      	push	{r4, r7, lr}
 8006920:	b087      	sub	sp, #28
 8006922:	af00      	add	r7, sp, #0
 8006924:	6078      	str	r0, [r7, #4]
    union ldl_mac_response_arg arg;     
    arg.session_updated.session = &self->ctx;
 8006926:	687b      	ldr	r3, [r7, #4]
 8006928:	335d      	adds	r3, #93	; 0x5d
 800692a:	33ff      	adds	r3, #255	; 0xff
 800692c:	001a      	movs	r2, r3
 800692e:	2408      	movs	r4, #8
 8006930:	193b      	adds	r3, r7, r4
 8006932:	601a      	str	r2, [r3, #0]
    self->handler(self->app, LDL_MAC_SESSION_UPDATED, &arg);        
 8006934:	687a      	ldr	r2, [r7, #4]
 8006936:	2392      	movs	r3, #146	; 0x92
 8006938:	009b      	lsls	r3, r3, #2
 800693a:	58d3      	ldr	r3, [r2, r3]
 800693c:	6879      	ldr	r1, [r7, #4]
 800693e:	2293      	movs	r2, #147	; 0x93
 8006940:	0092      	lsls	r2, r2, #2
 8006942:	5888      	ldr	r0, [r1, r2]
 8006944:	193a      	adds	r2, r7, r4
 8006946:	210f      	movs	r1, #15
 8006948:	4798      	blx	r3
}
 800694a:	46c0      	nop			; (mov r8, r8)
 800694c:	46bd      	mov	sp, r7
 800694e:	b007      	add	sp, #28
 8006950:	bd90      	pop	{r4, r7, pc}

08006952 <dummyResponseHandler>:
#endif

static void dummyResponseHandler(void *app, enum ldl_mac_response_type type, const union ldl_mac_response_arg *arg)
{
 8006952:	b580      	push	{r7, lr}
 8006954:	b084      	sub	sp, #16
 8006956:	af00      	add	r7, sp, #0
 8006958:	60f8      	str	r0, [r7, #12]
 800695a:	607a      	str	r2, [r7, #4]
 800695c:	230b      	movs	r3, #11
 800695e:	18fb      	adds	r3, r7, r3
 8006960:	1c0a      	adds	r2, r1, #0
 8006962:	701a      	strb	r2, [r3, #0]
    (void)app;
    (void)type;
    (void)arg;
}
 8006964:	46c0      	nop			; (mov r8, r8)
 8006966:	46bd      	mov	sp, r7
 8006968:	b004      	add	sp, #16
 800696a:	bd80      	pop	{r7, pc}

0800696c <commandIsPending>:

static bool commandIsPending(const struct ldl_mac *self, enum ldl_mac_cmd_type type)
{
 800696c:	b580      	push	{r7, lr}
 800696e:	b082      	sub	sp, #8
 8006970:	af00      	add	r7, sp, #0
 8006972:	6078      	str	r0, [r7, #4]
 8006974:	000a      	movs	r2, r1
 8006976:	1cfb      	adds	r3, r7, #3
 8006978:	701a      	strb	r2, [r3, #0]
    return (self->ctx.pending_cmds & (uint16_t)(1UL << type)) != 0UL;
 800697a:	687a      	ldr	r2, [r7, #4]
 800697c:	2383      	movs	r3, #131	; 0x83
 800697e:	009b      	lsls	r3, r3, #2
 8006980:	5ad3      	ldrh	r3, [r2, r3]
 8006982:	1cfa      	adds	r2, r7, #3
 8006984:	7812      	ldrb	r2, [r2, #0]
 8006986:	2101      	movs	r1, #1
 8006988:	4091      	lsls	r1, r2
 800698a:	000a      	movs	r2, r1
 800698c:	b292      	uxth	r2, r2
 800698e:	4013      	ands	r3, r2
 8006990:	b29b      	uxth	r3, r3
 8006992:	1e5a      	subs	r2, r3, #1
 8006994:	4193      	sbcs	r3, r2
 8006996:	b2db      	uxtb	r3, r3
}
 8006998:	0018      	movs	r0, r3
 800699a:	46bd      	mov	sp, r7
 800699c:	b002      	add	sp, #8
 800699e:	bd80      	pop	{r7, pc}

080069a0 <clearPendingCommand>:

static void clearPendingCommand(struct ldl_mac *self, enum ldl_mac_cmd_type type)
{
 80069a0:	b580      	push	{r7, lr}
 80069a2:	b082      	sub	sp, #8
 80069a4:	af00      	add	r7, sp, #0
 80069a6:	6078      	str	r0, [r7, #4]
 80069a8:	000a      	movs	r2, r1
 80069aa:	1cfb      	adds	r3, r7, #3
 80069ac:	701a      	strb	r2, [r3, #0]
    self->ctx.pending_cmds &= ~((uint16_t)(1UL << type));
 80069ae:	687a      	ldr	r2, [r7, #4]
 80069b0:	2383      	movs	r3, #131	; 0x83
 80069b2:	009b      	lsls	r3, r3, #2
 80069b4:	5ad3      	ldrh	r3, [r2, r3]
 80069b6:	b21b      	sxth	r3, r3
 80069b8:	1cfa      	adds	r2, r7, #3
 80069ba:	7812      	ldrb	r2, [r2, #0]
 80069bc:	2101      	movs	r1, #1
 80069be:	4091      	lsls	r1, r2
 80069c0:	000a      	movs	r2, r1
 80069c2:	b212      	sxth	r2, r2
 80069c4:	43d2      	mvns	r2, r2
 80069c6:	b212      	sxth	r2, r2
 80069c8:	4013      	ands	r3, r2
 80069ca:	b21b      	sxth	r3, r3
 80069cc:	b299      	uxth	r1, r3
 80069ce:	687a      	ldr	r2, [r7, #4]
 80069d0:	2383      	movs	r3, #131	; 0x83
 80069d2:	009b      	lsls	r3, r3, #2
 80069d4:	52d1      	strh	r1, [r2, r3]
}
 80069d6:	46c0      	nop			; (mov r8, r8)
 80069d8:	46bd      	mov	sp, r7
 80069da:	b002      	add	sp, #8
 80069dc:	bd80      	pop	{r7, pc}

080069de <setPendingCommand>:

static void setPendingCommand(struct ldl_mac *self, enum ldl_mac_cmd_type type)
{
 80069de:	b580      	push	{r7, lr}
 80069e0:	b082      	sub	sp, #8
 80069e2:	af00      	add	r7, sp, #0
 80069e4:	6078      	str	r0, [r7, #4]
 80069e6:	000a      	movs	r2, r1
 80069e8:	1cfb      	adds	r3, r7, #3
 80069ea:	701a      	strb	r2, [r3, #0]
    self->ctx.pending_cmds |= ((uint16_t)(1UL << type));
 80069ec:	687a      	ldr	r2, [r7, #4]
 80069ee:	2383      	movs	r3, #131	; 0x83
 80069f0:	009b      	lsls	r3, r3, #2
 80069f2:	5ad2      	ldrh	r2, [r2, r3]
 80069f4:	1cfb      	adds	r3, r7, #3
 80069f6:	781b      	ldrb	r3, [r3, #0]
 80069f8:	2101      	movs	r1, #1
 80069fa:	4099      	lsls	r1, r3
 80069fc:	000b      	movs	r3, r1
 80069fe:	b29b      	uxth	r3, r3
 8006a00:	4313      	orrs	r3, r2
 8006a02:	b299      	uxth	r1, r3
 8006a04:	687a      	ldr	r2, [r7, #4]
 8006a06:	2383      	movs	r3, #131	; 0x83
 8006a08:	009b      	lsls	r3, r3, #2
 8006a0a:	52d1      	strh	r1, [r2, r3]
}
 8006a0c:	46c0      	nop			; (mov r8, r8)
 8006a0e:	46bd      	mov	sp, r7
 8006a10:	b002      	add	sp, #8
 8006a12:	bd80      	pop	{r7, pc}

08006a14 <LDL_MAC_peekNextCommand>:
};

/* functions **********************************************************/

bool LDL_MAC_peekNextCommand(struct ldl_stream *s, enum ldl_mac_cmd_type *type)
{
 8006a14:	b590      	push	{r4, r7, lr}
 8006a16:	b085      	sub	sp, #20
 8006a18:	af00      	add	r7, sp, #0
 8006a1a:	6078      	str	r0, [r7, #4]
 8006a1c:	6039      	str	r1, [r7, #0]
    uint8_t tag;
    bool retval = false;
 8006a1e:	230f      	movs	r3, #15
 8006a20:	18fb      	adds	r3, r7, r3
 8006a22:	2200      	movs	r2, #0
 8006a24:	701a      	strb	r2, [r3, #0]
    
    if(LDL_Stream_peek(s, &tag)){
 8006a26:	230e      	movs	r3, #14
 8006a28:	18fa      	adds	r2, r7, r3
 8006a2a:	687b      	ldr	r3, [r7, #4]
 8006a2c:	0011      	movs	r1, r2
 8006a2e:	0018      	movs	r0, r3
 8006a30:	f002 fdb5 	bl	800959e <LDL_Stream_peek>
 8006a34:	1e03      	subs	r3, r0, #0
 8006a36:	d00b      	beq.n	8006a50 <LDL_MAC_peekNextCommand+0x3c>
        
        retval = tagToType(tag, type);            
 8006a38:	230e      	movs	r3, #14
 8006a3a:	18fb      	adds	r3, r7, r3
 8006a3c:	781b      	ldrb	r3, [r3, #0]
 8006a3e:	220f      	movs	r2, #15
 8006a40:	18bc      	adds	r4, r7, r2
 8006a42:	683a      	ldr	r2, [r7, #0]
 8006a44:	0011      	movs	r1, r2
 8006a46:	0018      	movs	r0, r3
 8006a48:	f000 fb36 	bl	80070b8 <tagToType>
 8006a4c:	0003      	movs	r3, r0
 8006a4e:	7023      	strb	r3, [r4, #0]
    }
    
    return retval;
 8006a50:	230f      	movs	r3, #15
 8006a52:	18fb      	adds	r3, r7, r3
 8006a54:	781b      	ldrb	r3, [r3, #0]
}
 8006a56:	0018      	movs	r0, r3
 8006a58:	46bd      	mov	sp, r7
 8006a5a:	b005      	add	sp, #20
 8006a5c:	bd90      	pop	{r4, r7, pc}

08006a5e <LDL_MAC_putLinkCheckReq>:
    
    return retval;
}

void LDL_MAC_putLinkCheckReq(struct ldl_stream *s)
{
 8006a5e:	b580      	push	{r7, lr}
 8006a60:	b082      	sub	sp, #8
 8006a62:	af00      	add	r7, sp, #0
 8006a64:	6078      	str	r0, [r7, #4]
    (void)LDL_Stream_putU8(s, typeToTag(LDL_CMD_LINK_CHECK));
 8006a66:	2000      	movs	r0, #0
 8006a68:	f000 fb14 	bl	8007094 <typeToTag>
 8006a6c:	0003      	movs	r3, r0
 8006a6e:	001a      	movs	r2, r3
 8006a70:	687b      	ldr	r3, [r7, #4]
 8006a72:	0011      	movs	r1, r2
 8006a74:	0018      	movs	r0, r3
 8006a76:	f002 fe14 	bl	80096a2 <LDL_Stream_putU8>
}
 8006a7a:	46c0      	nop			; (mov r8, r8)
 8006a7c:	46bd      	mov	sp, r7
 8006a7e:	b002      	add	sp, #8
 8006a80:	bd80      	pop	{r7, pc}

08006a82 <LDL_MAC_putLinkADRAns>:

void LDL_MAC_putLinkADRAns(struct ldl_stream *s, const struct ldl_link_adr_ans *value)
{
 8006a82:	b590      	push	{r4, r7, lr}
 8006a84:	b085      	sub	sp, #20
 8006a86:	af00      	add	r7, sp, #0
 8006a88:	6078      	str	r0, [r7, #4]
 8006a8a:	6039      	str	r1, [r7, #0]
    uint8_t buf;
    
    buf = (value->powerOK ? 4U : 0U) | (value->dataRateOK ? 2U : 0U) | (value->channelMaskOK ? 1U : 0U);
 8006a8c:	683b      	ldr	r3, [r7, #0]
 8006a8e:	781b      	ldrb	r3, [r3, #0]
 8006a90:	2b00      	cmp	r3, #0
 8006a92:	d001      	beq.n	8006a98 <LDL_MAC_putLinkADRAns+0x16>
 8006a94:	2204      	movs	r2, #4
 8006a96:	e000      	b.n	8006a9a <LDL_MAC_putLinkADRAns+0x18>
 8006a98:	2200      	movs	r2, #0
 8006a9a:	683b      	ldr	r3, [r7, #0]
 8006a9c:	785b      	ldrb	r3, [r3, #1]
 8006a9e:	2b00      	cmp	r3, #0
 8006aa0:	d001      	beq.n	8006aa6 <LDL_MAC_putLinkADRAns+0x24>
 8006aa2:	2302      	movs	r3, #2
 8006aa4:	e000      	b.n	8006aa8 <LDL_MAC_putLinkADRAns+0x26>
 8006aa6:	2300      	movs	r3, #0
 8006aa8:	4313      	orrs	r3, r2
 8006aaa:	b2d9      	uxtb	r1, r3
 8006aac:	683b      	ldr	r3, [r7, #0]
 8006aae:	789b      	ldrb	r3, [r3, #2]
 8006ab0:	2b00      	cmp	r3, #0
 8006ab2:	d001      	beq.n	8006ab8 <LDL_MAC_putLinkADRAns+0x36>
 8006ab4:	2301      	movs	r3, #1
 8006ab6:	e000      	b.n	8006aba <LDL_MAC_putLinkADRAns+0x38>
 8006ab8:	2300      	movs	r3, #0
 8006aba:	240f      	movs	r4, #15
 8006abc:	193a      	adds	r2, r7, r4
 8006abe:	430b      	orrs	r3, r1
 8006ac0:	7013      	strb	r3, [r2, #0]
    
    (void)LDL_Stream_putU8(s, typeToTag(LDL_CMD_LINK_ADR));        
 8006ac2:	2001      	movs	r0, #1
 8006ac4:	f000 fae6 	bl	8007094 <typeToTag>
 8006ac8:	0003      	movs	r3, r0
 8006aca:	001a      	movs	r2, r3
 8006acc:	687b      	ldr	r3, [r7, #4]
 8006ace:	0011      	movs	r1, r2
 8006ad0:	0018      	movs	r0, r3
 8006ad2:	f002 fde6 	bl	80096a2 <LDL_Stream_putU8>
    (void)LDL_Stream_putU8(s, buf);
 8006ad6:	193b      	adds	r3, r7, r4
 8006ad8:	781a      	ldrb	r2, [r3, #0]
 8006ada:	687b      	ldr	r3, [r7, #4]
 8006adc:	0011      	movs	r1, r2
 8006ade:	0018      	movs	r0, r3
 8006ae0:	f002 fddf 	bl	80096a2 <LDL_Stream_putU8>
}
 8006ae4:	46c0      	nop			; (mov r8, r8)
 8006ae6:	46bd      	mov	sp, r7
 8006ae8:	b005      	add	sp, #20
 8006aea:	bd90      	pop	{r4, r7, pc}

08006aec <LDL_MAC_putDutyCycleAns>:

void LDL_MAC_putDutyCycleAns(struct ldl_stream *s)
{
 8006aec:	b580      	push	{r7, lr}
 8006aee:	b082      	sub	sp, #8
 8006af0:	af00      	add	r7, sp, #0
 8006af2:	6078      	str	r0, [r7, #4]
    (void)LDL_Stream_putU8(s, typeToTag(LDL_CMD_DUTY_CYCLE));
 8006af4:	2002      	movs	r0, #2
 8006af6:	f000 facd 	bl	8007094 <typeToTag>
 8006afa:	0003      	movs	r3, r0
 8006afc:	001a      	movs	r2, r3
 8006afe:	687b      	ldr	r3, [r7, #4]
 8006b00:	0011      	movs	r1, r2
 8006b02:	0018      	movs	r0, r3
 8006b04:	f002 fdcd 	bl	80096a2 <LDL_Stream_putU8>
}
 8006b08:	46c0      	nop			; (mov r8, r8)
 8006b0a:	46bd      	mov	sp, r7
 8006b0c:	b002      	add	sp, #8
 8006b0e:	bd80      	pop	{r7, pc}

08006b10 <LDL_MAC_putRXParamSetupAns>:

void LDL_MAC_putRXParamSetupAns(struct ldl_stream *s, const struct ldl_rx_param_setup_ans *value)
{
 8006b10:	b590      	push	{r4, r7, lr}
 8006b12:	b085      	sub	sp, #20
 8006b14:	af00      	add	r7, sp, #0
 8006b16:	6078      	str	r0, [r7, #4]
 8006b18:	6039      	str	r1, [r7, #0]
    uint8_t buf;
    
    buf = (value->rx1DROffsetOK ? 4U : 0U) | (value->rx2DataRateOK ? 2U : 0U) | (value->channelOK ? 1U : 0U);
 8006b1a:	683b      	ldr	r3, [r7, #0]
 8006b1c:	781b      	ldrb	r3, [r3, #0]
 8006b1e:	2b00      	cmp	r3, #0
 8006b20:	d001      	beq.n	8006b26 <LDL_MAC_putRXParamSetupAns+0x16>
 8006b22:	2204      	movs	r2, #4
 8006b24:	e000      	b.n	8006b28 <LDL_MAC_putRXParamSetupAns+0x18>
 8006b26:	2200      	movs	r2, #0
 8006b28:	683b      	ldr	r3, [r7, #0]
 8006b2a:	785b      	ldrb	r3, [r3, #1]
 8006b2c:	2b00      	cmp	r3, #0
 8006b2e:	d001      	beq.n	8006b34 <LDL_MAC_putRXParamSetupAns+0x24>
 8006b30:	2302      	movs	r3, #2
 8006b32:	e000      	b.n	8006b36 <LDL_MAC_putRXParamSetupAns+0x26>
 8006b34:	2300      	movs	r3, #0
 8006b36:	4313      	orrs	r3, r2
 8006b38:	b2d9      	uxtb	r1, r3
 8006b3a:	683b      	ldr	r3, [r7, #0]
 8006b3c:	789b      	ldrb	r3, [r3, #2]
 8006b3e:	2b00      	cmp	r3, #0
 8006b40:	d001      	beq.n	8006b46 <LDL_MAC_putRXParamSetupAns+0x36>
 8006b42:	2301      	movs	r3, #1
 8006b44:	e000      	b.n	8006b48 <LDL_MAC_putRXParamSetupAns+0x38>
 8006b46:	2300      	movs	r3, #0
 8006b48:	240f      	movs	r4, #15
 8006b4a:	193a      	adds	r2, r7, r4
 8006b4c:	430b      	orrs	r3, r1
 8006b4e:	7013      	strb	r3, [r2, #0]
    
    (void)LDL_Stream_putU8(s, typeToTag(LDL_CMD_RX_PARAM_SETUP));
 8006b50:	2003      	movs	r0, #3
 8006b52:	f000 fa9f 	bl	8007094 <typeToTag>
 8006b56:	0003      	movs	r3, r0
 8006b58:	001a      	movs	r2, r3
 8006b5a:	687b      	ldr	r3, [r7, #4]
 8006b5c:	0011      	movs	r1, r2
 8006b5e:	0018      	movs	r0, r3
 8006b60:	f002 fd9f 	bl	80096a2 <LDL_Stream_putU8>
    (void)LDL_Stream_putU8(s, buf);
 8006b64:	193b      	adds	r3, r7, r4
 8006b66:	781a      	ldrb	r2, [r3, #0]
 8006b68:	687b      	ldr	r3, [r7, #4]
 8006b6a:	0011      	movs	r1, r2
 8006b6c:	0018      	movs	r0, r3
 8006b6e:	f002 fd98 	bl	80096a2 <LDL_Stream_putU8>
}
 8006b72:	46c0      	nop			; (mov r8, r8)
 8006b74:	46bd      	mov	sp, r7
 8006b76:	b005      	add	sp, #20
 8006b78:	bd90      	pop	{r4, r7, pc}

08006b7a <LDL_MAC_putDevStatusAns>:

void LDL_MAC_putDevStatusAns(struct ldl_stream *s, const struct ldl_dev_status_ans *value)
{
 8006b7a:	b580      	push	{r7, lr}
 8006b7c:	b082      	sub	sp, #8
 8006b7e:	af00      	add	r7, sp, #0
 8006b80:	6078      	str	r0, [r7, #4]
 8006b82:	6039      	str	r1, [r7, #0]
    (void)LDL_Stream_putU8(s, typeToTag(LDL_CMD_DEV_STATUS));
 8006b84:	2004      	movs	r0, #4
 8006b86:	f000 fa85 	bl	8007094 <typeToTag>
 8006b8a:	0003      	movs	r3, r0
 8006b8c:	001a      	movs	r2, r3
 8006b8e:	687b      	ldr	r3, [r7, #4]
 8006b90:	0011      	movs	r1, r2
 8006b92:	0018      	movs	r0, r3
 8006b94:	f002 fd85 	bl	80096a2 <LDL_Stream_putU8>
    (void)LDL_Stream_putU8(s, value->battery);
 8006b98:	683b      	ldr	r3, [r7, #0]
 8006b9a:	781a      	ldrb	r2, [r3, #0]
 8006b9c:	687b      	ldr	r3, [r7, #4]
 8006b9e:	0011      	movs	r1, r2
 8006ba0:	0018      	movs	r0, r3
 8006ba2:	f002 fd7e 	bl	80096a2 <LDL_Stream_putU8>
    (void)LDL_Stream_putU8(s, ((uint8_t)value->margin) & 0x3fU);           
 8006ba6:	683b      	ldr	r3, [r7, #0]
 8006ba8:	785b      	ldrb	r3, [r3, #1]
 8006baa:	b25b      	sxtb	r3, r3
 8006bac:	b2db      	uxtb	r3, r3
 8006bae:	223f      	movs	r2, #63	; 0x3f
 8006bb0:	4013      	ands	r3, r2
 8006bb2:	b2da      	uxtb	r2, r3
 8006bb4:	687b      	ldr	r3, [r7, #4]
 8006bb6:	0011      	movs	r1, r2
 8006bb8:	0018      	movs	r0, r3
 8006bba:	f002 fd72 	bl	80096a2 <LDL_Stream_putU8>
}
 8006bbe:	46c0      	nop			; (mov r8, r8)
 8006bc0:	46bd      	mov	sp, r7
 8006bc2:	b002      	add	sp, #8
 8006bc4:	bd80      	pop	{r7, pc}

08006bc6 <LDL_MAC_putNewChannelAns>:

void LDL_MAC_putNewChannelAns(struct ldl_stream *s, const struct ldl_new_channel_ans *value)
{
 8006bc6:	b590      	push	{r4, r7, lr}
 8006bc8:	b085      	sub	sp, #20
 8006bca:	af00      	add	r7, sp, #0
 8006bcc:	6078      	str	r0, [r7, #4]
 8006bce:	6039      	str	r1, [r7, #0]
    uint8_t buf;
    
    buf = (value->dataRateRangeOK ? 2U : 0U) | (value->channelFreqOK ? 1U : 0U);
 8006bd0:	683b      	ldr	r3, [r7, #0]
 8006bd2:	781b      	ldrb	r3, [r3, #0]
 8006bd4:	2b00      	cmp	r3, #0
 8006bd6:	d001      	beq.n	8006bdc <LDL_MAC_putNewChannelAns+0x16>
 8006bd8:	2202      	movs	r2, #2
 8006bda:	e000      	b.n	8006bde <LDL_MAC_putNewChannelAns+0x18>
 8006bdc:	2200      	movs	r2, #0
 8006bde:	683b      	ldr	r3, [r7, #0]
 8006be0:	785b      	ldrb	r3, [r3, #1]
 8006be2:	2b00      	cmp	r3, #0
 8006be4:	d001      	beq.n	8006bea <LDL_MAC_putNewChannelAns+0x24>
 8006be6:	2301      	movs	r3, #1
 8006be8:	e000      	b.n	8006bec <LDL_MAC_putNewChannelAns+0x26>
 8006bea:	2300      	movs	r3, #0
 8006bec:	240f      	movs	r4, #15
 8006bee:	1939      	adds	r1, r7, r4
 8006bf0:	4313      	orrs	r3, r2
 8006bf2:	700b      	strb	r3, [r1, #0]
    
    (void)LDL_Stream_putU8(s, typeToTag(LDL_CMD_NEW_CHANNEL));
 8006bf4:	2005      	movs	r0, #5
 8006bf6:	f000 fa4d 	bl	8007094 <typeToTag>
 8006bfa:	0003      	movs	r3, r0
 8006bfc:	001a      	movs	r2, r3
 8006bfe:	687b      	ldr	r3, [r7, #4]
 8006c00:	0011      	movs	r1, r2
 8006c02:	0018      	movs	r0, r3
 8006c04:	f002 fd4d 	bl	80096a2 <LDL_Stream_putU8>
    (void)LDL_Stream_putU8(s, buf);           
 8006c08:	193b      	adds	r3, r7, r4
 8006c0a:	781a      	ldrb	r2, [r3, #0]
 8006c0c:	687b      	ldr	r3, [r7, #4]
 8006c0e:	0011      	movs	r1, r2
 8006c10:	0018      	movs	r0, r3
 8006c12:	f002 fd46 	bl	80096a2 <LDL_Stream_putU8>
}
 8006c16:	46c0      	nop			; (mov r8, r8)
 8006c18:	46bd      	mov	sp, r7
 8006c1a:	b005      	add	sp, #20
 8006c1c:	bd90      	pop	{r4, r7, pc}

08006c1e <LDL_MAC_putDLChannelAns>:


void LDL_MAC_putDLChannelAns(struct ldl_stream *s, const struct ldl_dl_channel_ans *value)
{
 8006c1e:	b590      	push	{r4, r7, lr}
 8006c20:	b085      	sub	sp, #20
 8006c22:	af00      	add	r7, sp, #0
 8006c24:	6078      	str	r0, [r7, #4]
 8006c26:	6039      	str	r1, [r7, #0]
    uint8_t buf;
    
    buf = (value->uplinkFreqOK ? 2U : 0U) | (value->channelFreqOK ? 1U : 0U);
 8006c28:	683b      	ldr	r3, [r7, #0]
 8006c2a:	781b      	ldrb	r3, [r3, #0]
 8006c2c:	2b00      	cmp	r3, #0
 8006c2e:	d001      	beq.n	8006c34 <LDL_MAC_putDLChannelAns+0x16>
 8006c30:	2202      	movs	r2, #2
 8006c32:	e000      	b.n	8006c36 <LDL_MAC_putDLChannelAns+0x18>
 8006c34:	2200      	movs	r2, #0
 8006c36:	683b      	ldr	r3, [r7, #0]
 8006c38:	785b      	ldrb	r3, [r3, #1]
 8006c3a:	2b00      	cmp	r3, #0
 8006c3c:	d001      	beq.n	8006c42 <LDL_MAC_putDLChannelAns+0x24>
 8006c3e:	2301      	movs	r3, #1
 8006c40:	e000      	b.n	8006c44 <LDL_MAC_putDLChannelAns+0x26>
 8006c42:	2300      	movs	r3, #0
 8006c44:	240f      	movs	r4, #15
 8006c46:	1939      	adds	r1, r7, r4
 8006c48:	4313      	orrs	r3, r2
 8006c4a:	700b      	strb	r3, [r1, #0]
    
    (void)LDL_Stream_putU8(s, typeToTag(LDL_CMD_DL_CHANNEL));
 8006c4c:	2008      	movs	r0, #8
 8006c4e:	f000 fa21 	bl	8007094 <typeToTag>
 8006c52:	0003      	movs	r3, r0
 8006c54:	001a      	movs	r2, r3
 8006c56:	687b      	ldr	r3, [r7, #4]
 8006c58:	0011      	movs	r1, r2
 8006c5a:	0018      	movs	r0, r3
 8006c5c:	f002 fd21 	bl	80096a2 <LDL_Stream_putU8>
    (void)LDL_Stream_putU8(s, buf);    
 8006c60:	193b      	adds	r3, r7, r4
 8006c62:	781a      	ldrb	r2, [r3, #0]
 8006c64:	687b      	ldr	r3, [r7, #4]
 8006c66:	0011      	movs	r1, r2
 8006c68:	0018      	movs	r0, r3
 8006c6a:	f002 fd1a 	bl	80096a2 <LDL_Stream_putU8>
}
 8006c6e:	46c0      	nop			; (mov r8, r8)
 8006c70:	46bd      	mov	sp, r7
 8006c72:	b005      	add	sp, #20
 8006c74:	bd90      	pop	{r4, r7, pc}

08006c76 <LDL_MAC_putRXTimingSetupAns>:

void LDL_MAC_putRXTimingSetupAns(struct ldl_stream *s)
{
 8006c76:	b580      	push	{r7, lr}
 8006c78:	b082      	sub	sp, #8
 8006c7a:	af00      	add	r7, sp, #0
 8006c7c:	6078      	str	r0, [r7, #4]
    (void)LDL_Stream_putU8(s, typeToTag(LDL_CMD_RX_TIMING_SETUP));
 8006c7e:	2006      	movs	r0, #6
 8006c80:	f000 fa08 	bl	8007094 <typeToTag>
 8006c84:	0003      	movs	r3, r0
 8006c86:	001a      	movs	r2, r3
 8006c88:	687b      	ldr	r3, [r7, #4]
 8006c8a:	0011      	movs	r1, r2
 8006c8c:	0018      	movs	r0, r3
 8006c8e:	f002 fd08 	bl	80096a2 <LDL_Stream_putU8>
}
 8006c92:	46c0      	nop			; (mov r8, r8)
 8006c94:	46bd      	mov	sp, r7
 8006c96:	b002      	add	sp, #8
 8006c98:	bd80      	pop	{r7, pc}

08006c9a <LDL_MAC_putTXParamSetupAns>:

void LDL_MAC_putTXParamSetupAns(struct ldl_stream *s)
{
 8006c9a:	b580      	push	{r7, lr}
 8006c9c:	b082      	sub	sp, #8
 8006c9e:	af00      	add	r7, sp, #0
 8006ca0:	6078      	str	r0, [r7, #4]
    (void)LDL_Stream_putU8(s, typeToTag(LDL_CMD_TX_PARAM_SETUP));
 8006ca2:	2007      	movs	r0, #7
 8006ca4:	f000 f9f6 	bl	8007094 <typeToTag>
 8006ca8:	0003      	movs	r3, r0
 8006caa:	001a      	movs	r2, r3
 8006cac:	687b      	ldr	r3, [r7, #4]
 8006cae:	0011      	movs	r1, r2
 8006cb0:	0018      	movs	r0, r3
 8006cb2:	f002 fcf6 	bl	80096a2 <LDL_Stream_putU8>
}
 8006cb6:	46c0      	nop			; (mov r8, r8)
 8006cb8:	46bd      	mov	sp, r7
 8006cba:	b002      	add	sp, #8
 8006cbc:	bd80      	pop	{r7, pc}

08006cbe <LDL_MAC_putRekeyInd>:

void LDL_MAC_putRekeyInd(struct ldl_stream *s, const struct ldl_rekey_ind *value)
{
 8006cbe:	b580      	push	{r7, lr}
 8006cc0:	b082      	sub	sp, #8
 8006cc2:	af00      	add	r7, sp, #0
 8006cc4:	6078      	str	r0, [r7, #4]
 8006cc6:	6039      	str	r1, [r7, #0]
    (void)LDL_Stream_putU8(s, typeToTag(LDL_CMD_REKEY));
 8006cc8:	2009      	movs	r0, #9
 8006cca:	f000 f9e3 	bl	8007094 <typeToTag>
 8006cce:	0003      	movs	r3, r0
 8006cd0:	001a      	movs	r2, r3
 8006cd2:	687b      	ldr	r3, [r7, #4]
 8006cd4:	0011      	movs	r1, r2
 8006cd6:	0018      	movs	r0, r3
 8006cd8:	f002 fce3 	bl	80096a2 <LDL_Stream_putU8>
    (void)LDL_Stream_putU8(s, value->version);
 8006cdc:	683b      	ldr	r3, [r7, #0]
 8006cde:	781a      	ldrb	r2, [r3, #0]
 8006ce0:	687b      	ldr	r3, [r7, #4]
 8006ce2:	0011      	movs	r1, r2
 8006ce4:	0018      	movs	r0, r3
 8006ce6:	f002 fcdc 	bl	80096a2 <LDL_Stream_putU8>
}
 8006cea:	46c0      	nop			; (mov r8, r8)
 8006cec:	46bd      	mov	sp, r7
 8006cee:	b002      	add	sp, #8
 8006cf0:	bd80      	pop	{r7, pc}

08006cf2 <LDL_MAC_putADRParamSetupAns>:

void LDL_MAC_putADRParamSetupAns(struct ldl_stream *s)
{
 8006cf2:	b580      	push	{r7, lr}
 8006cf4:	b082      	sub	sp, #8
 8006cf6:	af00      	add	r7, sp, #0
 8006cf8:	6078      	str	r0, [r7, #4]
    (void)LDL_Stream_putU8(s, typeToTag(LDL_CMD_ADR_PARAM_SETUP));
 8006cfa:	200a      	movs	r0, #10
 8006cfc:	f000 f9ca 	bl	8007094 <typeToTag>
 8006d00:	0003      	movs	r3, r0
 8006d02:	001a      	movs	r2, r3
 8006d04:	687b      	ldr	r3, [r7, #4]
 8006d06:	0011      	movs	r1, r2
 8006d08:	0018      	movs	r0, r3
 8006d0a:	f002 fcca 	bl	80096a2 <LDL_Stream_putU8>
}
 8006d0e:	46c0      	nop			; (mov r8, r8)
 8006d10:	46bd      	mov	sp, r7
 8006d12:	b002      	add	sp, #8
 8006d14:	bd80      	pop	{r7, pc}

08006d16 <LDL_MAC_putDeviceTimeReq>:

void LDL_MAC_putDeviceTimeReq(struct ldl_stream *s)
{
 8006d16:	b580      	push	{r7, lr}
 8006d18:	b082      	sub	sp, #8
 8006d1a:	af00      	add	r7, sp, #0
 8006d1c:	6078      	str	r0, [r7, #4]
    (void)LDL_Stream_putU8(s, typeToTag(LDL_CMD_DEVICE_TIME));
 8006d1e:	200b      	movs	r0, #11
 8006d20:	f000 f9b8 	bl	8007094 <typeToTag>
 8006d24:	0003      	movs	r3, r0
 8006d26:	001a      	movs	r2, r3
 8006d28:	687b      	ldr	r3, [r7, #4]
 8006d2a:	0011      	movs	r1, r2
 8006d2c:	0018      	movs	r0, r3
 8006d2e:	f002 fcb8 	bl	80096a2 <LDL_Stream_putU8>
}
 8006d32:	46c0      	nop			; (mov r8, r8)
 8006d34:	46bd      	mov	sp, r7
 8006d36:	b002      	add	sp, #8
 8006d38:	bd80      	pop	{r7, pc}

08006d3a <LDL_MAC_putRejoinParamSetupAns>:

void LDL_MAC_putRejoinParamSetupAns(struct ldl_stream *s, struct ldl_rejoin_param_setup_ans *value)
{
 8006d3a:	b580      	push	{r7, lr}
 8006d3c:	b082      	sub	sp, #8
 8006d3e:	af00      	add	r7, sp, #0
 8006d40:	6078      	str	r0, [r7, #4]
 8006d42:	6039      	str	r1, [r7, #0]
    (void)LDL_Stream_putU8(s, typeToTag(LDL_CMD_REJOIN_PARAM_SETUP));
 8006d44:	200d      	movs	r0, #13
 8006d46:	f000 f9a5 	bl	8007094 <typeToTag>
 8006d4a:	0003      	movs	r3, r0
 8006d4c:	001a      	movs	r2, r3
 8006d4e:	687b      	ldr	r3, [r7, #4]
 8006d50:	0011      	movs	r1, r2
 8006d52:	0018      	movs	r0, r3
 8006d54:	f002 fca5 	bl	80096a2 <LDL_Stream_putU8>
    (void)LDL_Stream_putU8(s, value->timeOK);
 8006d58:	683b      	ldr	r3, [r7, #0]
 8006d5a:	781a      	ldrb	r2, [r3, #0]
 8006d5c:	687b      	ldr	r3, [r7, #4]
 8006d5e:	0011      	movs	r1, r2
 8006d60:	0018      	movs	r0, r3
 8006d62:	f002 fc9e 	bl	80096a2 <LDL_Stream_putU8>
}
 8006d66:	46c0      	nop			; (mov r8, r8)
 8006d68:	46bd      	mov	sp, r7
 8006d6a:	b002      	add	sp, #8
 8006d6c:	bd80      	pop	{r7, pc}
	...

08006d70 <LDL_MAC_getDownCommand>:

bool LDL_MAC_getDownCommand(struct ldl_stream *s, struct ldl_downstream_cmd *cmd)
{
 8006d70:	b5b0      	push	{r4, r5, r7, lr}
 8006d72:	b086      	sub	sp, #24
 8006d74:	af00      	add	r7, sp, #0
 8006d76:	6078      	str	r0, [r7, #4]
 8006d78:	6039      	str	r1, [r7, #0]
    uint8_t tag;
    bool retval = false;
 8006d7a:	2317      	movs	r3, #23
 8006d7c:	18fb      	adds	r3, r7, r3
 8006d7e:	2200      	movs	r2, #0
 8006d80:	701a      	strb	r2, [r3, #0]
    
    if(LDL_Stream_getU8(s, &tag)){
 8006d82:	2316      	movs	r3, #22
 8006d84:	18fa      	adds	r2, r7, r3
 8006d86:	687b      	ldr	r3, [r7, #4]
 8006d88:	0011      	movs	r1, r2
 8006d8a:	0018      	movs	r0, r3
 8006d8c:	f002 fd19 	bl	80097c2 <LDL_Stream_getU8>
 8006d90:	1e03      	subs	r3, r0, #0
 8006d92:	d100      	bne.n	8006d96 <LDL_MAC_getDownCommand+0x26>
 8006d94:	e164      	b.n	8007060 <LDL_MAC_getDownCommand+0x2f0>
        
        retval = tagToType(tag, &cmd->type);
 8006d96:	2316      	movs	r3, #22
 8006d98:	18fb      	adds	r3, r7, r3
 8006d9a:	781b      	ldrb	r3, [r3, #0]
 8006d9c:	683a      	ldr	r2, [r7, #0]
 8006d9e:	2517      	movs	r5, #23
 8006da0:	197c      	adds	r4, r7, r5
 8006da2:	0011      	movs	r1, r2
 8006da4:	0018      	movs	r0, r3
 8006da6:	f000 f987 	bl	80070b8 <tagToType>
 8006daa:	0003      	movs	r3, r0
 8006dac:	7023      	strb	r3, [r4, #0]
        
        if(retval){
 8006dae:	197b      	adds	r3, r7, r5
 8006db0:	781b      	ldrb	r3, [r3, #0]
 8006db2:	2b00      	cmp	r3, #0
 8006db4:	d100      	bne.n	8006db8 <LDL_MAC_getDownCommand+0x48>
 8006db6:	e153      	b.n	8007060 <LDL_MAC_getDownCommand+0x2f0>
            
            switch(cmd->type){
 8006db8:	683b      	ldr	r3, [r7, #0]
 8006dba:	781b      	ldrb	r3, [r3, #0]
 8006dbc:	2b0d      	cmp	r3, #13
 8006dbe:	d900      	bls.n	8006dc2 <LDL_MAC_getDownCommand+0x52>
 8006dc0:	e150      	b.n	8007064 <LDL_MAC_getDownCommand+0x2f4>
 8006dc2:	009a      	lsls	r2, r3, #2
 8006dc4:	4bb2      	ldr	r3, [pc, #712]	; (8007090 <LDL_MAC_getDownCommand+0x320>)
 8006dc6:	18d3      	adds	r3, r2, r3
 8006dc8:	681b      	ldr	r3, [r3, #0]
 8006dca:	469f      	mov	pc, r3
                /* impossible */
                break;
                
            case LDL_CMD_LINK_CHECK:
                
                (void)LDL_Stream_getU8(s, &cmd->fields.linkCheck.margin);
 8006dcc:	683b      	ldr	r3, [r7, #0]
 8006dce:	1d1a      	adds	r2, r3, #4
 8006dd0:	687b      	ldr	r3, [r7, #4]
 8006dd2:	0011      	movs	r1, r2
 8006dd4:	0018      	movs	r0, r3
 8006dd6:	f002 fcf4 	bl	80097c2 <LDL_Stream_getU8>
                (void)LDL_Stream_getU8(s, &cmd->fields.linkCheck.gwCount);    
 8006dda:	683b      	ldr	r3, [r7, #0]
 8006ddc:	1d5a      	adds	r2, r3, #5
 8006dde:	687b      	ldr	r3, [r7, #4]
 8006de0:	0011      	movs	r1, r2
 8006de2:	0018      	movs	r0, r3
 8006de4:	f002 fced 	bl	80097c2 <LDL_Stream_getU8>
                break;
 8006de8:	e13f      	b.n	800706a <LDL_MAC_getDownCommand+0x2fa>
                
            case LDL_CMD_LINK_ADR:                    
            {
                uint8_t buf;
                
                (void)LDL_Stream_getU8(s, &buf);
 8006dea:	2415      	movs	r4, #21
 8006dec:	193a      	adds	r2, r7, r4
 8006dee:	687b      	ldr	r3, [r7, #4]
 8006df0:	0011      	movs	r1, r2
 8006df2:	0018      	movs	r0, r3
 8006df4:	f002 fce5 	bl	80097c2 <LDL_Stream_getU8>
                
                cmd->fields.linkADR.dataRate = buf >> 4;
 8006df8:	0021      	movs	r1, r4
 8006dfa:	193b      	adds	r3, r7, r4
 8006dfc:	781b      	ldrb	r3, [r3, #0]
 8006dfe:	091b      	lsrs	r3, r3, #4
 8006e00:	b2da      	uxtb	r2, r3
 8006e02:	683b      	ldr	r3, [r7, #0]
 8006e04:	711a      	strb	r2, [r3, #4]
                cmd->fields.linkADR.txPower = buf & 0xfU;
 8006e06:	000c      	movs	r4, r1
 8006e08:	187b      	adds	r3, r7, r1
 8006e0a:	781b      	ldrb	r3, [r3, #0]
 8006e0c:	220f      	movs	r2, #15
 8006e0e:	4013      	ands	r3, r2
 8006e10:	b2da      	uxtb	r2, r3
 8006e12:	683b      	ldr	r3, [r7, #0]
 8006e14:	715a      	strb	r2, [r3, #5]
                
                (void)LDL_Stream_getU16(s, &cmd->fields.linkADR.channelMask);
 8006e16:	683b      	ldr	r3, [r7, #0]
 8006e18:	1d9a      	adds	r2, r3, #6
 8006e1a:	687b      	ldr	r3, [r7, #4]
 8006e1c:	0011      	movs	r1, r2
 8006e1e:	0018      	movs	r0, r3
 8006e20:	f002 fcdf 	bl	80097e2 <LDL_Stream_getU16>
                        
                (void)LDL_Stream_getU8(s, &buf);
 8006e24:	193a      	adds	r2, r7, r4
 8006e26:	687b      	ldr	r3, [r7, #4]
 8006e28:	0011      	movs	r1, r2
 8006e2a:	0018      	movs	r0, r3
 8006e2c:	f002 fcc9 	bl	80097c2 <LDL_Stream_getU8>
                        
                cmd->fields.linkADR.channelMaskControl = (buf >> 4) & 0x7U;
 8006e30:	0021      	movs	r1, r4
 8006e32:	193b      	adds	r3, r7, r4
 8006e34:	781b      	ldrb	r3, [r3, #0]
 8006e36:	091b      	lsrs	r3, r3, #4
 8006e38:	b2db      	uxtb	r3, r3
 8006e3a:	2207      	movs	r2, #7
 8006e3c:	4013      	ands	r3, r2
 8006e3e:	b2da      	uxtb	r2, r3
 8006e40:	683b      	ldr	r3, [r7, #0]
 8006e42:	721a      	strb	r2, [r3, #8]
                cmd->fields.linkADR.nbTrans = buf & 0xfU;
 8006e44:	187b      	adds	r3, r7, r1
 8006e46:	781b      	ldrb	r3, [r3, #0]
 8006e48:	220f      	movs	r2, #15
 8006e4a:	4013      	ands	r3, r2
 8006e4c:	b2da      	uxtb	r2, r3
 8006e4e:	683b      	ldr	r3, [r7, #0]
 8006e50:	725a      	strb	r2, [r3, #9]
            }
                break;
 8006e52:	e10a      	b.n	800706a <LDL_MAC_getDownCommand+0x2fa>
            
            case LDL_CMD_DUTY_CYCLE:                
            
                (void)LDL_Stream_getU8(s, &cmd->fields.dutyCycle.maxDutyCycle);
 8006e54:	683b      	ldr	r3, [r7, #0]
 8006e56:	1d1a      	adds	r2, r3, #4
 8006e58:	687b      	ldr	r3, [r7, #4]
 8006e5a:	0011      	movs	r1, r2
 8006e5c:	0018      	movs	r0, r3
 8006e5e:	f002 fcb0 	bl	80097c2 <LDL_Stream_getU8>
                cmd->fields.dutyCycle.maxDutyCycle &= 0xfU;             
 8006e62:	683b      	ldr	r3, [r7, #0]
 8006e64:	791b      	ldrb	r3, [r3, #4]
 8006e66:	220f      	movs	r2, #15
 8006e68:	4013      	ands	r3, r2
 8006e6a:	b2da      	uxtb	r2, r3
 8006e6c:	683b      	ldr	r3, [r7, #0]
 8006e6e:	711a      	strb	r2, [r3, #4]
                break;
 8006e70:	e0fb      	b.n	800706a <LDL_MAC_getDownCommand+0x2fa>
            
            case LDL_CMD_RX_PARAM_SETUP:
            
                (void)LDL_Stream_getU8(s, &cmd->fields.rxParamSetup.rx1DROffset);
 8006e72:	683b      	ldr	r3, [r7, #0]
 8006e74:	1d1a      	adds	r2, r3, #4
 8006e76:	687b      	ldr	r3, [r7, #4]
 8006e78:	0011      	movs	r1, r2
 8006e7a:	0018      	movs	r0, r3
 8006e7c:	f002 fca1 	bl	80097c2 <LDL_Stream_getU8>
                (void)LDL_Stream_getU24(s, &cmd->fields.rxParamSetup.freq);                 
 8006e80:	683b      	ldr	r3, [r7, #0]
 8006e82:	3308      	adds	r3, #8
 8006e84:	001a      	movs	r2, r3
 8006e86:	687b      	ldr	r3, [r7, #4]
 8006e88:	0011      	movs	r1, r2
 8006e8a:	0018      	movs	r0, r3
 8006e8c:	f002 fcd5 	bl	800983a <LDL_Stream_getU24>
                break;
 8006e90:	e0eb      	b.n	800706a <LDL_MAC_getDownCommand+0x2fa>
            
            case LDL_CMD_NEW_CHANNEL:
            {
                uint8_t buf;
    
                (void)LDL_Stream_getU8(s, &cmd->fields.newChannel.chIndex);        
 8006e92:	683b      	ldr	r3, [r7, #0]
 8006e94:	1d1a      	adds	r2, r3, #4
 8006e96:	687b      	ldr	r3, [r7, #4]
 8006e98:	0011      	movs	r1, r2
 8006e9a:	0018      	movs	r0, r3
 8006e9c:	f002 fc91 	bl	80097c2 <LDL_Stream_getU8>
                (void)LDL_Stream_getU24(s, &cmd->fields.newChannel.freq);
 8006ea0:	683b      	ldr	r3, [r7, #0]
 8006ea2:	3308      	adds	r3, #8
 8006ea4:	001a      	movs	r2, r3
 8006ea6:	687b      	ldr	r3, [r7, #4]
 8006ea8:	0011      	movs	r1, r2
 8006eaa:	0018      	movs	r0, r3
 8006eac:	f002 fcc5 	bl	800983a <LDL_Stream_getU24>
                (void)LDL_Stream_getU8(s, &buf);
 8006eb0:	2114      	movs	r1, #20
 8006eb2:	000c      	movs	r4, r1
 8006eb4:	187a      	adds	r2, r7, r1
 8006eb6:	687b      	ldr	r3, [r7, #4]
 8006eb8:	0011      	movs	r1, r2
 8006eba:	0018      	movs	r0, r3
 8006ebc:	f002 fc81 	bl	80097c2 <LDL_Stream_getU8>

                cmd->fields.newChannel.maxDR = buf >> 4;
 8006ec0:	0021      	movs	r1, r4
 8006ec2:	187b      	adds	r3, r7, r1
 8006ec4:	781b      	ldrb	r3, [r3, #0]
 8006ec6:	091b      	lsrs	r3, r3, #4
 8006ec8:	b2da      	uxtb	r2, r3
 8006eca:	683b      	ldr	r3, [r7, #0]
 8006ecc:	731a      	strb	r2, [r3, #12]
                cmd->fields.newChannel.minDR = buf & 0xfU;           
 8006ece:	187b      	adds	r3, r7, r1
 8006ed0:	781b      	ldrb	r3, [r3, #0]
 8006ed2:	220f      	movs	r2, #15
 8006ed4:	4013      	ands	r3, r2
 8006ed6:	b2da      	uxtb	r2, r3
 8006ed8:	683b      	ldr	r3, [r7, #0]
 8006eda:	735a      	strb	r2, [r3, #13]
            }
                break;
 8006edc:	e0c5      	b.n	800706a <LDL_MAC_getDownCommand+0x2fa>
                
            case LDL_CMD_DL_CHANNEL:
            
                (void)LDL_Stream_getU8(s, &cmd->fields.dlChannel.chIndex);
 8006ede:	683b      	ldr	r3, [r7, #0]
 8006ee0:	1d1a      	adds	r2, r3, #4
 8006ee2:	687b      	ldr	r3, [r7, #4]
 8006ee4:	0011      	movs	r1, r2
 8006ee6:	0018      	movs	r0, r3
 8006ee8:	f002 fc6b 	bl	80097c2 <LDL_Stream_getU8>
                (void)LDL_Stream_getU24(s, &cmd->fields.dlChannel.freq);     
 8006eec:	683b      	ldr	r3, [r7, #0]
 8006eee:	3308      	adds	r3, #8
 8006ef0:	001a      	movs	r2, r3
 8006ef2:	687b      	ldr	r3, [r7, #4]
 8006ef4:	0011      	movs	r1, r2
 8006ef6:	0018      	movs	r0, r3
 8006ef8:	f002 fc9f 	bl	800983a <LDL_Stream_getU24>
                break;
 8006efc:	e0b5      	b.n	800706a <LDL_MAC_getDownCommand+0x2fa>
            
            case LDL_CMD_RX_TIMING_SETUP:
            
                (void)LDL_Stream_getU8(s, &cmd->fields.rxTimingSetup.delay);
 8006efe:	683b      	ldr	r3, [r7, #0]
 8006f00:	1d1a      	adds	r2, r3, #4
 8006f02:	687b      	ldr	r3, [r7, #4]
 8006f04:	0011      	movs	r1, r2
 8006f06:	0018      	movs	r0, r3
 8006f08:	f002 fc5b 	bl	80097c2 <LDL_Stream_getU8>
                cmd->fields.rxTimingSetup.delay &= 0xfU;   
 8006f0c:	683b      	ldr	r3, [r7, #0]
 8006f0e:	791b      	ldrb	r3, [r3, #4]
 8006f10:	220f      	movs	r2, #15
 8006f12:	4013      	ands	r3, r2
 8006f14:	b2da      	uxtb	r2, r3
 8006f16:	683b      	ldr	r3, [r7, #0]
 8006f18:	711a      	strb	r2, [r3, #4]
                break;
 8006f1a:	e0a6      	b.n	800706a <LDL_MAC_getDownCommand+0x2fa>
            
            case LDL_CMD_TX_PARAM_SETUP:
            {
                uint8_t buf;
                
                (void)LDL_Stream_getU8(s, &buf);
 8006f1c:	2113      	movs	r1, #19
 8006f1e:	000c      	movs	r4, r1
 8006f20:	187a      	adds	r2, r7, r1
 8006f22:	687b      	ldr	r3, [r7, #4]
 8006f24:	0011      	movs	r1, r2
 8006f26:	0018      	movs	r0, r3
 8006f28:	f002 fc4b 	bl	80097c2 <LDL_Stream_getU8>
                
                cmd->fields.txParamSetup.downlinkDwell = ((buf & 0x20U) == 0x20U); 
 8006f2c:	0021      	movs	r1, r4
 8006f2e:	187b      	adds	r3, r7, r1
 8006f30:	781b      	ldrb	r3, [r3, #0]
 8006f32:	001a      	movs	r2, r3
 8006f34:	2320      	movs	r3, #32
 8006f36:	4013      	ands	r3, r2
 8006f38:	1e5a      	subs	r2, r3, #1
 8006f3a:	4193      	sbcs	r3, r2
 8006f3c:	b2da      	uxtb	r2, r3
 8006f3e:	683b      	ldr	r3, [r7, #0]
 8006f40:	711a      	strb	r2, [r3, #4]
                cmd->fields.txParamSetup.uplinkDwell = ((buf & 0x10U) == 0x10U); 
 8006f42:	187b      	adds	r3, r7, r1
 8006f44:	781b      	ldrb	r3, [r3, #0]
 8006f46:	001a      	movs	r2, r3
 8006f48:	2310      	movs	r3, #16
 8006f4a:	4013      	ands	r3, r2
 8006f4c:	1e5a      	subs	r2, r3, #1
 8006f4e:	4193      	sbcs	r3, r2
 8006f50:	b2da      	uxtb	r2, r3
 8006f52:	683b      	ldr	r3, [r7, #0]
 8006f54:	715a      	strb	r2, [r3, #5]
                cmd->fields.txParamSetup.maxEIRP = buf & 0xfU; 
 8006f56:	187b      	adds	r3, r7, r1
 8006f58:	781b      	ldrb	r3, [r3, #0]
 8006f5a:	220f      	movs	r2, #15
 8006f5c:	4013      	ands	r3, r2
 8006f5e:	b2da      	uxtb	r2, r3
 8006f60:	683b      	ldr	r3, [r7, #0]
 8006f62:	719a      	strb	r2, [r3, #6]
            }
                break;
 8006f64:	e081      	b.n	800706a <LDL_MAC_getDownCommand+0x2fa>
            
            case LDL_CMD_REKEY:
            
                (void)LDL_Stream_getU8(s, &cmd->fields.rekey.version);
 8006f66:	683b      	ldr	r3, [r7, #0]
 8006f68:	1d1a      	adds	r2, r3, #4
 8006f6a:	687b      	ldr	r3, [r7, #4]
 8006f6c:	0011      	movs	r1, r2
 8006f6e:	0018      	movs	r0, r3
 8006f70:	f002 fc27 	bl	80097c2 <LDL_Stream_getU8>
                cmd->fields.rekey.version &= 0xfU; 
 8006f74:	683b      	ldr	r3, [r7, #0]
 8006f76:	791b      	ldrb	r3, [r3, #4]
 8006f78:	220f      	movs	r2, #15
 8006f7a:	4013      	ands	r3, r2
 8006f7c:	b2da      	uxtb	r2, r3
 8006f7e:	683b      	ldr	r3, [r7, #0]
 8006f80:	711a      	strb	r2, [r3, #4]
                break;
 8006f82:	e072      	b.n	800706a <LDL_MAC_getDownCommand+0x2fa>
            
            case LDL_CMD_ADR_PARAM_SETUP:
            {
                uint8_t buf;
                
                (void)LDL_Stream_getU8(s, &buf);
 8006f84:	2112      	movs	r1, #18
 8006f86:	000c      	movs	r4, r1
 8006f88:	187a      	adds	r2, r7, r1
 8006f8a:	687b      	ldr	r3, [r7, #4]
 8006f8c:	0011      	movs	r1, r2
 8006f8e:	0018      	movs	r0, r3
 8006f90:	f002 fc17 	bl	80097c2 <LDL_Stream_getU8>
    
                cmd->fields.adrParamSetup.limit_exp = buf >> 4;
 8006f94:	0021      	movs	r1, r4
 8006f96:	187b      	adds	r3, r7, r1
 8006f98:	781b      	ldrb	r3, [r3, #0]
 8006f9a:	091b      	lsrs	r3, r3, #4
 8006f9c:	b2da      	uxtb	r2, r3
 8006f9e:	683b      	ldr	r3, [r7, #0]
 8006fa0:	711a      	strb	r2, [r3, #4]
                cmd->fields.adrParamSetup.delay_exp = buf & 0xfU;
 8006fa2:	187b      	adds	r3, r7, r1
 8006fa4:	781b      	ldrb	r3, [r3, #0]
 8006fa6:	220f      	movs	r2, #15
 8006fa8:	4013      	ands	r3, r2
 8006faa:	b2da      	uxtb	r2, r3
 8006fac:	683b      	ldr	r3, [r7, #0]
 8006fae:	715a      	strb	r2, [r3, #5]
            }
                break;
 8006fb0:	e05b      	b.n	800706a <LDL_MAC_getDownCommand+0x2fa>
            
            case LDL_CMD_DEVICE_TIME:
            
                (void)LDL_Stream_getU32(s, &cmd->fields.deviceTime.seconds);
 8006fb2:	683b      	ldr	r3, [r7, #0]
 8006fb4:	1d1a      	adds	r2, r3, #4
 8006fb6:	687b      	ldr	r3, [r7, #4]
 8006fb8:	0011      	movs	r1, r2
 8006fba:	0018      	movs	r0, r3
 8006fbc:	f002 fc72 	bl	80098a4 <LDL_Stream_getU32>
                (void)LDL_Stream_getU8(s, &cmd->fields.deviceTime.fractions);
 8006fc0:	683b      	ldr	r3, [r7, #0]
 8006fc2:	3308      	adds	r3, #8
 8006fc4:	001a      	movs	r2, r3
 8006fc6:	687b      	ldr	r3, [r7, #4]
 8006fc8:	0011      	movs	r1, r2
 8006fca:	0018      	movs	r0, r3
 8006fcc:	f002 fbf9 	bl	80097c2 <LDL_Stream_getU8>
                break;
 8006fd0:	e04b      	b.n	800706a <LDL_MAC_getDownCommand+0x2fa>
            
            case LDL_CMD_FORCE_REJOIN:
            {
                uint16_t buf;
    
                (void)LDL_Stream_getU16(s, &buf);
 8006fd2:	2110      	movs	r1, #16
 8006fd4:	000c      	movs	r4, r1
 8006fd6:	187a      	adds	r2, r7, r1
 8006fd8:	687b      	ldr	r3, [r7, #4]
 8006fda:	0011      	movs	r1, r2
 8006fdc:	0018      	movs	r0, r3
 8006fde:	f002 fc00 	bl	80097e2 <LDL_Stream_getU16>
                
                cmd->fields.forceRejoin.period = (buf >> 10) & 0x7U;
 8006fe2:	0021      	movs	r1, r4
 8006fe4:	187b      	adds	r3, r7, r1
 8006fe6:	881b      	ldrh	r3, [r3, #0]
 8006fe8:	0a9b      	lsrs	r3, r3, #10
 8006fea:	b29b      	uxth	r3, r3
 8006fec:	b2db      	uxtb	r3, r3
 8006fee:	2207      	movs	r2, #7
 8006ff0:	4013      	ands	r3, r2
 8006ff2:	b2da      	uxtb	r2, r3
 8006ff4:	683b      	ldr	r3, [r7, #0]
 8006ff6:	711a      	strb	r2, [r3, #4]
                cmd->fields.forceRejoin.max_retries = (buf >> 7) & 0x7U;
 8006ff8:	187b      	adds	r3, r7, r1
 8006ffa:	881b      	ldrh	r3, [r3, #0]
 8006ffc:	09db      	lsrs	r3, r3, #7
 8006ffe:	b29b      	uxth	r3, r3
 8007000:	b2db      	uxtb	r3, r3
 8007002:	2207      	movs	r2, #7
 8007004:	4013      	ands	r3, r2
 8007006:	b2da      	uxtb	r2, r3
 8007008:	683b      	ldr	r3, [r7, #0]
 800700a:	715a      	strb	r2, [r3, #5]
                cmd->fields.forceRejoin.rejoin_type = (buf >> 4) & 0x7U;
 800700c:	187b      	adds	r3, r7, r1
 800700e:	881b      	ldrh	r3, [r3, #0]
 8007010:	091b      	lsrs	r3, r3, #4
 8007012:	b29b      	uxth	r3, r3
 8007014:	b2db      	uxtb	r3, r3
 8007016:	2207      	movs	r2, #7
 8007018:	4013      	ands	r3, r2
 800701a:	b2da      	uxtb	r2, r3
 800701c:	683b      	ldr	r3, [r7, #0]
 800701e:	719a      	strb	r2, [r3, #6]
                cmd->fields.forceRejoin.dr = buf & 0xfU;
 8007020:	187b      	adds	r3, r7, r1
 8007022:	881b      	ldrh	r3, [r3, #0]
 8007024:	b2db      	uxtb	r3, r3
 8007026:	220f      	movs	r2, #15
 8007028:	4013      	ands	r3, r2
 800702a:	b2da      	uxtb	r2, r3
 800702c:	683b      	ldr	r3, [r7, #0]
 800702e:	71da      	strb	r2, [r3, #7]
            }
                break;
 8007030:	e01b      	b.n	800706a <LDL_MAC_getDownCommand+0x2fa>
            
            case LDL_CMD_REJOIN_PARAM_SETUP:
            {
                uint8_t buf;
    
                (void)LDL_Stream_getU8(s, &buf);
 8007032:	210f      	movs	r1, #15
 8007034:	000c      	movs	r4, r1
 8007036:	187a      	adds	r2, r7, r1
 8007038:	687b      	ldr	r3, [r7, #4]
 800703a:	0011      	movs	r1, r2
 800703c:	0018      	movs	r0, r3
 800703e:	f002 fbc0 	bl	80097c2 <LDL_Stream_getU8>
                
                cmd->fields.rejoinParamSetup.maxTimeN = buf >> 4;
 8007042:	0021      	movs	r1, r4
 8007044:	187b      	adds	r3, r7, r1
 8007046:	781b      	ldrb	r3, [r3, #0]
 8007048:	091b      	lsrs	r3, r3, #4
 800704a:	b2da      	uxtb	r2, r3
 800704c:	683b      	ldr	r3, [r7, #0]
 800704e:	711a      	strb	r2, [r3, #4]
                cmd->fields.rejoinParamSetup.maxCountN = buf & 0xfU;
 8007050:	187b      	adds	r3, r7, r1
 8007052:	781b      	ldrb	r3, [r3, #0]
 8007054:	220f      	movs	r2, #15
 8007056:	4013      	ands	r3, r2
 8007058:	b2da      	uxtb	r2, r3
 800705a:	683b      	ldr	r3, [r7, #0]
 800705c:	715a      	strb	r2, [r3, #5]
            }
                break;
 800705e:	e004      	b.n	800706a <LDL_MAC_getDownCommand+0x2fa>
            }
        }
 8007060:	46c0      	nop			; (mov r8, r8)
 8007062:	e002      	b.n	800706a <LDL_MAC_getDownCommand+0x2fa>
                break;
 8007064:	46c0      	nop			; (mov r8, r8)
 8007066:	e000      	b.n	800706a <LDL_MAC_getDownCommand+0x2fa>
                break;
 8007068:	46c0      	nop			; (mov r8, r8)
    }
    
    return LDL_Stream_error(s) ? false : retval;
 800706a:	687b      	ldr	r3, [r7, #4]
 800706c:	0018      	movs	r0, r3
 800706e:	f002 fc5a 	bl	8009926 <LDL_Stream_error>
 8007072:	1e03      	subs	r3, r0, #0
 8007074:	d106      	bne.n	8007084 <LDL_MAC_getDownCommand+0x314>
 8007076:	2317      	movs	r3, #23
 8007078:	18fb      	adds	r3, r7, r3
 800707a:	781b      	ldrb	r3, [r3, #0]
 800707c:	2b00      	cmp	r3, #0
 800707e:	d001      	beq.n	8007084 <LDL_MAC_getDownCommand+0x314>
 8007080:	2301      	movs	r3, #1
 8007082:	e000      	b.n	8007086 <LDL_MAC_getDownCommand+0x316>
 8007084:	2300      	movs	r3, #0
}
 8007086:	0018      	movs	r0, r3
 8007088:	46bd      	mov	sp, r7
 800708a:	b006      	add	sp, #24
 800708c:	bdb0      	pop	{r4, r5, r7, pc}
 800708e:	46c0      	nop			; (mov r8, r8)
 8007090:	0800e538 	.word	0x0800e538

08007094 <typeToTag>:

/* static functions ***************************************************/

static uint8_t typeToTag(enum ldl_mac_cmd_type type)
{
 8007094:	b580      	push	{r7, lr}
 8007096:	b082      	sub	sp, #8
 8007098:	af00      	add	r7, sp, #0
 800709a:	0002      	movs	r2, r0
 800709c:	1dfb      	adds	r3, r7, #7
 800709e:	701a      	strb	r2, [r3, #0]
    return tags[type].tag;
 80070a0:	1dfb      	adds	r3, r7, #7
 80070a2:	781a      	ldrb	r2, [r3, #0]
 80070a4:	4b03      	ldr	r3, [pc, #12]	; (80070b4 <typeToTag+0x20>)
 80070a6:	0052      	lsls	r2, r2, #1
 80070a8:	5cd3      	ldrb	r3, [r2, r3]
}
 80070aa:	0018      	movs	r0, r3
 80070ac:	46bd      	mov	sp, r7
 80070ae:	b002      	add	sp, #8
 80070b0:	bd80      	pop	{r7, pc}
 80070b2:	46c0      	nop			; (mov r8, r8)
 80070b4:	0800e51c 	.word	0x0800e51c

080070b8 <tagToType>:

static bool tagToType(uint8_t tag, enum ldl_mac_cmd_type *type)
{
 80070b8:	b580      	push	{r7, lr}
 80070ba:	b084      	sub	sp, #16
 80070bc:	af00      	add	r7, sp, #0
 80070be:	0002      	movs	r2, r0
 80070c0:	6039      	str	r1, [r7, #0]
 80070c2:	1dfb      	adds	r3, r7, #7
 80070c4:	701a      	strb	r2, [r3, #0]
    bool retval = false;
 80070c6:	230f      	movs	r3, #15
 80070c8:	18fb      	adds	r3, r7, r3
 80070ca:	2200      	movs	r2, #0
 80070cc:	701a      	strb	r2, [r3, #0]
    uint8_t i;
    
    for(i=0U; i < (sizeof(tags)/sizeof(*tags)); i++){
 80070ce:	230e      	movs	r3, #14
 80070d0:	18fb      	adds	r3, r7, r3
 80070d2:	2200      	movs	r2, #0
 80070d4:	701a      	strb	r2, [r3, #0]
 80070d6:	e01e      	b.n	8007116 <tagToType+0x5e>
        
        if(tags[i].tag == tag){
 80070d8:	230e      	movs	r3, #14
 80070da:	18fb      	adds	r3, r7, r3
 80070dc:	781a      	ldrb	r2, [r3, #0]
 80070de:	4b14      	ldr	r3, [pc, #80]	; (8007130 <tagToType+0x78>)
 80070e0:	0052      	lsls	r2, r2, #1
 80070e2:	5cd3      	ldrb	r3, [r2, r3]
 80070e4:	1dfa      	adds	r2, r7, #7
 80070e6:	7812      	ldrb	r2, [r2, #0]
 80070e8:	429a      	cmp	r2, r3
 80070ea:	d10e      	bne.n	800710a <tagToType+0x52>
            
            *type = tags[i].type;
 80070ec:	230e      	movs	r3, #14
 80070ee:	18fb      	adds	r3, r7, r3
 80070f0:	781b      	ldrb	r3, [r3, #0]
 80070f2:	4a0f      	ldr	r2, [pc, #60]	; (8007130 <tagToType+0x78>)
 80070f4:	005b      	lsls	r3, r3, #1
 80070f6:	18d3      	adds	r3, r2, r3
 80070f8:	3301      	adds	r3, #1
 80070fa:	781a      	ldrb	r2, [r3, #0]
 80070fc:	683b      	ldr	r3, [r7, #0]
 80070fe:	701a      	strb	r2, [r3, #0]
            retval = true;
 8007100:	230f      	movs	r3, #15
 8007102:	18fb      	adds	r3, r7, r3
 8007104:	2201      	movs	r2, #1
 8007106:	701a      	strb	r2, [r3, #0]
            break;
 8007108:	e00a      	b.n	8007120 <tagToType+0x68>
    for(i=0U; i < (sizeof(tags)/sizeof(*tags)); i++){
 800710a:	210e      	movs	r1, #14
 800710c:	187b      	adds	r3, r7, r1
 800710e:	781a      	ldrb	r2, [r3, #0]
 8007110:	187b      	adds	r3, r7, r1
 8007112:	3201      	adds	r2, #1
 8007114:	701a      	strb	r2, [r3, #0]
 8007116:	230e      	movs	r3, #14
 8007118:	18fb      	adds	r3, r7, r3
 800711a:	781b      	ldrb	r3, [r3, #0]
 800711c:	2b0d      	cmp	r3, #13
 800711e:	d9db      	bls.n	80070d8 <tagToType+0x20>
        }
    }
    
    return retval;
 8007120:	230f      	movs	r3, #15
 8007122:	18fb      	adds	r3, r7, r3
 8007124:	781b      	ldrb	r3, [r3, #0]
}
 8007126:	0018      	movs	r0, r3
 8007128:	46bd      	mov	sp, r7
 800712a:	b004      	add	sp, #16
 800712c:	bd80      	pop	{r7, pc}
 800712e:	46c0      	nop			; (mov r8, r8)
 8007130:	0800e51c 	.word	0x0800e51c

08007134 <LDL_OPS_syncDownCounter>:
static uint8_t putEUI(uint8_t *buf, const uint8_t *value);

/* functions **********************************************************/

void LDL_OPS_syncDownCounter(struct ldl_mac *self, uint8_t port, uint16_t counter)
{
 8007134:	b580      	push	{r7, lr}
 8007136:	b084      	sub	sp, #16
 8007138:	af00      	add	r7, sp, #0
 800713a:	6078      	str	r0, [r7, #4]
 800713c:	0008      	movs	r0, r1
 800713e:	0011      	movs	r1, r2
 8007140:	1cfb      	adds	r3, r7, #3
 8007142:	1c02      	adds	r2, r0, #0
 8007144:	701a      	strb	r2, [r3, #0]
 8007146:	003b      	movs	r3, r7
 8007148:	1c0a      	adds	r2, r1, #0
 800714a:	801a      	strh	r2, [r3, #0]
    LDL_PEDANTIC(self != NULL)
    
    uint32_t derived;
    
    derived = deriveDownCounter(self, port, counter);
 800714c:	003b      	movs	r3, r7
 800714e:	881a      	ldrh	r2, [r3, #0]
 8007150:	1cfb      	adds	r3, r7, #3
 8007152:	7819      	ldrb	r1, [r3, #0]
 8007154:	687b      	ldr	r3, [r7, #4]
 8007156:	0018      	movs	r0, r3
 8007158:	f000 fd9a 	bl	8007c90 <deriveDownCounter>
 800715c:	0003      	movs	r3, r0
 800715e:	60fb      	str	r3, [r7, #12]
    
    if((self->ctx.version > 0U) && (port == 0U)){
 8007160:	687b      	ldr	r3, [r7, #4]
 8007162:	4a0d      	ldr	r2, [pc, #52]	; (8007198 <LDL_OPS_syncDownCounter+0x64>)
 8007164:	5c9b      	ldrb	r3, [r3, r2]
 8007166:	2b00      	cmp	r3, #0
 8007168:	d00b      	beq.n	8007182 <LDL_OPS_syncDownCounter+0x4e>
 800716a:	1cfb      	adds	r3, r7, #3
 800716c:	781b      	ldrb	r3, [r3, #0]
 800716e:	2b00      	cmp	r3, #0
 8007170:	d107      	bne.n	8007182 <LDL_OPS_syncDownCounter+0x4e>
        
        self->ctx.nwkDown = (uint16_t)(derived >> 16);
 8007172:	68fb      	ldr	r3, [r7, #12]
 8007174:	0c1b      	lsrs	r3, r3, #16
 8007176:	b299      	uxth	r1, r3
 8007178:	687a      	ldr	r2, [r7, #4]
 800717a:	23b1      	movs	r3, #177	; 0xb1
 800717c:	005b      	lsls	r3, r3, #1
 800717e:	52d1      	strh	r1, [r2, r3]
 8007180:	e006      	b.n	8007190 <LDL_OPS_syncDownCounter+0x5c>
    }
    else{
        
        self->ctx.appDown = (uint16_t)(derived >> 16);
 8007182:	68fb      	ldr	r3, [r7, #12]
 8007184:	0c1b      	lsrs	r3, r3, #16
 8007186:	b299      	uxth	r1, r3
 8007188:	687a      	ldr	r2, [r7, #4]
 800718a:	23b0      	movs	r3, #176	; 0xb0
 800718c:	005b      	lsls	r3, r3, #1
 800718e:	52d1      	strh	r1, [r2, r3]
    }    
}
 8007190:	46c0      	nop			; (mov r8, r8)
 8007192:	46bd      	mov	sp, r7
 8007194:	b004      	add	sp, #16
 8007196:	bd80      	pop	{r7, pc}
 8007198:	00000206 	.word	0x00000206

0800719c <LDL_OPS_deriveKeys>:
         
void LDL_OPS_deriveKeys(struct ldl_mac *self)
{
 800719c:	b590      	push	{r4, r7, lr}
 800719e:	b089      	sub	sp, #36	; 0x24
 80071a0:	af00      	add	r7, sp, #0
 80071a2:	6078      	str	r0, [r7, #4]
    
    struct ldl_block iv;
    uint8_t *ptr;
    uint8_t pos;
    
    ptr = iv.value;
 80071a4:	2208      	movs	r2, #8
 80071a6:	18bb      	adds	r3, r7, r2
 80071a8:	61fb      	str	r3, [r7, #28]
    
    (void)memset(&iv, 0, sizeof(iv));
 80071aa:	18bb      	adds	r3, r7, r2
 80071ac:	2210      	movs	r2, #16
 80071ae:	2100      	movs	r1, #0
 80071b0:	0018      	movs	r0, r3
 80071b2:	f005 fb92 	bl	800c8da <memset>
    
    LDL_SM_beginUpdateSessionKey(self->sm); 
 80071b6:	687a      	ldr	r2, [r7, #4]
 80071b8:	2387      	movs	r3, #135	; 0x87
 80071ba:	009b      	lsls	r3, r3, #2
 80071bc:	58d3      	ldr	r3, [r2, r3]
 80071be:	0018      	movs	r0, r3
 80071c0:	f001 ffe0 	bl	8009184 <LDL_SM_beginUpdateSessionKey>
    {
        if(self->ctx.version == 0U){
 80071c4:	687b      	ldr	r3, [r7, #4]
 80071c6:	4a68      	ldr	r2, [pc, #416]	; (8007368 <LDL_OPS_deriveKeys+0x1cc>)
 80071c8:	5c9b      	ldrb	r3, [r3, r2]
 80071ca:	2b00      	cmp	r3, #0
 80071cc:	d15e      	bne.n	800728c <LDL_OPS_deriveKeys+0xf0>
            
            /* ptr[0] below */    
            pos = 1U;
 80071ce:	241b      	movs	r4, #27
 80071d0:	193b      	adds	r3, r7, r4
 80071d2:	2201      	movs	r2, #1
 80071d4:	701a      	strb	r2, [r3, #0]
            pos += putU24(&ptr[pos], self->joinNonce);
 80071d6:	193b      	adds	r3, r7, r4
 80071d8:	781b      	ldrb	r3, [r3, #0]
 80071da:	69fa      	ldr	r2, [r7, #28]
 80071dc:	18d0      	adds	r0, r2, r3
 80071de:	687a      	ldr	r2, [r7, #4]
 80071e0:	239c      	movs	r3, #156	; 0x9c
 80071e2:	005b      	lsls	r3, r3, #1
 80071e4:	58d3      	ldr	r3, [r2, r3]
 80071e6:	0019      	movs	r1, r3
 80071e8:	f000 fdea 	bl	8007dc0 <putU24>
 80071ec:	0003      	movs	r3, r0
 80071ee:	0019      	movs	r1, r3
 80071f0:	193b      	adds	r3, r7, r4
 80071f2:	193a      	adds	r2, r7, r4
 80071f4:	7812      	ldrb	r2, [r2, #0]
 80071f6:	188a      	adds	r2, r1, r2
 80071f8:	701a      	strb	r2, [r3, #0]
            pos += putU24(&ptr[pos], self->ctx.netID);
 80071fa:	193b      	adds	r3, r7, r4
 80071fc:	781b      	ldrb	r3, [r3, #0]
 80071fe:	69fa      	ldr	r2, [r7, #28]
 8007200:	18d0      	adds	r0, r2, r3
 8007202:	687a      	ldr	r2, [r7, #4]
 8007204:	23b4      	movs	r3, #180	; 0xb4
 8007206:	005b      	lsls	r3, r3, #1
 8007208:	58d3      	ldr	r3, [r2, r3]
 800720a:	0019      	movs	r1, r3
 800720c:	f000 fdd8 	bl	8007dc0 <putU24>
 8007210:	0003      	movs	r3, r0
 8007212:	0019      	movs	r1, r3
 8007214:	193b      	adds	r3, r7, r4
 8007216:	193a      	adds	r2, r7, r4
 8007218:	7812      	ldrb	r2, [r2, #0]
 800721a:	188a      	adds	r2, r1, r2
 800721c:	701a      	strb	r2, [r3, #0]
            (void)putU16(&ptr[pos], self->devNonce);
 800721e:	193b      	adds	r3, r7, r4
 8007220:	781b      	ldrb	r3, [r3, #0]
 8007222:	69fa      	ldr	r2, [r7, #28]
 8007224:	18d0      	adds	r0, r2, r3
 8007226:	687a      	ldr	r2, [r7, #4]
 8007228:	239a      	movs	r3, #154	; 0x9a
 800722a:	005b      	lsls	r3, r3, #1
 800722c:	5ad3      	ldrh	r3, [r2, r3]
 800722e:	0019      	movs	r1, r3
 8007230:	f000 fdad 	bl	8007d8e <putU16>
            
            ptr[0] = 2U;
 8007234:	69fb      	ldr	r3, [r7, #28]
 8007236:	2202      	movs	r2, #2
 8007238:	701a      	strb	r2, [r3, #0]
            LDL_SM_updateSessionKey(self->sm, LDL_SM_KEY_APPS, LDL_SM_KEY_NWK, &iv);
 800723a:	687a      	ldr	r2, [r7, #4]
 800723c:	2387      	movs	r3, #135	; 0x87
 800723e:	009b      	lsls	r3, r3, #2
 8007240:	58d0      	ldr	r0, [r2, r3]
 8007242:	2408      	movs	r4, #8
 8007244:	193b      	adds	r3, r7, r4
 8007246:	2207      	movs	r2, #7
 8007248:	2101      	movs	r1, #1
 800724a:	f001 ffab 	bl	80091a4 <LDL_SM_updateSessionKey>
            
            ptr[0] = 1U;
 800724e:	69fb      	ldr	r3, [r7, #28]
 8007250:	2201      	movs	r2, #1
 8007252:	701a      	strb	r2, [r3, #0]
            LDL_SM_updateSessionKey(self->sm, LDL_SM_KEY_FNWKSINT, LDL_SM_KEY_NWK, &iv);    
 8007254:	687a      	ldr	r2, [r7, #4]
 8007256:	2387      	movs	r3, #135	; 0x87
 8007258:	009b      	lsls	r3, r3, #2
 800725a:	58d0      	ldr	r0, [r2, r3]
 800725c:	193b      	adds	r3, r7, r4
 800725e:	2207      	movs	r2, #7
 8007260:	2100      	movs	r1, #0
 8007262:	f001 ff9f 	bl	80091a4 <LDL_SM_updateSessionKey>
            LDL_SM_updateSessionKey(self->sm, LDL_SM_KEY_SNWKSINT, LDL_SM_KEY_NWK, &iv);
 8007266:	687a      	ldr	r2, [r7, #4]
 8007268:	2387      	movs	r3, #135	; 0x87
 800726a:	009b      	lsls	r3, r3, #2
 800726c:	58d0      	ldr	r0, [r2, r3]
 800726e:	193b      	adds	r3, r7, r4
 8007270:	2207      	movs	r2, #7
 8007272:	2102      	movs	r1, #2
 8007274:	f001 ff96 	bl	80091a4 <LDL_SM_updateSessionKey>
            LDL_SM_updateSessionKey(self->sm, LDL_SM_KEY_NWKSENC, LDL_SM_KEY_NWK, &iv);
 8007278:	687a      	ldr	r2, [r7, #4]
 800727a:	2387      	movs	r3, #135	; 0x87
 800727c:	009b      	lsls	r3, r3, #2
 800727e:	58d0      	ldr	r0, [r2, r3]
 8007280:	193b      	adds	r3, r7, r4
 8007282:	2207      	movs	r2, #7
 8007284:	2103      	movs	r1, #3
 8007286:	f001 ff8d 	bl	80091a4 <LDL_SM_updateSessionKey>
 800728a:	e062      	b.n	8007352 <LDL_OPS_deriveKeys+0x1b6>
        }
        else{
            
            /* ptr[0] below */ 
            pos = 1U;
 800728c:	241b      	movs	r4, #27
 800728e:	193b      	adds	r3, r7, r4
 8007290:	2201      	movs	r2, #1
 8007292:	701a      	strb	r2, [r3, #0]
            pos += putU24(&ptr[pos], self->joinNonce);
 8007294:	193b      	adds	r3, r7, r4
 8007296:	781b      	ldrb	r3, [r3, #0]
 8007298:	69fa      	ldr	r2, [r7, #28]
 800729a:	18d0      	adds	r0, r2, r3
 800729c:	687a      	ldr	r2, [r7, #4]
 800729e:	239c      	movs	r3, #156	; 0x9c
 80072a0:	005b      	lsls	r3, r3, #1
 80072a2:	58d3      	ldr	r3, [r2, r3]
 80072a4:	0019      	movs	r1, r3
 80072a6:	f000 fd8b 	bl	8007dc0 <putU24>
 80072aa:	0003      	movs	r3, r0
 80072ac:	0019      	movs	r1, r3
 80072ae:	193b      	adds	r3, r7, r4
 80072b0:	193a      	adds	r2, r7, r4
 80072b2:	7812      	ldrb	r2, [r2, #0]
 80072b4:	188a      	adds	r2, r1, r2
 80072b6:	701a      	strb	r2, [r3, #0]
            pos += putEUI(&ptr[pos], self->joinEUI);
 80072b8:	193b      	adds	r3, r7, r4
 80072ba:	781b      	ldrb	r3, [r3, #0]
 80072bc:	69fa      	ldr	r2, [r7, #28]
 80072be:	18d2      	adds	r2, r2, r3
 80072c0:	687b      	ldr	r3, [r7, #4]
 80072c2:	3303      	adds	r3, #3
 80072c4:	0019      	movs	r1, r3
 80072c6:	0010      	movs	r0, r2
 80072c8:	f000 fd20 	bl	8007d0c <putEUI>
 80072cc:	0003      	movs	r3, r0
 80072ce:	0019      	movs	r1, r3
 80072d0:	193b      	adds	r3, r7, r4
 80072d2:	193a      	adds	r2, r7, r4
 80072d4:	7812      	ldrb	r2, [r2, #0]
 80072d6:	188a      	adds	r2, r1, r2
 80072d8:	701a      	strb	r2, [r3, #0]
            (void)putU16(&ptr[pos], self->devNonce);
 80072da:	193b      	adds	r3, r7, r4
 80072dc:	781b      	ldrb	r3, [r3, #0]
 80072de:	69fa      	ldr	r2, [r7, #28]
 80072e0:	18d0      	adds	r0, r2, r3
 80072e2:	687a      	ldr	r2, [r7, #4]
 80072e4:	239a      	movs	r3, #154	; 0x9a
 80072e6:	005b      	lsls	r3, r3, #1
 80072e8:	5ad3      	ldrh	r3, [r2, r3]
 80072ea:	0019      	movs	r1, r3
 80072ec:	f000 fd4f 	bl	8007d8e <putU16>
               
            ptr[0] = 1U;
 80072f0:	69fb      	ldr	r3, [r7, #28]
 80072f2:	2201      	movs	r2, #1
 80072f4:	701a      	strb	r2, [r3, #0]
            LDL_SM_updateSessionKey(self->sm, LDL_SM_KEY_FNWKSINT, LDL_SM_KEY_NWK, &iv);    
 80072f6:	687a      	ldr	r2, [r7, #4]
 80072f8:	2387      	movs	r3, #135	; 0x87
 80072fa:	009b      	lsls	r3, r3, #2
 80072fc:	58d0      	ldr	r0, [r2, r3]
 80072fe:	2408      	movs	r4, #8
 8007300:	193b      	adds	r3, r7, r4
 8007302:	2207      	movs	r2, #7
 8007304:	2100      	movs	r1, #0
 8007306:	f001 ff4d 	bl	80091a4 <LDL_SM_updateSessionKey>
            
            ptr[0] = 2U;
 800730a:	69fb      	ldr	r3, [r7, #28]
 800730c:	2202      	movs	r2, #2
 800730e:	701a      	strb	r2, [r3, #0]
            LDL_SM_updateSessionKey(self->sm, LDL_SM_KEY_APPS, LDL_SM_KEY_APP, &iv);
 8007310:	687a      	ldr	r2, [r7, #4]
 8007312:	2387      	movs	r3, #135	; 0x87
 8007314:	009b      	lsls	r3, r3, #2
 8007316:	58d0      	ldr	r0, [r2, r3]
 8007318:	193b      	adds	r3, r7, r4
 800731a:	2206      	movs	r2, #6
 800731c:	2101      	movs	r1, #1
 800731e:	f001 ff41 	bl	80091a4 <LDL_SM_updateSessionKey>
            
            ptr[0] = 3U;
 8007322:	69fb      	ldr	r3, [r7, #28]
 8007324:	2203      	movs	r2, #3
 8007326:	701a      	strb	r2, [r3, #0]
            LDL_SM_updateSessionKey(self->sm, LDL_SM_KEY_SNWKSINT, LDL_SM_KEY_NWK, &iv);
 8007328:	687a      	ldr	r2, [r7, #4]
 800732a:	2387      	movs	r3, #135	; 0x87
 800732c:	009b      	lsls	r3, r3, #2
 800732e:	58d0      	ldr	r0, [r2, r3]
 8007330:	193b      	adds	r3, r7, r4
 8007332:	2207      	movs	r2, #7
 8007334:	2102      	movs	r1, #2
 8007336:	f001 ff35 	bl	80091a4 <LDL_SM_updateSessionKey>
            
            ptr[0] = 4U;
 800733a:	69fb      	ldr	r3, [r7, #28]
 800733c:	2204      	movs	r2, #4
 800733e:	701a      	strb	r2, [r3, #0]
            LDL_SM_updateSessionKey(self->sm, LDL_SM_KEY_NWKSENC, LDL_SM_KEY_NWK, &iv);                               
 8007340:	687a      	ldr	r2, [r7, #4]
 8007342:	2387      	movs	r3, #135	; 0x87
 8007344:	009b      	lsls	r3, r3, #2
 8007346:	58d0      	ldr	r0, [r2, r3]
 8007348:	193b      	adds	r3, r7, r4
 800734a:	2207      	movs	r2, #7
 800734c:	2103      	movs	r1, #3
 800734e:	f001 ff29 	bl	80091a4 <LDL_SM_updateSessionKey>
        }        
    }    
    LDL_SM_endUpdateSessionKey(self->sm);    
 8007352:	687a      	ldr	r2, [r7, #4]
 8007354:	2387      	movs	r3, #135	; 0x87
 8007356:	009b      	lsls	r3, r3, #2
 8007358:	58d3      	ldr	r3, [r2, r3]
 800735a:	0018      	movs	r0, r3
 800735c:	f001 ff1a 	bl	8009194 <LDL_SM_endUpdateSessionKey>
}
 8007360:	46c0      	nop			; (mov r8, r8)
 8007362:	46bd      	mov	sp, r7
 8007364:	b009      	add	sp, #36	; 0x24
 8007366:	bd90      	pop	{r4, r7, pc}
 8007368:	00000206 	.word	0x00000206

0800736c <LDL_OPS_prepareData>:
    LDL_SM_endUpdateSessionKey(self->sm);        
}
#endif

uint8_t LDL_OPS_prepareData(struct ldl_mac *self, const struct ldl_frame_data *f, uint8_t *out, uint8_t max)
{
 800736c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800736e:	b08d      	sub	sp, #52	; 0x34
 8007370:	af02      	add	r7, sp, #8
 8007372:	60f8      	str	r0, [r7, #12]
 8007374:	60b9      	str	r1, [r7, #8]
 8007376:	607a      	str	r2, [r7, #4]
 8007378:	001a      	movs	r2, r3
 800737a:	1cfb      	adds	r3, r7, #3
 800737c:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(self != NULL)
    
    struct ldl_frame_data_offset off;
    uint8_t retval = 0U;
 800737e:	2627      	movs	r6, #39	; 0x27
 8007380:	19bb      	adds	r3, r7, r6
 8007382:	2200      	movs	r2, #0
 8007384:	701a      	strb	r2, [r3, #0]
    
    retval = LDL_Frame_putData(f, out, max, &off);
 8007386:	19bc      	adds	r4, r7, r6
 8007388:	2324      	movs	r3, #36	; 0x24
 800738a:	18fd      	adds	r5, r7, r3
 800738c:	1cfb      	adds	r3, r7, #3
 800738e:	781a      	ldrb	r2, [r3, #0]
 8007390:	6879      	ldr	r1, [r7, #4]
 8007392:	68b8      	ldr	r0, [r7, #8]
 8007394:	002b      	movs	r3, r5
 8007396:	f7fa ff15 	bl	80021c4 <LDL_Frame_putData>
 800739a:	0003      	movs	r3, r0
 800739c:	7023      	strb	r3, [r4, #0]

    if(retval > 0U){
 800739e:	19bb      	adds	r3, r7, r6
 80073a0:	781b      	ldrb	r3, [r3, #0]
 80073a2:	2b00      	cmp	r3, #0
 80073a4:	d049      	beq.n	800743a <LDL_OPS_prepareData+0xce>

        
        struct ldl_block A;
        
        /* encrypt fopt (LoRaWAN 1.1) */
        if(self->ctx.version == 1U){
 80073a6:	68fb      	ldr	r3, [r7, #12]
 80073a8:	4a27      	ldr	r2, [pc, #156]	; (8007448 <LDL_OPS_prepareData+0xdc>)
 80073aa:	5c9b      	ldrb	r3, [r3, r2]
 80073ac:	2b01      	cmp	r3, #1
 80073ae:	d11e      	bne.n	80073ee <LDL_OPS_prepareData+0x82>
            
            initA(&A, f->devAddr, true, f->counter, 0U);
 80073b0:	68bb      	ldr	r3, [r7, #8]
 80073b2:	6859      	ldr	r1, [r3, #4]
 80073b4:	68bb      	ldr	r3, [r7, #8]
 80073b6:	891b      	ldrh	r3, [r3, #8]
 80073b8:	001a      	movs	r2, r3
 80073ba:	2414      	movs	r4, #20
 80073bc:	1938      	adds	r0, r7, r4
 80073be:	2300      	movs	r3, #0
 80073c0:	9300      	str	r3, [sp, #0]
 80073c2:	0013      	movs	r3, r2
 80073c4:	2201      	movs	r2, #1
 80073c6:	f000 fb39 	bl	8007a3c <initA>
            
            LDL_SM_ctr(self->sm, LDL_SM_KEY_NWKSENC, &A, &out[off.opts], f->optsLen);            
 80073ca:	68fa      	ldr	r2, [r7, #12]
 80073cc:	2387      	movs	r3, #135	; 0x87
 80073ce:	009b      	lsls	r3, r3, #2
 80073d0:	58d0      	ldr	r0, [r2, r3]
 80073d2:	2324      	movs	r3, #36	; 0x24
 80073d4:	18fb      	adds	r3, r7, r3
 80073d6:	781b      	ldrb	r3, [r3, #0]
 80073d8:	001a      	movs	r2, r3
 80073da:	687b      	ldr	r3, [r7, #4]
 80073dc:	1899      	adds	r1, r3, r2
 80073de:	68bb      	ldr	r3, [r7, #8]
 80073e0:	7d1b      	ldrb	r3, [r3, #20]
 80073e2:	193a      	adds	r2, r7, r4
 80073e4:	9300      	str	r3, [sp, #0]
 80073e6:	000b      	movs	r3, r1
 80073e8:	2103      	movs	r1, #3
 80073ea:	f001 ffd2 	bl	8009392 <LDL_SM_ctr>
        }
        
        initA(&A, f->devAddr, true, f->counter, 1U);
 80073ee:	68bb      	ldr	r3, [r7, #8]
 80073f0:	6859      	ldr	r1, [r3, #4]
 80073f2:	68bb      	ldr	r3, [r7, #8]
 80073f4:	891b      	ldrh	r3, [r3, #8]
 80073f6:	001a      	movs	r2, r3
 80073f8:	2314      	movs	r3, #20
 80073fa:	18f8      	adds	r0, r7, r3
 80073fc:	2301      	movs	r3, #1
 80073fe:	9300      	str	r3, [sp, #0]
 8007400:	0013      	movs	r3, r2
 8007402:	2201      	movs	r2, #1
 8007404:	f000 fb1a 	bl	8007a3c <initA>
        
        /* encrypt data */
        LDL_SM_ctr(self->sm, (f->port == 0U) ? LDL_SM_KEY_NWKSENC : LDL_SM_KEY_APPS, &A, &out[off.data], f->dataLen);                
 8007408:	68fa      	ldr	r2, [r7, #12]
 800740a:	2387      	movs	r3, #135	; 0x87
 800740c:	009b      	lsls	r3, r3, #2
 800740e:	58d0      	ldr	r0, [r2, r3]
 8007410:	68bb      	ldr	r3, [r7, #8]
 8007412:	7d5b      	ldrb	r3, [r3, #21]
 8007414:	2b00      	cmp	r3, #0
 8007416:	d101      	bne.n	800741c <LDL_OPS_prepareData+0xb0>
 8007418:	2103      	movs	r1, #3
 800741a:	e000      	b.n	800741e <LDL_OPS_prepareData+0xb2>
 800741c:	2101      	movs	r1, #1
 800741e:	2324      	movs	r3, #36	; 0x24
 8007420:	18fb      	adds	r3, r7, r3
 8007422:	785b      	ldrb	r3, [r3, #1]
 8007424:	001a      	movs	r2, r3
 8007426:	687b      	ldr	r3, [r7, #4]
 8007428:	189c      	adds	r4, r3, r2
 800742a:	68bb      	ldr	r3, [r7, #8]
 800742c:	7f1b      	ldrb	r3, [r3, #28]
 800742e:	2214      	movs	r2, #20
 8007430:	18ba      	adds	r2, r7, r2
 8007432:	9300      	str	r3, [sp, #0]
 8007434:	0023      	movs	r3, r4
 8007436:	f001 ffac 	bl	8009392 <LDL_SM_ctr>
        
    }
     
    return retval;
 800743a:	2327      	movs	r3, #39	; 0x27
 800743c:	18fb      	adds	r3, r7, r3
 800743e:	781b      	ldrb	r3, [r3, #0]
}
 8007440:	0018      	movs	r0, r3
 8007442:	46bd      	mov	sp, r7
 8007444:	b00b      	add	sp, #44	; 0x2c
 8007446:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007448:	00000206 	.word	0x00000206

0800744c <LDL_OPS_micDataFrame>:

void LDL_OPS_micDataFrame(struct ldl_mac *self, void *buffer, uint8_t size)
{
 800744c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800744e:	b093      	sub	sp, #76	; 0x4c
 8007450:	af04      	add	r7, sp, #16
 8007452:	60f8      	str	r0, [r7, #12]
 8007454:	60b9      	str	r1, [r7, #8]
 8007456:	1dfb      	adds	r3, r7, #7
 8007458:	701a      	strb	r2, [r3, #0]
    struct ldl_block B0;
    struct ldl_block B1;            
    uint32_t micS;
    uint32_t micF;
    
    initB(&B0, 0U, 0U, 0U, true, self->ctx.devAddr, self->tx.counter, size - sizeof(micF)); 
 800745a:	68fa      	ldr	r2, [r7, #12]
 800745c:	23b2      	movs	r3, #178	; 0xb2
 800745e:	005b      	lsls	r3, r3, #1
 8007460:	58d3      	ldr	r3, [r2, r3]
 8007462:	68f9      	ldr	r1, [r7, #12]
 8007464:	22a4      	movs	r2, #164	; 0xa4
 8007466:	0052      	lsls	r2, r2, #1
 8007468:	588a      	ldr	r2, [r1, r2]
 800746a:	1df9      	adds	r1, r7, #7
 800746c:	7809      	ldrb	r1, [r1, #0]
 800746e:	3904      	subs	r1, #4
 8007470:	b2c9      	uxtb	r1, r1
 8007472:	2620      	movs	r6, #32
 8007474:	19b8      	adds	r0, r7, r6
 8007476:	9103      	str	r1, [sp, #12]
 8007478:	9202      	str	r2, [sp, #8]
 800747a:	9301      	str	r3, [sp, #4]
 800747c:	2301      	movs	r3, #1
 800747e:	9300      	str	r3, [sp, #0]
 8007480:	2300      	movs	r3, #0
 8007482:	2200      	movs	r2, #0
 8007484:	2100      	movs	r1, #0
 8007486:	f000 fb59 	bl	8007b3c <initB>
    initB(&B1, 0U, self->tx.rate, self->tx.chIndex, true, self->ctx.devAddr, self->tx.counter, size - sizeof(micS));
 800748a:	68fa      	ldr	r2, [r7, #12]
 800748c:	234e      	movs	r3, #78	; 0x4e
 800748e:	33ff      	adds	r3, #255	; 0xff
 8007490:	5cd4      	ldrb	r4, [r2, r3]
 8007492:	68fa      	ldr	r2, [r7, #12]
 8007494:	23a6      	movs	r3, #166	; 0xa6
 8007496:	005b      	lsls	r3, r3, #1
 8007498:	5cd5      	ldrb	r5, [r2, r3]
 800749a:	68fa      	ldr	r2, [r7, #12]
 800749c:	23b2      	movs	r3, #178	; 0xb2
 800749e:	005b      	lsls	r3, r3, #1
 80074a0:	58d3      	ldr	r3, [r2, r3]
 80074a2:	68f9      	ldr	r1, [r7, #12]
 80074a4:	22a4      	movs	r2, #164	; 0xa4
 80074a6:	0052      	lsls	r2, r2, #1
 80074a8:	588a      	ldr	r2, [r1, r2]
 80074aa:	1df9      	adds	r1, r7, #7
 80074ac:	7809      	ldrb	r1, [r1, #0]
 80074ae:	3904      	subs	r1, #4
 80074b0:	b2c9      	uxtb	r1, r1
 80074b2:	2010      	movs	r0, #16
 80074b4:	1838      	adds	r0, r7, r0
 80074b6:	9103      	str	r1, [sp, #12]
 80074b8:	9202      	str	r2, [sp, #8]
 80074ba:	9301      	str	r3, [sp, #4]
 80074bc:	2301      	movs	r3, #1
 80074be:	9300      	str	r3, [sp, #0]
 80074c0:	002b      	movs	r3, r5
 80074c2:	0022      	movs	r2, r4
 80074c4:	2100      	movs	r1, #0
 80074c6:	f000 fb39 	bl	8007b3c <initB>

    micF = LDL_SM_mic(self->sm, LDL_SM_KEY_FNWKSINT, &B0, sizeof(B0.value), buffer, size - sizeof(micF));       
 80074ca:	68fa      	ldr	r2, [r7, #12]
 80074cc:	2387      	movs	r3, #135	; 0x87
 80074ce:	009b      	lsls	r3, r3, #2
 80074d0:	58d0      	ldr	r0, [r2, r3]
 80074d2:	1dfb      	adds	r3, r7, #7
 80074d4:	781b      	ldrb	r3, [r3, #0]
 80074d6:	3b04      	subs	r3, #4
 80074d8:	b2db      	uxtb	r3, r3
 80074da:	19ba      	adds	r2, r7, r6
 80074dc:	9301      	str	r3, [sp, #4]
 80074de:	68bb      	ldr	r3, [r7, #8]
 80074e0:	9300      	str	r3, [sp, #0]
 80074e2:	2310      	movs	r3, #16
 80074e4:	2100      	movs	r1, #0
 80074e6:	f001 fea1 	bl	800922c <LDL_SM_mic>
 80074ea:	0003      	movs	r3, r0
 80074ec:	637b      	str	r3, [r7, #52]	; 0x34

    if(self->ctx.version == 1U){
 80074ee:	68fb      	ldr	r3, [r7, #12]
 80074f0:	4a17      	ldr	r2, [pc, #92]	; (8007550 <LDL_OPS_micDataFrame+0x104>)
 80074f2:	5c9b      	ldrb	r3, [r3, r2]
 80074f4:	2b01      	cmp	r3, #1
 80074f6:	d11f      	bne.n	8007538 <LDL_OPS_micDataFrame+0xec>
    
        micS = LDL_SM_mic(self->sm, LDL_SM_KEY_SNWKSINT, &B1, sizeof(B1.value), buffer, size - sizeof(micS));
 80074f8:	68fa      	ldr	r2, [r7, #12]
 80074fa:	2387      	movs	r3, #135	; 0x87
 80074fc:	009b      	lsls	r3, r3, #2
 80074fe:	58d0      	ldr	r0, [r2, r3]
 8007500:	1dfb      	adds	r3, r7, #7
 8007502:	781b      	ldrb	r3, [r3, #0]
 8007504:	3b04      	subs	r3, #4
 8007506:	b2db      	uxtb	r3, r3
 8007508:	2210      	movs	r2, #16
 800750a:	18ba      	adds	r2, r7, r2
 800750c:	9301      	str	r3, [sp, #4]
 800750e:	68bb      	ldr	r3, [r7, #8]
 8007510:	9300      	str	r3, [sp, #0]
 8007512:	2310      	movs	r3, #16
 8007514:	2102      	movs	r1, #2
 8007516:	f001 fe89 	bl	800922c <LDL_SM_mic>
 800751a:	0003      	movs	r3, r0
 800751c:	633b      	str	r3, [r7, #48]	; 0x30
        
        LDL_Frame_updateMIC(buffer, size, ((micF << 16) | (micS & 0xffffUL))); 
 800751e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007520:	041a      	lsls	r2, r3, #16
 8007522:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007524:	041b      	lsls	r3, r3, #16
 8007526:	0c1b      	lsrs	r3, r3, #16
 8007528:	431a      	orrs	r2, r3
 800752a:	1dfb      	adds	r3, r7, #7
 800752c:	7819      	ldrb	r1, [r3, #0]
 800752e:	68bb      	ldr	r3, [r7, #8]
 8007530:	0018      	movs	r0, r3
 8007532:	f7fa fe1e 	bl	8002172 <LDL_Frame_updateMIC>
    } 
    else{
        
        LDL_Frame_updateMIC(buffer, size, micF); 
    }
}
 8007536:	e006      	b.n	8007546 <LDL_OPS_micDataFrame+0xfa>
        LDL_Frame_updateMIC(buffer, size, micF); 
 8007538:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800753a:	1dfb      	adds	r3, r7, #7
 800753c:	7819      	ldrb	r1, [r3, #0]
 800753e:	68bb      	ldr	r3, [r7, #8]
 8007540:	0018      	movs	r0, r3
 8007542:	f7fa fe16 	bl	8002172 <LDL_Frame_updateMIC>
}
 8007546:	46c0      	nop			; (mov r8, r8)
 8007548:	46bd      	mov	sp, r7
 800754a:	b00f      	add	sp, #60	; 0x3c
 800754c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800754e:	46c0      	nop			; (mov r8, r8)
 8007550:	00000206 	.word	0x00000206

08007554 <LDL_OPS_prepareJoinRequest>:

uint8_t LDL_OPS_prepareJoinRequest(struct ldl_mac *self, const struct ldl_frame_join_request *f, uint8_t *out, uint8_t max)
{
 8007554:	b5b0      	push	{r4, r5, r7, lr}
 8007556:	b088      	sub	sp, #32
 8007558:	af02      	add	r7, sp, #8
 800755a:	60f8      	str	r0, [r7, #12]
 800755c:	60b9      	str	r1, [r7, #8]
 800755e:	607a      	str	r2, [r7, #4]
 8007560:	001a      	movs	r2, r3
 8007562:	1cfb      	adds	r3, r7, #3
 8007564:	701a      	strb	r2, [r3, #0]
    uint32_t mic;
    uint8_t retval;
    
    retval = LDL_Frame_putJoinRequest(f, out, max);
 8007566:	2517      	movs	r5, #23
 8007568:	197c      	adds	r4, r7, r5
 800756a:	1cfb      	adds	r3, r7, #3
 800756c:	781a      	ldrb	r2, [r3, #0]
 800756e:	6879      	ldr	r1, [r7, #4]
 8007570:	68bb      	ldr	r3, [r7, #8]
 8007572:	0018      	movs	r0, r3
 8007574:	f7fa fecb 	bl	800230e <LDL_Frame_putJoinRequest>
 8007578:	0003      	movs	r3, r0
 800757a:	7023      	strb	r3, [r4, #0]
    
    mic = LDL_SM_mic(self->sm, LDL_SM_KEY_NWK, NULL, 0U, out, retval-sizeof(mic));
 800757c:	68fa      	ldr	r2, [r7, #12]
 800757e:	2387      	movs	r3, #135	; 0x87
 8007580:	009b      	lsls	r3, r3, #2
 8007582:	58d0      	ldr	r0, [r2, r3]
 8007584:	197b      	adds	r3, r7, r5
 8007586:	781b      	ldrb	r3, [r3, #0]
 8007588:	3b04      	subs	r3, #4
 800758a:	b2db      	uxtb	r3, r3
 800758c:	9301      	str	r3, [sp, #4]
 800758e:	687b      	ldr	r3, [r7, #4]
 8007590:	9300      	str	r3, [sp, #0]
 8007592:	2300      	movs	r3, #0
 8007594:	2200      	movs	r2, #0
 8007596:	2107      	movs	r1, #7
 8007598:	f001 fe48 	bl	800922c <LDL_SM_mic>
 800759c:	0003      	movs	r3, r0
 800759e:	613b      	str	r3, [r7, #16]
    
    LDL_Frame_updateMIC(out, retval, mic);
 80075a0:	693a      	ldr	r2, [r7, #16]
 80075a2:	197b      	adds	r3, r7, r5
 80075a4:	7819      	ldrb	r1, [r3, #0]
 80075a6:	687b      	ldr	r3, [r7, #4]
 80075a8:	0018      	movs	r0, r3
 80075aa:	f7fa fde2 	bl	8002172 <LDL_Frame_updateMIC>
    
    return retval;
 80075ae:	197b      	adds	r3, r7, r5
 80075b0:	781b      	ldrb	r3, [r3, #0]
}
 80075b2:	0018      	movs	r0, r3
 80075b4:	46bd      	mov	sp, r7
 80075b6:	b006      	add	sp, #24
 80075b8:	bdb0      	pop	{r4, r5, r7, pc}
	...

080075bc <LDL_OPS_receiveFrame>:

bool LDL_OPS_receiveFrame(struct ldl_mac *self, struct ldl_frame_down *f, uint8_t *in, uint8_t len)
{
 80075bc:	b5b0      	push	{r4, r5, r7, lr}
 80075be:	b098      	sub	sp, #96	; 0x60
 80075c0:	af04      	add	r7, sp, #16
 80075c2:	60f8      	str	r0, [r7, #12]
 80075c4:	60b9      	str	r1, [r7, #8]
 80075c6:	607a      	str	r2, [r7, #4]
 80075c8:	001a      	movs	r2, r3
 80075ca:	1cfb      	adds	r3, r7, #3
 80075cc:	701a      	strb	r2, [r3, #0]
    bool retval;
    uint32_t mic;
        
    retval = false;
 80075ce:	234f      	movs	r3, #79	; 0x4f
 80075d0:	18fb      	adds	r3, r7, r3
 80075d2:	2200      	movs	r2, #0
 80075d4:	701a      	strb	r2, [r3, #0]
    
    if(LDL_Frame_decode(f, in, len)){
 80075d6:	1cfb      	adds	r3, r7, #3
 80075d8:	781a      	ldrb	r2, [r3, #0]
 80075da:	6879      	ldr	r1, [r7, #4]
 80075dc:	68bb      	ldr	r3, [r7, #8]
 80075de:	0018      	movs	r0, r3
 80075e0:	f7fa fee8 	bl	80023b4 <LDL_Frame_decode>
 80075e4:	1e03      	subs	r3, r0, #0
 80075e6:	d100      	bne.n	80075ea <LDL_OPS_receiveFrame+0x2e>
 80075e8:	e202      	b.n	80079f0 <LDL_OPS_receiveFrame+0x434>
        
        switch(f->type){
 80075ea:	68bb      	ldr	r3, [r7, #8]
 80075ec:	781b      	ldrb	r3, [r3, #0]
 80075ee:	2b03      	cmp	r3, #3
 80075f0:	d100      	bne.n	80075f4 <LDL_OPS_receiveFrame+0x38>
 80075f2:	e117      	b.n	8007824 <LDL_OPS_receiveFrame+0x268>
 80075f4:	2b05      	cmp	r3, #5
 80075f6:	d100      	bne.n	80075fa <LDL_OPS_receiveFrame+0x3e>
 80075f8:	e114      	b.n	8007824 <LDL_OPS_receiveFrame+0x268>
 80075fa:	2b01      	cmp	r3, #1
 80075fc:	d000      	beq.n	8007600 <LDL_OPS_receiveFrame+0x44>
        default:
            break;
 80075fe:	e203      	b.n	8007a08 <LDL_OPS_receiveFrame+0x44c>
        
        case FRAME_TYPE_JOIN_ACCEPT:
        
            if((self->op == LDL_OP_JOINING) || (self->op == LDL_OP_REJOINING)){
 8007600:	68fb      	ldr	r3, [r7, #12]
 8007602:	785b      	ldrb	r3, [r3, #1]
 8007604:	2b01      	cmp	r3, #1
 8007606:	d004      	beq.n	8007612 <LDL_OPS_receiveFrame+0x56>
 8007608:	68fb      	ldr	r3, [r7, #12]
 800760a:	785b      	ldrb	r3, [r3, #1]
 800760c:	2b02      	cmp	r3, #2
 800760e:	d000      	beq.n	8007612 <LDL_OPS_receiveFrame+0x56>
 8007610:	e0f9      	b.n	8007806 <LDL_OPS_receiveFrame+0x24a>
                
                enum ldl_sm_key key;
                
                key = (self->op == LDL_OP_JOINING) ? LDL_SM_KEY_NWK : LDL_SM_KEY_JSENC;
 8007612:	68fb      	ldr	r3, [r7, #12]
 8007614:	785b      	ldrb	r3, [r3, #1]
 8007616:	2b01      	cmp	r3, #1
 8007618:	d101      	bne.n	800761e <LDL_OPS_receiveFrame+0x62>
 800761a:	2207      	movs	r2, #7
 800761c:	e000      	b.n	8007620 <LDL_OPS_receiveFrame+0x64>
 800761e:	2204      	movs	r2, #4
 8007620:	2143      	movs	r1, #67	; 0x43
 8007622:	187b      	adds	r3, r7, r1
 8007624:	701a      	strb	r2, [r3, #0]
                
                LDL_SM_ecb(self->sm, key, &in[1U]);
 8007626:	68fa      	ldr	r2, [r7, #12]
 8007628:	2387      	movs	r3, #135	; 0x87
 800762a:	009b      	lsls	r3, r3, #2
 800762c:	58d0      	ldr	r0, [r2, r3]
 800762e:	687b      	ldr	r3, [r7, #4]
 8007630:	1c5a      	adds	r2, r3, #1
 8007632:	187b      	adds	r3, r7, r1
 8007634:	781b      	ldrb	r3, [r3, #0]
 8007636:	0019      	movs	r1, r3
 8007638:	f001 fe8a 	bl	8009350 <LDL_SM_ecb>
        
                if(len == LDL_Frame_sizeofJoinAccept(true)){
 800763c:	2001      	movs	r0, #1
 800763e:	f7fa fea8 	bl	8002392 <LDL_Frame_sizeofJoinAccept>
 8007642:	0003      	movs	r3, r0
 8007644:	001a      	movs	r2, r3
 8007646:	1cfb      	adds	r3, r7, #3
 8007648:	781b      	ldrb	r3, [r3, #0]
 800764a:	4293      	cmp	r3, r2
 800764c:	d111      	bne.n	8007672 <LDL_OPS_receiveFrame+0xb6>
                    
                    LDL_SM_ecb(self->sm, key, &in[LDL_Frame_sizeofJoinAccept(false)]);
 800764e:	68fa      	ldr	r2, [r7, #12]
 8007650:	2387      	movs	r3, #135	; 0x87
 8007652:	009b      	lsls	r3, r3, #2
 8007654:	58d4      	ldr	r4, [r2, r3]
 8007656:	2000      	movs	r0, #0
 8007658:	f7fa fe9b 	bl	8002392 <LDL_Frame_sizeofJoinAccept>
 800765c:	0003      	movs	r3, r0
 800765e:	001a      	movs	r2, r3
 8007660:	687b      	ldr	r3, [r7, #4]
 8007662:	189a      	adds	r2, r3, r2
 8007664:	2343      	movs	r3, #67	; 0x43
 8007666:	18fb      	adds	r3, r7, r3
 8007668:	781b      	ldrb	r3, [r3, #0]
 800766a:	0019      	movs	r1, r3
 800766c:	0020      	movs	r0, r4
 800766e:	f001 fe6f 	bl	8009350 <LDL_SM_ecb>
                }
                
                if(LDL_Frame_decode(f, in, len)){
 8007672:	1cfb      	adds	r3, r7, #3
 8007674:	781a      	ldrb	r2, [r3, #0]
 8007676:	6879      	ldr	r1, [r7, #4]
 8007678:	68bb      	ldr	r3, [r7, #8]
 800767a:	0018      	movs	r0, r3
 800767c:	f7fa fe9a 	bl	80023b4 <LDL_Frame_decode>
 8007680:	1e03      	subs	r3, r0, #0
 8007682:	d100      	bne.n	8007686 <LDL_OPS_receiveFrame+0xca>
 8007684:	e0cc      	b.n	8007820 <LDL_OPS_receiveFrame+0x264>
                    
                    if(f->optNeg){
 8007686:	68bb      	ldr	r3, [r7, #8]
 8007688:	7cdb      	ldrb	r3, [r3, #19]
 800768a:	2b00      	cmp	r3, #0
 800768c:	d100      	bne.n	8007690 <LDL_OPS_receiveFrame+0xd4>
 800768e:	e091      	b.n	80077b4 <LDL_OPS_receiveFrame+0x1f8>
                        
                        if(f->joinNonce >= self->joinNonce){
 8007690:	68bb      	ldr	r3, [r7, #8]
 8007692:	685a      	ldr	r2, [r3, #4]
 8007694:	68f9      	ldr	r1, [r7, #12]
 8007696:	239c      	movs	r3, #156	; 0x9c
 8007698:	005b      	lsls	r3, r3, #1
 800769a:	58cb      	ldr	r3, [r1, r3]
 800769c:	429a      	cmp	r2, r3
 800769e:	d200      	bcs.n	80076a2 <LDL_OPS_receiveFrame+0xe6>
 80076a0:	e07b      	b.n	800779a <LDL_OPS_receiveFrame+0x1de>
                        
                            struct ldl_block hdr;
                            uint8_t pos;
                            
                            pos = 0U;
 80076a2:	234e      	movs	r3, #78	; 0x4e
 80076a4:	18fb      	adds	r3, r7, r3
 80076a6:	2200      	movs	r2, #0
 80076a8:	701a      	strb	r2, [r3, #0]
                            
                            switch(self->op){
 80076aa:	68fb      	ldr	r3, [r7, #12]
 80076ac:	785b      	ldrb	r3, [r3, #1]
 80076ae:	2b02      	cmp	r3, #2
 80076b0:	d011      	beq.n	80076d6 <LDL_OPS_receiveFrame+0x11a>
                            default:
                            case LDL_OP_JOINING:
                                pos += putU8(&hdr.value[pos], 0xffU);
 80076b2:	244e      	movs	r4, #78	; 0x4e
 80076b4:	193b      	adds	r3, r7, r4
 80076b6:	781b      	ldrb	r3, [r3, #0]
 80076b8:	2230      	movs	r2, #48	; 0x30
 80076ba:	18ba      	adds	r2, r7, r2
 80076bc:	18d3      	adds	r3, r2, r3
 80076be:	21ff      	movs	r1, #255	; 0xff
 80076c0:	0018      	movs	r0, r3
 80076c2:	f000 fb54 	bl	8007d6e <putU8>
 80076c6:	0003      	movs	r3, r0
 80076c8:	0019      	movs	r1, r3
 80076ca:	193b      	adds	r3, r7, r4
 80076cc:	193a      	adds	r2, r7, r4
 80076ce:	7812      	ldrb	r2, [r2, #0]
 80076d0:	188a      	adds	r2, r1, r2
 80076d2:	701a      	strb	r2, [r3, #0]
                                break;
 80076d4:	e011      	b.n	80076fa <LDL_OPS_receiveFrame+0x13e>
                            case LDL_OP_REJOINING:                        
                                pos += putU8(&hdr.value[pos], 2U);
 80076d6:	244e      	movs	r4, #78	; 0x4e
 80076d8:	193b      	adds	r3, r7, r4
 80076da:	781b      	ldrb	r3, [r3, #0]
 80076dc:	2230      	movs	r2, #48	; 0x30
 80076de:	18ba      	adds	r2, r7, r2
 80076e0:	18d3      	adds	r3, r2, r3
 80076e2:	2102      	movs	r1, #2
 80076e4:	0018      	movs	r0, r3
 80076e6:	f000 fb42 	bl	8007d6e <putU8>
 80076ea:	0003      	movs	r3, r0
 80076ec:	0019      	movs	r1, r3
 80076ee:	193b      	adds	r3, r7, r4
 80076f0:	193a      	adds	r2, r7, r4
 80076f2:	7812      	ldrb	r2, [r2, #0]
 80076f4:	188a      	adds	r2, r1, r2
 80076f6:	701a      	strb	r2, [r3, #0]
                                break;
 80076f8:	46c0      	nop			; (mov r8, r8)
                            }
                            
                            pos += putEUI(&hdr.value[pos], self->joinEUI);
 80076fa:	244e      	movs	r4, #78	; 0x4e
 80076fc:	193b      	adds	r3, r7, r4
 80076fe:	781b      	ldrb	r3, [r3, #0]
 8007700:	2530      	movs	r5, #48	; 0x30
 8007702:	197a      	adds	r2, r7, r5
 8007704:	18d2      	adds	r2, r2, r3
 8007706:	68fb      	ldr	r3, [r7, #12]
 8007708:	3303      	adds	r3, #3
 800770a:	0019      	movs	r1, r3
 800770c:	0010      	movs	r0, r2
 800770e:	f000 fafd 	bl	8007d0c <putEUI>
 8007712:	0003      	movs	r3, r0
 8007714:	0019      	movs	r1, r3
 8007716:	193b      	adds	r3, r7, r4
 8007718:	193a      	adds	r2, r7, r4
 800771a:	7812      	ldrb	r2, [r2, #0]
 800771c:	188a      	adds	r2, r1, r2
 800771e:	701a      	strb	r2, [r3, #0]
                            pos += putU16(&hdr.value[pos], self->devNonce);
 8007720:	193b      	adds	r3, r7, r4
 8007722:	781b      	ldrb	r3, [r3, #0]
 8007724:	197a      	adds	r2, r7, r5
 8007726:	18d0      	adds	r0, r2, r3
 8007728:	68fa      	ldr	r2, [r7, #12]
 800772a:	239a      	movs	r3, #154	; 0x9a
 800772c:	005b      	lsls	r3, r3, #1
 800772e:	5ad3      	ldrh	r3, [r2, r3]
 8007730:	0019      	movs	r1, r3
 8007732:	f000 fb2c 	bl	8007d8e <putU16>
 8007736:	0003      	movs	r3, r0
 8007738:	0019      	movs	r1, r3
 800773a:	193b      	adds	r3, r7, r4
 800773c:	193a      	adds	r2, r7, r4
 800773e:	7812      	ldrb	r2, [r2, #0]
 8007740:	188a      	adds	r2, r1, r2
 8007742:	701a      	strb	r2, [r3, #0]
                            
                            mic = LDL_SM_mic(self->sm, LDL_SM_KEY_JSINT, &hdr, pos, in, len-sizeof(mic));
 8007744:	68fa      	ldr	r2, [r7, #12]
 8007746:	2387      	movs	r3, #135	; 0x87
 8007748:	009b      	lsls	r3, r3, #2
 800774a:	58d0      	ldr	r0, [r2, r3]
 800774c:	1cfb      	adds	r3, r7, #3
 800774e:	781b      	ldrb	r3, [r3, #0]
 8007750:	3b04      	subs	r3, #4
 8007752:	b2db      	uxtb	r3, r3
 8007754:	193a      	adds	r2, r7, r4
 8007756:	7811      	ldrb	r1, [r2, #0]
 8007758:	197a      	adds	r2, r7, r5
 800775a:	9301      	str	r3, [sp, #4]
 800775c:	687b      	ldr	r3, [r7, #4]
 800775e:	9300      	str	r3, [sp, #0]
 8007760:	000b      	movs	r3, r1
 8007762:	2105      	movs	r1, #5
 8007764:	f001 fd62 	bl	800922c <LDL_SM_mic>
 8007768:	0003      	movs	r3, r0
 800776a:	647b      	str	r3, [r7, #68]	; 0x44
                            
                            if(f->mic == mic){
 800776c:	68bb      	ldr	r3, [r7, #8]
 800776e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007770:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8007772:	429a      	cmp	r2, r3
 8007774:	d104      	bne.n	8007780 <LDL_OPS_receiveFrame+0x1c4>
                            
                                retval = true;                    
 8007776:	234f      	movs	r3, #79	; 0x4f
 8007778:	18fb      	adds	r3, r7, r3
 800777a:	2201      	movs	r2, #1
 800777c:	701a      	strb	r2, [r3, #0]
            if((self->op == LDL_OP_JOINING) || (self->op == LDL_OP_REJOINING)){
 800777e:	e04f      	b.n	8007820 <LDL_OPS_receiveFrame+0x264>
                            }
                            else{
                                
                                LDL_DEBUG(self->app, "joinAccept MIC failed")
 8007780:	4ba5      	ldr	r3, [pc, #660]	; (8007a18 <LDL_OPS_receiveFrame+0x45c>)
 8007782:	0018      	movs	r0, r3
 8007784:	f005 f8b2 	bl	800c8ec <iprintf>
 8007788:	4ba4      	ldr	r3, [pc, #656]	; (8007a1c <LDL_OPS_receiveFrame+0x460>)
 800778a:	0018      	movs	r0, r3
 800778c:	f005 f8ae 	bl	800c8ec <iprintf>
 8007790:	4ba3      	ldr	r3, [pc, #652]	; (8007a20 <LDL_OPS_receiveFrame+0x464>)
 8007792:	0018      	movs	r0, r3
 8007794:	f005 f924 	bl	800c9e0 <puts>
            if((self->op == LDL_OP_JOINING) || (self->op == LDL_OP_REJOINING)){
 8007798:	e042      	b.n	8007820 <LDL_OPS_receiveFrame+0x264>
                            }                           
                        }
                        else{
                            
                            LDL_DEBUG(self->app, "invalid joinNonce")
 800779a:	4b9f      	ldr	r3, [pc, #636]	; (8007a18 <LDL_OPS_receiveFrame+0x45c>)
 800779c:	0018      	movs	r0, r3
 800779e:	f005 f8a5 	bl	800c8ec <iprintf>
 80077a2:	4ba0      	ldr	r3, [pc, #640]	; (8007a24 <LDL_OPS_receiveFrame+0x468>)
 80077a4:	0018      	movs	r0, r3
 80077a6:	f005 f8a1 	bl	800c8ec <iprintf>
 80077aa:	4b9d      	ldr	r3, [pc, #628]	; (8007a20 <LDL_OPS_receiveFrame+0x464>)
 80077ac:	0018      	movs	r0, r3
 80077ae:	f005 f917 	bl	800c9e0 <puts>
            if((self->op == LDL_OP_JOINING) || (self->op == LDL_OP_REJOINING)){
 80077b2:	e035      	b.n	8007820 <LDL_OPS_receiveFrame+0x264>
                        }
                    }
                    else{
                        
                        mic = LDL_SM_mic(self->sm, LDL_SM_KEY_NWK, NULL, 0U, in, len-sizeof(mic));                        
 80077b4:	68fa      	ldr	r2, [r7, #12]
 80077b6:	2387      	movs	r3, #135	; 0x87
 80077b8:	009b      	lsls	r3, r3, #2
 80077ba:	58d0      	ldr	r0, [r2, r3]
 80077bc:	1cfb      	adds	r3, r7, #3
 80077be:	781b      	ldrb	r3, [r3, #0]
 80077c0:	3b04      	subs	r3, #4
 80077c2:	b2db      	uxtb	r3, r3
 80077c4:	9301      	str	r3, [sp, #4]
 80077c6:	687b      	ldr	r3, [r7, #4]
 80077c8:	9300      	str	r3, [sp, #0]
 80077ca:	2300      	movs	r3, #0
 80077cc:	2200      	movs	r2, #0
 80077ce:	2107      	movs	r1, #7
 80077d0:	f001 fd2c 	bl	800922c <LDL_SM_mic>
 80077d4:	0003      	movs	r3, r0
 80077d6:	647b      	str	r3, [r7, #68]	; 0x44
                        
                        if(f->mic == mic){
 80077d8:	68bb      	ldr	r3, [r7, #8]
 80077da:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80077dc:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80077de:	429a      	cmp	r2, r3
 80077e0:	d104      	bne.n	80077ec <LDL_OPS_receiveFrame+0x230>
                        
                            retval = true;                    
 80077e2:	234f      	movs	r3, #79	; 0x4f
 80077e4:	18fb      	adds	r3, r7, r3
 80077e6:	2201      	movs	r2, #1
 80077e8:	701a      	strb	r2, [r3, #0]
            if((self->op == LDL_OP_JOINING) || (self->op == LDL_OP_REJOINING)){
 80077ea:	e019      	b.n	8007820 <LDL_OPS_receiveFrame+0x264>
                        }
                        else{
                            
                            LDL_DEBUG(self->app, "joinAccept MIC failed")
 80077ec:	4b8a      	ldr	r3, [pc, #552]	; (8007a18 <LDL_OPS_receiveFrame+0x45c>)
 80077ee:	0018      	movs	r0, r3
 80077f0:	f005 f87c 	bl	800c8ec <iprintf>
 80077f4:	4b89      	ldr	r3, [pc, #548]	; (8007a1c <LDL_OPS_receiveFrame+0x460>)
 80077f6:	0018      	movs	r0, r3
 80077f8:	f005 f878 	bl	800c8ec <iprintf>
 80077fc:	4b88      	ldr	r3, [pc, #544]	; (8007a20 <LDL_OPS_receiveFrame+0x464>)
 80077fe:	0018      	movs	r0, r3
 8007800:	f005 f8ee 	bl	800c9e0 <puts>
            if((self->op == LDL_OP_JOINING) || (self->op == LDL_OP_REJOINING)){
 8007804:	e00c      	b.n	8007820 <LDL_OPS_receiveFrame+0x264>
                    }                     
                }                                
            }
            else{
                
                LDL_DEBUG(self->app, "unexpected frame type")
 8007806:	4b84      	ldr	r3, [pc, #528]	; (8007a18 <LDL_OPS_receiveFrame+0x45c>)
 8007808:	0018      	movs	r0, r3
 800780a:	f005 f86f 	bl	800c8ec <iprintf>
 800780e:	4b86      	ldr	r3, [pc, #536]	; (8007a28 <LDL_OPS_receiveFrame+0x46c>)
 8007810:	0018      	movs	r0, r3
 8007812:	f005 f86b 	bl	800c8ec <iprintf>
 8007816:	4b82      	ldr	r3, [pc, #520]	; (8007a20 <LDL_OPS_receiveFrame+0x464>)
 8007818:	0018      	movs	r0, r3
 800781a:	f005 f8e1 	bl	800c9e0 <puts>
            }
            break;
 800781e:	e0f3      	b.n	8007a08 <LDL_OPS_receiveFrame+0x44c>
            if((self->op == LDL_OP_JOINING) || (self->op == LDL_OP_REJOINING)){
 8007820:	46c0      	nop			; (mov r8, r8)
            break;
 8007822:	e0f1      	b.n	8007a08 <LDL_OPS_receiveFrame+0x44c>
        
        case FRAME_TYPE_DATA_UNCONFIRMED_DOWN:
        case FRAME_TYPE_DATA_CONFIRMED_DOWN:
        
            if(
                ((self->ctx.version > 0) && (self->op == LDL_OP_REJOINING))
 8007824:	68fb      	ldr	r3, [r7, #12]
 8007826:	4a81      	ldr	r2, [pc, #516]	; (8007a2c <LDL_OPS_receiveFrame+0x470>)
 8007828:	5c9b      	ldrb	r3, [r3, r2]
            if(
 800782a:	2b00      	cmp	r3, #0
 800782c:	d003      	beq.n	8007836 <LDL_OPS_receiveFrame+0x27a>
                ((self->ctx.version > 0) && (self->op == LDL_OP_REJOINING))
 800782e:	68fb      	ldr	r3, [r7, #12]
 8007830:	785b      	ldrb	r3, [r3, #1]
 8007832:	2b02      	cmp	r3, #2
 8007834:	d008      	beq.n	8007848 <LDL_OPS_receiveFrame+0x28c>
                ||
                (self->op  == LDL_OP_DATA_UNCONFIRMED)
 8007836:	68fb      	ldr	r3, [r7, #12]
 8007838:	785b      	ldrb	r3, [r3, #1]
                ||
 800783a:	2b03      	cmp	r3, #3
 800783c:	d004      	beq.n	8007848 <LDL_OPS_receiveFrame+0x28c>
                ||
                (self->op == LDL_OP_DATA_CONFIRMED)
 800783e:	68fb      	ldr	r3, [r7, #12]
 8007840:	785b      	ldrb	r3, [r3, #1]
                ||
 8007842:	2b04      	cmp	r3, #4
 8007844:	d000      	beq.n	8007848 <LDL_OPS_receiveFrame+0x28c>
 8007846:	e0c5      	b.n	80079d4 <LDL_OPS_receiveFrame+0x418>
            ){
            
                if(self->ctx.devAddr == f->devAddr){
 8007848:	68fa      	ldr	r2, [r7, #12]
 800784a:	23b2      	movs	r3, #178	; 0xb2
 800784c:	005b      	lsls	r3, r3, #1
 800784e:	58d2      	ldr	r2, [r2, r3]
 8007850:	68bb      	ldr	r3, [r7, #8]
 8007852:	68db      	ldr	r3, [r3, #12]
 8007854:	429a      	cmp	r2, r3
 8007856:	d000      	beq.n	800785a <LDL_OPS_receiveFrame+0x29e>
 8007858:	e0af      	b.n	80079ba <LDL_OPS_receiveFrame+0x3fe>
                    
                    uint32_t counter;
                    
                    counter = deriveDownCounter(self, f->port, f->counter);
 800785a:	68bb      	ldr	r3, [r7, #8]
 800785c:	2226      	movs	r2, #38	; 0x26
 800785e:	5c99      	ldrb	r1, [r3, r2]
 8007860:	68bb      	ldr	r3, [r7, #8]
 8007862:	8b5a      	ldrh	r2, [r3, #26]
 8007864:	68fb      	ldr	r3, [r7, #12]
 8007866:	0018      	movs	r0, r3
 8007868:	f000 fa12 	bl	8007c90 <deriveDownCounter>
 800786c:	0003      	movs	r3, r0
 800786e:	64bb      	str	r3, [r7, #72]	; 0x48

                    struct ldl_block B;
                    struct ldl_block A;

                    if((self->ctx.version == 1U) && f->ack){
 8007870:	68fb      	ldr	r3, [r7, #12]
 8007872:	4a6e      	ldr	r2, [pc, #440]	; (8007a2c <LDL_OPS_receiveFrame+0x470>)
 8007874:	5c9b      	ldrb	r3, [r3, r2]
 8007876:	2b01      	cmp	r3, #1
 8007878:	d11d      	bne.n	80078b6 <LDL_OPS_receiveFrame+0x2fa>
 800787a:	68bb      	ldr	r3, [r7, #8]
 800787c:	7f1b      	ldrb	r3, [r3, #28]
 800787e:	2b00      	cmp	r3, #0
 8007880:	d019      	beq.n	80078b6 <LDL_OPS_receiveFrame+0x2fa>
                    
                        initB(&B, (self->ctx.up-1U), 0U, 0U, false, f->devAddr, counter, len-sizeof(mic));
 8007882:	68fa      	ldr	r2, [r7, #12]
 8007884:	23ae      	movs	r3, #174	; 0xae
 8007886:	005b      	lsls	r3, r3, #1
 8007888:	58d3      	ldr	r3, [r2, r3]
 800788a:	b29b      	uxth	r3, r3
 800788c:	3b01      	subs	r3, #1
 800788e:	b299      	uxth	r1, r3
 8007890:	68bb      	ldr	r3, [r7, #8]
 8007892:	68db      	ldr	r3, [r3, #12]
 8007894:	1cfa      	adds	r2, r7, #3
 8007896:	7812      	ldrb	r2, [r2, #0]
 8007898:	3a04      	subs	r2, #4
 800789a:	b2d2      	uxtb	r2, r2
 800789c:	2020      	movs	r0, #32
 800789e:	1838      	adds	r0, r7, r0
 80078a0:	9203      	str	r2, [sp, #12]
 80078a2:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80078a4:	9202      	str	r2, [sp, #8]
 80078a6:	9301      	str	r3, [sp, #4]
 80078a8:	2300      	movs	r3, #0
 80078aa:	9300      	str	r3, [sp, #0]
 80078ac:	2300      	movs	r3, #0
 80078ae:	2200      	movs	r2, #0
 80078b0:	f000 f944 	bl	8007b3c <initB>
 80078b4:	e012      	b.n	80078dc <LDL_OPS_receiveFrame+0x320>
                    }                    
                    else{
                        
                        initB(&B, 0U, 0U, 0U, false, f->devAddr, counter, len-sizeof(mic));
 80078b6:	68bb      	ldr	r3, [r7, #8]
 80078b8:	68db      	ldr	r3, [r3, #12]
 80078ba:	1cfa      	adds	r2, r7, #3
 80078bc:	7812      	ldrb	r2, [r2, #0]
 80078be:	3a04      	subs	r2, #4
 80078c0:	b2d2      	uxtb	r2, r2
 80078c2:	2120      	movs	r1, #32
 80078c4:	1878      	adds	r0, r7, r1
 80078c6:	9203      	str	r2, [sp, #12]
 80078c8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80078ca:	9202      	str	r2, [sp, #8]
 80078cc:	9301      	str	r3, [sp, #4]
 80078ce:	2300      	movs	r3, #0
 80078d0:	9300      	str	r3, [sp, #0]
 80078d2:	2300      	movs	r3, #0
 80078d4:	2200      	movs	r2, #0
 80078d6:	2100      	movs	r1, #0
 80078d8:	f000 f930 	bl	8007b3c <initB>
                    }
                    
                    mic = LDL_SM_mic(self->sm, LDL_SM_KEY_SNWKSINT, &B, sizeof(B.value), in, len-sizeof(mic));
 80078dc:	68fa      	ldr	r2, [r7, #12]
 80078de:	2387      	movs	r3, #135	; 0x87
 80078e0:	009b      	lsls	r3, r3, #2
 80078e2:	58d0      	ldr	r0, [r2, r3]
 80078e4:	1cfb      	adds	r3, r7, #3
 80078e6:	781b      	ldrb	r3, [r3, #0]
 80078e8:	3b04      	subs	r3, #4
 80078ea:	b2db      	uxtb	r3, r3
 80078ec:	2220      	movs	r2, #32
 80078ee:	18ba      	adds	r2, r7, r2
 80078f0:	9301      	str	r3, [sp, #4]
 80078f2:	687b      	ldr	r3, [r7, #4]
 80078f4:	9300      	str	r3, [sp, #0]
 80078f6:	2310      	movs	r3, #16
 80078f8:	2102      	movs	r1, #2
 80078fa:	f001 fc97 	bl	800922c <LDL_SM_mic>
 80078fe:	0003      	movs	r3, r0
 8007900:	647b      	str	r3, [r7, #68]	; 0x44
                    
                    if(mic == f->mic){
 8007902:	68bb      	ldr	r3, [r7, #8]
 8007904:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007906:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8007908:	429a      	cmp	r2, r3
 800790a:	d149      	bne.n	80079a0 <LDL_OPS_receiveFrame+0x3e4>
                        
                        /* V1.1 encrypts the opts */
                        if(self->ctx.version == 1U){
 800790c:	68fb      	ldr	r3, [r7, #12]
 800790e:	4a47      	ldr	r2, [pc, #284]	; (8007a2c <LDL_OPS_receiveFrame+0x470>)
 8007910:	5c9b      	ldrb	r3, [r3, r2]
 8007912:	2b01      	cmp	r3, #1
 8007914:	d11b      	bne.n	800794e <LDL_OPS_receiveFrame+0x392>
                            
                            initA(&A, f->devAddr, false, f->counter, 0U);
 8007916:	68bb      	ldr	r3, [r7, #8]
 8007918:	68d9      	ldr	r1, [r3, #12]
 800791a:	68bb      	ldr	r3, [r7, #8]
 800791c:	8b5b      	ldrh	r3, [r3, #26]
 800791e:	001a      	movs	r2, r3
 8007920:	2410      	movs	r4, #16
 8007922:	1938      	adds	r0, r7, r4
 8007924:	2300      	movs	r3, #0
 8007926:	9300      	str	r3, [sp, #0]
 8007928:	0013      	movs	r3, r2
 800792a:	2200      	movs	r2, #0
 800792c:	f000 f886 	bl	8007a3c <initA>
                            
                            LDL_SM_ctr(self->sm, LDL_SM_KEY_NWKSENC, &A, f->opts, f->optsLen);    
 8007930:	68fa      	ldr	r2, [r7, #12]
 8007932:	2387      	movs	r3, #135	; 0x87
 8007934:	009b      	lsls	r3, r3, #2
 8007936:	58d0      	ldr	r0, [r2, r3]
 8007938:	68bb      	ldr	r3, [r7, #8]
 800793a:	6a19      	ldr	r1, [r3, #32]
 800793c:	68bb      	ldr	r3, [r7, #8]
 800793e:	2224      	movs	r2, #36	; 0x24
 8007940:	5c9b      	ldrb	r3, [r3, r2]
 8007942:	193a      	adds	r2, r7, r4
 8007944:	9300      	str	r3, [sp, #0]
 8007946:	000b      	movs	r3, r1
 8007948:	2103      	movs	r1, #3
 800794a:	f001 fd22 	bl	8009392 <LDL_SM_ctr>
                        }
                        
                        initA(&A, f->devAddr, false, f->counter, 1U);
 800794e:	68bb      	ldr	r3, [r7, #8]
 8007950:	68d9      	ldr	r1, [r3, #12]
 8007952:	68bb      	ldr	r3, [r7, #8]
 8007954:	8b5b      	ldrh	r3, [r3, #26]
 8007956:	001a      	movs	r2, r3
 8007958:	2310      	movs	r3, #16
 800795a:	18f8      	adds	r0, r7, r3
 800795c:	2301      	movs	r3, #1
 800795e:	9300      	str	r3, [sp, #0]
 8007960:	0013      	movs	r3, r2
 8007962:	2200      	movs	r2, #0
 8007964:	f000 f86a 	bl	8007a3c <initA>
                        
                        LDL_SM_ctr(self->sm, (f->port == 0U) ? LDL_SM_KEY_NWKSENC : LDL_SM_KEY_APPS, &A, f->data, f->dataLen);
 8007968:	68fa      	ldr	r2, [r7, #12]
 800796a:	2387      	movs	r3, #135	; 0x87
 800796c:	009b      	lsls	r3, r3, #2
 800796e:	58d0      	ldr	r0, [r2, r3]
 8007970:	68bb      	ldr	r3, [r7, #8]
 8007972:	2226      	movs	r2, #38	; 0x26
 8007974:	5c9b      	ldrb	r3, [r3, r2]
 8007976:	2b00      	cmp	r3, #0
 8007978:	d101      	bne.n	800797e <LDL_OPS_receiveFrame+0x3c2>
 800797a:	2103      	movs	r1, #3
 800797c:	e000      	b.n	8007980 <LDL_OPS_receiveFrame+0x3c4>
 800797e:	2101      	movs	r1, #1
 8007980:	68bb      	ldr	r3, [r7, #8]
 8007982:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 8007984:	68bb      	ldr	r3, [r7, #8]
 8007986:	222c      	movs	r2, #44	; 0x2c
 8007988:	5c9b      	ldrb	r3, [r3, r2]
 800798a:	2210      	movs	r2, #16
 800798c:	18ba      	adds	r2, r7, r2
 800798e:	9300      	str	r3, [sp, #0]
 8007990:	0023      	movs	r3, r4
 8007992:	f001 fcfe 	bl	8009392 <LDL_SM_ctr>
                       
                        retval = true;
 8007996:	234f      	movs	r3, #79	; 0x4f
 8007998:	18fb      	adds	r3, r7, r3
 800799a:	2201      	movs	r2, #1
 800799c:	701a      	strb	r2, [r3, #0]
                if(self->ctx.devAddr == f->devAddr){
 800799e:	e025      	b.n	80079ec <LDL_OPS_receiveFrame+0x430>
                    }
                    else{
                                            
                        LDL_DEBUG(self->app, "mic failed")
 80079a0:	4b1d      	ldr	r3, [pc, #116]	; (8007a18 <LDL_OPS_receiveFrame+0x45c>)
 80079a2:	0018      	movs	r0, r3
 80079a4:	f004 ffa2 	bl	800c8ec <iprintf>
 80079a8:	4b21      	ldr	r3, [pc, #132]	; (8007a30 <LDL_OPS_receiveFrame+0x474>)
 80079aa:	0018      	movs	r0, r3
 80079ac:	f004 ff9e 	bl	800c8ec <iprintf>
 80079b0:	4b1b      	ldr	r3, [pc, #108]	; (8007a20 <LDL_OPS_receiveFrame+0x464>)
 80079b2:	0018      	movs	r0, r3
 80079b4:	f005 f814 	bl	800c9e0 <puts>
                if(self->ctx.devAddr == f->devAddr){
 80079b8:	e018      	b.n	80079ec <LDL_OPS_receiveFrame+0x430>
                    }                           
                }
                else{
                    
                    LDL_DEBUG(self->app, "devaddr mismatch")        
 80079ba:	4b17      	ldr	r3, [pc, #92]	; (8007a18 <LDL_OPS_receiveFrame+0x45c>)
 80079bc:	0018      	movs	r0, r3
 80079be:	f004 ff95 	bl	800c8ec <iprintf>
 80079c2:	4b1c      	ldr	r3, [pc, #112]	; (8007a34 <LDL_OPS_receiveFrame+0x478>)
 80079c4:	0018      	movs	r0, r3
 80079c6:	f004 ff91 	bl	800c8ec <iprintf>
 80079ca:	4b15      	ldr	r3, [pc, #84]	; (8007a20 <LDL_OPS_receiveFrame+0x464>)
 80079cc:	0018      	movs	r0, r3
 80079ce:	f005 f807 	bl	800c9e0 <puts>
                if(self->ctx.devAddr == f->devAddr){
 80079d2:	e00b      	b.n	80079ec <LDL_OPS_receiveFrame+0x430>
                }                                                         
            }
            else{
                
                LDL_DEBUG(self->app, "unexpected frame type")
 80079d4:	4b10      	ldr	r3, [pc, #64]	; (8007a18 <LDL_OPS_receiveFrame+0x45c>)
 80079d6:	0018      	movs	r0, r3
 80079d8:	f004 ff88 	bl	800c8ec <iprintf>
 80079dc:	4b12      	ldr	r3, [pc, #72]	; (8007a28 <LDL_OPS_receiveFrame+0x46c>)
 80079de:	0018      	movs	r0, r3
 80079e0:	f004 ff84 	bl	800c8ec <iprintf>
 80079e4:	4b0e      	ldr	r3, [pc, #56]	; (8007a20 <LDL_OPS_receiveFrame+0x464>)
 80079e6:	0018      	movs	r0, r3
 80079e8:	f004 fffa 	bl	800c9e0 <puts>
            }
        
            break;
 80079ec:	46c0      	nop			; (mov r8, r8)
 80079ee:	e00b      	b.n	8007a08 <LDL_OPS_receiveFrame+0x44c>
        }    
    }
    else{
        
        LDL_DEBUG(self->app, "invalid frame")
 80079f0:	4b09      	ldr	r3, [pc, #36]	; (8007a18 <LDL_OPS_receiveFrame+0x45c>)
 80079f2:	0018      	movs	r0, r3
 80079f4:	f004 ff7a 	bl	800c8ec <iprintf>
 80079f8:	4b0f      	ldr	r3, [pc, #60]	; (8007a38 <LDL_OPS_receiveFrame+0x47c>)
 80079fa:	0018      	movs	r0, r3
 80079fc:	f004 ff76 	bl	800c8ec <iprintf>
 8007a00:	4b07      	ldr	r3, [pc, #28]	; (8007a20 <LDL_OPS_receiveFrame+0x464>)
 8007a02:	0018      	movs	r0, r3
 8007a04:	f004 ffec 	bl	800c9e0 <puts>
    }
    
    return retval;
 8007a08:	234f      	movs	r3, #79	; 0x4f
 8007a0a:	18fb      	adds	r3, r7, r3
 8007a0c:	781b      	ldrb	r3, [r3, #0]
}
 8007a0e:	0018      	movs	r0, r3
 8007a10:	46bd      	mov	sp, r7
 8007a12:	b014      	add	sp, #80	; 0x50
 8007a14:	bdb0      	pop	{r4, r5, r7, pc}
 8007a16:	46c0      	nop			; (mov r8, r8)
 8007a18:	0800e064 	.word	0x0800e064
 8007a1c:	0800e070 	.word	0x0800e070
 8007a20:	0800e088 	.word	0x0800e088
 8007a24:	0800e08c 	.word	0x0800e08c
 8007a28:	0800e0a0 	.word	0x0800e0a0
 8007a2c:	00000206 	.word	0x00000206
 8007a30:	0800e0b8 	.word	0x0800e0b8
 8007a34:	0800e0c4 	.word	0x0800e0c4
 8007a38:	0800e0d8 	.word	0x0800e0d8

08007a3c <initA>:

/* static functions ***************************************************/

static void initA(struct ldl_block *a, uint32_t devAddr, bool up, uint32_t counter, uint8_t i)
{
 8007a3c:	b590      	push	{r4, r7, lr}
 8007a3e:	b087      	sub	sp, #28
 8007a40:	af00      	add	r7, sp, #0
 8007a42:	60f8      	str	r0, [r7, #12]
 8007a44:	60b9      	str	r1, [r7, #8]
 8007a46:	603b      	str	r3, [r7, #0]
 8007a48:	1dfb      	adds	r3, r7, #7
 8007a4a:	701a      	strb	r2, [r3, #0]
    uint8_t pos = 0U;
 8007a4c:	2417      	movs	r4, #23
 8007a4e:	193b      	adds	r3, r7, r4
 8007a50:	2200      	movs	r2, #0
 8007a52:	701a      	strb	r2, [r3, #0]
    uint8_t *ptr = a->value;
 8007a54:	68fb      	ldr	r3, [r7, #12]
 8007a56:	613b      	str	r3, [r7, #16]
    
    pos += putU8(&ptr[pos], 1U);
 8007a58:	193b      	adds	r3, r7, r4
 8007a5a:	781b      	ldrb	r3, [r3, #0]
 8007a5c:	693a      	ldr	r2, [r7, #16]
 8007a5e:	18d3      	adds	r3, r2, r3
 8007a60:	2101      	movs	r1, #1
 8007a62:	0018      	movs	r0, r3
 8007a64:	f000 f983 	bl	8007d6e <putU8>
 8007a68:	0003      	movs	r3, r0
 8007a6a:	0019      	movs	r1, r3
 8007a6c:	193b      	adds	r3, r7, r4
 8007a6e:	193a      	adds	r2, r7, r4
 8007a70:	7812      	ldrb	r2, [r2, #0]
 8007a72:	188a      	adds	r2, r1, r2
 8007a74:	701a      	strb	r2, [r3, #0]
    pos += putU32(&ptr[pos], 0U);
 8007a76:	193b      	adds	r3, r7, r4
 8007a78:	781b      	ldrb	r3, [r3, #0]
 8007a7a:	693a      	ldr	r2, [r7, #16]
 8007a7c:	18d3      	adds	r3, r2, r3
 8007a7e:	2100      	movs	r1, #0
 8007a80:	0018      	movs	r0, r3
 8007a82:	f000 f9b7 	bl	8007df4 <putU32>
 8007a86:	0003      	movs	r3, r0
 8007a88:	0019      	movs	r1, r3
 8007a8a:	193b      	adds	r3, r7, r4
 8007a8c:	193a      	adds	r2, r7, r4
 8007a8e:	7812      	ldrb	r2, [r2, #0]
 8007a90:	188a      	adds	r2, r1, r2
 8007a92:	701a      	strb	r2, [r3, #0]
    pos += putU8(&ptr[pos], up ? 0U : 1U);
 8007a94:	193b      	adds	r3, r7, r4
 8007a96:	781b      	ldrb	r3, [r3, #0]
 8007a98:	693a      	ldr	r2, [r7, #16]
 8007a9a:	18d0      	adds	r0, r2, r3
 8007a9c:	1dfb      	adds	r3, r7, #7
 8007a9e:	781b      	ldrb	r3, [r3, #0]
 8007aa0:	2201      	movs	r2, #1
 8007aa2:	4053      	eors	r3, r2
 8007aa4:	b2db      	uxtb	r3, r3
 8007aa6:	0019      	movs	r1, r3
 8007aa8:	f000 f961 	bl	8007d6e <putU8>
 8007aac:	0003      	movs	r3, r0
 8007aae:	0019      	movs	r1, r3
 8007ab0:	193b      	adds	r3, r7, r4
 8007ab2:	193a      	adds	r2, r7, r4
 8007ab4:	7812      	ldrb	r2, [r2, #0]
 8007ab6:	188a      	adds	r2, r1, r2
 8007ab8:	701a      	strb	r2, [r3, #0]
    pos += putU32(&ptr[pos], devAddr);
 8007aba:	193b      	adds	r3, r7, r4
 8007abc:	781b      	ldrb	r3, [r3, #0]
 8007abe:	693a      	ldr	r2, [r7, #16]
 8007ac0:	18d3      	adds	r3, r2, r3
 8007ac2:	68ba      	ldr	r2, [r7, #8]
 8007ac4:	0011      	movs	r1, r2
 8007ac6:	0018      	movs	r0, r3
 8007ac8:	f000 f994 	bl	8007df4 <putU32>
 8007acc:	0003      	movs	r3, r0
 8007ace:	0019      	movs	r1, r3
 8007ad0:	193b      	adds	r3, r7, r4
 8007ad2:	193a      	adds	r2, r7, r4
 8007ad4:	7812      	ldrb	r2, [r2, #0]
 8007ad6:	188a      	adds	r2, r1, r2
 8007ad8:	701a      	strb	r2, [r3, #0]
    pos += putU32(&ptr[pos], counter);    
 8007ada:	193b      	adds	r3, r7, r4
 8007adc:	781b      	ldrb	r3, [r3, #0]
 8007ade:	693a      	ldr	r2, [r7, #16]
 8007ae0:	18d3      	adds	r3, r2, r3
 8007ae2:	683a      	ldr	r2, [r7, #0]
 8007ae4:	0011      	movs	r1, r2
 8007ae6:	0018      	movs	r0, r3
 8007ae8:	f000 f984 	bl	8007df4 <putU32>
 8007aec:	0003      	movs	r3, r0
 8007aee:	0019      	movs	r1, r3
 8007af0:	193b      	adds	r3, r7, r4
 8007af2:	193a      	adds	r2, r7, r4
 8007af4:	7812      	ldrb	r2, [r2, #0]
 8007af6:	188a      	adds	r2, r1, r2
 8007af8:	701a      	strb	r2, [r3, #0]
    pos += putU8(&ptr[pos], 0U);    
 8007afa:	193b      	adds	r3, r7, r4
 8007afc:	781b      	ldrb	r3, [r3, #0]
 8007afe:	693a      	ldr	r2, [r7, #16]
 8007b00:	18d3      	adds	r3, r2, r3
 8007b02:	2100      	movs	r1, #0
 8007b04:	0018      	movs	r0, r3
 8007b06:	f000 f932 	bl	8007d6e <putU8>
 8007b0a:	0003      	movs	r3, r0
 8007b0c:	0019      	movs	r1, r3
 8007b0e:	193b      	adds	r3, r7, r4
 8007b10:	193a      	adds	r2, r7, r4
 8007b12:	7812      	ldrb	r2, [r2, #0]
 8007b14:	188a      	adds	r2, r1, r2
 8007b16:	701a      	strb	r2, [r3, #0]
    (void)putU8(&ptr[pos], i);    
 8007b18:	193b      	adds	r3, r7, r4
 8007b1a:	781b      	ldrb	r3, [r3, #0]
 8007b1c:	693a      	ldr	r2, [r7, #16]
 8007b1e:	18d3      	adds	r3, r2, r3
 8007b20:	2220      	movs	r2, #32
 8007b22:	2108      	movs	r1, #8
 8007b24:	468c      	mov	ip, r1
 8007b26:	44bc      	add	ip, r7
 8007b28:	4462      	add	r2, ip
 8007b2a:	7812      	ldrb	r2, [r2, #0]
 8007b2c:	0011      	movs	r1, r2
 8007b2e:	0018      	movs	r0, r3
 8007b30:	f000 f91d 	bl	8007d6e <putU8>
}
 8007b34:	46c0      	nop			; (mov r8, r8)
 8007b36:	46bd      	mov	sp, r7
 8007b38:	b007      	add	sp, #28
 8007b3a:	bd90      	pop	{r4, r7, pc}

08007b3c <initB>:

static void initB(struct ldl_block *b, uint16_t confirmCounter, uint8_t rate, uint8_t chIndex, bool up, uint32_t devAddr, uint32_t upCounter, uint8_t len)
{    
 8007b3c:	b590      	push	{r4, r7, lr}
 8007b3e:	b085      	sub	sp, #20
 8007b40:	af00      	add	r7, sp, #0
 8007b42:	6078      	str	r0, [r7, #4]
 8007b44:	000c      	movs	r4, r1
 8007b46:	0010      	movs	r0, r2
 8007b48:	0019      	movs	r1, r3
 8007b4a:	1cbb      	adds	r3, r7, #2
 8007b4c:	1c22      	adds	r2, r4, #0
 8007b4e:	801a      	strh	r2, [r3, #0]
 8007b50:	1c7b      	adds	r3, r7, #1
 8007b52:	1c02      	adds	r2, r0, #0
 8007b54:	701a      	strb	r2, [r3, #0]
 8007b56:	003b      	movs	r3, r7
 8007b58:	1c0a      	adds	r2, r1, #0
 8007b5a:	701a      	strb	r2, [r3, #0]
    uint8_t pos = 0U;
 8007b5c:	240f      	movs	r4, #15
 8007b5e:	193b      	adds	r3, r7, r4
 8007b60:	2200      	movs	r2, #0
 8007b62:	701a      	strb	r2, [r3, #0]
    uint8_t *ptr = b->value;
 8007b64:	687b      	ldr	r3, [r7, #4]
 8007b66:	60bb      	str	r3, [r7, #8]
    
    pos += putU8(&ptr[pos], 0x49U);
 8007b68:	193b      	adds	r3, r7, r4
 8007b6a:	781b      	ldrb	r3, [r3, #0]
 8007b6c:	68ba      	ldr	r2, [r7, #8]
 8007b6e:	18d3      	adds	r3, r2, r3
 8007b70:	2149      	movs	r1, #73	; 0x49
 8007b72:	0018      	movs	r0, r3
 8007b74:	f000 f8fb 	bl	8007d6e <putU8>
 8007b78:	0003      	movs	r3, r0
 8007b7a:	0019      	movs	r1, r3
 8007b7c:	193b      	adds	r3, r7, r4
 8007b7e:	193a      	adds	r2, r7, r4
 8007b80:	7812      	ldrb	r2, [r2, #0]
 8007b82:	188a      	adds	r2, r1, r2
 8007b84:	701a      	strb	r2, [r3, #0]
    pos += putU16(&ptr[pos], confirmCounter);
 8007b86:	193b      	adds	r3, r7, r4
 8007b88:	781b      	ldrb	r3, [r3, #0]
 8007b8a:	68ba      	ldr	r2, [r7, #8]
 8007b8c:	18d2      	adds	r2, r2, r3
 8007b8e:	1cbb      	adds	r3, r7, #2
 8007b90:	881b      	ldrh	r3, [r3, #0]
 8007b92:	0019      	movs	r1, r3
 8007b94:	0010      	movs	r0, r2
 8007b96:	f000 f8fa 	bl	8007d8e <putU16>
 8007b9a:	0003      	movs	r3, r0
 8007b9c:	0019      	movs	r1, r3
 8007b9e:	193b      	adds	r3, r7, r4
 8007ba0:	193a      	adds	r2, r7, r4
 8007ba2:	7812      	ldrb	r2, [r2, #0]
 8007ba4:	188a      	adds	r2, r1, r2
 8007ba6:	701a      	strb	r2, [r3, #0]
    pos += putU8(&ptr[pos], rate);
 8007ba8:	193b      	adds	r3, r7, r4
 8007baa:	781b      	ldrb	r3, [r3, #0]
 8007bac:	68ba      	ldr	r2, [r7, #8]
 8007bae:	18d2      	adds	r2, r2, r3
 8007bb0:	1c7b      	adds	r3, r7, #1
 8007bb2:	781b      	ldrb	r3, [r3, #0]
 8007bb4:	0019      	movs	r1, r3
 8007bb6:	0010      	movs	r0, r2
 8007bb8:	f000 f8d9 	bl	8007d6e <putU8>
 8007bbc:	0003      	movs	r3, r0
 8007bbe:	0019      	movs	r1, r3
 8007bc0:	193b      	adds	r3, r7, r4
 8007bc2:	193a      	adds	r2, r7, r4
 8007bc4:	7812      	ldrb	r2, [r2, #0]
 8007bc6:	188a      	adds	r2, r1, r2
 8007bc8:	701a      	strb	r2, [r3, #0]
    pos += putU8(&ptr[pos], chIndex);
 8007bca:	193b      	adds	r3, r7, r4
 8007bcc:	781b      	ldrb	r3, [r3, #0]
 8007bce:	68ba      	ldr	r2, [r7, #8]
 8007bd0:	18d2      	adds	r2, r2, r3
 8007bd2:	003b      	movs	r3, r7
 8007bd4:	781b      	ldrb	r3, [r3, #0]
 8007bd6:	0019      	movs	r1, r3
 8007bd8:	0010      	movs	r0, r2
 8007bda:	f000 f8c8 	bl	8007d6e <putU8>
 8007bde:	0003      	movs	r3, r0
 8007be0:	0019      	movs	r1, r3
 8007be2:	193b      	adds	r3, r7, r4
 8007be4:	193a      	adds	r2, r7, r4
 8007be6:	7812      	ldrb	r2, [r2, #0]
 8007be8:	188a      	adds	r2, r1, r2
 8007bea:	701a      	strb	r2, [r3, #0]
    pos += putU8(&ptr[pos], up ? 0U : 1U);
 8007bec:	193b      	adds	r3, r7, r4
 8007bee:	781b      	ldrb	r3, [r3, #0]
 8007bf0:	68ba      	ldr	r2, [r7, #8]
 8007bf2:	18d0      	adds	r0, r2, r3
 8007bf4:	2320      	movs	r3, #32
 8007bf6:	18fb      	adds	r3, r7, r3
 8007bf8:	781b      	ldrb	r3, [r3, #0]
 8007bfa:	2201      	movs	r2, #1
 8007bfc:	4053      	eors	r3, r2
 8007bfe:	b2db      	uxtb	r3, r3
 8007c00:	0019      	movs	r1, r3
 8007c02:	f000 f8b4 	bl	8007d6e <putU8>
 8007c06:	0003      	movs	r3, r0
 8007c08:	0019      	movs	r1, r3
 8007c0a:	193b      	adds	r3, r7, r4
 8007c0c:	193a      	adds	r2, r7, r4
 8007c0e:	7812      	ldrb	r2, [r2, #0]
 8007c10:	188a      	adds	r2, r1, r2
 8007c12:	701a      	strb	r2, [r3, #0]
    pos += putU32(&ptr[pos], devAddr);
 8007c14:	193b      	adds	r3, r7, r4
 8007c16:	781b      	ldrb	r3, [r3, #0]
 8007c18:	68ba      	ldr	r2, [r7, #8]
 8007c1a:	18d3      	adds	r3, r2, r3
 8007c1c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007c1e:	0011      	movs	r1, r2
 8007c20:	0018      	movs	r0, r3
 8007c22:	f000 f8e7 	bl	8007df4 <putU32>
 8007c26:	0003      	movs	r3, r0
 8007c28:	0019      	movs	r1, r3
 8007c2a:	193b      	adds	r3, r7, r4
 8007c2c:	193a      	adds	r2, r7, r4
 8007c2e:	7812      	ldrb	r2, [r2, #0]
 8007c30:	188a      	adds	r2, r1, r2
 8007c32:	701a      	strb	r2, [r3, #0]
    pos += putU32(&ptr[pos], upCounter);
 8007c34:	193b      	adds	r3, r7, r4
 8007c36:	781b      	ldrb	r3, [r3, #0]
 8007c38:	68ba      	ldr	r2, [r7, #8]
 8007c3a:	18d3      	adds	r3, r2, r3
 8007c3c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007c3e:	0011      	movs	r1, r2
 8007c40:	0018      	movs	r0, r3
 8007c42:	f000 f8d7 	bl	8007df4 <putU32>
 8007c46:	0003      	movs	r3, r0
 8007c48:	0019      	movs	r1, r3
 8007c4a:	193b      	adds	r3, r7, r4
 8007c4c:	193a      	adds	r2, r7, r4
 8007c4e:	7812      	ldrb	r2, [r2, #0]
 8007c50:	188a      	adds	r2, r1, r2
 8007c52:	701a      	strb	r2, [r3, #0]
    pos += putU8(&ptr[pos], 0U);
 8007c54:	193b      	adds	r3, r7, r4
 8007c56:	781b      	ldrb	r3, [r3, #0]
 8007c58:	68ba      	ldr	r2, [r7, #8]
 8007c5a:	18d3      	adds	r3, r2, r3
 8007c5c:	2100      	movs	r1, #0
 8007c5e:	0018      	movs	r0, r3
 8007c60:	f000 f885 	bl	8007d6e <putU8>
 8007c64:	0003      	movs	r3, r0
 8007c66:	0019      	movs	r1, r3
 8007c68:	193b      	adds	r3, r7, r4
 8007c6a:	193a      	adds	r2, r7, r4
 8007c6c:	7812      	ldrb	r2, [r2, #0]
 8007c6e:	188a      	adds	r2, r1, r2
 8007c70:	701a      	strb	r2, [r3, #0]
    (void)putU8(&ptr[pos], len);
 8007c72:	193b      	adds	r3, r7, r4
 8007c74:	781b      	ldrb	r3, [r3, #0]
 8007c76:	68ba      	ldr	r2, [r7, #8]
 8007c78:	18d2      	adds	r2, r2, r3
 8007c7a:	232c      	movs	r3, #44	; 0x2c
 8007c7c:	18fb      	adds	r3, r7, r3
 8007c7e:	781b      	ldrb	r3, [r3, #0]
 8007c80:	0019      	movs	r1, r3
 8007c82:	0010      	movs	r0, r2
 8007c84:	f000 f873 	bl	8007d6e <putU8>
}
 8007c88:	46c0      	nop			; (mov r8, r8)
 8007c8a:	46bd      	mov	sp, r7
 8007c8c:	b005      	add	sp, #20
 8007c8e:	bd90      	pop	{r4, r7, pc}

08007c90 <deriveDownCounter>:

static uint32_t deriveDownCounter(struct ldl_mac *self, uint8_t port, uint16_t counter)
{
 8007c90:	b580      	push	{r7, lr}
 8007c92:	b084      	sub	sp, #16
 8007c94:	af00      	add	r7, sp, #0
 8007c96:	6078      	str	r0, [r7, #4]
 8007c98:	0008      	movs	r0, r1
 8007c9a:	0011      	movs	r1, r2
 8007c9c:	1cfb      	adds	r3, r7, #3
 8007c9e:	1c02      	adds	r2, r0, #0
 8007ca0:	701a      	strb	r2, [r3, #0]
 8007ca2:	003b      	movs	r3, r7
 8007ca4:	1c0a      	adds	r2, r1, #0
 8007ca6:	801a      	strh	r2, [r3, #0]
    uint32_t mine = ((self->ctx.version > 0U) && (port == 0U)) ? (uint32_t)self->ctx.nwkDown : (uint32_t)self->ctx.appDown;
 8007ca8:	687b      	ldr	r3, [r7, #4]
 8007caa:	4a17      	ldr	r2, [pc, #92]	; (8007d08 <deriveDownCounter+0x78>)
 8007cac:	5c9b      	ldrb	r3, [r3, r2]
 8007cae:	2b00      	cmp	r3, #0
 8007cb0:	d008      	beq.n	8007cc4 <deriveDownCounter+0x34>
 8007cb2:	1cfb      	adds	r3, r7, #3
 8007cb4:	781b      	ldrb	r3, [r3, #0]
 8007cb6:	2b00      	cmp	r3, #0
 8007cb8:	d104      	bne.n	8007cc4 <deriveDownCounter+0x34>
 8007cba:	687a      	ldr	r2, [r7, #4]
 8007cbc:	23b1      	movs	r3, #177	; 0xb1
 8007cbe:	005b      	lsls	r3, r3, #1
 8007cc0:	5ad3      	ldrh	r3, [r2, r3]
 8007cc2:	e003      	b.n	8007ccc <deriveDownCounter+0x3c>
 8007cc4:	687a      	ldr	r2, [r7, #4]
 8007cc6:	23b0      	movs	r3, #176	; 0xb0
 8007cc8:	005b      	lsls	r3, r3, #1
 8007cca:	5ad3      	ldrh	r3, [r2, r3]
 8007ccc:	60fb      	str	r3, [r7, #12]
    
    mine = mine << 16;
 8007cce:	68fb      	ldr	r3, [r7, #12]
 8007cd0:	041b      	lsls	r3, r3, #16
 8007cd2:	60fb      	str	r3, [r7, #12]
    
    if((uint32_t)counter < mine){
 8007cd4:	003b      	movs	r3, r7
 8007cd6:	881b      	ldrh	r3, [r3, #0]
 8007cd8:	68fa      	ldr	r2, [r7, #12]
 8007cda:	429a      	cmp	r2, r3
 8007cdc:	d909      	bls.n	8007cf2 <deriveDownCounter+0x62>
        
        mine = mine + 0x10000UL + (uint32_t)counter;
 8007cde:	003b      	movs	r3, r7
 8007ce0:	881a      	ldrh	r2, [r3, #0]
 8007ce2:	68fb      	ldr	r3, [r7, #12]
 8007ce4:	18d3      	adds	r3, r2, r3
 8007ce6:	2280      	movs	r2, #128	; 0x80
 8007ce8:	0252      	lsls	r2, r2, #9
 8007cea:	4694      	mov	ip, r2
 8007cec:	4463      	add	r3, ip
 8007cee:	60fb      	str	r3, [r7, #12]
 8007cf0:	e004      	b.n	8007cfc <deriveDownCounter+0x6c>
    }
    else{
        
        mine = mine + (uint32_t)counter;
 8007cf2:	003b      	movs	r3, r7
 8007cf4:	881b      	ldrh	r3, [r3, #0]
 8007cf6:	68fa      	ldr	r2, [r7, #12]
 8007cf8:	18d3      	adds	r3, r2, r3
 8007cfa:	60fb      	str	r3, [r7, #12]
    }    
    
    return mine;
 8007cfc:	68fb      	ldr	r3, [r7, #12]
}
 8007cfe:	0018      	movs	r0, r3
 8007d00:	46bd      	mov	sp, r7
 8007d02:	b004      	add	sp, #16
 8007d04:	bd80      	pop	{r7, pc}
 8007d06:	46c0      	nop			; (mov r8, r8)
 8007d08:	00000206 	.word	0x00000206

08007d0c <putEUI>:

static uint8_t putEUI(uint8_t *buf, const uint8_t *value)
{
 8007d0c:	b580      	push	{r7, lr}
 8007d0e:	b082      	sub	sp, #8
 8007d10:	af00      	add	r7, sp, #0
 8007d12:	6078      	str	r0, [r7, #4]
 8007d14:	6039      	str	r1, [r7, #0]
    buf[0] = value[7];
 8007d16:	683b      	ldr	r3, [r7, #0]
 8007d18:	79da      	ldrb	r2, [r3, #7]
 8007d1a:	687b      	ldr	r3, [r7, #4]
 8007d1c:	701a      	strb	r2, [r3, #0]
    buf[1] = value[6];
 8007d1e:	687b      	ldr	r3, [r7, #4]
 8007d20:	3301      	adds	r3, #1
 8007d22:	683a      	ldr	r2, [r7, #0]
 8007d24:	7992      	ldrb	r2, [r2, #6]
 8007d26:	701a      	strb	r2, [r3, #0]
    buf[2] = value[5];
 8007d28:	687b      	ldr	r3, [r7, #4]
 8007d2a:	3302      	adds	r3, #2
 8007d2c:	683a      	ldr	r2, [r7, #0]
 8007d2e:	7952      	ldrb	r2, [r2, #5]
 8007d30:	701a      	strb	r2, [r3, #0]
    buf[3] = value[4];
 8007d32:	687b      	ldr	r3, [r7, #4]
 8007d34:	3303      	adds	r3, #3
 8007d36:	683a      	ldr	r2, [r7, #0]
 8007d38:	7912      	ldrb	r2, [r2, #4]
 8007d3a:	701a      	strb	r2, [r3, #0]
    buf[4] = value[3];
 8007d3c:	687b      	ldr	r3, [r7, #4]
 8007d3e:	3304      	adds	r3, #4
 8007d40:	683a      	ldr	r2, [r7, #0]
 8007d42:	78d2      	ldrb	r2, [r2, #3]
 8007d44:	701a      	strb	r2, [r3, #0]
    buf[5] = value[2];
 8007d46:	687b      	ldr	r3, [r7, #4]
 8007d48:	3305      	adds	r3, #5
 8007d4a:	683a      	ldr	r2, [r7, #0]
 8007d4c:	7892      	ldrb	r2, [r2, #2]
 8007d4e:	701a      	strb	r2, [r3, #0]
    buf[6] = value[1];
 8007d50:	687b      	ldr	r3, [r7, #4]
 8007d52:	3306      	adds	r3, #6
 8007d54:	683a      	ldr	r2, [r7, #0]
 8007d56:	7852      	ldrb	r2, [r2, #1]
 8007d58:	701a      	strb	r2, [r3, #0]
    buf[7] = value[0];
 8007d5a:	687b      	ldr	r3, [r7, #4]
 8007d5c:	3307      	adds	r3, #7
 8007d5e:	683a      	ldr	r2, [r7, #0]
 8007d60:	7812      	ldrb	r2, [r2, #0]
 8007d62:	701a      	strb	r2, [r3, #0]
    
    return 8U;
 8007d64:	2308      	movs	r3, #8
}
 8007d66:	0018      	movs	r0, r3
 8007d68:	46bd      	mov	sp, r7
 8007d6a:	b002      	add	sp, #8
 8007d6c:	bd80      	pop	{r7, pc}

08007d6e <putU8>:

static uint8_t putU8(uint8_t *buf, uint8_t value)
{
 8007d6e:	b580      	push	{r7, lr}
 8007d70:	b082      	sub	sp, #8
 8007d72:	af00      	add	r7, sp, #0
 8007d74:	6078      	str	r0, [r7, #4]
 8007d76:	000a      	movs	r2, r1
 8007d78:	1cfb      	adds	r3, r7, #3
 8007d7a:	701a      	strb	r2, [r3, #0]
    buf[0] = value;
 8007d7c:	687b      	ldr	r3, [r7, #4]
 8007d7e:	1cfa      	adds	r2, r7, #3
 8007d80:	7812      	ldrb	r2, [r2, #0]
 8007d82:	701a      	strb	r2, [r3, #0]
    
    return 1U;
 8007d84:	2301      	movs	r3, #1
}
 8007d86:	0018      	movs	r0, r3
 8007d88:	46bd      	mov	sp, r7
 8007d8a:	b002      	add	sp, #8
 8007d8c:	bd80      	pop	{r7, pc}

08007d8e <putU16>:

static uint8_t putU16(uint8_t *buf, uint16_t value)
{
 8007d8e:	b580      	push	{r7, lr}
 8007d90:	b082      	sub	sp, #8
 8007d92:	af00      	add	r7, sp, #0
 8007d94:	6078      	str	r0, [r7, #4]
 8007d96:	000a      	movs	r2, r1
 8007d98:	1cbb      	adds	r3, r7, #2
 8007d9a:	801a      	strh	r2, [r3, #0]
    buf[0] = value;
 8007d9c:	1cbb      	adds	r3, r7, #2
 8007d9e:	881b      	ldrh	r3, [r3, #0]
 8007da0:	b2da      	uxtb	r2, r3
 8007da2:	687b      	ldr	r3, [r7, #4]
 8007da4:	701a      	strb	r2, [r3, #0]
    buf[1] = value >> 8;
 8007da6:	1cbb      	adds	r3, r7, #2
 8007da8:	881b      	ldrh	r3, [r3, #0]
 8007daa:	0a1b      	lsrs	r3, r3, #8
 8007dac:	b29a      	uxth	r2, r3
 8007dae:	687b      	ldr	r3, [r7, #4]
 8007db0:	3301      	adds	r3, #1
 8007db2:	b2d2      	uxtb	r2, r2
 8007db4:	701a      	strb	r2, [r3, #0]
    
    return 2U;
 8007db6:	2302      	movs	r3, #2
}
 8007db8:	0018      	movs	r0, r3
 8007dba:	46bd      	mov	sp, r7
 8007dbc:	b002      	add	sp, #8
 8007dbe:	bd80      	pop	{r7, pc}

08007dc0 <putU24>:

static uint8_t putU24(uint8_t *buf, uint32_t value)
{
 8007dc0:	b580      	push	{r7, lr}
 8007dc2:	b082      	sub	sp, #8
 8007dc4:	af00      	add	r7, sp, #0
 8007dc6:	6078      	str	r0, [r7, #4]
 8007dc8:	6039      	str	r1, [r7, #0]
    buf[0] = value;
 8007dca:	683b      	ldr	r3, [r7, #0]
 8007dcc:	b2da      	uxtb	r2, r3
 8007dce:	687b      	ldr	r3, [r7, #4]
 8007dd0:	701a      	strb	r2, [r3, #0]
    buf[1] = value >> 8;
 8007dd2:	683b      	ldr	r3, [r7, #0]
 8007dd4:	0a1a      	lsrs	r2, r3, #8
 8007dd6:	687b      	ldr	r3, [r7, #4]
 8007dd8:	3301      	adds	r3, #1
 8007dda:	b2d2      	uxtb	r2, r2
 8007ddc:	701a      	strb	r2, [r3, #0]
    buf[2] = value >> 16;
 8007dde:	683b      	ldr	r3, [r7, #0]
 8007de0:	0c1a      	lsrs	r2, r3, #16
 8007de2:	687b      	ldr	r3, [r7, #4]
 8007de4:	3302      	adds	r3, #2
 8007de6:	b2d2      	uxtb	r2, r2
 8007de8:	701a      	strb	r2, [r3, #0]
    
    return 3U;    
 8007dea:	2303      	movs	r3, #3
}
 8007dec:	0018      	movs	r0, r3
 8007dee:	46bd      	mov	sp, r7
 8007df0:	b002      	add	sp, #8
 8007df2:	bd80      	pop	{r7, pc}

08007df4 <putU32>:

static uint8_t putU32(uint8_t *buf, uint32_t value)
{
 8007df4:	b580      	push	{r7, lr}
 8007df6:	b082      	sub	sp, #8
 8007df8:	af00      	add	r7, sp, #0
 8007dfa:	6078      	str	r0, [r7, #4]
 8007dfc:	6039      	str	r1, [r7, #0]
    buf[0] = value;
 8007dfe:	683b      	ldr	r3, [r7, #0]
 8007e00:	b2da      	uxtb	r2, r3
 8007e02:	687b      	ldr	r3, [r7, #4]
 8007e04:	701a      	strb	r2, [r3, #0]
    buf[1] = value >> 8;
 8007e06:	683b      	ldr	r3, [r7, #0]
 8007e08:	0a1a      	lsrs	r2, r3, #8
 8007e0a:	687b      	ldr	r3, [r7, #4]
 8007e0c:	3301      	adds	r3, #1
 8007e0e:	b2d2      	uxtb	r2, r2
 8007e10:	701a      	strb	r2, [r3, #0]
    buf[2] = value >> 16;
 8007e12:	683b      	ldr	r3, [r7, #0]
 8007e14:	0c1a      	lsrs	r2, r3, #16
 8007e16:	687b      	ldr	r3, [r7, #4]
 8007e18:	3302      	adds	r3, #2
 8007e1a:	b2d2      	uxtb	r2, r2
 8007e1c:	701a      	strb	r2, [r3, #0]
    buf[3] = value >> 24;
 8007e1e:	683b      	ldr	r3, [r7, #0]
 8007e20:	0e1a      	lsrs	r2, r3, #24
 8007e22:	687b      	ldr	r3, [r7, #4]
 8007e24:	3303      	adds	r3, #3
 8007e26:	b2d2      	uxtb	r2, r2
 8007e28:	701a      	strb	r2, [r3, #0]
    
    return 4U;        
 8007e2a:	2304      	movs	r3, #4
}
 8007e2c:	0018      	movs	r0, r3
 8007e2e:	46bd      	mov	sp, r7
 8007e30:	b002      	add	sp, #8
 8007e32:	bd80      	pop	{r7, pc}

08007e34 <LDL_Radio_init>:
static uint8_t sfSetting(const struct ldl_radio *self, enum ldl_spreading_factor sf);

/* functions **********************************************************/

void LDL_Radio_init(struct ldl_radio *self, enum ldl_radio_type type, void *board)
{
 8007e34:	b590      	push	{r4, r7, lr}
 8007e36:	b085      	sub	sp, #20
 8007e38:	af00      	add	r7, sp, #0
 8007e3a:	60f8      	str	r0, [r7, #12]
 8007e3c:	607a      	str	r2, [r7, #4]
 8007e3e:	240b      	movs	r4, #11
 8007e40:	193b      	adds	r3, r7, r4
 8007e42:	1c0a      	adds	r2, r1, #0
 8007e44:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(self != NULL)
    
    (void)memset(self, 0, sizeof(*self));
 8007e46:	68fb      	ldr	r3, [r7, #12]
 8007e48:	2210      	movs	r2, #16
 8007e4a:	2100      	movs	r1, #0
 8007e4c:	0018      	movs	r0, r3
 8007e4e:	f004 fd44 	bl	800c8da <memset>
    self->board = board;
 8007e52:	68fb      	ldr	r3, [r7, #12]
 8007e54:	687a      	ldr	r2, [r7, #4]
 8007e56:	601a      	str	r2, [r3, #0]

    self->type = type;
 8007e58:	68fb      	ldr	r3, [r7, #12]
 8007e5a:	193a      	adds	r2, r7, r4
 8007e5c:	7812      	ldrb	r2, [r2, #0]
 8007e5e:	719a      	strb	r2, [r3, #6]
}
 8007e60:	46c0      	nop			; (mov r8, r8)
 8007e62:	46bd      	mov	sp, r7
 8007e64:	b005      	add	sp, #20
 8007e66:	bd90      	pop	{r4, r7, pc}

08007e68 <LDL_Radio_setPA>:

void LDL_Radio_setPA(struct ldl_radio *self, enum ldl_radio_pa pa)
{
 8007e68:	b580      	push	{r7, lr}
 8007e6a:	b082      	sub	sp, #8
 8007e6c:	af00      	add	r7, sp, #0
 8007e6e:	6078      	str	r0, [r7, #4]
 8007e70:	000a      	movs	r2, r1
 8007e72:	1cfb      	adds	r3, r7, #3
 8007e74:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(self != NULL)
    
    self->pa = pa;    
 8007e76:	687b      	ldr	r3, [r7, #4]
 8007e78:	1cfa      	adds	r2, r7, #3
 8007e7a:	7812      	ldrb	r2, [r2, #0]
 8007e7c:	711a      	strb	r2, [r3, #4]
}
 8007e7e:	46c0      	nop			; (mov r8, r8)
 8007e80:	46bd      	mov	sp, r7
 8007e82:	b002      	add	sp, #8
 8007e84:	bd80      	pop	{r7, pc}

08007e86 <LDL_Radio_setHandler>:

void LDL_Radio_setHandler(struct ldl_radio *self, struct ldl_mac *mac, ldl_radio_event_fn handler)
{
 8007e86:	b580      	push	{r7, lr}
 8007e88:	b084      	sub	sp, #16
 8007e8a:	af00      	add	r7, sp, #0
 8007e8c:	60f8      	str	r0, [r7, #12]
 8007e8e:	60b9      	str	r1, [r7, #8]
 8007e90:	607a      	str	r2, [r7, #4]
    LDL_PEDANTIC(self != NULL)
    
    self->handler = handler;
 8007e92:	68fb      	ldr	r3, [r7, #12]
 8007e94:	687a      	ldr	r2, [r7, #4]
 8007e96:	60da      	str	r2, [r3, #12]
    self->mac = mac;
 8007e98:	68fb      	ldr	r3, [r7, #12]
 8007e9a:	68ba      	ldr	r2, [r7, #8]
 8007e9c:	609a      	str	r2, [r3, #8]
}
 8007e9e:	46c0      	nop			; (mov r8, r8)
 8007ea0:	46bd      	mov	sp, r7
 8007ea2:	b004      	add	sp, #16
 8007ea4:	bd80      	pop	{r7, pc}

08007ea6 <LDL_Radio_interrupt>:

void LDL_Radio_interrupt(struct ldl_radio *self, uint8_t n)
{
 8007ea6:	b5b0      	push	{r4, r5, r7, lr}
 8007ea8:	b082      	sub	sp, #8
 8007eaa:	af00      	add	r7, sp, #0
 8007eac:	6078      	str	r0, [r7, #4]
 8007eae:	000a      	movs	r2, r1
 8007eb0:	1cfb      	adds	r3, r7, #3
 8007eb2:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(self != NULL)
    
    if(self->handler != NULL){
 8007eb4:	687b      	ldr	r3, [r7, #4]
 8007eb6:	68db      	ldr	r3, [r3, #12]
 8007eb8:	2b00      	cmp	r3, #0
 8007eba:	d00e      	beq.n	8007eda <LDL_Radio_interrupt+0x34>
        
        self->handler(self->mac, LDL_Radio_signal(self, n));
 8007ebc:	687b      	ldr	r3, [r7, #4]
 8007ebe:	68dc      	ldr	r4, [r3, #12]
 8007ec0:	687b      	ldr	r3, [r7, #4]
 8007ec2:	689d      	ldr	r5, [r3, #8]
 8007ec4:	1cfb      	adds	r3, r7, #3
 8007ec6:	781a      	ldrb	r2, [r3, #0]
 8007ec8:	687b      	ldr	r3, [r7, #4]
 8007eca:	0011      	movs	r1, r2
 8007ecc:	0018      	movs	r0, r3
 8007ece:	f000 f929 	bl	8008124 <LDL_Radio_signal>
 8007ed2:	0003      	movs	r3, r0
 8007ed4:	0019      	movs	r1, r3
 8007ed6:	0028      	movs	r0, r5
 8007ed8:	47a0      	blx	r4
    }
}
 8007eda:	46c0      	nop			; (mov r8, r8)
 8007edc:	46bd      	mov	sp, r7
 8007ede:	b002      	add	sp, #8
 8007ee0:	bdb0      	pop	{r4, r5, r7, pc}

08007ee2 <LDL_Radio_reset>:

void LDL_Radio_reset(struct ldl_radio *self, bool state)
{
 8007ee2:	b580      	push	{r7, lr}
 8007ee4:	b082      	sub	sp, #8
 8007ee6:	af00      	add	r7, sp, #0
 8007ee8:	6078      	str	r0, [r7, #4]
 8007eea:	000a      	movs	r2, r1
 8007eec:	1cfb      	adds	r3, r7, #3
 8007eee:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(self != NULL)
    
    LDL_Chip_reset(self->board, state);
 8007ef0:	687b      	ldr	r3, [r7, #4]
 8007ef2:	681a      	ldr	r2, [r3, #0]
 8007ef4:	1cfb      	adds	r3, r7, #3
 8007ef6:	781b      	ldrb	r3, [r3, #0]
 8007ef8:	0019      	movs	r1, r3
 8007efa:	0010      	movs	r0, r2
 8007efc:	f002 f8c8 	bl	800a090 <LDL_Chip_reset>
}
 8007f00:	46c0      	nop			; (mov r8, r8)
 8007f02:	46bd      	mov	sp, r7
 8007f04:	b002      	add	sp, #8
 8007f06:	bd80      	pop	{r7, pc}

08007f08 <LDL_Radio_transmit>:

void LDL_Radio_transmit(struct ldl_radio *self, const struct ldl_radio_tx_setting *settings, const void *data, uint8_t len)
{
 8007f08:	b580      	push	{r7, lr}
 8007f0a:	b084      	sub	sp, #16
 8007f0c:	af00      	add	r7, sp, #0
 8007f0e:	60f8      	str	r0, [r7, #12]
 8007f10:	60b9      	str	r1, [r7, #8]
 8007f12:	607a      	str	r2, [r7, #4]
 8007f14:	001a      	movs	r2, r3
 8007f16:	1cfb      	adds	r3, r7, #3
 8007f18:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(self != NULL)
    LDL_PEDANTIC(settings != NULL)
    LDL_PEDANTIC((data != NULL) || (len == 0U))
    LDL_PEDANTIC(settings->freq != 0U)
    
    self->dio_mapping1 = 0x40U;
 8007f1a:	68fb      	ldr	r3, [r7, #12]
 8007f1c:	2240      	movs	r2, #64	; 0x40
 8007f1e:	715a      	strb	r2, [r3, #5]
    
    setOpStandby(self);
 8007f20:	68fb      	ldr	r3, [r7, #12]
 8007f22:	0018      	movs	r0, r3
 8007f24:	f000 fa47 	bl	80083b6 <setOpStandby>
    
    setModemConfig(self, settings->bw, settings->sf);    
 8007f28:	68bb      	ldr	r3, [r7, #8]
 8007f2a:	7919      	ldrb	r1, [r3, #4]
 8007f2c:	68bb      	ldr	r3, [r7, #8]
 8007f2e:	795a      	ldrb	r2, [r3, #5]
 8007f30:	68fb      	ldr	r3, [r7, #12]
 8007f32:	0018      	movs	r0, r3
 8007f34:	f000 fa73 	bl	800841e <setModemConfig>

    setFreq(self, settings->freq);
 8007f38:	68bb      	ldr	r3, [r7, #8]
 8007f3a:	681a      	ldr	r2, [r3, #0]
 8007f3c:	68fb      	ldr	r3, [r7, #12]
 8007f3e:	0011      	movs	r1, r2
 8007f40:	0018      	movs	r0, r3
 8007f42:	f000 fc0d 	bl	8008760 <setFreq>
    setPower(self, settings->dbm);
 8007f46:	68bb      	ldr	r3, [r7, #8]
 8007f48:	2206      	movs	r2, #6
 8007f4a:	5e9a      	ldrsh	r2, [r3, r2]
 8007f4c:	68fb      	ldr	r3, [r7, #12]
 8007f4e:	0011      	movs	r1, r2
 8007f50:	0018      	movs	r0, r3
 8007f52:	f000 fac4 	bl	80084de <setPower>
    
    writeReg(self, RegSyncWord, 0x34);                                               // set sync word
 8007f56:	68fb      	ldr	r3, [r7, #12]
 8007f58:	2234      	movs	r2, #52	; 0x34
 8007f5a:	2139      	movs	r1, #57	; 0x39
 8007f5c:	0018      	movs	r0, r3
 8007f5e:	f000 fca7 	bl	80088b0 <writeReg>
    writeReg(self, RegPaRamp, (readReg(self, RegPaRamp) & 0xf0U) | 0x08U);    // 50us PA ramp
 8007f62:	68fb      	ldr	r3, [r7, #12]
 8007f64:	210a      	movs	r1, #10
 8007f66:	0018      	movs	r0, r3
 8007f68:	f000 fc8c 	bl	8008884 <readReg>
 8007f6c:	0003      	movs	r3, r0
 8007f6e:	001a      	movs	r2, r3
 8007f70:	230f      	movs	r3, #15
 8007f72:	439a      	bics	r2, r3
 8007f74:	0013      	movs	r3, r2
 8007f76:	b2db      	uxtb	r3, r3
 8007f78:	2208      	movs	r2, #8
 8007f7a:	4313      	orrs	r3, r2
 8007f7c:	b2da      	uxtb	r2, r3
 8007f7e:	68fb      	ldr	r3, [r7, #12]
 8007f80:	210a      	movs	r1, #10
 8007f82:	0018      	movs	r0, r3
 8007f84:	f000 fc94 	bl	80088b0 <writeReg>
    writeReg(self, RegInvertIQ, readReg(self, RegInvertIQ) & ~(0x40U));       // non-invert IQ    
 8007f88:	68fb      	ldr	r3, [r7, #12]
 8007f8a:	2133      	movs	r1, #51	; 0x33
 8007f8c:	0018      	movs	r0, r3
 8007f8e:	f000 fc79 	bl	8008884 <readReg>
 8007f92:	0003      	movs	r3, r0
 8007f94:	001a      	movs	r2, r3
 8007f96:	2340      	movs	r3, #64	; 0x40
 8007f98:	439a      	bics	r2, r3
 8007f9a:	0013      	movs	r3, r2
 8007f9c:	b2da      	uxtb	r2, r3
 8007f9e:	68fb      	ldr	r3, [r7, #12]
 8007fa0:	2133      	movs	r1, #51	; 0x33
 8007fa2:	0018      	movs	r0, r3
 8007fa4:	f000 fc84 	bl	80088b0 <writeReg>
    writeReg(self, RegDioMapping1, self->dio_mapping1);                              // DIO0 (TX_COMPLETE) DIO1 (RX_DONE)
 8007fa8:	68fb      	ldr	r3, [r7, #12]
 8007faa:	795a      	ldrb	r2, [r3, #5]
 8007fac:	68fb      	ldr	r3, [r7, #12]
 8007fae:	2140      	movs	r1, #64	; 0x40
 8007fb0:	0018      	movs	r0, r3
 8007fb2:	f000 fc7d 	bl	80088b0 <writeReg>
    writeReg(self, RegIrqFlags, 0xff);                                               // clear all interrupts
 8007fb6:	68fb      	ldr	r3, [r7, #12]
 8007fb8:	22ff      	movs	r2, #255	; 0xff
 8007fba:	2112      	movs	r1, #18
 8007fbc:	0018      	movs	r0, r3
 8007fbe:	f000 fc77 	bl	80088b0 <writeReg>
    writeReg(self, RegIrqFlagsMask, 0xf7U);                                          // unmask TX_DONE interrupt                    
 8007fc2:	68fb      	ldr	r3, [r7, #12]
 8007fc4:	22f7      	movs	r2, #247	; 0xf7
 8007fc6:	2111      	movs	r1, #17
 8007fc8:	0018      	movs	r0, r3
 8007fca:	f000 fc71 	bl	80088b0 <writeReg>
    
    writeFIFO(self, data, len);
 8007fce:	1cfb      	adds	r3, r7, #3
 8007fd0:	781a      	ldrb	r2, [r3, #0]
 8007fd2:	6879      	ldr	r1, [r7, #4]
 8007fd4:	68fb      	ldr	r3, [r7, #12]
 8007fd6:	0018      	movs	r0, r3
 8007fd8:	f000 fc2f 	bl	800883a <writeFIFO>
    
    setOpTX(self);    
 8007fdc:	68fb      	ldr	r3, [r7, #12]
 8007fde:	0018      	movs	r0, r3
 8007fe0:	f000 fa10 	bl	8008404 <setOpTX>
}
 8007fe4:	46c0      	nop			; (mov r8, r8)
 8007fe6:	46bd      	mov	sp, r7
 8007fe8:	b004      	add	sp, #16
 8007fea:	bd80      	pop	{r7, pc}

08007fec <LDL_Radio_receive>:

void LDL_Radio_receive(struct ldl_radio *self, const struct ldl_radio_rx_setting *settings)
{
 8007fec:	b580      	push	{r7, lr}
 8007fee:	b082      	sub	sp, #8
 8007ff0:	af00      	add	r7, sp, #0
 8007ff2:	6078      	str	r0, [r7, #4]
 8007ff4:	6039      	str	r1, [r7, #0]
    LDL_PEDANTIC(self != NULL)
    LDL_PEDANTIC(settings != NULL)
    LDL_PEDANTIC(settings->freq != 0U)
    
    self->dio_mapping1 = 0U;
 8007ff6:	687b      	ldr	r3, [r7, #4]
 8007ff8:	2200      	movs	r2, #0
 8007ffa:	715a      	strb	r2, [r3, #5]
    
    setOpStandby(self);
 8007ffc:	687b      	ldr	r3, [r7, #4]
 8007ffe:	0018      	movs	r0, r3
 8008000:	f000 f9d9 	bl	80083b6 <setOpStandby>
    
    setModemConfig(self, settings->bw, settings->sf);
 8008004:	683b      	ldr	r3, [r7, #0]
 8008006:	7a19      	ldrb	r1, [r3, #8]
 8008008:	683b      	ldr	r3, [r7, #0]
 800800a:	7a5a      	ldrb	r2, [r3, #9]
 800800c:	687b      	ldr	r3, [r7, #4]
 800800e:	0018      	movs	r0, r3
 8008010:	f000 fa05 	bl	800841e <setModemConfig>
    
    setFreq(self, settings->freq);                                                  // set carrier frequency        
 8008014:	683b      	ldr	r3, [r7, #0]
 8008016:	685a      	ldr	r2, [r3, #4]
 8008018:	687b      	ldr	r3, [r7, #4]
 800801a:	0011      	movs	r1, r2
 800801c:	0018      	movs	r0, r3
 800801e:	f000 fb9f 	bl	8008760 <setFreq>
    
    writeReg(self, RegSymbTimeoutLsb, settings->timeout);                    // set symbol timeout
 8008022:	683b      	ldr	r3, [r7, #0]
 8008024:	7a9a      	ldrb	r2, [r3, #10]
 8008026:	687b      	ldr	r3, [r7, #4]
 8008028:	211f      	movs	r1, #31
 800802a:	0018      	movs	r0, r3
 800802c:	f000 fc40 	bl	80088b0 <writeReg>
    writeReg(self, RegSyncWord, 0x34);                                       // set sync word
 8008030:	687b      	ldr	r3, [r7, #4]
 8008032:	2234      	movs	r2, #52	; 0x34
 8008034:	2139      	movs	r1, #57	; 0x39
 8008036:	0018      	movs	r0, r3
 8008038:	f000 fc3a 	bl	80088b0 <writeReg>
    writeReg(self, RegLna, 0x23U);                                           // LNA gain to max, LNA boost enable    
 800803c:	687b      	ldr	r3, [r7, #4]
 800803e:	2223      	movs	r2, #35	; 0x23
 8008040:	210c      	movs	r1, #12
 8008042:	0018      	movs	r0, r3
 8008044:	f000 fc34 	bl	80088b0 <writeReg>
    writeReg(self, RegPayloadMaxLength, settings->max);                      // max payload
 8008048:	683b      	ldr	r3, [r7, #0]
 800804a:	7ada      	ldrb	r2, [r3, #11]
 800804c:	687b      	ldr	r3, [r7, #4]
 800804e:	2123      	movs	r1, #35	; 0x23
 8008050:	0018      	movs	r0, r3
 8008052:	f000 fc2d 	bl	80088b0 <writeReg>
    writeReg(self, RegInvertIQ, readReg(self, RegInvertIQ) | 0x40U);  // invert IQ    
 8008056:	687b      	ldr	r3, [r7, #4]
 8008058:	2133      	movs	r1, #51	; 0x33
 800805a:	0018      	movs	r0, r3
 800805c:	f000 fc12 	bl	8008884 <readReg>
 8008060:	0003      	movs	r3, r0
 8008062:	001a      	movs	r2, r3
 8008064:	2340      	movs	r3, #64	; 0x40
 8008066:	4313      	orrs	r3, r2
 8008068:	b2da      	uxtb	r2, r3
 800806a:	687b      	ldr	r3, [r7, #4]
 800806c:	2133      	movs	r1, #51	; 0x33
 800806e:	0018      	movs	r0, r3
 8008070:	f000 fc1e 	bl	80088b0 <writeReg>
    writeReg(self, RegDioMapping1, self->dio_mapping1);                      // DIO0 (RX_TIMEOUT) DIO1 (RX_DONE)    
 8008074:	687b      	ldr	r3, [r7, #4]
 8008076:	795a      	ldrb	r2, [r3, #5]
 8008078:	687b      	ldr	r3, [r7, #4]
 800807a:	2140      	movs	r1, #64	; 0x40
 800807c:	0018      	movs	r0, r3
 800807e:	f000 fc17 	bl	80088b0 <writeReg>
    writeReg(self, RegIrqFlags, 0xff);                                       // clear all interrupts
 8008082:	687b      	ldr	r3, [r7, #4]
 8008084:	22ff      	movs	r2, #255	; 0xff
 8008086:	2112      	movs	r1, #18
 8008088:	0018      	movs	r0, r3
 800808a:	f000 fc11 	bl	80088b0 <writeReg>
    writeReg(self, RegIrqFlagsMask, 0x3fU);                                  // unmask RX_TIMEOUT and RX_DONE interrupt                    
 800808e:	687b      	ldr	r3, [r7, #4]
 8008090:	223f      	movs	r2, #63	; 0x3f
 8008092:	2111      	movs	r1, #17
 8008094:	0018      	movs	r0, r3
 8008096:	f000 fc0b 	bl	80088b0 <writeReg>
    
    setOpRX(self);
 800809a:	687b      	ldr	r3, [r7, #4]
 800809c:	0018      	movs	r0, r3
 800809e:	f000 f997 	bl	80083d0 <setOpRX>
}
 80080a2:	46c0      	nop			; (mov r8, r8)
 80080a4:	46bd      	mov	sp, r7
 80080a6:	b002      	add	sp, #8
 80080a8:	bd80      	pop	{r7, pc}

080080aa <LDL_Radio_collect>:

uint8_t LDL_Radio_collect(struct ldl_radio *self, struct ldl_radio_packet_metadata *meta, void *data, uint8_t max)
{   
 80080aa:	b590      	push	{r4, r7, lr}
 80080ac:	b087      	sub	sp, #28
 80080ae:	af00      	add	r7, sp, #0
 80080b0:	60f8      	str	r0, [r7, #12]
 80080b2:	60b9      	str	r1, [r7, #8]
 80080b4:	607a      	str	r2, [r7, #4]
 80080b6:	001a      	movs	r2, r3
 80080b8:	1cfb      	adds	r3, r7, #3
 80080ba:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(self != NULL)
    LDL_PEDANTIC((data != NULL) || (max == 0U))
    
    uint8_t retval;
    
    (void)memset(meta, 0, sizeof(*meta));
 80080bc:	68bb      	ldr	r3, [r7, #8]
 80080be:	2204      	movs	r2, #4
 80080c0:	2100      	movs	r1, #0
 80080c2:	0018      	movs	r0, r3
 80080c4:	f004 fc09 	bl	800c8da <memset>
    
    retval = readFIFO(self, data, max);
 80080c8:	2317      	movs	r3, #23
 80080ca:	18fc      	adds	r4, r7, r3
 80080cc:	1cfb      	adds	r3, r7, #3
 80080ce:	781a      	ldrb	r2, [r3, #0]
 80080d0:	6879      	ldr	r1, [r7, #4]
 80080d2:	68fb      	ldr	r3, [r7, #12]
 80080d4:	0018      	movs	r0, r3
 80080d6:	f000 fb75 	bl	80087c4 <readFIFO>
 80080da:	0003      	movs	r3, r0
 80080dc:	7023      	strb	r3, [r4, #0]
    
    meta->rssi = (int16_t)readReg(self, RegPktRssiValue) - 157;
 80080de:	68fb      	ldr	r3, [r7, #12]
 80080e0:	211a      	movs	r1, #26
 80080e2:	0018      	movs	r0, r3
 80080e4:	f000 fbce 	bl	8008884 <readReg>
 80080e8:	0003      	movs	r3, r0
 80080ea:	b29b      	uxth	r3, r3
 80080ec:	3b9d      	subs	r3, #157	; 0x9d
 80080ee:	b29b      	uxth	r3, r3
 80080f0:	b21a      	sxth	r2, r3
 80080f2:	68bb      	ldr	r3, [r7, #8]
 80080f4:	801a      	strh	r2, [r3, #0]
    meta->snr = ((int16_t)readReg(self, RegPktSnrValue)) * 100 / 4;
 80080f6:	68fb      	ldr	r3, [r7, #12]
 80080f8:	2119      	movs	r1, #25
 80080fa:	0018      	movs	r0, r3
 80080fc:	f000 fbc2 	bl	8008884 <readReg>
 8008100:	0003      	movs	r3, r0
 8008102:	001a      	movs	r2, r3
 8008104:	2364      	movs	r3, #100	; 0x64
 8008106:	4353      	muls	r3, r2
 8008108:	2b00      	cmp	r3, #0
 800810a:	da00      	bge.n	800810e <LDL_Radio_collect+0x64>
 800810c:	3303      	adds	r3, #3
 800810e:	109b      	asrs	r3, r3, #2
 8008110:	b21a      	sxth	r2, r3
 8008112:	68bb      	ldr	r3, [r7, #8]
 8008114:	805a      	strh	r2, [r3, #2]
    
    return retval;
 8008116:	2317      	movs	r3, #23
 8008118:	18fb      	adds	r3, r7, r3
 800811a:	781b      	ldrb	r3, [r3, #0]
}
 800811c:	0018      	movs	r0, r3
 800811e:	46bd      	mov	sp, r7
 8008120:	b007      	add	sp, #28
 8008122:	bd90      	pop	{r4, r7, pc}

08008124 <LDL_Radio_signal>:

enum ldl_radio_event LDL_Radio_signal(struct ldl_radio *self, uint8_t n)
{    
 8008124:	b580      	push	{r7, lr}
 8008126:	b084      	sub	sp, #16
 8008128:	af00      	add	r7, sp, #0
 800812a:	6078      	str	r0, [r7, #4]
 800812c:	000a      	movs	r2, r1
 800812e:	1cfb      	adds	r3, r7, #3
 8008130:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(self != NULL)
    
    enum ldl_radio_event retval = LDL_RADIO_EVENT_NONE;
 8008132:	230f      	movs	r3, #15
 8008134:	18fb      	adds	r3, r7, r3
 8008136:	2203      	movs	r2, #3
 8008138:	701a      	strb	r2, [r3, #0]
    
    switch(n){
 800813a:	1cfb      	adds	r3, r7, #3
 800813c:	781b      	ldrb	r3, [r3, #0]
 800813e:	2b00      	cmp	r3, #0
 8008140:	d002      	beq.n	8008148 <LDL_Radio_signal+0x24>
 8008142:	2b01      	cmp	r3, #1
 8008144:	d012      	beq.n	800816c <LDL_Radio_signal+0x48>
        }         
        break;
    
    default:
        /* do nothing */
        break;
 8008146:	e01c      	b.n	8008182 <LDL_Radio_signal+0x5e>
        switch(self->dio_mapping1){
 8008148:	687b      	ldr	r3, [r7, #4]
 800814a:	795b      	ldrb	r3, [r3, #5]
 800814c:	2b00      	cmp	r3, #0
 800814e:	d002      	beq.n	8008156 <LDL_Radio_signal+0x32>
 8008150:	2b40      	cmp	r3, #64	; 0x40
 8008152:	d005      	beq.n	8008160 <LDL_Radio_signal+0x3c>
            break;
 8008154:	e009      	b.n	800816a <LDL_Radio_signal+0x46>
            retval = LDL_RADIO_EVENT_RX_READY;
 8008156:	230f      	movs	r3, #15
 8008158:	18fb      	adds	r3, r7, r3
 800815a:	2201      	movs	r2, #1
 800815c:	701a      	strb	r2, [r3, #0]
            break;
 800815e:	e004      	b.n	800816a <LDL_Radio_signal+0x46>
            retval = LDL_RADIO_EVENT_TX_COMPLETE;
 8008160:	230f      	movs	r3, #15
 8008162:	18fb      	adds	r3, r7, r3
 8008164:	2200      	movs	r2, #0
 8008166:	701a      	strb	r2, [r3, #0]
            break;
 8008168:	46c0      	nop			; (mov r8, r8)
        break;
 800816a:	e00a      	b.n	8008182 <LDL_Radio_signal+0x5e>
        switch(self->dio_mapping1){
 800816c:	687b      	ldr	r3, [r7, #4]
 800816e:	795b      	ldrb	r3, [r3, #5]
 8008170:	2b00      	cmp	r3, #0
 8008172:	d000      	beq.n	8008176 <LDL_Radio_signal+0x52>
            break;
 8008174:	e004      	b.n	8008180 <LDL_Radio_signal+0x5c>
            retval = LDL_RADIO_EVENT_RX_TIMEOUT;
 8008176:	230f      	movs	r3, #15
 8008178:	18fb      	adds	r3, r7, r3
 800817a:	2202      	movs	r2, #2
 800817c:	701a      	strb	r2, [r3, #0]
            break;
 800817e:	46c0      	nop			; (mov r8, r8)
        break;
 8008180:	46c0      	nop			; (mov r8, r8)
    }
    
    return retval;
 8008182:	230f      	movs	r3, #15
 8008184:	18fb      	adds	r3, r7, r3
 8008186:	781b      	ldrb	r3, [r3, #0]
}
 8008188:	0018      	movs	r0, r3
 800818a:	46bd      	mov	sp, r7
 800818c:	b004      	add	sp, #16
 800818e:	bd80      	pop	{r7, pc}

08008190 <LDL_Radio_entropyBegin>:

void LDL_Radio_entropyBegin(struct ldl_radio *self)
{
 8008190:	b580      	push	{r7, lr}
 8008192:	b082      	sub	sp, #8
 8008194:	af00      	add	r7, sp, #0
 8008196:	6078      	str	r0, [r7, #4]
    enableLora(self);
 8008198:	687b      	ldr	r3, [r7, #4]
 800819a:	0018      	movs	r0, r3
 800819c:	f000 f8c0 	bl	8008320 <enableLora>
    setOpStandby(self);
 80081a0:	687b      	ldr	r3, [r7, #4]
 80081a2:	0018      	movs	r0, r3
 80081a4:	f000 f907 	bl	80083b6 <setOpStandby>
    
    writeReg(self, RegIrqFlags, 0xff);         // clear all interrupts
 80081a8:	687b      	ldr	r3, [r7, #4]
 80081aa:	22ff      	movs	r2, #255	; 0xff
 80081ac:	2112      	movs	r1, #18
 80081ae:	0018      	movs	r0, r3
 80081b0:	f000 fb7e 	bl	80088b0 <writeReg>
    writeReg(self, RegIrqFlagsMask, 0xffU);    // mask all interrupts
 80081b4:	687b      	ldr	r3, [r7, #4]
 80081b6:	22ff      	movs	r2, #255	; 0xff
 80081b8:	2111      	movs	r1, #17
 80081ba:	0018      	movs	r0, r3
 80081bc:	f000 fb78 	bl	80088b0 <writeReg>
    
    /* application note instructions */
    switch(self->type){
 80081c0:	687b      	ldr	r3, [r7, #4]
 80081c2:	799b      	ldrb	r3, [r3, #6]
 80081c4:	2b00      	cmp	r3, #0
 80081c6:	d000      	beq.n	80081ca <LDL_Radio_entropyBegin+0x3a>
    default:
        break;
 80081c8:	e00c      	b.n	80081e4 <LDL_Radio_entropyBegin+0x54>
#ifdef LDL_ENABLE_SX1272        
    case LDL_RADIO_SX1272:
        writeReg(self, RegModemConfig1, 0x0aU);
 80081ca:	687b      	ldr	r3, [r7, #4]
 80081cc:	220a      	movs	r2, #10
 80081ce:	211d      	movs	r1, #29
 80081d0:	0018      	movs	r0, r3
 80081d2:	f000 fb6d 	bl	80088b0 <writeReg>
        writeReg(self, RegModemConfig2, 0x74U);    
 80081d6:	687b      	ldr	r3, [r7, #4]
 80081d8:	2274      	movs	r2, #116	; 0x74
 80081da:	211e      	movs	r1, #30
 80081dc:	0018      	movs	r0, r3
 80081de:	f000 fb67 	bl	80088b0 <writeReg>
        break;
 80081e2:	46c0      	nop			; (mov r8, r8)
        writeReg(self, RegModemConfig2, 0x70U);
        break;
#endif    
    }   
    
    setOpRXContinuous(self);
 80081e4:	687b      	ldr	r3, [r7, #4]
 80081e6:	0018      	movs	r0, r3
 80081e8:	f000 f8ff 	bl	80083ea <setOpRXContinuous>
}
 80081ec:	46c0      	nop			; (mov r8, r8)
 80081ee:	46bd      	mov	sp, r7
 80081f0:	b002      	add	sp, #8
 80081f2:	bd80      	pop	{r7, pc}

080081f4 <LDL_Radio_entropyEnd>:

unsigned int LDL_Radio_entropyEnd(struct ldl_radio *self)
{
 80081f4:	b580      	push	{r7, lr}
 80081f6:	b084      	sub	sp, #16
 80081f8:	af00      	add	r7, sp, #0
 80081fa:	6078      	str	r0, [r7, #4]
    unsigned int retval = 0U;
 80081fc:	2300      	movs	r3, #0
 80081fe:	60fb      	str	r3, [r7, #12]
    size_t i;
    
    for(i=0U; i < (sizeof(unsigned int)*8U); i++){
 8008200:	2300      	movs	r3, #0
 8008202:	60bb      	str	r3, [r7, #8]
 8008204:	e011      	b.n	800822a <LDL_Radio_entropyEnd+0x36>
        
        retval <<= 1;
 8008206:	68fb      	ldr	r3, [r7, #12]
 8008208:	005b      	lsls	r3, r3, #1
 800820a:	60fb      	str	r3, [r7, #12]
        retval |= readReg(self, RegRssiWideband) & 0x1U;
 800820c:	687b      	ldr	r3, [r7, #4]
 800820e:	212c      	movs	r1, #44	; 0x2c
 8008210:	0018      	movs	r0, r3
 8008212:	f000 fb37 	bl	8008884 <readReg>
 8008216:	0003      	movs	r3, r0
 8008218:	001a      	movs	r2, r3
 800821a:	2301      	movs	r3, #1
 800821c:	4013      	ands	r3, r2
 800821e:	68fa      	ldr	r2, [r7, #12]
 8008220:	4313      	orrs	r3, r2
 8008222:	60fb      	str	r3, [r7, #12]
    for(i=0U; i < (sizeof(unsigned int)*8U); i++){
 8008224:	68bb      	ldr	r3, [r7, #8]
 8008226:	3301      	adds	r3, #1
 8008228:	60bb      	str	r3, [r7, #8]
 800822a:	68bb      	ldr	r3, [r7, #8]
 800822c:	2b1f      	cmp	r3, #31
 800822e:	d9ea      	bls.n	8008206 <LDL_Radio_entropyEnd+0x12>
    }
    
    setOpSleep(self);
 8008230:	687b      	ldr	r3, [r7, #4]
 8008232:	0018      	movs	r0, r3
 8008234:	f000 f8b2 	bl	800839c <setOpSleep>
    
    return retval;
 8008238:	68fb      	ldr	r3, [r7, #12]
}
 800823a:	0018      	movs	r0, r3
 800823c:	46bd      	mov	sp, r7
 800823e:	b004      	add	sp, #16
 8008240:	bd80      	pop	{r7, pc}

08008242 <LDL_Radio_sleep>:

void LDL_Radio_sleep(struct ldl_radio *self)
{
 8008242:	b580      	push	{r7, lr}
 8008244:	b082      	sub	sp, #8
 8008246:	af00      	add	r7, sp, #0
 8008248:	6078      	str	r0, [r7, #4]
    LDL_PEDANTIC(self != NULL)    
    
    enableLora(self);
 800824a:	687b      	ldr	r3, [r7, #4]
 800824c:	0018      	movs	r0, r3
 800824e:	f000 f867 	bl	8008320 <enableLora>
}
 8008252:	46c0      	nop			; (mov r8, r8)
 8008254:	46bd      	mov	sp, r7
 8008256:	b002      	add	sp, #8
 8008258:	bd80      	pop	{r7, pc}

0800825a <LDL_Radio_clearInterrupt>:

void LDL_Radio_clearInterrupt(struct ldl_radio *self)
{
 800825a:	b580      	push	{r7, lr}
 800825c:	b082      	sub	sp, #8
 800825e:	af00      	add	r7, sp, #0
 8008260:	6078      	str	r0, [r7, #4]
    LDL_PEDANTIC(self != NULL)
    
    writeReg(self, RegIrqFlags, 0xff);         // clear all interrupts
 8008262:	687b      	ldr	r3, [r7, #4]
 8008264:	22ff      	movs	r2, #255	; 0xff
 8008266:	2112      	movs	r1, #18
 8008268:	0018      	movs	r0, r3
 800826a:	f000 fb21 	bl	80088b0 <writeReg>
    writeReg(self, RegIrqFlagsMask, 0xffU);    // mask all interrupts
 800826e:	687b      	ldr	r3, [r7, #4]
 8008270:	22ff      	movs	r2, #255	; 0xff
 8008272:	2111      	movs	r1, #17
 8008274:	0018      	movs	r0, r3
 8008276:	f000 fb1b 	bl	80088b0 <writeReg>
    
    setOpSleep(self);
 800827a:	687b      	ldr	r3, [r7, #4]
 800827c:	0018      	movs	r0, r3
 800827e:	f000 f88d 	bl	800839c <setOpSleep>
}
 8008282:	46c0      	nop			; (mov r8, r8)
 8008284:	46bd      	mov	sp, r7
 8008286:	b002      	add	sp, #8
 8008288:	bd80      	pop	{r7, pc}
	...

0800828c <LDL_Radio_minSNR>:
    enableLora(self);
}
#endif

int16_t LDL_Radio_minSNR(const struct ldl_radio *self, enum ldl_spreading_factor sf)
{
 800828c:	b580      	push	{r7, lr}
 800828e:	b084      	sub	sp, #16
 8008290:	af00      	add	r7, sp, #0
 8008292:	6078      	str	r0, [r7, #4]
 8008294:	000a      	movs	r2, r1
 8008296:	1cfb      	adds	r3, r7, #3
 8008298:	701a      	strb	r2, [r3, #0]
    int16_t retval = 0;
 800829a:	230e      	movs	r3, #14
 800829c:	18fb      	adds	r3, r7, r3
 800829e:	2200      	movs	r2, #0
 80082a0:	801a      	strh	r2, [r3, #0]
    
    (void)self;
    
    /* applicable to 1272 and 1276 */
    switch(sf){
 80082a2:	1cfb      	adds	r3, r7, #3
 80082a4:	781b      	ldrb	r3, [r3, #0]
 80082a6:	3b08      	subs	r3, #8
 80082a8:	2b04      	cmp	r3, #4
 80082aa:	d804      	bhi.n	80082b6 <LDL_Radio_minSNR+0x2a>
 80082ac:	009a      	lsls	r2, r3, #2
 80082ae:	4b15      	ldr	r3, [pc, #84]	; (8008304 <LDL_Radio_minSNR+0x78>)
 80082b0:	18d3      	adds	r3, r2, r3
 80082b2:	681b      	ldr	r3, [r3, #0]
 80082b4:	469f      	mov	pc, r3
    default:
    case LDL_SF_7:
        retval = -750;
 80082b6:	230e      	movs	r3, #14
 80082b8:	18fb      	adds	r3, r7, r3
 80082ba:	4a13      	ldr	r2, [pc, #76]	; (8008308 <LDL_Radio_minSNR+0x7c>)
 80082bc:	801a      	strh	r2, [r3, #0]
        break;
 80082be:	e018      	b.n	80082f2 <LDL_Radio_minSNR+0x66>
    case LDL_SF_8:
        retval = -1000;
 80082c0:	230e      	movs	r3, #14
 80082c2:	18fb      	adds	r3, r7, r3
 80082c4:	4a11      	ldr	r2, [pc, #68]	; (800830c <LDL_Radio_minSNR+0x80>)
 80082c6:	801a      	strh	r2, [r3, #0]
        break;
 80082c8:	e013      	b.n	80082f2 <LDL_Radio_minSNR+0x66>
    case LDL_SF_9:
        retval = -1250;
 80082ca:	230e      	movs	r3, #14
 80082cc:	18fb      	adds	r3, r7, r3
 80082ce:	4a10      	ldr	r2, [pc, #64]	; (8008310 <LDL_Radio_minSNR+0x84>)
 80082d0:	801a      	strh	r2, [r3, #0]
        break;
 80082d2:	e00e      	b.n	80082f2 <LDL_Radio_minSNR+0x66>
    case LDL_SF_10:
        retval = -1500;
 80082d4:	230e      	movs	r3, #14
 80082d6:	18fb      	adds	r3, r7, r3
 80082d8:	4a0e      	ldr	r2, [pc, #56]	; (8008314 <LDL_Radio_minSNR+0x88>)
 80082da:	801a      	strh	r2, [r3, #0]
        break;
 80082dc:	e009      	b.n	80082f2 <LDL_Radio_minSNR+0x66>
    case LDL_SF_11:
        retval = -1750;
 80082de:	230e      	movs	r3, #14
 80082e0:	18fb      	adds	r3, r7, r3
 80082e2:	4a0d      	ldr	r2, [pc, #52]	; (8008318 <LDL_Radio_minSNR+0x8c>)
 80082e4:	801a      	strh	r2, [r3, #0]
        break;
 80082e6:	e004      	b.n	80082f2 <LDL_Radio_minSNR+0x66>
    case LDL_SF_12:
        retval = -2000;
 80082e8:	230e      	movs	r3, #14
 80082ea:	18fb      	adds	r3, r7, r3
 80082ec:	4a0b      	ldr	r2, [pc, #44]	; (800831c <LDL_Radio_minSNR+0x90>)
 80082ee:	801a      	strh	r2, [r3, #0]
        break;
 80082f0:	46c0      	nop			; (mov r8, r8)
    }
    
    return retval;
 80082f2:	230e      	movs	r3, #14
 80082f4:	18fb      	adds	r3, r7, r3
 80082f6:	2200      	movs	r2, #0
 80082f8:	5e9b      	ldrsh	r3, [r3, r2]
}
 80082fa:	0018      	movs	r0, r3
 80082fc:	46bd      	mov	sp, r7
 80082fe:	b004      	add	sp, #16
 8008300:	bd80      	pop	{r7, pc}
 8008302:	46c0      	nop			; (mov r8, r8)
 8008304:	0800e570 	.word	0x0800e570
 8008308:	fffffd12 	.word	0xfffffd12
 800830c:	fffffc18 	.word	0xfffffc18
 8008310:	fffffb1e 	.word	0xfffffb1e
 8008314:	fffffa24 	.word	0xfffffa24
 8008318:	fffff92a 	.word	0xfffff92a
 800831c:	fffff830 	.word	0xfffff830

08008320 <enableLora>:
    
/* static functions ***************************************************/

static void enableLora(struct ldl_radio *self)
{
 8008320:	b580      	push	{r7, lr}
 8008322:	b082      	sub	sp, #8
 8008324:	af00      	add	r7, sp, #0
 8008326:	6078      	str	r0, [r7, #4]
    setOpSleep(self);    
 8008328:	687b      	ldr	r3, [r7, #4]
 800832a:	0018      	movs	r0, r3
 800832c:	f000 f836 	bl	800839c <setOpSleep>
    writeReg(self, RegOpMode, readReg(self, RegOpMode) | 0x80U);      
 8008330:	687b      	ldr	r3, [r7, #4]
 8008332:	2101      	movs	r1, #1
 8008334:	0018      	movs	r0, r3
 8008336:	f000 faa5 	bl	8008884 <readReg>
 800833a:	0003      	movs	r3, r0
 800833c:	001a      	movs	r2, r3
 800833e:	2380      	movs	r3, #128	; 0x80
 8008340:	425b      	negs	r3, r3
 8008342:	4313      	orrs	r3, r2
 8008344:	b2da      	uxtb	r2, r3
 8008346:	687b      	ldr	r3, [r7, #4]
 8008348:	2101      	movs	r1, #1
 800834a:	0018      	movs	r0, r3
 800834c:	f000 fab0 	bl	80088b0 <writeReg>
}
 8008350:	46c0      	nop			; (mov r8, r8)
 8008352:	46bd      	mov	sp, r7
 8008354:	b002      	add	sp, #8
 8008356:	bd80      	pop	{r7, pc}

08008358 <setOp>:

static void setOp(struct ldl_radio *self, uint8_t op)
{
 8008358:	b580      	push	{r7, lr}
 800835a:	b082      	sub	sp, #8
 800835c:	af00      	add	r7, sp, #0
 800835e:	6078      	str	r0, [r7, #4]
 8008360:	000a      	movs	r2, r1
 8008362:	1cfb      	adds	r3, r7, #3
 8008364:	701a      	strb	r2, [r3, #0]
    writeReg(self, RegOpMode, (readReg(self, RegOpMode) & ~(0x7U)) | (op & 0x7U));    
 8008366:	687b      	ldr	r3, [r7, #4]
 8008368:	2101      	movs	r1, #1
 800836a:	0018      	movs	r0, r3
 800836c:	f000 fa8a 	bl	8008884 <readReg>
 8008370:	0003      	movs	r3, r0
 8008372:	001a      	movs	r2, r3
 8008374:	2307      	movs	r3, #7
 8008376:	439a      	bics	r2, r3
 8008378:	0013      	movs	r3, r2
 800837a:	b2da      	uxtb	r2, r3
 800837c:	1cfb      	adds	r3, r7, #3
 800837e:	781b      	ldrb	r3, [r3, #0]
 8008380:	2107      	movs	r1, #7
 8008382:	400b      	ands	r3, r1
 8008384:	b2db      	uxtb	r3, r3
 8008386:	4313      	orrs	r3, r2
 8008388:	b2da      	uxtb	r2, r3
 800838a:	687b      	ldr	r3, [r7, #4]
 800838c:	2101      	movs	r1, #1
 800838e:	0018      	movs	r0, r3
 8008390:	f000 fa8e 	bl	80088b0 <writeReg>
}
 8008394:	46c0      	nop			; (mov r8, r8)
 8008396:	46bd      	mov	sp, r7
 8008398:	b002      	add	sp, #8
 800839a:	bd80      	pop	{r7, pc}

0800839c <setOpSleep>:

static void setOpSleep(struct ldl_radio *self)
{
 800839c:	b580      	push	{r7, lr}
 800839e:	b082      	sub	sp, #8
 80083a0:	af00      	add	r7, sp, #0
 80083a2:	6078      	str	r0, [r7, #4]
    setOp(self, 0U);
 80083a4:	687b      	ldr	r3, [r7, #4]
 80083a6:	2100      	movs	r1, #0
 80083a8:	0018      	movs	r0, r3
 80083aa:	f7ff ffd5 	bl	8008358 <setOp>
}
 80083ae:	46c0      	nop			; (mov r8, r8)
 80083b0:	46bd      	mov	sp, r7
 80083b2:	b002      	add	sp, #8
 80083b4:	bd80      	pop	{r7, pc}

080083b6 <setOpStandby>:

static void setOpStandby(struct ldl_radio *self)
{   
 80083b6:	b580      	push	{r7, lr}
 80083b8:	b082      	sub	sp, #8
 80083ba:	af00      	add	r7, sp, #0
 80083bc:	6078      	str	r0, [r7, #4]
    setOp(self, 1U);    
 80083be:	687b      	ldr	r3, [r7, #4]
 80083c0:	2101      	movs	r1, #1
 80083c2:	0018      	movs	r0, r3
 80083c4:	f7ff ffc8 	bl	8008358 <setOp>
}
 80083c8:	46c0      	nop			; (mov r8, r8)
 80083ca:	46bd      	mov	sp, r7
 80083cc:	b002      	add	sp, #8
 80083ce:	bd80      	pop	{r7, pc}

080083d0 <setOpRX>:

static void setOpRX(struct ldl_radio *self)
{   
 80083d0:	b580      	push	{r7, lr}
 80083d2:	b082      	sub	sp, #8
 80083d4:	af00      	add	r7, sp, #0
 80083d6:	6078      	str	r0, [r7, #4]
    setOp(self, 6U);
 80083d8:	687b      	ldr	r3, [r7, #4]
 80083da:	2106      	movs	r1, #6
 80083dc:	0018      	movs	r0, r3
 80083de:	f7ff ffbb 	bl	8008358 <setOp>
}
 80083e2:	46c0      	nop			; (mov r8, r8)
 80083e4:	46bd      	mov	sp, r7
 80083e6:	b002      	add	sp, #8
 80083e8:	bd80      	pop	{r7, pc}

080083ea <setOpRXContinuous>:

static void setOpRXContinuous(struct ldl_radio *self)
{   
 80083ea:	b580      	push	{r7, lr}
 80083ec:	b082      	sub	sp, #8
 80083ee:	af00      	add	r7, sp, #0
 80083f0:	6078      	str	r0, [r7, #4]
    setOp(self, 5U);    
 80083f2:	687b      	ldr	r3, [r7, #4]
 80083f4:	2105      	movs	r1, #5
 80083f6:	0018      	movs	r0, r3
 80083f8:	f7ff ffae 	bl	8008358 <setOp>
}
 80083fc:	46c0      	nop			; (mov r8, r8)
 80083fe:	46bd      	mov	sp, r7
 8008400:	b002      	add	sp, #8
 8008402:	bd80      	pop	{r7, pc}

08008404 <setOpTX>:

static void setOpTX(struct ldl_radio *self)
{   
 8008404:	b580      	push	{r7, lr}
 8008406:	b082      	sub	sp, #8
 8008408:	af00      	add	r7, sp, #0
 800840a:	6078      	str	r0, [r7, #4]
    setOp(self, 3U);    
 800840c:	687b      	ldr	r3, [r7, #4]
 800840e:	2103      	movs	r1, #3
 8008410:	0018      	movs	r0, r3
 8008412:	f7ff ffa1 	bl	8008358 <setOp>
}
 8008416:	46c0      	nop			; (mov r8, r8)
 8008418:	46bd      	mov	sp, r7
 800841a:	b002      	add	sp, #8
 800841c:	bd80      	pop	{r7, pc}

0800841e <setModemConfig>:

static void setModemConfig(struct ldl_radio *self, enum ldl_signal_bandwidth bw, enum ldl_spreading_factor sf)
{
 800841e:	b590      	push	{r4, r7, lr}
 8008420:	b085      	sub	sp, #20
 8008422:	af00      	add	r7, sp, #0
 8008424:	6078      	str	r0, [r7, #4]
 8008426:	0008      	movs	r0, r1
 8008428:	0011      	movs	r1, r2
 800842a:	1cfb      	adds	r3, r7, #3
 800842c:	1c02      	adds	r2, r0, #0
 800842e:	701a      	strb	r2, [r3, #0]
 8008430:	1cbb      	adds	r3, r7, #2
 8008432:	1c0a      	adds	r2, r1, #0
 8008434:	701a      	strb	r2, [r3, #0]
    bool low_rate = ((bw == LDL_BW_125) && ((sf == LDL_SF_11) || (sf == LDL_SF_12))) ? true : false;
 8008436:	1cfb      	adds	r3, r7, #3
 8008438:	781b      	ldrb	r3, [r3, #0]
 800843a:	2b00      	cmp	r3, #0
 800843c:	d109      	bne.n	8008452 <setModemConfig+0x34>
 800843e:	1cbb      	adds	r3, r7, #2
 8008440:	781b      	ldrb	r3, [r3, #0]
 8008442:	2b0b      	cmp	r3, #11
 8008444:	d003      	beq.n	800844e <setModemConfig+0x30>
 8008446:	1cbb      	adds	r3, r7, #2
 8008448:	781b      	ldrb	r3, [r3, #0]
 800844a:	2b0c      	cmp	r3, #12
 800844c:	d101      	bne.n	8008452 <setModemConfig+0x34>
 800844e:	2201      	movs	r2, #1
 8008450:	e000      	b.n	8008454 <setModemConfig+0x36>
 8008452:	2200      	movs	r2, #0
 8008454:	230f      	movs	r3, #15
 8008456:	18fb      	adds	r3, r7, r3
 8008458:	701a      	strb	r2, [r3, #0]
 800845a:	781a      	ldrb	r2, [r3, #0]
 800845c:	2101      	movs	r1, #1
 800845e:	400a      	ands	r2, r1
 8008460:	701a      	strb	r2, [r3, #0]
    
    switch(self->type){
 8008462:	687b      	ldr	r3, [r7, #4]
 8008464:	799b      	ldrb	r3, [r3, #6]
 8008466:	2b00      	cmp	r3, #0
 8008468:	d000      	beq.n	800846c <setModemConfig+0x4e>
    default:
        break;
 800846a:	e034      	b.n	80084d6 <setModemConfig+0xb8>
        /* bandwidth            (2bit)
         * codingRate           (3bit)
         * implicitHeaderModeOn (1bit) (0)
         * rxPayloadCrcOn       (1bit) (1)
         * lowDataRateOptimize  (1bit)      */
        writeReg(self, RegModemConfig1, bwSetting(self, bw) | crSetting(self, CR_5) | 0U | 2U | (low_rate ? 1U : 0U));
 800846c:	1cfb      	adds	r3, r7, #3
 800846e:	781a      	ldrb	r2, [r3, #0]
 8008470:	687b      	ldr	r3, [r7, #4]
 8008472:	0011      	movs	r1, r2
 8008474:	0018      	movs	r0, r3
 8008476:	f000 f8ed 	bl	8008654 <bwSetting>
 800847a:	0003      	movs	r3, r0
 800847c:	001c      	movs	r4, r3
 800847e:	687b      	ldr	r3, [r7, #4]
 8008480:	2101      	movs	r1, #1
 8008482:	0018      	movs	r0, r3
 8008484:	f000 f950 	bl	8008728 <crSetting>
 8008488:	0003      	movs	r3, r0
 800848a:	4323      	orrs	r3, r4
 800848c:	b2da      	uxtb	r2, r3
 800848e:	230f      	movs	r3, #15
 8008490:	18fb      	adds	r3, r7, r3
 8008492:	781b      	ldrb	r3, [r3, #0]
 8008494:	2b00      	cmp	r3, #0
 8008496:	d001      	beq.n	800849c <setModemConfig+0x7e>
 8008498:	2301      	movs	r3, #1
 800849a:	e000      	b.n	800849e <setModemConfig+0x80>
 800849c:	2300      	movs	r3, #0
 800849e:	4313      	orrs	r3, r2
 80084a0:	b2db      	uxtb	r3, r3
 80084a2:	2202      	movs	r2, #2
 80084a4:	4313      	orrs	r3, r2
 80084a6:	b2da      	uxtb	r2, r3
 80084a8:	687b      	ldr	r3, [r7, #4]
 80084aa:	211d      	movs	r1, #29
 80084ac:	0018      	movs	r0, r3
 80084ae:	f000 f9ff 	bl	80088b0 <writeReg>
        
        /* spreadingFactor      (4bit)
         * txContinuousMode     (1bit) (0)
         * agcAutoOn            (1bit) (1)
         * symbTimeout(9:8)     (2bit) (0)  */
        writeReg(self, RegModemConfig2, sfSetting(self, sf) | 0U | 4U | 0U);    
 80084b2:	1cbb      	adds	r3, r7, #2
 80084b4:	781a      	ldrb	r2, [r3, #0]
 80084b6:	687b      	ldr	r3, [r7, #4]
 80084b8:	0011      	movs	r1, r2
 80084ba:	0018      	movs	r0, r3
 80084bc:	f000 f8f8 	bl	80086b0 <sfSetting>
 80084c0:	0003      	movs	r3, r0
 80084c2:	001a      	movs	r2, r3
 80084c4:	2304      	movs	r3, #4
 80084c6:	4313      	orrs	r3, r2
 80084c8:	b2da      	uxtb	r2, r3
 80084ca:	687b      	ldr	r3, [r7, #4]
 80084cc:	211e      	movs	r1, #30
 80084ce:	0018      	movs	r0, r3
 80084d0:	f000 f9ee 	bl	80088b0 <writeReg>
        break;
 80084d4:	46c0      	nop			; (mov r8, r8)
         * unused               (2bit) (0)  */
        writeReg(self, RegModemConfig3, 0U | (low_rate ? 8U : 0U) | 4U | 0U);        
        break;
#endif    
    }
}
 80084d6:	46c0      	nop			; (mov r8, r8)
 80084d8:	46bd      	mov	sp, r7
 80084da:	b005      	add	sp, #20
 80084dc:	bd90      	pop	{r4, r7, pc}

080084de <setPower>:

static void setPower(struct ldl_radio *self, int16_t dbm)
{
 80084de:	b5b0      	push	{r4, r5, r7, lr}
 80084e0:	b084      	sub	sp, #16
 80084e2:	af00      	add	r7, sp, #0
 80084e4:	6078      	str	r0, [r7, #4]
 80084e6:	000a      	movs	r2, r1
 80084e8:	1cbb      	adds	r3, r7, #2
 80084ea:	801a      	strh	r2, [r3, #0]
     * - compensate for output gains/losses here
     * - adjust current limit trim
     * 
     * */
     
     dbm /= 100;
 80084ec:	1cbc      	adds	r4, r7, #2
 80084ee:	1cbb      	adds	r3, r7, #2
 80084f0:	2200      	movs	r2, #0
 80084f2:	5e9b      	ldrsh	r3, [r3, r2]
 80084f4:	2164      	movs	r1, #100	; 0x64
 80084f6:	0018      	movs	r0, r3
 80084f8:	f7f7 fe90 	bl	800021c <__divsi3>
 80084fc:	0003      	movs	r3, r0
 80084fe:	8023      	strh	r3, [r4, #0]

    switch(self->type){
 8008500:	687b      	ldr	r3, [r7, #4]
 8008502:	799b      	ldrb	r3, [r3, #6]
 8008504:	2b00      	cmp	r3, #0
 8008506:	d000      	beq.n	800850a <setPower+0x2c>
        }
    }
        break;
#endif    
    default:
        break;
 8008508:	e0a0      	b.n	800864c <setPower+0x16e>
        paConfig = readReg(self, RegPaConfig);         
 800850a:	250f      	movs	r5, #15
 800850c:	197c      	adds	r4, r7, r5
 800850e:	687b      	ldr	r3, [r7, #4]
 8008510:	2109      	movs	r1, #9
 8008512:	0018      	movs	r0, r3
 8008514:	f000 f9b6 	bl	8008884 <readReg>
 8008518:	0003      	movs	r3, r0
 800851a:	7023      	strb	r3, [r4, #0]
        paConfig &= ~(0xfU);
 800851c:	197b      	adds	r3, r7, r5
 800851e:	197a      	adds	r2, r7, r5
 8008520:	7812      	ldrb	r2, [r2, #0]
 8008522:	210f      	movs	r1, #15
 8008524:	438a      	bics	r2, r1
 8008526:	701a      	strb	r2, [r3, #0]
        switch(self->pa){
 8008528:	687b      	ldr	r3, [r7, #4]
 800852a:	791b      	ldrb	r3, [r3, #4]
 800852c:	2b00      	cmp	r3, #0
 800852e:	d002      	beq.n	8008536 <setPower+0x58>
 8008530:	2b01      	cmp	r3, #1
 8008532:	d02b      	beq.n	800858c <setPower+0xae>
            break;        
 8008534:	e089      	b.n	800864a <setPower+0x16c>
            paConfig &= ~(0x80U);
 8008536:	220f      	movs	r2, #15
 8008538:	18bb      	adds	r3, r7, r2
 800853a:	18ba      	adds	r2, r7, r2
 800853c:	7812      	ldrb	r2, [r2, #0]
 800853e:	217f      	movs	r1, #127	; 0x7f
 8008540:	400a      	ands	r2, r1
 8008542:	701a      	strb	r2, [r3, #0]
            paConfig |= (dbm > 14) ? 0xf : (uint8_t)( (dbm < -1) ? 0 : (dbm + 1) );
 8008544:	1cbb      	adds	r3, r7, #2
 8008546:	2200      	movs	r2, #0
 8008548:	5e9b      	ldrsh	r3, [r3, r2]
 800854a:	2b0e      	cmp	r3, #14
 800854c:	dc0d      	bgt.n	800856a <setPower+0x8c>
 800854e:	1cbb      	adds	r3, r7, #2
 8008550:	2200      	movs	r2, #0
 8008552:	5e9b      	ldrsh	r3, [r3, r2]
 8008554:	3301      	adds	r3, #1
 8008556:	db06      	blt.n	8008566 <setPower+0x88>
 8008558:	1cbb      	adds	r3, r7, #2
 800855a:	881b      	ldrh	r3, [r3, #0]
 800855c:	b2db      	uxtb	r3, r3
 800855e:	3301      	adds	r3, #1
 8008560:	b2db      	uxtb	r3, r3
 8008562:	b25b      	sxtb	r3, r3
 8008564:	e002      	b.n	800856c <setPower+0x8e>
 8008566:	2300      	movs	r3, #0
 8008568:	e000      	b.n	800856c <setPower+0x8e>
 800856a:	230f      	movs	r3, #15
 800856c:	210f      	movs	r1, #15
 800856e:	187a      	adds	r2, r7, r1
 8008570:	7812      	ldrb	r2, [r2, #0]
 8008572:	b252      	sxtb	r2, r2
 8008574:	4313      	orrs	r3, r2
 8008576:	b25a      	sxtb	r2, r3
 8008578:	187b      	adds	r3, r7, r1
 800857a:	701a      	strb	r2, [r3, #0]
            writeReg(self, RegPaConfig, paConfig);            
 800857c:	187b      	adds	r3, r7, r1
 800857e:	781a      	ldrb	r2, [r3, #0]
 8008580:	687b      	ldr	r3, [r7, #4]
 8008582:	2109      	movs	r1, #9
 8008584:	0018      	movs	r0, r3
 8008586:	f000 f993 	bl	80088b0 <writeReg>
            break;
 800858a:	e05e      	b.n	800864a <setPower+0x16c>
            paDac = readReg(self, RegPaDac); 
 800858c:	250e      	movs	r5, #14
 800858e:	197c      	adds	r4, r7, r5
 8008590:	687b      	ldr	r3, [r7, #4]
 8008592:	215a      	movs	r1, #90	; 0x5a
 8008594:	0018      	movs	r0, r3
 8008596:	f000 f975 	bl	8008884 <readReg>
 800859a:	0003      	movs	r3, r0
 800859c:	7023      	strb	r3, [r4, #0]
            paConfig |= 0x80U;
 800859e:	220f      	movs	r2, #15
 80085a0:	18bb      	adds	r3, r7, r2
 80085a2:	18ba      	adds	r2, r7, r2
 80085a4:	7812      	ldrb	r2, [r2, #0]
 80085a6:	2180      	movs	r1, #128	; 0x80
 80085a8:	4249      	negs	r1, r1
 80085aa:	430a      	orrs	r2, r1
 80085ac:	701a      	strb	r2, [r3, #0]
            paDac &= ~(7U);
 80085ae:	197b      	adds	r3, r7, r5
 80085b0:	197a      	adds	r2, r7, r5
 80085b2:	7812      	ldrb	r2, [r2, #0]
 80085b4:	2107      	movs	r1, #7
 80085b6:	438a      	bics	r2, r1
 80085b8:	701a      	strb	r2, [r3, #0]
            if(dbm >= 20){
 80085ba:	1cbb      	adds	r3, r7, #2
 80085bc:	2200      	movs	r2, #0
 80085be:	5e9b      	ldrsh	r3, [r3, r2]
 80085c0:	2b13      	cmp	r3, #19
 80085c2:	dd0e      	ble.n	80085e2 <setPower+0x104>
                paDac |= 7U;                
 80085c4:	220e      	movs	r2, #14
 80085c6:	18bb      	adds	r3, r7, r2
 80085c8:	18ba      	adds	r2, r7, r2
 80085ca:	7812      	ldrb	r2, [r2, #0]
 80085cc:	2107      	movs	r1, #7
 80085ce:	430a      	orrs	r2, r1
 80085d0:	701a      	strb	r2, [r3, #0]
                paConfig |= 0xfU;
 80085d2:	220f      	movs	r2, #15
 80085d4:	18bb      	adds	r3, r7, r2
 80085d6:	18ba      	adds	r2, r7, r2
 80085d8:	7812      	ldrb	r2, [r2, #0]
 80085da:	210f      	movs	r1, #15
 80085dc:	430a      	orrs	r2, r1
 80085de:	701a      	strb	r2, [r3, #0]
 80085e0:	e022      	b.n	8008628 <setPower+0x14a>
                paDac |= 4U;
 80085e2:	220e      	movs	r2, #14
 80085e4:	18bb      	adds	r3, r7, r2
 80085e6:	18ba      	adds	r2, r7, r2
 80085e8:	7812      	ldrb	r2, [r2, #0]
 80085ea:	2104      	movs	r1, #4
 80085ec:	430a      	orrs	r2, r1
 80085ee:	701a      	strb	r2, [r3, #0]
                paConfig |= (dbm > 17) ? 0xf : ( (dbm < 2) ? 0 : (dbm - 2) ); 
 80085f0:	1cbb      	adds	r3, r7, #2
 80085f2:	2200      	movs	r2, #0
 80085f4:	5e9b      	ldrsh	r3, [r3, r2]
 80085f6:	2b11      	cmp	r3, #17
 80085f8:	dc0d      	bgt.n	8008616 <setPower+0x138>
 80085fa:	1cbb      	adds	r3, r7, #2
 80085fc:	2200      	movs	r2, #0
 80085fe:	5e9b      	ldrsh	r3, [r3, r2]
 8008600:	2b01      	cmp	r3, #1
 8008602:	dd06      	ble.n	8008612 <setPower+0x134>
 8008604:	1cbb      	adds	r3, r7, #2
 8008606:	881b      	ldrh	r3, [r3, #0]
 8008608:	b2db      	uxtb	r3, r3
 800860a:	3b02      	subs	r3, #2
 800860c:	b2db      	uxtb	r3, r3
 800860e:	b25b      	sxtb	r3, r3
 8008610:	e002      	b.n	8008618 <setPower+0x13a>
 8008612:	2300      	movs	r3, #0
 8008614:	e000      	b.n	8008618 <setPower+0x13a>
 8008616:	230f      	movs	r3, #15
 8008618:	210f      	movs	r1, #15
 800861a:	187a      	adds	r2, r7, r1
 800861c:	7812      	ldrb	r2, [r2, #0]
 800861e:	b252      	sxtb	r2, r2
 8008620:	4313      	orrs	r3, r2
 8008622:	b25a      	sxtb	r2, r3
 8008624:	187b      	adds	r3, r7, r1
 8008626:	701a      	strb	r2, [r3, #0]
            writeReg(self, RegPaDac, paDac);
 8008628:	230e      	movs	r3, #14
 800862a:	18fb      	adds	r3, r7, r3
 800862c:	781a      	ldrb	r2, [r3, #0]
 800862e:	687b      	ldr	r3, [r7, #4]
 8008630:	215a      	movs	r1, #90	; 0x5a
 8008632:	0018      	movs	r0, r3
 8008634:	f000 f93c 	bl	80088b0 <writeReg>
            writeReg(self, RegPaConfig, paConfig);            
 8008638:	230f      	movs	r3, #15
 800863a:	18fb      	adds	r3, r7, r3
 800863c:	781a      	ldrb	r2, [r3, #0]
 800863e:	687b      	ldr	r3, [r7, #4]
 8008640:	2109      	movs	r1, #9
 8008642:	0018      	movs	r0, r3
 8008644:	f000 f934 	bl	80088b0 <writeReg>
            break;
 8008648:	46c0      	nop			; (mov r8, r8)
        break;
 800864a:	46c0      	nop			; (mov r8, r8)
    }
}
 800864c:	46c0      	nop			; (mov r8, r8)
 800864e:	46bd      	mov	sp, r7
 8008650:	b004      	add	sp, #16
 8008652:	bdb0      	pop	{r4, r5, r7, pc}

08008654 <bwSetting>:

static uint8_t bwSetting(const struct ldl_radio *self, enum ldl_signal_bandwidth bw)
{
 8008654:	b580      	push	{r7, lr}
 8008656:	b084      	sub	sp, #16
 8008658:	af00      	add	r7, sp, #0
 800865a:	6078      	str	r0, [r7, #4]
 800865c:	000a      	movs	r2, r1
 800865e:	1cfb      	adds	r3, r7, #3
 8008660:	701a      	strb	r2, [r3, #0]
    uint8_t retval = 0U;
 8008662:	230f      	movs	r3, #15
 8008664:	18fb      	adds	r3, r7, r3
 8008666:	2200      	movs	r2, #0
 8008668:	701a      	strb	r2, [r3, #0]
    
    switch(self->type){
 800866a:	687b      	ldr	r3, [r7, #4]
 800866c:	799b      	ldrb	r3, [r3, #6]
 800866e:	2b00      	cmp	r3, #0
 8008670:	d000      	beq.n	8008674 <bwSetting+0x20>
    default:
        break;
 8008672:	e015      	b.n	80086a0 <bwSetting+0x4c>
#ifdef LDL_ENABLE_SX1272          
    case LDL_RADIO_SX1272:    
        switch(bw){
 8008674:	1cfb      	adds	r3, r7, #3
 8008676:	781b      	ldrb	r3, [r3, #0]
 8008678:	2b01      	cmp	r3, #1
 800867a:	d006      	beq.n	800868a <bwSetting+0x36>
 800867c:	2b02      	cmp	r3, #2
 800867e:	d009      	beq.n	8008694 <bwSetting+0x40>
        default:
        case LDL_BW_125:
            retval = 0x00U;
 8008680:	230f      	movs	r3, #15
 8008682:	18fb      	adds	r3, r7, r3
 8008684:	2200      	movs	r2, #0
 8008686:	701a      	strb	r2, [r3, #0]
            break;
 8008688:	e009      	b.n	800869e <bwSetting+0x4a>
        case LDL_BW_250:
            retval = 0x40U;
 800868a:	230f      	movs	r3, #15
 800868c:	18fb      	adds	r3, r7, r3
 800868e:	2240      	movs	r2, #64	; 0x40
 8008690:	701a      	strb	r2, [r3, #0]
            break;
 8008692:	e004      	b.n	800869e <bwSetting+0x4a>
        case LDL_BW_500:
            retval = 0x80U;
 8008694:	230f      	movs	r3, #15
 8008696:	18fb      	adds	r3, r7, r3
 8008698:	2280      	movs	r2, #128	; 0x80
 800869a:	701a      	strb	r2, [r3, #0]
            break;
 800869c:	46c0      	nop			; (mov r8, r8)
        }
        break;
 800869e:	46c0      	nop			; (mov r8, r8)
        }
        break;
#endif
    }
    
    return retval;    
 80086a0:	230f      	movs	r3, #15
 80086a2:	18fb      	adds	r3, r7, r3
 80086a4:	781b      	ldrb	r3, [r3, #0]
}
 80086a6:	0018      	movs	r0, r3
 80086a8:	46bd      	mov	sp, r7
 80086aa:	b004      	add	sp, #16
 80086ac:	bd80      	pop	{r7, pc}
	...

080086b0 <sfSetting>:

static uint8_t sfSetting(const struct ldl_radio *self, enum ldl_spreading_factor sf)
{
 80086b0:	b580      	push	{r7, lr}
 80086b2:	b084      	sub	sp, #16
 80086b4:	af00      	add	r7, sp, #0
 80086b6:	6078      	str	r0, [r7, #4]
 80086b8:	000a      	movs	r2, r1
 80086ba:	1cfb      	adds	r3, r7, #3
 80086bc:	701a      	strb	r2, [r3, #0]
    uint8_t retval = 0U;
 80086be:	230f      	movs	r3, #15
 80086c0:	18fb      	adds	r3, r7, r3
 80086c2:	2200      	movs	r2, #0
 80086c4:	701a      	strb	r2, [r3, #0]
    
    (void)self;
    
    switch(sf){
 80086c6:	1cfb      	adds	r3, r7, #3
 80086c8:	781b      	ldrb	r3, [r3, #0]
 80086ca:	3b08      	subs	r3, #8
 80086cc:	2b04      	cmp	r3, #4
 80086ce:	d804      	bhi.n	80086da <sfSetting+0x2a>
 80086d0:	009a      	lsls	r2, r3, #2
 80086d2:	4b14      	ldr	r3, [pc, #80]	; (8008724 <sfSetting+0x74>)
 80086d4:	18d3      	adds	r3, r2, r3
 80086d6:	681b      	ldr	r3, [r3, #0]
 80086d8:	469f      	mov	pc, r3
    default:
    case LDL_SF_7:
        retval = 0x70U;
 80086da:	230f      	movs	r3, #15
 80086dc:	18fb      	adds	r3, r7, r3
 80086de:	2270      	movs	r2, #112	; 0x70
 80086e0:	701a      	strb	r2, [r3, #0]
        break;
 80086e2:	e018      	b.n	8008716 <sfSetting+0x66>
    case LDL_SF_8:
        retval = 0x80U;
 80086e4:	230f      	movs	r3, #15
 80086e6:	18fb      	adds	r3, r7, r3
 80086e8:	2280      	movs	r2, #128	; 0x80
 80086ea:	701a      	strb	r2, [r3, #0]
        break;
 80086ec:	e013      	b.n	8008716 <sfSetting+0x66>
    case LDL_SF_9:
        retval = 0x90U;
 80086ee:	230f      	movs	r3, #15
 80086f0:	18fb      	adds	r3, r7, r3
 80086f2:	2290      	movs	r2, #144	; 0x90
 80086f4:	701a      	strb	r2, [r3, #0]
        break;
 80086f6:	e00e      	b.n	8008716 <sfSetting+0x66>
    case LDL_SF_10:
        retval = 0xa0U;
 80086f8:	230f      	movs	r3, #15
 80086fa:	18fb      	adds	r3, r7, r3
 80086fc:	22a0      	movs	r2, #160	; 0xa0
 80086fe:	701a      	strb	r2, [r3, #0]
        break;
 8008700:	e009      	b.n	8008716 <sfSetting+0x66>
    case LDL_SF_11:
        retval = 0xb0U;
 8008702:	230f      	movs	r3, #15
 8008704:	18fb      	adds	r3, r7, r3
 8008706:	22b0      	movs	r2, #176	; 0xb0
 8008708:	701a      	strb	r2, [r3, #0]
        break;
 800870a:	e004      	b.n	8008716 <sfSetting+0x66>
    case LDL_SF_12:
        retval = 0xc0U;
 800870c:	230f      	movs	r3, #15
 800870e:	18fb      	adds	r3, r7, r3
 8008710:	22c0      	movs	r2, #192	; 0xc0
 8008712:	701a      	strb	r2, [r3, #0]
        break;
 8008714:	46c0      	nop			; (mov r8, r8)
    }
    return retval;
 8008716:	230f      	movs	r3, #15
 8008718:	18fb      	adds	r3, r7, r3
 800871a:	781b      	ldrb	r3, [r3, #0]
}
 800871c:	0018      	movs	r0, r3
 800871e:	46bd      	mov	sp, r7
 8008720:	b004      	add	sp, #16
 8008722:	bd80      	pop	{r7, pc}
 8008724:	0800e584 	.word	0x0800e584

08008728 <crSetting>:

static uint8_t crSetting(const struct ldl_radio *self, enum ldl_coding_rate cr)
{
 8008728:	b580      	push	{r7, lr}
 800872a:	b084      	sub	sp, #16
 800872c:	af00      	add	r7, sp, #0
 800872e:	6078      	str	r0, [r7, #4]
 8008730:	000a      	movs	r2, r1
 8008732:	1cfb      	adds	r3, r7, #3
 8008734:	701a      	strb	r2, [r3, #0]
    uint8_t retval = 0U;
 8008736:	230f      	movs	r3, #15
 8008738:	18fb      	adds	r3, r7, r3
 800873a:	2200      	movs	r2, #0
 800873c:	701a      	strb	r2, [r3, #0]
    
    (void)cr;
    
    switch(self->type){
 800873e:	687b      	ldr	r3, [r7, #4]
 8008740:	799b      	ldrb	r3, [r3, #6]
 8008742:	2b00      	cmp	r3, #0
 8008744:	d000      	beq.n	8008748 <crSetting+0x20>
    default:
        break;
 8008746:	e004      	b.n	8008752 <crSetting+0x2a>
#ifdef LDL_ENABLE_SX1272
    case LDL_RADIO_SX1272:
        retval = 8U;    // CR_5
 8008748:	230f      	movs	r3, #15
 800874a:	18fb      	adds	r3, r7, r3
 800874c:	2208      	movs	r2, #8
 800874e:	701a      	strb	r2, [r3, #0]
        break;
 8008750:	46c0      	nop			; (mov r8, r8)
        retval = 2U;    // CR_5
        break;
#endif
    }
    
    return retval;
 8008752:	230f      	movs	r3, #15
 8008754:	18fb      	adds	r3, r7, r3
 8008756:	781b      	ldrb	r3, [r3, #0]
}
 8008758:	0018      	movs	r0, r3
 800875a:	46bd      	mov	sp, r7
 800875c:	b004      	add	sp, #16
 800875e:	bd80      	pop	{r7, pc}

08008760 <setFreq>:

static void setFreq(struct ldl_radio *self, uint32_t freq)
{
 8008760:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008762:	b085      	sub	sp, #20
 8008764:	af00      	add	r7, sp, #0
 8008766:	6078      	str	r0, [r7, #4]
 8008768:	6039      	str	r1, [r7, #0]
    uint32_t f = (uint32_t)(((uint64_t)freq << 19U) / 32000000UL);
 800876a:	683a      	ldr	r2, [r7, #0]
 800876c:	0013      	movs	r3, r2
 800876e:	2200      	movs	r2, #0
 8008770:	0014      	movs	r4, r2
 8008772:	0b5e      	lsrs	r6, r3, #13
 8008774:	04dd      	lsls	r5, r3, #19
 8008776:	4a12      	ldr	r2, [pc, #72]	; (80087c0 <setFreq+0x60>)
 8008778:	2300      	movs	r3, #0
 800877a:	0028      	movs	r0, r5
 800877c:	0031      	movs	r1, r6
 800877e:	f7f7 fe39 	bl	80003f4 <__aeabi_uldivmod>
 8008782:	0003      	movs	r3, r0
 8008784:	000c      	movs	r4, r1
 8008786:	60fb      	str	r3, [r7, #12]
        
    writeReg(self, RegFrfMsb, f >> 16);
 8008788:	68fb      	ldr	r3, [r7, #12]
 800878a:	0c1b      	lsrs	r3, r3, #16
 800878c:	b2da      	uxtb	r2, r3
 800878e:	687b      	ldr	r3, [r7, #4]
 8008790:	2106      	movs	r1, #6
 8008792:	0018      	movs	r0, r3
 8008794:	f000 f88c 	bl	80088b0 <writeReg>
    writeReg(self, RegFrfMid, f >> 8);
 8008798:	68fb      	ldr	r3, [r7, #12]
 800879a:	0a1b      	lsrs	r3, r3, #8
 800879c:	b2da      	uxtb	r2, r3
 800879e:	687b      	ldr	r3, [r7, #4]
 80087a0:	2107      	movs	r1, #7
 80087a2:	0018      	movs	r0, r3
 80087a4:	f000 f884 	bl	80088b0 <writeReg>
    writeReg(self, RegFrfLsb, f);    
 80087a8:	68fb      	ldr	r3, [r7, #12]
 80087aa:	b2da      	uxtb	r2, r3
 80087ac:	687b      	ldr	r3, [r7, #4]
 80087ae:	2108      	movs	r1, #8
 80087b0:	0018      	movs	r0, r3
 80087b2:	f000 f87d 	bl	80088b0 <writeReg>
}
 80087b6:	46c0      	nop			; (mov r8, r8)
 80087b8:	46bd      	mov	sp, r7
 80087ba:	b005      	add	sp, #20
 80087bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80087be:	46c0      	nop			; (mov r8, r8)
 80087c0:	01e84800 	.word	0x01e84800

080087c4 <readFIFO>:

static uint8_t readFIFO(struct ldl_radio *self, uint8_t *data, uint8_t max)
{
 80087c4:	b5b0      	push	{r4, r5, r7, lr}
 80087c6:	b086      	sub	sp, #24
 80087c8:	af00      	add	r7, sp, #0
 80087ca:	60f8      	str	r0, [r7, #12]
 80087cc:	60b9      	str	r1, [r7, #8]
 80087ce:	1dfb      	adds	r3, r7, #7
 80087d0:	701a      	strb	r2, [r3, #0]
    uint8_t size = readReg(self, RegRxNbBytes);
 80087d2:	2517      	movs	r5, #23
 80087d4:	197c      	adds	r4, r7, r5
 80087d6:	68fb      	ldr	r3, [r7, #12]
 80087d8:	2113      	movs	r1, #19
 80087da:	0018      	movs	r0, r3
 80087dc:	f000 f852 	bl	8008884 <readReg>
 80087e0:	0003      	movs	r3, r0
 80087e2:	7023      	strb	r3, [r4, #0]
    
    size = (size > max) ? max : size;
 80087e4:	197a      	adds	r2, r7, r5
 80087e6:	197b      	adds	r3, r7, r5
 80087e8:	1df9      	adds	r1, r7, #7
 80087ea:	780c      	ldrb	r4, [r1, #0]
 80087ec:	781b      	ldrb	r3, [r3, #0]
 80087ee:	b2d8      	uxtb	r0, r3
 80087f0:	b2e1      	uxtb	r1, r4
 80087f2:	4288      	cmp	r0, r1
 80087f4:	d900      	bls.n	80087f8 <readFIFO+0x34>
 80087f6:	1c23      	adds	r3, r4, #0
 80087f8:	7013      	strb	r3, [r2, #0]
    
    if(size > 0U){
 80087fa:	2317      	movs	r3, #23
 80087fc:	18fb      	adds	r3, r7, r3
 80087fe:	781b      	ldrb	r3, [r3, #0]
 8008800:	2b00      	cmp	r3, #0
 8008802:	d013      	beq.n	800882c <readFIFO+0x68>
    
        writeReg(self, RegFifoAddrPtr, readReg(self, RegFifoRxCurrentAddr));
 8008804:	68fb      	ldr	r3, [r7, #12]
 8008806:	2110      	movs	r1, #16
 8008808:	0018      	movs	r0, r3
 800880a:	f000 f83b 	bl	8008884 <readReg>
 800880e:	0003      	movs	r3, r0
 8008810:	001a      	movs	r2, r3
 8008812:	68fb      	ldr	r3, [r7, #12]
 8008814:	210d      	movs	r1, #13
 8008816:	0018      	movs	r0, r3
 8008818:	f000 f84a 	bl	80088b0 <writeReg>
        
        burstRead(self, RegFifo, data, size);
 800881c:	2317      	movs	r3, #23
 800881e:	18fb      	adds	r3, r7, r3
 8008820:	781b      	ldrb	r3, [r3, #0]
 8008822:	68ba      	ldr	r2, [r7, #8]
 8008824:	68f8      	ldr	r0, [r7, #12]
 8008826:	2100      	movs	r1, #0
 8008828:	f000 f877 	bl	800891a <burstRead>
    }

    return size;
 800882c:	2317      	movs	r3, #23
 800882e:	18fb      	adds	r3, r7, r3
 8008830:	781b      	ldrb	r3, [r3, #0]
}
 8008832:	0018      	movs	r0, r3
 8008834:	46bd      	mov	sp, r7
 8008836:	b006      	add	sp, #24
 8008838:	bdb0      	pop	{r4, r5, r7, pc}

0800883a <writeFIFO>:

static void writeFIFO(struct ldl_radio *self, const uint8_t *data, uint8_t len)
{
 800883a:	b580      	push	{r7, lr}
 800883c:	b084      	sub	sp, #16
 800883e:	af00      	add	r7, sp, #0
 8008840:	60f8      	str	r0, [r7, #12]
 8008842:	60b9      	str	r1, [r7, #8]
 8008844:	1dfb      	adds	r3, r7, #7
 8008846:	701a      	strb	r2, [r3, #0]
    writeReg(self, RegFifoTxBaseAddr, 0x00U);    // set tx base
 8008848:	68fb      	ldr	r3, [r7, #12]
 800884a:	2200      	movs	r2, #0
 800884c:	210e      	movs	r1, #14
 800884e:	0018      	movs	r0, r3
 8008850:	f000 f82e 	bl	80088b0 <writeReg>
    writeReg(self, RegFifoAddrPtr, 0x00U);       // set address pointer
 8008854:	68fb      	ldr	r3, [r7, #12]
 8008856:	2200      	movs	r2, #0
 8008858:	210d      	movs	r1, #13
 800885a:	0018      	movs	r0, r3
 800885c:	f000 f828 	bl	80088b0 <writeReg>
    writeReg(self, LoraRegPayloadLength, len);
 8008860:	1dfb      	adds	r3, r7, #7
 8008862:	781a      	ldrb	r2, [r3, #0]
 8008864:	68fb      	ldr	r3, [r7, #12]
 8008866:	2122      	movs	r1, #34	; 0x22
 8008868:	0018      	movs	r0, r3
 800886a:	f000 f821 	bl	80088b0 <writeReg>
    burstWrite(self, RegFifo, data, len);        // write into fifo
 800886e:	1dfb      	adds	r3, r7, #7
 8008870:	781b      	ldrb	r3, [r3, #0]
 8008872:	68ba      	ldr	r2, [r7, #8]
 8008874:	68f8      	ldr	r0, [r7, #12]
 8008876:	2100      	movs	r1, #0
 8008878:	f000 f832 	bl	80088e0 <burstWrite>
}
 800887c:	46c0      	nop			; (mov r8, r8)
 800887e:	46bd      	mov	sp, r7
 8008880:	b004      	add	sp, #16
 8008882:	bd80      	pop	{r7, pc}

08008884 <readReg>:

static uint8_t readReg(struct ldl_radio *self, uint8_t reg)
{
 8008884:	b590      	push	{r4, r7, lr}
 8008886:	b085      	sub	sp, #20
 8008888:	af00      	add	r7, sp, #0
 800888a:	6078      	str	r0, [r7, #4]
 800888c:	000a      	movs	r2, r1
 800888e:	1cfb      	adds	r3, r7, #3
 8008890:	701a      	strb	r2, [r3, #0]
    uint8_t data;
    LDL_Chip_read(self->board, reg, &data, sizeof(data));
 8008892:	687b      	ldr	r3, [r7, #4]
 8008894:	6818      	ldr	r0, [r3, #0]
 8008896:	240f      	movs	r4, #15
 8008898:	193a      	adds	r2, r7, r4
 800889a:	1cfb      	adds	r3, r7, #3
 800889c:	7819      	ldrb	r1, [r3, #0]
 800889e:	2301      	movs	r3, #1
 80088a0:	f001 fbac 	bl	8009ffc <LDL_Chip_read>
    return data;
 80088a4:	193b      	adds	r3, r7, r4
 80088a6:	781b      	ldrb	r3, [r3, #0]
}
 80088a8:	0018      	movs	r0, r3
 80088aa:	46bd      	mov	sp, r7
 80088ac:	b005      	add	sp, #20
 80088ae:	bd90      	pop	{r4, r7, pc}

080088b0 <writeReg>:

static void writeReg(struct ldl_radio *self, uint8_t reg, uint8_t data)
{
 80088b0:	b580      	push	{r7, lr}
 80088b2:	b082      	sub	sp, #8
 80088b4:	af00      	add	r7, sp, #0
 80088b6:	6078      	str	r0, [r7, #4]
 80088b8:	0008      	movs	r0, r1
 80088ba:	0011      	movs	r1, r2
 80088bc:	1cfb      	adds	r3, r7, #3
 80088be:	1c02      	adds	r2, r0, #0
 80088c0:	701a      	strb	r2, [r3, #0]
 80088c2:	1cbb      	adds	r3, r7, #2
 80088c4:	1c0a      	adds	r2, r1, #0
 80088c6:	701a      	strb	r2, [r3, #0]
    LDL_Chip_write(self->board, reg, &data, sizeof(data));
 80088c8:	687b      	ldr	r3, [r7, #4]
 80088ca:	6818      	ldr	r0, [r3, #0]
 80088cc:	1cba      	adds	r2, r7, #2
 80088ce:	1cfb      	adds	r3, r7, #3
 80088d0:	7819      	ldrb	r1, [r3, #0]
 80088d2:	2301      	movs	r3, #1
 80088d4:	f001 fb48 	bl	8009f68 <LDL_Chip_write>
}
 80088d8:	46c0      	nop			; (mov r8, r8)
 80088da:	46bd      	mov	sp, r7
 80088dc:	b002      	add	sp, #8
 80088de:	bd80      	pop	{r7, pc}

080088e0 <burstWrite>:

static void burstWrite(struct ldl_radio *self, uint8_t reg, const uint8_t *data, uint8_t len)
{
 80088e0:	b5b0      	push	{r4, r5, r7, lr}
 80088e2:	b084      	sub	sp, #16
 80088e4:	af00      	add	r7, sp, #0
 80088e6:	60f8      	str	r0, [r7, #12]
 80088e8:	0008      	movs	r0, r1
 80088ea:	607a      	str	r2, [r7, #4]
 80088ec:	0019      	movs	r1, r3
 80088ee:	250b      	movs	r5, #11
 80088f0:	197b      	adds	r3, r7, r5
 80088f2:	1c02      	adds	r2, r0, #0
 80088f4:	701a      	strb	r2, [r3, #0]
 80088f6:	240a      	movs	r4, #10
 80088f8:	193b      	adds	r3, r7, r4
 80088fa:	1c0a      	adds	r2, r1, #0
 80088fc:	701a      	strb	r2, [r3, #0]
    LDL_Chip_write(self->board, reg, data, len);    
 80088fe:	68fb      	ldr	r3, [r7, #12]
 8008900:	6818      	ldr	r0, [r3, #0]
 8008902:	193b      	adds	r3, r7, r4
 8008904:	781c      	ldrb	r4, [r3, #0]
 8008906:	687a      	ldr	r2, [r7, #4]
 8008908:	197b      	adds	r3, r7, r5
 800890a:	7819      	ldrb	r1, [r3, #0]
 800890c:	0023      	movs	r3, r4
 800890e:	f001 fb2b 	bl	8009f68 <LDL_Chip_write>
}
 8008912:	46c0      	nop			; (mov r8, r8)
 8008914:	46bd      	mov	sp, r7
 8008916:	b004      	add	sp, #16
 8008918:	bdb0      	pop	{r4, r5, r7, pc}

0800891a <burstRead>:

static void burstRead(struct ldl_radio *self, uint8_t reg, uint8_t *data, uint8_t len)
{
 800891a:	b5b0      	push	{r4, r5, r7, lr}
 800891c:	b084      	sub	sp, #16
 800891e:	af00      	add	r7, sp, #0
 8008920:	60f8      	str	r0, [r7, #12]
 8008922:	0008      	movs	r0, r1
 8008924:	607a      	str	r2, [r7, #4]
 8008926:	0019      	movs	r1, r3
 8008928:	250b      	movs	r5, #11
 800892a:	197b      	adds	r3, r7, r5
 800892c:	1c02      	adds	r2, r0, #0
 800892e:	701a      	strb	r2, [r3, #0]
 8008930:	240a      	movs	r4, #10
 8008932:	193b      	adds	r3, r7, r4
 8008934:	1c0a      	adds	r2, r1, #0
 8008936:	701a      	strb	r2, [r3, #0]
    LDL_Chip_read(self->board, reg, data, len);    
 8008938:	68fb      	ldr	r3, [r7, #12]
 800893a:	6818      	ldr	r0, [r3, #0]
 800893c:	193b      	adds	r3, r7, r4
 800893e:	781c      	ldrb	r4, [r3, #0]
 8008940:	687a      	ldr	r2, [r7, #4]
 8008942:	197b      	adds	r3, r7, r5
 8008944:	7819      	ldrb	r1, [r3, #0]
 8008946:	0023      	movs	r3, r4
 8008948:	f001 fb58 	bl	8009ffc <LDL_Chip_read>
}
 800894c:	46c0      	nop			; (mov r8, r8)
 800894e:	46bd      	mov	sp, r7
 8008950:	b004      	add	sp, #16
 8008952:	bdb0      	pop	{r4, r5, r7, pc}

08008954 <LDL_Region_convertRate>:
static bool upRateRange(enum ldl_region region, uint8_t chIndex, uint8_t *minRate, uint8_t *maxRate);

/* functions **********************************************************/

void LDL_Region_convertRate(enum ldl_region region, uint8_t rate, enum ldl_spreading_factor *sf, enum ldl_signal_bandwidth *bw, uint8_t *mtu)
{
 8008954:	b590      	push	{r4, r7, lr}
 8008956:	b085      	sub	sp, #20
 8008958:	af00      	add	r7, sp, #0
 800895a:	60ba      	str	r2, [r7, #8]
 800895c:	607b      	str	r3, [r7, #4]
 800895e:	240f      	movs	r4, #15
 8008960:	193b      	adds	r3, r7, r4
 8008962:	1c02      	adds	r2, r0, #0
 8008964:	701a      	strb	r2, [r3, #0]
 8008966:	230e      	movs	r3, #14
 8008968:	18fb      	adds	r3, r7, r3
 800896a:	1c0a      	adds	r2, r1, #0
 800896c:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(sf != NULL)
    LDL_PEDANTIC(bw != NULL)
    LDL_PEDANTIC(mtu != NULL)
    
    switch(region){ 
 800896e:	193b      	adds	r3, r7, r4
 8008970:	781b      	ldrb	r3, [r3, #0]
 8008972:	2b00      	cmp	r3, #0
 8008974:	d000      	beq.n	8008978 <LDL_Region_convertRate+0x24>
            break;
        }    
        break;
#endif                
    default:
        break;
 8008976:	e066      	b.n	8008a46 <LDL_Region_convertRate+0xf2>
        switch(rate){
 8008978:	230e      	movs	r3, #14
 800897a:	18fb      	adds	r3, r7, r3
 800897c:	781b      	ldrb	r3, [r3, #0]
 800897e:	2b06      	cmp	r3, #6
 8008980:	d84a      	bhi.n	8008a18 <LDL_Region_convertRate+0xc4>
 8008982:	009a      	lsls	r2, r3, #2
 8008984:	4b32      	ldr	r3, [pc, #200]	; (8008a50 <LDL_Region_convertRate+0xfc>)
 8008986:	18d3      	adds	r3, r2, r3
 8008988:	681b      	ldr	r3, [r3, #0]
 800898a:	469f      	mov	pc, r3
            *sf = LDL_SF_12;
 800898c:	68bb      	ldr	r3, [r7, #8]
 800898e:	220c      	movs	r2, #12
 8008990:	701a      	strb	r2, [r3, #0]
            *bw = LDL_BW_125;
 8008992:	687b      	ldr	r3, [r7, #4]
 8008994:	2200      	movs	r2, #0
 8008996:	701a      	strb	r2, [r3, #0]
            *mtu = 59U;
 8008998:	6a3b      	ldr	r3, [r7, #32]
 800899a:	223b      	movs	r2, #59	; 0x3b
 800899c:	701a      	strb	r2, [r3, #0]
            break;
 800899e:	e051      	b.n	8008a44 <LDL_Region_convertRate+0xf0>
            *sf = LDL_SF_11;
 80089a0:	68bb      	ldr	r3, [r7, #8]
 80089a2:	220b      	movs	r2, #11
 80089a4:	701a      	strb	r2, [r3, #0]
            *bw = LDL_BW_125;
 80089a6:	687b      	ldr	r3, [r7, #4]
 80089a8:	2200      	movs	r2, #0
 80089aa:	701a      	strb	r2, [r3, #0]
            *mtu = 59U;
 80089ac:	6a3b      	ldr	r3, [r7, #32]
 80089ae:	223b      	movs	r2, #59	; 0x3b
 80089b0:	701a      	strb	r2, [r3, #0]
            break;
 80089b2:	e047      	b.n	8008a44 <LDL_Region_convertRate+0xf0>
            *sf = LDL_SF_10;
 80089b4:	68bb      	ldr	r3, [r7, #8]
 80089b6:	220a      	movs	r2, #10
 80089b8:	701a      	strb	r2, [r3, #0]
            *bw = LDL_BW_125;
 80089ba:	687b      	ldr	r3, [r7, #4]
 80089bc:	2200      	movs	r2, #0
 80089be:	701a      	strb	r2, [r3, #0]
            *mtu = 59U;
 80089c0:	6a3b      	ldr	r3, [r7, #32]
 80089c2:	223b      	movs	r2, #59	; 0x3b
 80089c4:	701a      	strb	r2, [r3, #0]
            break;
 80089c6:	e03d      	b.n	8008a44 <LDL_Region_convertRate+0xf0>
            *sf = LDL_SF_9;
 80089c8:	68bb      	ldr	r3, [r7, #8]
 80089ca:	2209      	movs	r2, #9
 80089cc:	701a      	strb	r2, [r3, #0]
            *bw = LDL_BW_125;
 80089ce:	687b      	ldr	r3, [r7, #4]
 80089d0:	2200      	movs	r2, #0
 80089d2:	701a      	strb	r2, [r3, #0]
            *mtu = 123U;
 80089d4:	6a3b      	ldr	r3, [r7, #32]
 80089d6:	227b      	movs	r2, #123	; 0x7b
 80089d8:	701a      	strb	r2, [r3, #0]
            break;
 80089da:	e033      	b.n	8008a44 <LDL_Region_convertRate+0xf0>
            *sf = LDL_SF_8;
 80089dc:	68bb      	ldr	r3, [r7, #8]
 80089de:	2208      	movs	r2, #8
 80089e0:	701a      	strb	r2, [r3, #0]
            *bw = LDL_BW_125;
 80089e2:	687b      	ldr	r3, [r7, #4]
 80089e4:	2200      	movs	r2, #0
 80089e6:	701a      	strb	r2, [r3, #0]
            *mtu = 250U;
 80089e8:	6a3b      	ldr	r3, [r7, #32]
 80089ea:	22fa      	movs	r2, #250	; 0xfa
 80089ec:	701a      	strb	r2, [r3, #0]
            break;
 80089ee:	e029      	b.n	8008a44 <LDL_Region_convertRate+0xf0>
            *sf = LDL_SF_7;
 80089f0:	68bb      	ldr	r3, [r7, #8]
 80089f2:	2207      	movs	r2, #7
 80089f4:	701a      	strb	r2, [r3, #0]
            *bw = LDL_BW_125;
 80089f6:	687b      	ldr	r3, [r7, #4]
 80089f8:	2200      	movs	r2, #0
 80089fa:	701a      	strb	r2, [r3, #0]
            *mtu = 250U;
 80089fc:	6a3b      	ldr	r3, [r7, #32]
 80089fe:	22fa      	movs	r2, #250	; 0xfa
 8008a00:	701a      	strb	r2, [r3, #0]
            break;
 8008a02:	e01f      	b.n	8008a44 <LDL_Region_convertRate+0xf0>
            *sf = LDL_SF_7;
 8008a04:	68bb      	ldr	r3, [r7, #8]
 8008a06:	2207      	movs	r2, #7
 8008a08:	701a      	strb	r2, [r3, #0]
            *bw = LDL_BW_250;
 8008a0a:	687b      	ldr	r3, [r7, #4]
 8008a0c:	2201      	movs	r2, #1
 8008a0e:	701a      	strb	r2, [r3, #0]
            *mtu = 250U;
 8008a10:	6a3b      	ldr	r3, [r7, #32]
 8008a12:	22fa      	movs	r2, #250	; 0xfa
 8008a14:	701a      	strb	r2, [r3, #0]
            break;                        
 8008a16:	e015      	b.n	8008a44 <LDL_Region_convertRate+0xf0>
            *sf = LDL_SF_7;
 8008a18:	68bb      	ldr	r3, [r7, #8]
 8008a1a:	2207      	movs	r2, #7
 8008a1c:	701a      	strb	r2, [r3, #0]
            *bw = LDL_BW_125;
 8008a1e:	687b      	ldr	r3, [r7, #4]
 8008a20:	2200      	movs	r2, #0
 8008a22:	701a      	strb	r2, [r3, #0]
            *mtu = 250U;
 8008a24:	6a3b      	ldr	r3, [r7, #32]
 8008a26:	22fa      	movs	r2, #250	; 0xfa
 8008a28:	701a      	strb	r2, [r3, #0]
            LDL_INFO(NULL,"invalid rate")
 8008a2a:	4b0a      	ldr	r3, [pc, #40]	; (8008a54 <LDL_Region_convertRate+0x100>)
 8008a2c:	0018      	movs	r0, r3
 8008a2e:	f003 ff5d 	bl	800c8ec <iprintf>
 8008a32:	4b09      	ldr	r3, [pc, #36]	; (8008a58 <LDL_Region_convertRate+0x104>)
 8008a34:	0018      	movs	r0, r3
 8008a36:	f003 ff59 	bl	800c8ec <iprintf>
 8008a3a:	4b08      	ldr	r3, [pc, #32]	; (8008a5c <LDL_Region_convertRate+0x108>)
 8008a3c:	0018      	movs	r0, r3
 8008a3e:	f003 ffcf 	bl	800c9e0 <puts>
            break;
 8008a42:	46c0      	nop			; (mov r8, r8)
        break;
 8008a44:	46c0      	nop			; (mov r8, r8)
    }
}
 8008a46:	46c0      	nop			; (mov r8, r8)
 8008a48:	46bd      	mov	sp, r7
 8008a4a:	b005      	add	sp, #20
 8008a4c:	bd90      	pop	{r4, r7, pc}
 8008a4e:	46c0      	nop			; (mov r8, r8)
 8008a50:	0800e598 	.word	0x0800e598
 8008a54:	0800e0e8 	.word	0x0800e0e8
 8008a58:	0800e0f0 	.word	0x0800e0f0
 8008a5c:	0800e100 	.word	0x0800e100

08008a60 <LDL_Region_getBand>:

bool LDL_Region_getBand(enum ldl_region region, uint32_t freq, uint8_t *band)
{
 8008a60:	b580      	push	{r7, lr}
 8008a62:	b086      	sub	sp, #24
 8008a64:	af00      	add	r7, sp, #0
 8008a66:	60b9      	str	r1, [r7, #8]
 8008a68:	607a      	str	r2, [r7, #4]
 8008a6a:	210f      	movs	r1, #15
 8008a6c:	187b      	adds	r3, r7, r1
 8008a6e:	1c02      	adds	r2, r0, #0
 8008a70:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(band != NULL)

    bool retval = false;
 8008a72:	2317      	movs	r3, #23
 8008a74:	18fb      	adds	r3, r7, r3
 8008a76:	2200      	movs	r2, #0
 8008a78:	701a      	strb	r2, [r3, #0]

    switch(region){
 8008a7a:	187b      	adds	r3, r7, r1
 8008a7c:	781b      	ldrb	r3, [r3, #0]
 8008a7e:	2b00      	cmp	r3, #0
 8008a80:	d145      	bne.n	8008b0e <LDL_Region_getBand+0xae>
#ifdef LDL_ENABLE_EU_863_870        
    case LDL_EU_863_870:
    
        retval = true;
 8008a82:	2317      	movs	r3, #23
 8008a84:	18fb      	adds	r3, r7, r3
 8008a86:	2201      	movs	r2, #1
 8008a88:	701a      	strb	r2, [r3, #0]
    
        if((freq >= 863000000UL) && (freq <= 868000000UL)){
 8008a8a:	68bb      	ldr	r3, [r7, #8]
 8008a8c:	4a27      	ldr	r2, [pc, #156]	; (8008b2c <LDL_Region_getBand+0xcc>)
 8008a8e:	4293      	cmp	r3, r2
 8008a90:	d907      	bls.n	8008aa2 <LDL_Region_getBand+0x42>
 8008a92:	68bb      	ldr	r3, [r7, #8]
 8008a94:	4a26      	ldr	r2, [pc, #152]	; (8008b30 <LDL_Region_getBand+0xd0>)
 8008a96:	4293      	cmp	r3, r2
 8008a98:	d803      	bhi.n	8008aa2 <LDL_Region_getBand+0x42>
            
            *band = 0U;
 8008a9a:	687b      	ldr	r3, [r7, #4]
 8008a9c:	2200      	movs	r2, #0
 8008a9e:	701a      	strb	r2, [r3, #0]
 8008aa0:	e034      	b.n	8008b0c <LDL_Region_getBand+0xac>
        }
        else if((freq >= 868000000UL) && (freq <= 868600000UL)){
 8008aa2:	68bb      	ldr	r3, [r7, #8]
 8008aa4:	4a23      	ldr	r2, [pc, #140]	; (8008b34 <LDL_Region_getBand+0xd4>)
 8008aa6:	4293      	cmp	r3, r2
 8008aa8:	d907      	bls.n	8008aba <LDL_Region_getBand+0x5a>
 8008aaa:	68bb      	ldr	r3, [r7, #8]
 8008aac:	4a22      	ldr	r2, [pc, #136]	; (8008b38 <LDL_Region_getBand+0xd8>)
 8008aae:	4293      	cmp	r3, r2
 8008ab0:	d803      	bhi.n	8008aba <LDL_Region_getBand+0x5a>
            
            *band = 1U;
 8008ab2:	687b      	ldr	r3, [r7, #4]
 8008ab4:	2201      	movs	r2, #1
 8008ab6:	701a      	strb	r2, [r3, #0]
 8008ab8:	e028      	b.n	8008b0c <LDL_Region_getBand+0xac>
        }
        else if((freq >= 868700000UL) && (freq <= 869200000UL)){
 8008aba:	68bb      	ldr	r3, [r7, #8]
 8008abc:	4a1f      	ldr	r2, [pc, #124]	; (8008b3c <LDL_Region_getBand+0xdc>)
 8008abe:	4293      	cmp	r3, r2
 8008ac0:	d907      	bls.n	8008ad2 <LDL_Region_getBand+0x72>
 8008ac2:	68bb      	ldr	r3, [r7, #8]
 8008ac4:	4a1e      	ldr	r2, [pc, #120]	; (8008b40 <LDL_Region_getBand+0xe0>)
 8008ac6:	4293      	cmp	r3, r2
 8008ac8:	d803      	bhi.n	8008ad2 <LDL_Region_getBand+0x72>
            
            *band = 2U;
 8008aca:	687b      	ldr	r3, [r7, #4]
 8008acc:	2202      	movs	r2, #2
 8008ace:	701a      	strb	r2, [r3, #0]
 8008ad0:	e01c      	b.n	8008b0c <LDL_Region_getBand+0xac>
        }
        else if((freq >= 869400000UL) && (freq <= 869650000UL)){
 8008ad2:	68bb      	ldr	r3, [r7, #8]
 8008ad4:	4a1b      	ldr	r2, [pc, #108]	; (8008b44 <LDL_Region_getBand+0xe4>)
 8008ad6:	4293      	cmp	r3, r2
 8008ad8:	d907      	bls.n	8008aea <LDL_Region_getBand+0x8a>
 8008ada:	68bb      	ldr	r3, [r7, #8]
 8008adc:	4a1a      	ldr	r2, [pc, #104]	; (8008b48 <LDL_Region_getBand+0xe8>)
 8008ade:	4293      	cmp	r3, r2
 8008ae0:	d803      	bhi.n	8008aea <LDL_Region_getBand+0x8a>
            
            *band = 3U;
 8008ae2:	687b      	ldr	r3, [r7, #4]
 8008ae4:	2203      	movs	r2, #3
 8008ae6:	701a      	strb	r2, [r3, #0]
 8008ae8:	e010      	b.n	8008b0c <LDL_Region_getBand+0xac>
        }
        else if((freq >= 869700000UL) && (freq < 870000000UL)){
 8008aea:	68bb      	ldr	r3, [r7, #8]
 8008aec:	4a17      	ldr	r2, [pc, #92]	; (8008b4c <LDL_Region_getBand+0xec>)
 8008aee:	4293      	cmp	r3, r2
 8008af0:	d907      	bls.n	8008b02 <LDL_Region_getBand+0xa2>
 8008af2:	68bb      	ldr	r3, [r7, #8]
 8008af4:	4a16      	ldr	r2, [pc, #88]	; (8008b50 <LDL_Region_getBand+0xf0>)
 8008af6:	4293      	cmp	r3, r2
 8008af8:	d803      	bhi.n	8008b02 <LDL_Region_getBand+0xa2>
            
            *band = 4U;
 8008afa:	687b      	ldr	r3, [r7, #4]
 8008afc:	2204      	movs	r2, #4
 8008afe:	701a      	strb	r2, [r3, #0]
 8008b00:	e004      	b.n	8008b0c <LDL_Region_getBand+0xac>
        }
        else{
            
            retval = false;
 8008b02:	2317      	movs	r3, #23
 8008b04:	18fb      	adds	r3, r7, r3
 8008b06:	2200      	movs	r2, #0
 8008b08:	701a      	strb	r2, [r3, #0]
        }        
        break;
 8008b0a:	e008      	b.n	8008b1e <LDL_Region_getBand+0xbe>
 8008b0c:	e007      	b.n	8008b1e <LDL_Region_getBand+0xbe>
#endif    
    default:
        *band = 0U;
 8008b0e:	687b      	ldr	r3, [r7, #4]
 8008b10:	2200      	movs	r2, #0
 8008b12:	701a      	strb	r2, [r3, #0]
        retval = true;
 8008b14:	2317      	movs	r3, #23
 8008b16:	18fb      	adds	r3, r7, r3
 8008b18:	2201      	movs	r2, #1
 8008b1a:	701a      	strb	r2, [r3, #0]
        break;        
 8008b1c:	46c0      	nop			; (mov r8, r8)
    }
    
    return retval;
 8008b1e:	2317      	movs	r3, #23
 8008b20:	18fb      	adds	r3, r7, r3
 8008b22:	781b      	ldrb	r3, [r3, #0]
}
 8008b24:	0018      	movs	r0, r3
 8008b26:	46bd      	mov	sp, r7
 8008b28:	b006      	add	sp, #24
 8008b2a:	bd80      	pop	{r7, pc}
 8008b2c:	337055bf 	.word	0x337055bf
 8008b30:	33bca100 	.word	0x33bca100
 8008b34:	33bca0ff 	.word	0x33bca0ff
 8008b38:	33c5c8c0 	.word	0x33c5c8c0
 8008b3c:	33c74f5f 	.word	0x33c74f5f
 8008b40:	33cef080 	.word	0x33cef080
 8008b44:	33d1fdbf 	.word	0x33d1fdbf
 8008b48:	33d5ce50 	.word	0x33d5ce50
 8008b4c:	33d6919f 	.word	0x33d6919f
 8008b50:	33db257f 	.word	0x33db257f

08008b54 <LDL_Region_isDynamic>:

bool LDL_Region_isDynamic(enum ldl_region region)
{
 8008b54:	b580      	push	{r7, lr}
 8008b56:	b084      	sub	sp, #16
 8008b58:	af00      	add	r7, sp, #0
 8008b5a:	0002      	movs	r2, r0
 8008b5c:	1dfb      	adds	r3, r7, #7
 8008b5e:	701a      	strb	r2, [r3, #0]
    bool retval;
    
    switch(region){
    default:
        retval = true;
 8008b60:	210f      	movs	r1, #15
 8008b62:	187b      	adds	r3, r7, r1
 8008b64:	2201      	movs	r2, #1
 8008b66:	701a      	strb	r2, [r3, #0]
        break;        
 8008b68:	46c0      	nop			; (mov r8, r8)
        retval = false;                    
        break;
#endif        
    }
    
    return retval;
 8008b6a:	187b      	adds	r3, r7, r1
 8008b6c:	781b      	ldrb	r3, [r3, #0]
}
 8008b6e:	0018      	movs	r0, r3
 8008b70:	46bd      	mov	sp, r7
 8008b72:	b004      	add	sp, #16
 8008b74:	bd80      	pop	{r7, pc}

08008b76 <LDL_Region_getChannel>:

bool LDL_Region_getChannel(enum ldl_region region, uint8_t chIndex, uint32_t *freq, uint8_t *minRate, uint8_t *maxRate)
{
 8008b76:	b580      	push	{r7, lr}
 8008b78:	b086      	sub	sp, #24
 8008b7a:	af00      	add	r7, sp, #0
 8008b7c:	60ba      	str	r2, [r7, #8]
 8008b7e:	607b      	str	r3, [r7, #4]
 8008b80:	230f      	movs	r3, #15
 8008b82:	18fb      	adds	r3, r7, r3
 8008b84:	1c02      	adds	r2, r0, #0
 8008b86:	701a      	strb	r2, [r3, #0]
 8008b88:	230e      	movs	r3, #14
 8008b8a:	18fb      	adds	r3, r7, r3
 8008b8c:	1c0a      	adds	r2, r1, #0
 8008b8e:	701a      	strb	r2, [r3, #0]
    bool retval = false;
 8008b90:	2117      	movs	r1, #23
 8008b92:	187b      	adds	r3, r7, r1
 8008b94:	2200      	movs	r2, #0
 8008b96:	701a      	strb	r2, [r3, #0]
    (void)minRate;
    (void)maxRate;
    
    switch(region){
    default:
        break;    
 8008b98:	46c0      	nop			; (mov r8, r8)
        }
        break;
#endif        
    }
    
    return retval;
 8008b9a:	187b      	adds	r3, r7, r1
 8008b9c:	781b      	ldrb	r3, [r3, #0]
}
 8008b9e:	0018      	movs	r0, r3
 8008ba0:	46bd      	mov	sp, r7
 8008ba2:	b006      	add	sp, #24
 8008ba4:	bd80      	pop	{r7, pc}

08008ba6 <LDL_Region_numChannels>:

uint8_t LDL_Region_numChannels(enum ldl_region region)
{
 8008ba6:	b580      	push	{r7, lr}
 8008ba8:	b084      	sub	sp, #16
 8008baa:	af00      	add	r7, sp, #0
 8008bac:	0002      	movs	r2, r0
 8008bae:	1dfb      	adds	r3, r7, #7
 8008bb0:	701a      	strb	r2, [r3, #0]
    uint8_t retval;
    
    switch(region){
    default:
        retval = 16U;    
 8008bb2:	210f      	movs	r1, #15
 8008bb4:	187b      	adds	r3, r7, r1
 8008bb6:	2210      	movs	r2, #16
 8008bb8:	701a      	strb	r2, [r3, #0]
        break;
 8008bba:	46c0      	nop			; (mov r8, r8)
        retval = 72U;
        break;                
#endif        
    }
    
    return retval;    
 8008bbc:	187b      	adds	r3, r7, r1
 8008bbe:	781b      	ldrb	r3, [r3, #0]
}
 8008bc0:	0018      	movs	r0, r3
 8008bc2:	46bd      	mov	sp, r7
 8008bc4:	b004      	add	sp, #16
 8008bc6:	bd80      	pop	{r7, pc}

08008bc8 <LDL_Region_getDefaultChannels>:

void LDL_Region_getDefaultChannels(enum ldl_region region, struct ldl_mac *mac)
{
 8008bc8:	b5b0      	push	{r4, r5, r7, lr}
 8008bca:	b086      	sub	sp, #24
 8008bcc:	af02      	add	r7, sp, #8
 8008bce:	0002      	movs	r2, r0
 8008bd0:	6039      	str	r1, [r7, #0]
 8008bd2:	1dfb      	adds	r3, r7, #7
 8008bd4:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(mac != NULL)
    
    uint8_t minRate;
    uint8_t maxRate;
    
    switch(region){
 8008bd6:	1dfb      	adds	r3, r7, #7
 8008bd8:	781b      	ldrb	r3, [r3, #0]
 8008bda:	2b00      	cmp	r3, #0
 8008bdc:	d000      	beq.n	8008be0 <LDL_Region_getDefaultChannels+0x18>
    default:
        break;    
 8008bde:	e02e      	b.n	8008c3e <LDL_Region_getDefaultChannels+0x76>
#ifdef LDL_ENABLE_EU_863_870
    case LDL_EU_863_870:
    
        (void)upRateRange(region, 0U, &minRate, &maxRate);
 8008be0:	240e      	movs	r4, #14
 8008be2:	1939      	adds	r1, r7, r4
 8008be4:	250f      	movs	r5, #15
 8008be6:	197a      	adds	r2, r7, r5
 8008be8:	1dfb      	adds	r3, r7, #7
 8008bea:	7818      	ldrb	r0, [r3, #0]
 8008bec:	000b      	movs	r3, r1
 8008bee:	2100      	movs	r1, #0
 8008bf0:	f000 fa7c 	bl	80090ec <upRateRange>
        
        LDL_MAC_addChannel(mac, 0U, 868100000UL, minRate, maxRate);
 8008bf4:	197b      	adds	r3, r7, r5
 8008bf6:	781a      	ldrb	r2, [r3, #0]
 8008bf8:	193b      	adds	r3, r7, r4
 8008bfa:	781b      	ldrb	r3, [r3, #0]
 8008bfc:	4912      	ldr	r1, [pc, #72]	; (8008c48 <LDL_Region_getDefaultChannels+0x80>)
 8008bfe:	6838      	ldr	r0, [r7, #0]
 8008c00:	9300      	str	r3, [sp, #0]
 8008c02:	0013      	movs	r3, r2
 8008c04:	000a      	movs	r2, r1
 8008c06:	2100      	movs	r1, #0
 8008c08:	f7fb f8d4 	bl	8003db4 <LDL_MAC_addChannel>
        LDL_MAC_addChannel(mac, 1U, 868300000UL, minRate, maxRate);
 8008c0c:	197b      	adds	r3, r7, r5
 8008c0e:	781a      	ldrb	r2, [r3, #0]
 8008c10:	193b      	adds	r3, r7, r4
 8008c12:	781b      	ldrb	r3, [r3, #0]
 8008c14:	490d      	ldr	r1, [pc, #52]	; (8008c4c <LDL_Region_getDefaultChannels+0x84>)
 8008c16:	6838      	ldr	r0, [r7, #0]
 8008c18:	9300      	str	r3, [sp, #0]
 8008c1a:	0013      	movs	r3, r2
 8008c1c:	000a      	movs	r2, r1
 8008c1e:	2101      	movs	r1, #1
 8008c20:	f7fb f8c8 	bl	8003db4 <LDL_MAC_addChannel>
        LDL_MAC_addChannel(mac, 2U, 868500000UL, minRate, maxRate);        
 8008c24:	197b      	adds	r3, r7, r5
 8008c26:	781a      	ldrb	r2, [r3, #0]
 8008c28:	193b      	adds	r3, r7, r4
 8008c2a:	781b      	ldrb	r3, [r3, #0]
 8008c2c:	4908      	ldr	r1, [pc, #32]	; (8008c50 <LDL_Region_getDefaultChannels+0x88>)
 8008c2e:	6838      	ldr	r0, [r7, #0]
 8008c30:	9300      	str	r3, [sp, #0]
 8008c32:	0013      	movs	r3, r2
 8008c34:	000a      	movs	r2, r1
 8008c36:	2102      	movs	r1, #2
 8008c38:	f7fb f8bc 	bl	8003db4 <LDL_MAC_addChannel>
        break;
 8008c3c:	46c0      	nop			; (mov r8, r8)
        LDL_MAC_addChannel(mac, 1U, 433375000UL, minRate, maxRate);
        LDL_MAC_addChannel(mac, 2U, 433575000UL, minRate, maxRate);        
        break;
#endif        
    }
}
 8008c3e:	46c0      	nop			; (mov r8, r8)
 8008c40:	46bd      	mov	sp, r7
 8008c42:	b004      	add	sp, #16
 8008c44:	bdb0      	pop	{r4, r5, r7, pc}
 8008c46:	46c0      	nop			; (mov r8, r8)
 8008c48:	33be27a0 	.word	0x33be27a0
 8008c4c:	33c134e0 	.word	0x33c134e0
 8008c50:	33c44220 	.word	0x33c44220

08008c54 <unpackCFListFreq>:

#if defined(LDL_ENABLE_EU_863_870) || defined(LDL_ENABLE_EU_433)         
static uint8_t unpackCFListFreq(const uint8_t *cfList, uint32_t *freq)
{
 8008c54:	b580      	push	{r7, lr}
 8008c56:	b082      	sub	sp, #8
 8008c58:	af00      	add	r7, sp, #0
 8008c5a:	6078      	str	r0, [r7, #4]
 8008c5c:	6039      	str	r1, [r7, #0]
    *freq = cfList[2];
 8008c5e:	687b      	ldr	r3, [r7, #4]
 8008c60:	3302      	adds	r3, #2
 8008c62:	781b      	ldrb	r3, [r3, #0]
 8008c64:	001a      	movs	r2, r3
 8008c66:	683b      	ldr	r3, [r7, #0]
 8008c68:	601a      	str	r2, [r3, #0]
    *freq <<= 8;
 8008c6a:	683b      	ldr	r3, [r7, #0]
 8008c6c:	681b      	ldr	r3, [r3, #0]
 8008c6e:	021a      	lsls	r2, r3, #8
 8008c70:	683b      	ldr	r3, [r7, #0]
 8008c72:	601a      	str	r2, [r3, #0]
    *freq |= cfList[1];
 8008c74:	683b      	ldr	r3, [r7, #0]
 8008c76:	681b      	ldr	r3, [r3, #0]
 8008c78:	687a      	ldr	r2, [r7, #4]
 8008c7a:	3201      	adds	r2, #1
 8008c7c:	7812      	ldrb	r2, [r2, #0]
 8008c7e:	431a      	orrs	r2, r3
 8008c80:	683b      	ldr	r3, [r7, #0]
 8008c82:	601a      	str	r2, [r3, #0]
    *freq <<= 8;
 8008c84:	683b      	ldr	r3, [r7, #0]
 8008c86:	681b      	ldr	r3, [r3, #0]
 8008c88:	021a      	lsls	r2, r3, #8
 8008c8a:	683b      	ldr	r3, [r7, #0]
 8008c8c:	601a      	str	r2, [r3, #0]
    *freq |= cfList[0];
 8008c8e:	683b      	ldr	r3, [r7, #0]
 8008c90:	681b      	ldr	r3, [r3, #0]
 8008c92:	687a      	ldr	r2, [r7, #4]
 8008c94:	7812      	ldrb	r2, [r2, #0]
 8008c96:	431a      	orrs	r2, r3
 8008c98:	683b      	ldr	r3, [r7, #0]
 8008c9a:	601a      	str	r2, [r3, #0]
    
    *freq *= 100UL;
 8008c9c:	683b      	ldr	r3, [r7, #0]
 8008c9e:	681b      	ldr	r3, [r3, #0]
 8008ca0:	2264      	movs	r2, #100	; 0x64
 8008ca2:	435a      	muls	r2, r3
 8008ca4:	683b      	ldr	r3, [r7, #0]
 8008ca6:	601a      	str	r2, [r3, #0]
    
    return 3U;
 8008ca8:	2303      	movs	r3, #3
}
 8008caa:	0018      	movs	r0, r3
 8008cac:	46bd      	mov	sp, r7
 8008cae:	b002      	add	sp, #8
 8008cb0:	bd80      	pop	{r7, pc}

08008cb2 <LDL_Region_processCFList>:
    return 2U;    
}
#endif

void LDL_Region_processCFList(enum ldl_region region, struct ldl_mac *mac, const uint8_t *cfList, uint8_t cfListLen)
{
 8008cb2:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008cb4:	b089      	sub	sp, #36	; 0x24
 8008cb6:	af02      	add	r7, sp, #8
 8008cb8:	60b9      	str	r1, [r7, #8]
 8008cba:	607a      	str	r2, [r7, #4]
 8008cbc:	0019      	movs	r1, r3
 8008cbe:	230f      	movs	r3, #15
 8008cc0:	18fb      	adds	r3, r7, r3
 8008cc2:	1c02      	adds	r2, r0, #0
 8008cc4:	701a      	strb	r2, [r3, #0]
 8008cc6:	200e      	movs	r0, #14
 8008cc8:	183b      	adds	r3, r7, r0
 8008cca:	1c0a      	adds	r2, r1, #0
 8008ccc:	701a      	strb	r2, [r3, #0]
    if(cfListLen == 16U){
 8008cce:	183b      	adds	r3, r7, r0
 8008cd0:	781b      	ldrb	r3, [r3, #0]
 8008cd2:	2b10      	cmp	r3, #16
 8008cd4:	d14b      	bne.n	8008d6e <LDL_Region_processCFList+0xbc>
    
        switch(region){
 8008cd6:	230f      	movs	r3, #15
 8008cd8:	18fb      	adds	r3, r7, r3
 8008cda:	781b      	ldrb	r3, [r3, #0]
 8008cdc:	2b00      	cmp	r3, #0
 8008cde:	d000      	beq.n	8008ce2 <LDL_Region_processCFList+0x30>
        default:
            break;
 8008ce0:	e048      	b.n	8008d74 <LDL_Region_processCFList+0xc2>
#   endif
#   ifdef LDL_ENABLE_EU_433
        case LDL_EU_433:
#   endif        
           /* 0 means frequency list */
           if(cfList[15] == 0U){
 8008ce2:	687b      	ldr	r3, [r7, #4]
 8008ce4:	330f      	adds	r3, #15
 8008ce6:	781b      	ldrb	r3, [r3, #0]
 8008ce8:	2b00      	cmp	r3, #0
 8008cea:	d142      	bne.n	8008d72 <LDL_Region_processCFList+0xc0>
                uint8_t maxRate;
                uint32_t freq;
                uint8_t i;
                uint8_t pos;
                
                for(i=3U,pos=0U; i < 8U; i++){
 8008cec:	2317      	movs	r3, #23
 8008cee:	18fb      	adds	r3, r7, r3
 8008cf0:	2203      	movs	r2, #3
 8008cf2:	701a      	strb	r2, [r3, #0]
 8008cf4:	2316      	movs	r3, #22
 8008cf6:	18fb      	adds	r3, r7, r3
 8008cf8:	2200      	movs	r2, #0
 8008cfa:	701a      	strb	r2, [r3, #0]
 8008cfc:	e031      	b.n	8008d62 <LDL_Region_processCFList+0xb0>
                
                     pos += unpackCFListFreq(&cfList[pos], &freq);
 8008cfe:	2416      	movs	r4, #22
 8008d00:	193b      	adds	r3, r7, r4
 8008d02:	781b      	ldrb	r3, [r3, #0]
 8008d04:	687a      	ldr	r2, [r7, #4]
 8008d06:	18d3      	adds	r3, r2, r3
 8008d08:	2210      	movs	r2, #16
 8008d0a:	18ba      	adds	r2, r7, r2
 8008d0c:	0011      	movs	r1, r2
 8008d0e:	0018      	movs	r0, r3
 8008d10:	f7ff ffa0 	bl	8008c54 <unpackCFListFreq>
 8008d14:	0003      	movs	r3, r0
 8008d16:	0019      	movs	r1, r3
 8008d18:	193b      	adds	r3, r7, r4
 8008d1a:	193a      	adds	r2, r7, r4
 8008d1c:	7812      	ldrb	r2, [r2, #0]
 8008d1e:	188a      	adds	r2, r1, r2
 8008d20:	701a      	strb	r2, [r3, #0]
                     
                     (void)upRateRange(region, i, &minRate, &maxRate);                 
 8008d22:	2314      	movs	r3, #20
 8008d24:	18fc      	adds	r4, r7, r3
 8008d26:	2515      	movs	r5, #21
 8008d28:	197a      	adds	r2, r7, r5
 8008d2a:	2617      	movs	r6, #23
 8008d2c:	19bb      	adds	r3, r7, r6
 8008d2e:	7819      	ldrb	r1, [r3, #0]
 8008d30:	200f      	movs	r0, #15
 8008d32:	183b      	adds	r3, r7, r0
 8008d34:	7818      	ldrb	r0, [r3, #0]
 8008d36:	0023      	movs	r3, r4
 8008d38:	f000 f9d8 	bl	80090ec <upRateRange>
                     
                     (void)LDL_MAC_addChannel(mac, i, freq, minRate, maxRate);
 8008d3c:	693c      	ldr	r4, [r7, #16]
 8008d3e:	197b      	adds	r3, r7, r5
 8008d40:	781d      	ldrb	r5, [r3, #0]
 8008d42:	2314      	movs	r3, #20
 8008d44:	18fb      	adds	r3, r7, r3
 8008d46:	781b      	ldrb	r3, [r3, #0]
 8008d48:	19ba      	adds	r2, r7, r6
 8008d4a:	7811      	ldrb	r1, [r2, #0]
 8008d4c:	68b8      	ldr	r0, [r7, #8]
 8008d4e:	9300      	str	r3, [sp, #0]
 8008d50:	002b      	movs	r3, r5
 8008d52:	0022      	movs	r2, r4
 8008d54:	f7fb f82e 	bl	8003db4 <LDL_MAC_addChannel>
                for(i=3U,pos=0U; i < 8U; i++){
 8008d58:	19bb      	adds	r3, r7, r6
 8008d5a:	781a      	ldrb	r2, [r3, #0]
 8008d5c:	19bb      	adds	r3, r7, r6
 8008d5e:	3201      	adds	r2, #1
 8008d60:	701a      	strb	r2, [r3, #0]
 8008d62:	2317      	movs	r3, #23
 8008d64:	18fb      	adds	r3, r7, r3
 8008d66:	781b      	ldrb	r3, [r3, #0]
 8008d68:	2b07      	cmp	r3, #7
 8008d6a:	d9c8      	bls.n	8008cfe <LDL_Region_processCFList+0x4c>
                }            
            }        
            break;
 8008d6c:	e001      	b.n	8008d72 <LDL_Region_processCFList+0xc0>
                }            
            }        
            break;
#endif        
        }
    }    
 8008d6e:	46c0      	nop			; (mov r8, r8)
 8008d70:	e000      	b.n	8008d74 <LDL_Region_processCFList+0xc2>
            break;
 8008d72:	46c0      	nop			; (mov r8, r8)
}
 8008d74:	46c0      	nop			; (mov r8, r8)
 8008d76:	46bd      	mov	sp, r7
 8008d78:	b007      	add	sp, #28
 8008d7a:	bdf0      	pop	{r4, r5, r6, r7, pc}

08008d7c <LDL_Region_getOffTimeFactor>:

uint32_t LDL_Region_getOffTimeFactor(enum ldl_region region, uint8_t band)
{
 8008d7c:	b580      	push	{r7, lr}
 8008d7e:	b084      	sub	sp, #16
 8008d80:	af00      	add	r7, sp, #0
 8008d82:	0002      	movs	r2, r0
 8008d84:	1dfb      	adds	r3, r7, #7
 8008d86:	701a      	strb	r2, [r3, #0]
 8008d88:	1dbb      	adds	r3, r7, #6
 8008d8a:	1c0a      	adds	r2, r1, #0
 8008d8c:	701a      	strb	r2, [r3, #0]
    uint32_t retval = 0UL;
 8008d8e:	2300      	movs	r3, #0
 8008d90:	60fb      	str	r3, [r7, #12]
    
    switch(region){
 8008d92:	1dfb      	adds	r3, r7, #7
 8008d94:	781b      	ldrb	r3, [r3, #0]
 8008d96:	2b00      	cmp	r3, #0
 8008d98:	d000      	beq.n	8008d9c <LDL_Region_getOffTimeFactor+0x20>
    default:
        break;    
 8008d9a:	e014      	b.n	8008dc6 <LDL_Region_getOffTimeFactor+0x4a>
#ifdef LDL_ENABLE_EU_863_870    
    case LDL_EU_863_870:
    
        switch(band){
 8008d9c:	1dbb      	adds	r3, r7, #6
 8008d9e:	781b      	ldrb	r3, [r3, #0]
 8008da0:	2b04      	cmp	r3, #4
 8008da2:	d80e      	bhi.n	8008dc2 <LDL_Region_getOffTimeFactor+0x46>
 8008da4:	009a      	lsls	r2, r3, #2
 8008da6:	4b0a      	ldr	r3, [pc, #40]	; (8008dd0 <LDL_Region_getOffTimeFactor+0x54>)
 8008da8:	18d3      	adds	r3, r2, r3
 8008daa:	681b      	ldr	r3, [r3, #0]
 8008dac:	469f      	mov	pc, r3
        case 0U:
        case 1U:
        case 4U:
            retval = 100UL;      // 1.0%
 8008dae:	2364      	movs	r3, #100	; 0x64
 8008db0:	60fb      	str	r3, [r7, #12]
            break;
 8008db2:	e007      	b.n	8008dc4 <LDL_Region_getOffTimeFactor+0x48>
        case 2U:
            retval = 1000UL;     // 0.1%
 8008db4:	23fa      	movs	r3, #250	; 0xfa
 8008db6:	009b      	lsls	r3, r3, #2
 8008db8:	60fb      	str	r3, [r7, #12]
            break;
 8008dba:	e003      	b.n	8008dc4 <LDL_Region_getOffTimeFactor+0x48>
        case 3U:        
            retval = 10UL;       // 10.0%
 8008dbc:	230a      	movs	r3, #10
 8008dbe:	60fb      	str	r3, [r7, #12]
            break;                    
 8008dc0:	e000      	b.n	8008dc4 <LDL_Region_getOffTimeFactor+0x48>
        default:
            break;
 8008dc2:	46c0      	nop			; (mov r8, r8)
        }
        break;
 8008dc4:	46c0      	nop			; (mov r8, r8)
        retval = 100UL;
        break;    
#endif
    }
    
    return retval;    
 8008dc6:	68fb      	ldr	r3, [r7, #12]
}
 8008dc8:	0018      	movs	r0, r3
 8008dca:	46bd      	mov	sp, r7
 8008dcc:	b004      	add	sp, #16
 8008dce:	bd80      	pop	{r7, pc}
 8008dd0:	0800e5b4 	.word	0x0800e5b4

08008dd4 <LDL_Region_validateRate>:

bool LDL_Region_validateRate(enum ldl_region region, uint8_t chIndex, uint8_t minRate, uint8_t maxRate)
{
 8008dd4:	b5b0      	push	{r4, r5, r7, lr}
 8008dd6:	b084      	sub	sp, #16
 8008dd8:	af00      	add	r7, sp, #0
 8008dda:	0005      	movs	r5, r0
 8008ddc:	000c      	movs	r4, r1
 8008dde:	0010      	movs	r0, r2
 8008de0:	0019      	movs	r1, r3
 8008de2:	1dfb      	adds	r3, r7, #7
 8008de4:	1c2a      	adds	r2, r5, #0
 8008de6:	701a      	strb	r2, [r3, #0]
 8008de8:	1dbb      	adds	r3, r7, #6
 8008dea:	1c22      	adds	r2, r4, #0
 8008dec:	701a      	strb	r2, [r3, #0]
 8008dee:	1d7b      	adds	r3, r7, #5
 8008df0:	1c02      	adds	r2, r0, #0
 8008df2:	701a      	strb	r2, [r3, #0]
 8008df4:	1d3b      	adds	r3, r7, #4
 8008df6:	1c0a      	adds	r2, r1, #0
 8008df8:	701a      	strb	r2, [r3, #0]
    bool retval = false;
 8008dfa:	230f      	movs	r3, #15
 8008dfc:	18fb      	adds	r3, r7, r3
 8008dfe:	2200      	movs	r2, #0
 8008e00:	701a      	strb	r2, [r3, #0]
    uint8_t min;
    uint8_t max;

    if(upRateRange(region, chIndex, &min, &max)){
 8008e02:	230d      	movs	r3, #13
 8008e04:	18fc      	adds	r4, r7, r3
 8008e06:	230e      	movs	r3, #14
 8008e08:	18fa      	adds	r2, r7, r3
 8008e0a:	1dbb      	adds	r3, r7, #6
 8008e0c:	7819      	ldrb	r1, [r3, #0]
 8008e0e:	1dfb      	adds	r3, r7, #7
 8008e10:	7818      	ldrb	r0, [r3, #0]
 8008e12:	0023      	movs	r3, r4
 8008e14:	f000 f96a 	bl	80090ec <upRateRange>
 8008e18:	1e03      	subs	r3, r0, #0
 8008e1a:	d011      	beq.n	8008e40 <LDL_Region_validateRate+0x6c>
        
        if((minRate >= min) && (maxRate <= max)){
 8008e1c:	230e      	movs	r3, #14
 8008e1e:	18fb      	adds	r3, r7, r3
 8008e20:	781b      	ldrb	r3, [r3, #0]
 8008e22:	1d7a      	adds	r2, r7, #5
 8008e24:	7812      	ldrb	r2, [r2, #0]
 8008e26:	429a      	cmp	r2, r3
 8008e28:	d30a      	bcc.n	8008e40 <LDL_Region_validateRate+0x6c>
 8008e2a:	230d      	movs	r3, #13
 8008e2c:	18fb      	adds	r3, r7, r3
 8008e2e:	781b      	ldrb	r3, [r3, #0]
 8008e30:	1d3a      	adds	r2, r7, #4
 8008e32:	7812      	ldrb	r2, [r2, #0]
 8008e34:	429a      	cmp	r2, r3
 8008e36:	d803      	bhi.n	8008e40 <LDL_Region_validateRate+0x6c>
            
            retval = true;
 8008e38:	230f      	movs	r3, #15
 8008e3a:	18fb      	adds	r3, r7, r3
 8008e3c:	2201      	movs	r2, #1
 8008e3e:	701a      	strb	r2, [r3, #0]
        }
    }    
    
    return retval;
 8008e40:	230f      	movs	r3, #15
 8008e42:	18fb      	adds	r3, r7, r3
 8008e44:	781b      	ldrb	r3, [r3, #0]
}
 8008e46:	0018      	movs	r0, r3
 8008e48:	46bd      	mov	sp, r7
 8008e4a:	b004      	add	sp, #16
 8008e4c:	bdb0      	pop	{r4, r5, r7, pc}

08008e4e <LDL_Region_validateFreq>:

bool LDL_Region_validateFreq(enum ldl_region region, uint8_t chIndex, uint32_t freq)
{
 8008e4e:	b580      	push	{r7, lr}
 8008e50:	b082      	sub	sp, #8
 8008e52:	af00      	add	r7, sp, #0
 8008e54:	603a      	str	r2, [r7, #0]
 8008e56:	1dfb      	adds	r3, r7, #7
 8008e58:	1c02      	adds	r2, r0, #0
 8008e5a:	701a      	strb	r2, [r3, #0]
 8008e5c:	1dbb      	adds	r3, r7, #6
 8008e5e:	1c0a      	adds	r2, r1, #0
 8008e60:	701a      	strb	r2, [r3, #0]
    (void)region;
    (void)chIndex;
    (void)freq;
    
    return true;
 8008e62:	2301      	movs	r3, #1
}
 8008e64:	0018      	movs	r0, r3
 8008e66:	46bd      	mov	sp, r7
 8008e68:	b002      	add	sp, #8
 8008e6a:	bd80      	pop	{r7, pc}

08008e6c <LDL_Region_getRX1DataRate>:

void LDL_Region_getRX1DataRate(enum ldl_region region, uint8_t tx_rate, uint8_t rx1_offset, uint8_t *rx1_rate)
{
 8008e6c:	b590      	push	{r4, r7, lr}
 8008e6e:	b087      	sub	sp, #28
 8008e70:	af00      	add	r7, sp, #0
 8008e72:	0004      	movs	r4, r0
 8008e74:	0008      	movs	r0, r1
 8008e76:	0011      	movs	r1, r2
 8008e78:	603b      	str	r3, [r7, #0]
 8008e7a:	1dfb      	adds	r3, r7, #7
 8008e7c:	1c22      	adds	r2, r4, #0
 8008e7e:	701a      	strb	r2, [r3, #0]
 8008e80:	1dbb      	adds	r3, r7, #6
 8008e82:	1c02      	adds	r2, r0, #0
 8008e84:	701a      	strb	r2, [r3, #0]
 8008e86:	1d7b      	adds	r3, r7, #5
 8008e88:	1c0a      	adds	r2, r1, #0
 8008e8a:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(rx1_rate != NULL)

    const uint8_t *ptr = NULL;
 8008e8c:	2300      	movs	r3, #0
 8008e8e:	617b      	str	r3, [r7, #20]
    uint16_t i = 0U;
 8008e90:	2012      	movs	r0, #18
 8008e92:	183b      	adds	r3, r7, r0
 8008e94:	2200      	movs	r2, #0
 8008e96:	801a      	strh	r2, [r3, #0]
    size_t size = 0U;
 8008e98:	2300      	movs	r3, #0
 8008e9a:	60fb      	str	r3, [r7, #12]
            5U, 4U, 3U, 2U, 1U, 0U,
            6U, 5U, 4U, 3U, 2U, 1U,
            7U, 6U, 5U, 4U, 3U, 2U,
        };

        i = (tx_rate * 6U) + rx1_offset;
 8008e9c:	1dbb      	adds	r3, r7, #6
 8008e9e:	781b      	ldrb	r3, [r3, #0]
 8008ea0:	b29b      	uxth	r3, r3
 8008ea2:	1c1a      	adds	r2, r3, #0
 8008ea4:	1c13      	adds	r3, r2, #0
 8008ea6:	18db      	adds	r3, r3, r3
 8008ea8:	189b      	adds	r3, r3, r2
 8008eaa:	18db      	adds	r3, r3, r3
 8008eac:	b299      	uxth	r1, r3
 8008eae:	1d7b      	adds	r3, r7, #5
 8008eb0:	781b      	ldrb	r3, [r3, #0]
 8008eb2:	b29a      	uxth	r2, r3
 8008eb4:	183b      	adds	r3, r7, r0
 8008eb6:	188a      	adds	r2, r1, r2
 8008eb8:	801a      	strh	r2, [r3, #0]
        ptr = rates;
 8008eba:	4b15      	ldr	r3, [pc, #84]	; (8008f10 <LDL_Region_getRX1DataRate+0xa4>)
 8008ebc:	617b      	str	r3, [r7, #20]
        size = sizeof(rates);
 8008ebe:	2330      	movs	r3, #48	; 0x30
 8008ec0:	60fb      	str	r3, [r7, #12]
    }
        break;                   
 8008ec2:	46c0      	nop			; (mov r8, r8)
    }
        break;
#endif        
    }
    
    if(ptr != NULL){
 8008ec4:	697b      	ldr	r3, [r7, #20]
 8008ec6:	2b00      	cmp	r3, #0
 8008ec8:	d01e      	beq.n	8008f08 <LDL_Region_getRX1DataRate+0x9c>
    
        if(i < size){
 8008eca:	2312      	movs	r3, #18
 8008ecc:	18fb      	adds	r3, r7, r3
 8008ece:	881b      	ldrh	r3, [r3, #0]
 8008ed0:	68fa      	ldr	r2, [r7, #12]
 8008ed2:	429a      	cmp	r2, r3
 8008ed4:	d908      	bls.n	8008ee8 <LDL_Region_getRX1DataRate+0x7c>
        
            (void)memcpy_P(rx1_rate, &ptr[i], sizeof(*rx1_rate));
 8008ed6:	2312      	movs	r3, #18
 8008ed8:	18fb      	adds	r3, r7, r3
 8008eda:	881b      	ldrh	r3, [r3, #0]
 8008edc:	697a      	ldr	r2, [r7, #20]
 8008ede:	18d3      	adds	r3, r2, r3
 8008ee0:	781a      	ldrb	r2, [r3, #0]
 8008ee2:	683b      	ldr	r3, [r7, #0]
 8008ee4:	701a      	strb	r2, [r3, #0]
                        
            *rx1_rate = tx_rate;
            LDL_INFO(NULL,"out of range error")
        }
    }        
}
 8008ee6:	e00f      	b.n	8008f08 <LDL_Region_getRX1DataRate+0x9c>
            *rx1_rate = tx_rate;
 8008ee8:	683b      	ldr	r3, [r7, #0]
 8008eea:	1dba      	adds	r2, r7, #6
 8008eec:	7812      	ldrb	r2, [r2, #0]
 8008eee:	701a      	strb	r2, [r3, #0]
            LDL_INFO(NULL,"out of range error")
 8008ef0:	4b08      	ldr	r3, [pc, #32]	; (8008f14 <LDL_Region_getRX1DataRate+0xa8>)
 8008ef2:	0018      	movs	r0, r3
 8008ef4:	f003 fcfa 	bl	800c8ec <iprintf>
 8008ef8:	4b07      	ldr	r3, [pc, #28]	; (8008f18 <LDL_Region_getRX1DataRate+0xac>)
 8008efa:	0018      	movs	r0, r3
 8008efc:	f003 fcf6 	bl	800c8ec <iprintf>
 8008f00:	4b06      	ldr	r3, [pc, #24]	; (8008f1c <LDL_Region_getRX1DataRate+0xb0>)
 8008f02:	0018      	movs	r0, r3
 8008f04:	f003 fd6c 	bl	800c9e0 <puts>
}
 8008f08:	46c0      	nop			; (mov r8, r8)
 8008f0a:	46bd      	mov	sp, r7
 8008f0c:	b007      	add	sp, #28
 8008f0e:	bd90      	pop	{r4, r7, pc}
 8008f10:	0800e5c8 	.word	0x0800e5c8
 8008f14:	0800e0e8 	.word	0x0800e0e8
 8008f18:	0800e104 	.word	0x0800e104
 8008f1c:	0800e100 	.word	0x0800e100

08008f20 <LDL_Region_getRX1Freq>:

void LDL_Region_getRX1Freq(enum ldl_region region, uint32_t txFreq, uint8_t chIndex, uint32_t *freq)
{
 8008f20:	b580      	push	{r7, lr}
 8008f22:	b084      	sub	sp, #16
 8008f24:	af00      	add	r7, sp, #0
 8008f26:	60b9      	str	r1, [r7, #8]
 8008f28:	0011      	movs	r1, r2
 8008f2a:	607b      	str	r3, [r7, #4]
 8008f2c:	230f      	movs	r3, #15
 8008f2e:	18fb      	adds	r3, r7, r3
 8008f30:	1c02      	adds	r2, r0, #0
 8008f32:	701a      	strb	r2, [r3, #0]
 8008f34:	230e      	movs	r3, #14
 8008f36:	18fb      	adds	r3, r7, r3
 8008f38:	1c0a      	adds	r2, r1, #0
 8008f3a:	701a      	strb	r2, [r3, #0]
    (void)chIndex;
    
    switch(region){
    default:
        *freq = txFreq;
 8008f3c:	687b      	ldr	r3, [r7, #4]
 8008f3e:	68ba      	ldr	r2, [r7, #8]
 8008f40:	601a      	str	r2, [r3, #0]
        break;        
 8008f42:	46c0      	nop			; (mov r8, r8)
               
        *freq = 923300000UL + ((uint32_t)(chIndex % 8U) * 600000UL);       
        break;    
#endif        
    }
}
 8008f44:	46c0      	nop			; (mov r8, r8)
 8008f46:	46bd      	mov	sp, r7
 8008f48:	b004      	add	sp, #16
 8008f4a:	bd80      	pop	{r7, pc}

08008f4c <LDL_Region_getRX1Delay>:

uint8_t LDL_Region_getRX1Delay(enum ldl_region region)
{
 8008f4c:	b580      	push	{r7, lr}
 8008f4e:	b082      	sub	sp, #8
 8008f50:	af00      	add	r7, sp, #0
 8008f52:	0002      	movs	r2, r0
 8008f54:	1dfb      	adds	r3, r7, #7
 8008f56:	701a      	strb	r2, [r3, #0]
    (void)region;
    
    return 1U;    
 8008f58:	2301      	movs	r3, #1
}
 8008f5a:	0018      	movs	r0, r3
 8008f5c:	46bd      	mov	sp, r7
 8008f5e:	b002      	add	sp, #8
 8008f60:	bd80      	pop	{r7, pc}

08008f62 <LDL_Region_getJA1Delay>:

uint8_t LDL_Region_getJA1Delay(enum ldl_region region)
{
 8008f62:	b580      	push	{r7, lr}
 8008f64:	b082      	sub	sp, #8
 8008f66:	af00      	add	r7, sp, #0
 8008f68:	0002      	movs	r2, r0
 8008f6a:	1dfb      	adds	r3, r7, #7
 8008f6c:	701a      	strb	r2, [r3, #0]
    (void)region;
    
    return 5U;        
 8008f6e:	2305      	movs	r3, #5
}
 8008f70:	0018      	movs	r0, r3
 8008f72:	46bd      	mov	sp, r7
 8008f74:	b002      	add	sp, #8
 8008f76:	bd80      	pop	{r7, pc}

08008f78 <LDL_Region_getRX1Offset>:

uint8_t LDL_Region_getRX1Offset(enum ldl_region region)
{
 8008f78:	b580      	push	{r7, lr}
 8008f7a:	b082      	sub	sp, #8
 8008f7c:	af00      	add	r7, sp, #0
 8008f7e:	0002      	movs	r2, r0
 8008f80:	1dfb      	adds	r3, r7, #7
 8008f82:	701a      	strb	r2, [r3, #0]
    (void)region;
    
    return 0U;        
 8008f84:	2300      	movs	r3, #0
}
 8008f86:	0018      	movs	r0, r3
 8008f88:	46bd      	mov	sp, r7
 8008f8a:	b002      	add	sp, #8
 8008f8c:	bd80      	pop	{r7, pc}
	...

08008f90 <LDL_Region_getRX2Freq>:

uint32_t LDL_Region_getRX2Freq(enum ldl_region region)
{
 8008f90:	b580      	push	{r7, lr}
 8008f92:	b084      	sub	sp, #16
 8008f94:	af00      	add	r7, sp, #0
 8008f96:	0002      	movs	r2, r0
 8008f98:	1dfb      	adds	r3, r7, #7
 8008f9a:	701a      	strb	r2, [r3, #0]
    
    switch(region){
    default:
#ifdef LDL_ENABLE_EU_863_870    
    case LDL_EU_863_870:
        retval = 869525000UL;
 8008f9c:	4b03      	ldr	r3, [pc, #12]	; (8008fac <LDL_Region_getRX2Freq+0x1c>)
 8008f9e:	60fb      	str	r3, [r7, #12]
        break;    
 8008fa0:	46c0      	nop			; (mov r8, r8)
        retval = 923300000UL;
        break;        
#endif        
    }
    
    return retval; 
 8008fa2:	68fb      	ldr	r3, [r7, #12]
}
 8008fa4:	0018      	movs	r0, r3
 8008fa6:	46bd      	mov	sp, r7
 8008fa8:	b004      	add	sp, #16
 8008faa:	bd80      	pop	{r7, pc}
 8008fac:	33d3e608 	.word	0x33d3e608

08008fb0 <LDL_Region_getRX2Rate>:

uint8_t LDL_Region_getRX2Rate(enum ldl_region region)
{
 8008fb0:	b580      	push	{r7, lr}
 8008fb2:	b084      	sub	sp, #16
 8008fb4:	af00      	add	r7, sp, #0
 8008fb6:	0002      	movs	r2, r0
 8008fb8:	1dfb      	adds	r3, r7, #7
 8008fba:	701a      	strb	r2, [r3, #0]
    
    switch(region){
    default:
#ifdef LDL_ENABLE_EU_863_870
    case LDL_EU_863_870:
        retval = 0U;
 8008fbc:	210f      	movs	r1, #15
 8008fbe:	187b      	adds	r3, r7, r1
 8008fc0:	2200      	movs	r2, #0
 8008fc2:	701a      	strb	r2, [r3, #0]
        break;
 8008fc4:	46c0      	nop			; (mov r8, r8)
        retval = 8U;
        break;
#endif                
    }
    
    return retval; 
 8008fc6:	187b      	adds	r3, r7, r1
 8008fc8:	781b      	ldrb	r3, [r3, #0]
}
 8008fca:	0018      	movs	r0, r3
 8008fcc:	46bd      	mov	sp, r7
 8008fce:	b004      	add	sp, #16
 8008fd0:	bd80      	pop	{r7, pc}

08008fd2 <LDL_Region_validateTXPower>:

bool LDL_Region_validateTXPower(enum ldl_region region, uint8_t power)
{
 8008fd2:	b580      	push	{r7, lr}
 8008fd4:	b084      	sub	sp, #16
 8008fd6:	af00      	add	r7, sp, #0
 8008fd8:	0002      	movs	r2, r0
 8008fda:	1dfb      	adds	r3, r7, #7
 8008fdc:	701a      	strb	r2, [r3, #0]
 8008fde:	1dbb      	adds	r3, r7, #6
 8008fe0:	1c0a      	adds	r2, r1, #0
 8008fe2:	701a      	strb	r2, [r3, #0]
    bool retval = false;
 8008fe4:	230f      	movs	r3, #15
 8008fe6:	18fb      	adds	r3, r7, r3
 8008fe8:	2200      	movs	r2, #0
 8008fea:	701a      	strb	r2, [r3, #0]
    
    switch(region){ 
 8008fec:	1dfb      	adds	r3, r7, #7
 8008fee:	781b      	ldrb	r3, [r3, #0]
 8008ff0:	2b00      	cmp	r3, #0
 8008ff2:	d000      	beq.n	8008ff6 <LDL_Region_validateTXPower+0x24>
            retval = true;
        }
        break;
#endif    
    default:
        break;      
 8008ff4:	e008      	b.n	8009008 <LDL_Region_validateTXPower+0x36>
        if(power <= 7U){
 8008ff6:	1dbb      	adds	r3, r7, #6
 8008ff8:	781b      	ldrb	r3, [r3, #0]
 8008ffa:	2b07      	cmp	r3, #7
 8008ffc:	d803      	bhi.n	8009006 <LDL_Region_validateTXPower+0x34>
            retval = true;            
 8008ffe:	230f      	movs	r3, #15
 8009000:	18fb      	adds	r3, r7, r3
 8009002:	2201      	movs	r2, #1
 8009004:	701a      	strb	r2, [r3, #0]
        break;
 8009006:	46c0      	nop			; (mov r8, r8)
    }
    
    return retval;
 8009008:	230f      	movs	r3, #15
 800900a:	18fb      	adds	r3, r7, r3
 800900c:	781b      	ldrb	r3, [r3, #0]
}
 800900e:	0018      	movs	r0, r3
 8009010:	46bd      	mov	sp, r7
 8009012:	b004      	add	sp, #16
 8009014:	bd80      	pop	{r7, pc}

08009016 <LDL_Region_getTXPower>:

int16_t LDL_Region_getTXPower(enum ldl_region region, uint8_t power)
{
 8009016:	b580      	push	{r7, lr}
 8009018:	b084      	sub	sp, #16
 800901a:	af00      	add	r7, sp, #0
 800901c:	0002      	movs	r2, r0
 800901e:	1dfb      	adds	r3, r7, #7
 8009020:	701a      	strb	r2, [r3, #0]
 8009022:	1dbb      	adds	r3, r7, #6
 8009024:	1c0a      	adds	r2, r1, #0
 8009026:	701a      	strb	r2, [r3, #0]
    int16_t retval = 0;
 8009028:	230e      	movs	r3, #14
 800902a:	18fb      	adds	r3, r7, r3
 800902c:	2200      	movs	r2, #0
 800902e:	801a      	strh	r2, [r3, #0]
    
    switch(region){ 
 8009030:	1dfb      	adds	r3, r7, #7
 8009032:	781b      	ldrb	r3, [r3, #0]
 8009034:	2b00      	cmp	r3, #0
 8009036:	d000      	beq.n	800903a <LDL_Region_getTXPower+0x24>
            retval = 3000 - (10U * 200);
        }
        break;
#endif    
    default:
        break;      
 8009038:	e01d      	b.n	8009076 <LDL_Region_getTXPower+0x60>
        if(power <= 7U){
 800903a:	1dbb      	adds	r3, r7, #6
 800903c:	781b      	ldrb	r3, [r3, #0]
 800903e:	2b07      	cmp	r3, #7
 8009040:	d814      	bhi.n	800906c <LDL_Region_getTXPower+0x56>
            retval = 1600 - (power * 200);
 8009042:	1dbb      	adds	r3, r7, #6
 8009044:	781b      	ldrb	r3, [r3, #0]
 8009046:	b29b      	uxth	r3, r3
 8009048:	1c1a      	adds	r2, r3, #0
 800904a:	0212      	lsls	r2, r2, #8
 800904c:	1ad2      	subs	r2, r2, r3
 800904e:	0092      	lsls	r2, r2, #2
 8009050:	18d2      	adds	r2, r2, r3
 8009052:	00d2      	lsls	r2, r2, #3
 8009054:	1ad3      	subs	r3, r2, r3
 8009056:	00db      	lsls	r3, r3, #3
 8009058:	b29b      	uxth	r3, r3
 800905a:	22c8      	movs	r2, #200	; 0xc8
 800905c:	00d2      	lsls	r2, r2, #3
 800905e:	4694      	mov	ip, r2
 8009060:	4463      	add	r3, ip
 8009062:	b29a      	uxth	r2, r3
 8009064:	230e      	movs	r3, #14
 8009066:	18fb      	adds	r3, r7, r3
 8009068:	801a      	strh	r2, [r3, #0]
        break;
 800906a:	e003      	b.n	8009074 <LDL_Region_getTXPower+0x5e>
            retval = 1600 - (7U * 200);
 800906c:	230e      	movs	r3, #14
 800906e:	18fb      	adds	r3, r7, r3
 8009070:	22c8      	movs	r2, #200	; 0xc8
 8009072:	801a      	strh	r2, [r3, #0]
        break;
 8009074:	46c0      	nop			; (mov r8, r8)
    }
    
    return retval;
 8009076:	230e      	movs	r3, #14
 8009078:	18fb      	adds	r3, r7, r3
 800907a:	2200      	movs	r2, #0
 800907c:	5e9b      	ldrsh	r3, [r3, r2]
}
 800907e:	0018      	movs	r0, r3
 8009080:	46bd      	mov	sp, r7
 8009082:	b004      	add	sp, #16
 8009084:	bd80      	pop	{r7, pc}

08009086 <LDL_Region_getJoinRate>:

uint8_t LDL_Region_getJoinRate(enum ldl_region region, uint32_t trial)
{
 8009086:	b580      	push	{r7, lr}
 8009088:	b084      	sub	sp, #16
 800908a:	af00      	add	r7, sp, #0
 800908c:	0002      	movs	r2, r0
 800908e:	6039      	str	r1, [r7, #0]
 8009090:	1dfb      	adds	r3, r7, #7
 8009092:	701a      	strb	r2, [r3, #0]
    uint8_t retval = 0U;
 8009094:	230f      	movs	r3, #15
 8009096:	18fb      	adds	r3, r7, r3
 8009098:	2200      	movs	r2, #0
 800909a:	701a      	strb	r2, [r3, #0]
    
    switch(region){    
 800909c:	1dfb      	adds	r3, r7, #7
 800909e:	781b      	ldrb	r3, [r3, #0]
 80090a0:	2b00      	cmp	r3, #0
 80090a2:	d000      	beq.n	80090a6 <LDL_Region_getJoinRate+0x20>
            retval = 4U - ((trial >> 1U) % (5U - LDL_DEFAULT_RATE));
        }
        break;
#endif        
    default:
        break;
 80090a4:	e00c      	b.n	80090c0 <LDL_Region_getJoinRate+0x3a>
        retval = 5U - (trial % (6U - LDL_DEFAULT_RATE));
 80090a6:	683b      	ldr	r3, [r7, #0]
 80090a8:	2105      	movs	r1, #5
 80090aa:	0018      	movs	r0, r3
 80090ac:	f7f7 f8b2 	bl	8000214 <__aeabi_uidivmod>
 80090b0:	000b      	movs	r3, r1
 80090b2:	b2da      	uxtb	r2, r3
 80090b4:	230f      	movs	r3, #15
 80090b6:	18fb      	adds	r3, r7, r3
 80090b8:	2105      	movs	r1, #5
 80090ba:	1a8a      	subs	r2, r1, r2
 80090bc:	701a      	strb	r2, [r3, #0]
        break;
 80090be:	46c0      	nop			; (mov r8, r8)
    }
    
    return retval;
 80090c0:	230f      	movs	r3, #15
 80090c2:	18fb      	adds	r3, r7, r3
 80090c4:	781b      	ldrb	r3, [r3, #0]
}
 80090c6:	0018      	movs	r0, r3
 80090c8:	46bd      	mov	sp, r7
 80090ca:	b004      	add	sp, #16
 80090cc:	bd80      	pop	{r7, pc}
	...

080090d0 <LDL_Region_getMaxDCycleOffLimit>:

uint32_t LDL_Region_getMaxDCycleOffLimit(enum ldl_region region)
{
 80090d0:	b580      	push	{r7, lr}
 80090d2:	b082      	sub	sp, #8
 80090d4:	af00      	add	r7, sp, #0
 80090d6:	0002      	movs	r2, r0
 80090d8:	1dfb      	adds	r3, r7, #7
 80090da:	701a      	strb	r2, [r3, #0]
     * duty-cycle is evaluated over one hour therefore we can effectively
     * limit ourselves by never accumulating more than one hour of 
     * off-time.
     * 
     * */
    return (60UL*60UL*1000UL);
 80090dc:	4b02      	ldr	r3, [pc, #8]	; (80090e8 <LDL_Region_getMaxDCycleOffLimit+0x18>)
}
 80090de:	0018      	movs	r0, r3
 80090e0:	46bd      	mov	sp, r7
 80090e2:	b002      	add	sp, #8
 80090e4:	bd80      	pop	{r7, pc}
 80090e6:	46c0      	nop			; (mov r8, r8)
 80090e8:	0036ee80 	.word	0x0036ee80

080090ec <upRateRange>:

/* static functions ***************************************************/

static bool upRateRange(enum ldl_region region, uint8_t chIndex, uint8_t *minRate, uint8_t *maxRate)
{
 80090ec:	b590      	push	{r4, r7, lr}
 80090ee:	b087      	sub	sp, #28
 80090f0:	af00      	add	r7, sp, #0
 80090f2:	60ba      	str	r2, [r7, #8]
 80090f4:	607b      	str	r3, [r7, #4]
 80090f6:	240f      	movs	r4, #15
 80090f8:	193b      	adds	r3, r7, r4
 80090fa:	1c02      	adds	r2, r0, #0
 80090fc:	701a      	strb	r2, [r3, #0]
 80090fe:	230e      	movs	r3, #14
 8009100:	18fb      	adds	r3, r7, r3
 8009102:	1c0a      	adds	r2, r1, #0
 8009104:	701a      	strb	r2, [r3, #0]
    bool retval = false;
 8009106:	2317      	movs	r3, #23
 8009108:	18fb      	adds	r3, r7, r3
 800910a:	2200      	movs	r2, #0
 800910c:	701a      	strb	r2, [r3, #0]
    
    switch(region){    
 800910e:	193b      	adds	r3, r7, r4
 8009110:	781b      	ldrb	r3, [r3, #0]
 8009112:	2b00      	cmp	r3, #0
 8009114:	d10f      	bne.n	8009136 <upRateRange+0x4a>
#   endif    
#   ifdef LDL_ENABLE_EU_433    
    case LDL_EU_433:
#   endif       
    
        if(chIndex < 16U){
 8009116:	230e      	movs	r3, #14
 8009118:	18fb      	adds	r3, r7, r3
 800911a:	781b      	ldrb	r3, [r3, #0]
 800911c:	2b0f      	cmp	r3, #15
 800911e:	d811      	bhi.n	8009144 <upRateRange+0x58>
    
            *minRate = 0U;
 8009120:	68bb      	ldr	r3, [r7, #8]
 8009122:	2200      	movs	r2, #0
 8009124:	701a      	strb	r2, [r3, #0]
            *maxRate = 5U;
 8009126:	687b      	ldr	r3, [r7, #4]
 8009128:	2205      	movs	r2, #5
 800912a:	701a      	strb	r2, [r3, #0]
            retval = true;
 800912c:	2317      	movs	r3, #23
 800912e:	18fb      	adds	r3, r7, r3
 8009130:	2201      	movs	r2, #1
 8009132:	701a      	strb	r2, [r3, #0]
        }
        break;
 8009134:	e006      	b.n	8009144 <upRateRange+0x58>
            retval = true;
        }
        break;        
#endif    
    default:
        *minRate = 0U;
 8009136:	68bb      	ldr	r3, [r7, #8]
 8009138:	2200      	movs	r2, #0
 800913a:	701a      	strb	r2, [r3, #0]
        *maxRate = 0U;
 800913c:	687b      	ldr	r3, [r7, #4]
 800913e:	2200      	movs	r2, #0
 8009140:	701a      	strb	r2, [r3, #0]
        break;      
 8009142:	e000      	b.n	8009146 <upRateRange+0x5a>
        break;
 8009144:	46c0      	nop			; (mov r8, r8)
    }
    
    return retval;
 8009146:	2317      	movs	r3, #23
 8009148:	18fb      	adds	r3, r7, r3
 800914a:	781b      	ldrb	r3, [r3, #0]
}
 800914c:	0018      	movs	r0, r3
 800914e:	46bd      	mov	sp, r7
 8009150:	b007      	add	sp, #28
 8009152:	bd90      	pop	{r4, r7, pc}

08009154 <LDL_SM_init>:
static void *getKey(struct ldl_sm *self, enum ldl_sm_key desc);

/* functions **********************************************************/

void LDL_SM_init(struct ldl_sm *self, const void *appKey, const void *nwkKey)
{
 8009154:	b580      	push	{r7, lr}
 8009156:	b084      	sub	sp, #16
 8009158:	af00      	add	r7, sp, #0
 800915a:	60f8      	str	r0, [r7, #12]
 800915c:	60b9      	str	r1, [r7, #8]
 800915e:	607a      	str	r2, [r7, #4]
    (void)memcpy(self->keys[LDL_SM_KEY_APP].value, appKey, sizeof(self->keys[LDL_SM_KEY_APP].value)); 
 8009160:	68fb      	ldr	r3, [r7, #12]
 8009162:	3360      	adds	r3, #96	; 0x60
 8009164:	68b9      	ldr	r1, [r7, #8]
 8009166:	2210      	movs	r2, #16
 8009168:	0018      	movs	r0, r3
 800916a:	f003 fbad 	bl	800c8c8 <memcpy>
    (void)memcpy(self->keys[LDL_SM_KEY_NWK].value, nwkKey, sizeof(self->keys[LDL_SM_KEY_NWK].value)); 
 800916e:	68fb      	ldr	r3, [r7, #12]
 8009170:	3370      	adds	r3, #112	; 0x70
 8009172:	6879      	ldr	r1, [r7, #4]
 8009174:	2210      	movs	r2, #16
 8009176:	0018      	movs	r0, r3
 8009178:	f003 fba6 	bl	800c8c8 <memcpy>
}
 800917c:	46c0      	nop			; (mov r8, r8)
 800917e:	46bd      	mov	sp, r7
 8009180:	b004      	add	sp, #16
 8009182:	bd80      	pop	{r7, pc}

08009184 <LDL_SM_beginUpdateSessionKey>:
    (void)memcpy(keys, self->keys, sizeof(*keys));
}

/**! [LDL_SM_beginUpdateSessionKey] */
void LDL_SM_beginUpdateSessionKey(struct ldl_sm *self)
{
 8009184:	b580      	push	{r7, lr}
 8009186:	b082      	sub	sp, #8
 8009188:	af00      	add	r7, sp, #0
 800918a:	6078      	str	r0, [r7, #4]
    (void)self;
}
 800918c:	46c0      	nop			; (mov r8, r8)
 800918e:	46bd      	mov	sp, r7
 8009190:	b002      	add	sp, #8
 8009192:	bd80      	pop	{r7, pc}

08009194 <LDL_SM_endUpdateSessionKey>:
/**! [LDL_SM_beginUpdateSessionKey] */

/**! [LDL_SM_endUpdateSessionKey] */
void LDL_SM_endUpdateSessionKey(struct ldl_sm *self)
{
 8009194:	b580      	push	{r7, lr}
 8009196:	b082      	sub	sp, #8
 8009198:	af00      	add	r7, sp, #0
 800919a:	6078      	str	r0, [r7, #4]
    (void)self;
}
 800919c:	46c0      	nop			; (mov r8, r8)
 800919e:	46bd      	mov	sp, r7
 80091a0:	b002      	add	sp, #8
 80091a2:	bd80      	pop	{r7, pc}

080091a4 <LDL_SM_updateSessionKey>:
/**! [LDL_SM_endUpdateSessionKey] */

/**! [LDL_SM_updateSessionKey] */
void LDL_SM_updateSessionKey(struct ldl_sm *self, enum ldl_sm_key keyDesc, enum ldl_sm_key rootDesc, const void *iv)
{
 80091a4:	b5b0      	push	{r4, r5, r7, lr}
 80091a6:	b0c2      	sub	sp, #264	; 0x108
 80091a8:	af00      	add	r7, sp, #0
 80091aa:	60f8      	str	r0, [r7, #12]
 80091ac:	0008      	movs	r0, r1
 80091ae:	0011      	movs	r1, r2
 80091b0:	607b      	str	r3, [r7, #4]
 80091b2:	240b      	movs	r4, #11
 80091b4:	193b      	adds	r3, r7, r4
 80091b6:	1c02      	adds	r2, r0, #0
 80091b8:	701a      	strb	r2, [r3, #0]
 80091ba:	230a      	movs	r3, #10
 80091bc:	18fb      	adds	r3, r7, r3
 80091be:	1c0a      	adds	r2, r1, #0
 80091c0:	701a      	strb	r2, [r3, #0]
    struct ldl_aes_ctx ctx;
    
    switch(keyDesc){
 80091c2:	193b      	adds	r3, r7, r4
 80091c4:	781b      	ldrb	r3, [r3, #0]
 80091c6:	3300      	adds	r3, #0
 80091c8:	2b05      	cmp	r3, #5
 80091ca:	d829      	bhi.n	8009220 <LDL_SM_updateSessionKey+0x7c>
    case LDL_SM_KEY_SNWKSINT:
    case LDL_SM_KEY_NWKSENC: 
    case LDL_SM_KEY_JSINT:   
    case LDL_SM_KEY_JSENC:  
    
        LDL_AES_init(&ctx, getKey(self, rootDesc));    
 80091cc:	230a      	movs	r3, #10
 80091ce:	18fb      	adds	r3, r7, r3
 80091d0:	781a      	ldrb	r2, [r3, #0]
 80091d2:	68fb      	ldr	r3, [r7, #12]
 80091d4:	0011      	movs	r1, r2
 80091d6:	0018      	movs	r0, r3
 80091d8:	f000 f903 	bl	80093e2 <getKey>
 80091dc:	0002      	movs	r2, r0
 80091de:	2414      	movs	r4, #20
 80091e0:	193b      	adds	r3, r7, r4
 80091e2:	0011      	movs	r1, r2
 80091e4:	0018      	movs	r0, r3
 80091e6:	f7f8 f83d 	bl	8001264 <LDL_AES_init>
        
        (void)memcpy(getKey(self, keyDesc), iv, 16U);        
 80091ea:	250b      	movs	r5, #11
 80091ec:	197b      	adds	r3, r7, r5
 80091ee:	781a      	ldrb	r2, [r3, #0]
 80091f0:	68fb      	ldr	r3, [r7, #12]
 80091f2:	0011      	movs	r1, r2
 80091f4:	0018      	movs	r0, r3
 80091f6:	f000 f8f4 	bl	80093e2 <getKey>
 80091fa:	687b      	ldr	r3, [r7, #4]
 80091fc:	2210      	movs	r2, #16
 80091fe:	0019      	movs	r1, r3
 8009200:	f003 fb62 	bl	800c8c8 <memcpy>
        
        LDL_AES_encrypt(&ctx, getKey(self, keyDesc));
 8009204:	197b      	adds	r3, r7, r5
 8009206:	781a      	ldrb	r2, [r3, #0]
 8009208:	68fb      	ldr	r3, [r7, #12]
 800920a:	0011      	movs	r1, r2
 800920c:	0018      	movs	r0, r3
 800920e:	f000 f8e8 	bl	80093e2 <getKey>
 8009212:	0002      	movs	r2, r0
 8009214:	193b      	adds	r3, r7, r4
 8009216:	0011      	movs	r1, r2
 8009218:	0018      	movs	r0, r3
 800921a:	f7f8 f90b 	bl	8001434 <LDL_AES_encrypt>
        break;
 800921e:	e000      	b.n	8009222 <LDL_SM_updateSessionKey+0x7e>
    
    default:
        /* not a session key*/
        break;
 8009220:	46c0      	nop			; (mov r8, r8)
    }        
}
 8009222:	46c0      	nop			; (mov r8, r8)
 8009224:	46bd      	mov	sp, r7
 8009226:	b042      	add	sp, #264	; 0x108
 8009228:	bdb0      	pop	{r4, r5, r7, pc}
	...

0800922c <LDL_SM_mic>:
/**! [LDL_SM_updateSessionKey] */

/**! [LDL_SM_mic] */
uint32_t LDL_SM_mic(struct ldl_sm *self, enum ldl_sm_key desc, const void *hdr, uint8_t hdrLen, const void *data, uint8_t dataLen)
{
 800922c:	b5b0      	push	{r4, r5, r7, lr}
 800922e:	b0ce      	sub	sp, #312	; 0x138
 8009230:	af00      	add	r7, sp, #0
 8009232:	60f8      	str	r0, [r7, #12]
 8009234:	0008      	movs	r0, r1
 8009236:	607a      	str	r2, [r7, #4]
 8009238:	0019      	movs	r1, r3
 800923a:	4b43      	ldr	r3, [pc, #268]	; (8009348 <LDL_SM_mic+0x11c>)
 800923c:	229c      	movs	r2, #156	; 0x9c
 800923e:	0052      	lsls	r2, r2, #1
 8009240:	4694      	mov	ip, r2
 8009242:	44bc      	add	ip, r7
 8009244:	4463      	add	r3, ip
 8009246:	1c02      	adds	r2, r0, #0
 8009248:	701a      	strb	r2, [r3, #0]
 800924a:	4b40      	ldr	r3, [pc, #256]	; (800934c <LDL_SM_mic+0x120>)
 800924c:	229c      	movs	r2, #156	; 0x9c
 800924e:	0052      	lsls	r2, r2, #1
 8009250:	4694      	mov	ip, r2
 8009252:	44bc      	add	ip, r7
 8009254:	4463      	add	r3, ip
 8009256:	1c0a      	adds	r2, r1, #0
 8009258:	701a      	strb	r2, [r3, #0]
    uint32_t retval;
    uint8_t mic[sizeof(retval)];
    struct ldl_aes_ctx aes_ctx;
    struct ldl_cmac_ctx ctx;    
    
    LDL_AES_init(&aes_ctx, getKey(self, desc));
 800925a:	4b3b      	ldr	r3, [pc, #236]	; (8009348 <LDL_SM_mic+0x11c>)
 800925c:	229c      	movs	r2, #156	; 0x9c
 800925e:	0052      	lsls	r2, r2, #1
 8009260:	4694      	mov	ip, r2
 8009262:	44bc      	add	ip, r7
 8009264:	4463      	add	r3, ip
 8009266:	781a      	ldrb	r2, [r3, #0]
 8009268:	68fb      	ldr	r3, [r7, #12]
 800926a:	0011      	movs	r1, r2
 800926c:	0018      	movs	r0, r3
 800926e:	f000 f8b8 	bl	80093e2 <getKey>
 8009272:	0002      	movs	r2, r0
 8009274:	243c      	movs	r4, #60	; 0x3c
 8009276:	193b      	adds	r3, r7, r4
 8009278:	0011      	movs	r1, r2
 800927a:	0018      	movs	r0, r3
 800927c:	f7f7 fff2 	bl	8001264 <LDL_AES_init>
    LDL_CMAC_init(&ctx, &aes_ctx);
 8009280:	193a      	adds	r2, r7, r4
 8009282:	2414      	movs	r4, #20
 8009284:	193b      	adds	r3, r7, r4
 8009286:	0011      	movs	r1, r2
 8009288:	0018      	movs	r0, r3
 800928a:	f7f8 fba7 	bl	80019dc <LDL_CMAC_init>
    LDL_CMAC_update(&ctx, hdr, hdrLen);
 800928e:	4b2f      	ldr	r3, [pc, #188]	; (800934c <LDL_SM_mic+0x120>)
 8009290:	229c      	movs	r2, #156	; 0x9c
 8009292:	0052      	lsls	r2, r2, #1
 8009294:	4694      	mov	ip, r2
 8009296:	44bc      	add	ip, r7
 8009298:	4463      	add	r3, ip
 800929a:	781a      	ldrb	r2, [r3, #0]
 800929c:	6879      	ldr	r1, [r7, #4]
 800929e:	193b      	adds	r3, r7, r4
 80092a0:	0018      	movs	r0, r3
 80092a2:	f7f8 fbad 	bl	8001a00 <LDL_CMAC_update>
    LDL_CMAC_update(&ctx, data, dataLen);
 80092a6:	23a2      	movs	r3, #162	; 0xa2
 80092a8:	005b      	lsls	r3, r3, #1
 80092aa:	2208      	movs	r2, #8
 80092ac:	4694      	mov	ip, r2
 80092ae:	44bc      	add	ip, r7
 80092b0:	4463      	add	r3, ip
 80092b2:	781a      	ldrb	r2, [r3, #0]
 80092b4:	23a0      	movs	r3, #160	; 0xa0
 80092b6:	005b      	lsls	r3, r3, #1
 80092b8:	2108      	movs	r1, #8
 80092ba:	468c      	mov	ip, r1
 80092bc:	44bc      	add	ip, r7
 80092be:	4463      	add	r3, ip
 80092c0:	6819      	ldr	r1, [r3, #0]
 80092c2:	0025      	movs	r5, r4
 80092c4:	193b      	adds	r3, r7, r4
 80092c6:	0018      	movs	r0, r3
 80092c8:	f7f8 fb9a 	bl	8001a00 <LDL_CMAC_update>
    LDL_CMAC_finish(&ctx, &mic, sizeof(mic));
 80092cc:	2098      	movs	r0, #152	; 0x98
 80092ce:	0040      	lsls	r0, r0, #1
 80092d0:	0004      	movs	r4, r0
 80092d2:	1839      	adds	r1, r7, r0
 80092d4:	197b      	adds	r3, r7, r5
 80092d6:	2204      	movs	r2, #4
 80092d8:	0018      	movs	r0, r3
 80092da:	f7f8 fc58 	bl	8001b8e <LDL_CMAC_finish>
  
    /* intepret the 4th byte as most significant */
    retval = mic[3];
 80092de:	0020      	movs	r0, r4
 80092e0:	183b      	adds	r3, r7, r0
 80092e2:	78db      	ldrb	r3, [r3, #3]
 80092e4:	219a      	movs	r1, #154	; 0x9a
 80092e6:	0049      	lsls	r1, r1, #1
 80092e8:	187a      	adds	r2, r7, r1
 80092ea:	6013      	str	r3, [r2, #0]
    retval <<= 8;
 80092ec:	187b      	adds	r3, r7, r1
 80092ee:	681b      	ldr	r3, [r3, #0]
 80092f0:	021b      	lsls	r3, r3, #8
 80092f2:	187a      	adds	r2, r7, r1
 80092f4:	6013      	str	r3, [r2, #0]
    retval |= mic[2];
 80092f6:	183b      	adds	r3, r7, r0
 80092f8:	789b      	ldrb	r3, [r3, #2]
 80092fa:	001a      	movs	r2, r3
 80092fc:	187b      	adds	r3, r7, r1
 80092fe:	681b      	ldr	r3, [r3, #0]
 8009300:	4313      	orrs	r3, r2
 8009302:	187a      	adds	r2, r7, r1
 8009304:	6013      	str	r3, [r2, #0]
    retval <<= 8;
 8009306:	187b      	adds	r3, r7, r1
 8009308:	681b      	ldr	r3, [r3, #0]
 800930a:	021b      	lsls	r3, r3, #8
 800930c:	187a      	adds	r2, r7, r1
 800930e:	6013      	str	r3, [r2, #0]
    retval |= mic[1];
 8009310:	183b      	adds	r3, r7, r0
 8009312:	785b      	ldrb	r3, [r3, #1]
 8009314:	001a      	movs	r2, r3
 8009316:	187b      	adds	r3, r7, r1
 8009318:	681b      	ldr	r3, [r3, #0]
 800931a:	4313      	orrs	r3, r2
 800931c:	187a      	adds	r2, r7, r1
 800931e:	6013      	str	r3, [r2, #0]
    retval <<= 8;
 8009320:	187b      	adds	r3, r7, r1
 8009322:	681b      	ldr	r3, [r3, #0]
 8009324:	021b      	lsls	r3, r3, #8
 8009326:	187a      	adds	r2, r7, r1
 8009328:	6013      	str	r3, [r2, #0]
    retval |= mic[0];
 800932a:	183b      	adds	r3, r7, r0
 800932c:	781b      	ldrb	r3, [r3, #0]
 800932e:	001a      	movs	r2, r3
 8009330:	187b      	adds	r3, r7, r1
 8009332:	681b      	ldr	r3, [r3, #0]
 8009334:	4313      	orrs	r3, r2
 8009336:	187a      	adds	r2, r7, r1
 8009338:	6013      	str	r3, [r2, #0]

    /* LoRaWAN will encode this least significant byte first */
    return retval;
 800933a:	187b      	adds	r3, r7, r1
 800933c:	681b      	ldr	r3, [r3, #0]
}
 800933e:	0018      	movs	r0, r3
 8009340:	46bd      	mov	sp, r7
 8009342:	b04e      	add	sp, #312	; 0x138
 8009344:	bdb0      	pop	{r4, r5, r7, pc}
 8009346:	46c0      	nop			; (mov r8, r8)
 8009348:	fffffed3 	.word	0xfffffed3
 800934c:	fffffed2 	.word	0xfffffed2

08009350 <LDL_SM_ecb>:
/**! [LDL_SM_mic] */

/**! [LDL_SM_ecb] */
void LDL_SM_ecb(struct ldl_sm *self, enum ldl_sm_key desc, void *b)
{
 8009350:	b590      	push	{r4, r7, lr}
 8009352:	b0c3      	sub	sp, #268	; 0x10c
 8009354:	af00      	add	r7, sp, #0
 8009356:	60f8      	str	r0, [r7, #12]
 8009358:	607a      	str	r2, [r7, #4]
 800935a:	200b      	movs	r0, #11
 800935c:	183b      	adds	r3, r7, r0
 800935e:	1c0a      	adds	r2, r1, #0
 8009360:	701a      	strb	r2, [r3, #0]
    struct ldl_aes_ctx ctx;
    
    LDL_AES_init(&ctx, getKey(self, desc));
 8009362:	183b      	adds	r3, r7, r0
 8009364:	781a      	ldrb	r2, [r3, #0]
 8009366:	68fb      	ldr	r3, [r7, #12]
 8009368:	0011      	movs	r1, r2
 800936a:	0018      	movs	r0, r3
 800936c:	f000 f839 	bl	80093e2 <getKey>
 8009370:	0002      	movs	r2, r0
 8009372:	2414      	movs	r4, #20
 8009374:	193b      	adds	r3, r7, r4
 8009376:	0011      	movs	r1, r2
 8009378:	0018      	movs	r0, r3
 800937a:	f7f7 ff73 	bl	8001264 <LDL_AES_init>
    LDL_AES_encrypt(&ctx, b);
 800937e:	687a      	ldr	r2, [r7, #4]
 8009380:	193b      	adds	r3, r7, r4
 8009382:	0011      	movs	r1, r2
 8009384:	0018      	movs	r0, r3
 8009386:	f7f8 f855 	bl	8001434 <LDL_AES_encrypt>
}
 800938a:	46c0      	nop			; (mov r8, r8)
 800938c:	46bd      	mov	sp, r7
 800938e:	b043      	add	sp, #268	; 0x10c
 8009390:	bd90      	pop	{r4, r7, pc}

08009392 <LDL_SM_ctr>:
/**! [LDL_SM_ecb] */

/**! [LDL_SM_ctr] */
void LDL_SM_ctr(struct ldl_sm *self, enum ldl_sm_key desc, const void *iv, void *data, uint8_t len)
{
 8009392:	b5b0      	push	{r4, r5, r7, lr}
 8009394:	b0c4      	sub	sp, #272	; 0x110
 8009396:	af02      	add	r7, sp, #8
 8009398:	60f8      	str	r0, [r7, #12]
 800939a:	607a      	str	r2, [r7, #4]
 800939c:	603b      	str	r3, [r7, #0]
 800939e:	200b      	movs	r0, #11
 80093a0:	183b      	adds	r3, r7, r0
 80093a2:	1c0a      	adds	r2, r1, #0
 80093a4:	701a      	strb	r2, [r3, #0]
    struct ldl_aes_ctx ctx;

    LDL_AES_init(&ctx, getKey(self, desc));
 80093a6:	183b      	adds	r3, r7, r0
 80093a8:	781a      	ldrb	r2, [r3, #0]
 80093aa:	68fb      	ldr	r3, [r7, #12]
 80093ac:	0011      	movs	r1, r2
 80093ae:	0018      	movs	r0, r3
 80093b0:	f000 f817 	bl	80093e2 <getKey>
 80093b4:	0002      	movs	r2, r0
 80093b6:	2514      	movs	r5, #20
 80093b8:	197b      	adds	r3, r7, r5
 80093ba:	0011      	movs	r1, r2
 80093bc:	0018      	movs	r0, r3
 80093be:	f7f7 ff51 	bl	8001264 <LDL_AES_init>
    LDL_CTR_encrypt(&ctx, iv, data, data, len);
 80093c2:	683c      	ldr	r4, [r7, #0]
 80093c4:	683a      	ldr	r2, [r7, #0]
 80093c6:	6879      	ldr	r1, [r7, #4]
 80093c8:	1978      	adds	r0, r7, r5
 80093ca:	238c      	movs	r3, #140	; 0x8c
 80093cc:	005b      	lsls	r3, r3, #1
 80093ce:	18fb      	adds	r3, r7, r3
 80093d0:	781b      	ldrb	r3, [r3, #0]
 80093d2:	9300      	str	r3, [sp, #0]
 80093d4:	0023      	movs	r3, r4
 80093d6:	f7f8 fd81 	bl	8001edc <LDL_CTR_encrypt>
}
 80093da:	46c0      	nop			; (mov r8, r8)
 80093dc:	46bd      	mov	sp, r7
 80093de:	b042      	add	sp, #264	; 0x108
 80093e0:	bdb0      	pop	{r4, r5, r7, pc}

080093e2 <getKey>:
/**! [LDL_SM_ctr] */

/* static functions ***************************************************/

static void *getKey(struct ldl_sm *self, enum ldl_sm_key desc)
{
 80093e2:	b580      	push	{r7, lr}
 80093e4:	b082      	sub	sp, #8
 80093e6:	af00      	add	r7, sp, #0
 80093e8:	6078      	str	r0, [r7, #4]
 80093ea:	000a      	movs	r2, r1
 80093ec:	1cfb      	adds	r3, r7, #3
 80093ee:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(desc < sizeof(self->keys)/sizeof(*self->keys))
    
    return self->keys[desc].value;
 80093f0:	1cfb      	adds	r3, r7, #3
 80093f2:	781b      	ldrb	r3, [r3, #0]
 80093f4:	011b      	lsls	r3, r3, #4
 80093f6:	687a      	ldr	r2, [r7, #4]
 80093f8:	18d3      	adds	r3, r2, r3
}
 80093fa:	0018      	movs	r0, r3
 80093fc:	46bd      	mov	sp, r7
 80093fe:	b002      	add	sp, #8
 8009400:	bd80      	pop	{r7, pc}

08009402 <LDL_Stream_init>:
#include "ldl_debug.h"

#include <string.h>

void LDL_Stream_init(struct ldl_stream *self, void *buf, uint8_t size)
{
 8009402:	b580      	push	{r7, lr}
 8009404:	b084      	sub	sp, #16
 8009406:	af00      	add	r7, sp, #0
 8009408:	60f8      	str	r0, [r7, #12]
 800940a:	60b9      	str	r1, [r7, #8]
 800940c:	1dfb      	adds	r3, r7, #7
 800940e:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(self != NULL)
    LDL_PEDANTIC((buf != NULL) || (size == 0U))
    
    self->write = buf;
 8009410:	68fb      	ldr	r3, [r7, #12]
 8009412:	68ba      	ldr	r2, [r7, #8]
 8009414:	601a      	str	r2, [r3, #0]
    self->read = buf;
 8009416:	68fb      	ldr	r3, [r7, #12]
 8009418:	68ba      	ldr	r2, [r7, #8]
 800941a:	605a      	str	r2, [r3, #4]
    self->size = size;
 800941c:	68fb      	ldr	r3, [r7, #12]
 800941e:	1dfa      	adds	r2, r7, #7
 8009420:	7812      	ldrb	r2, [r2, #0]
 8009422:	721a      	strb	r2, [r3, #8]
    self->pos = 0U;
 8009424:	68fb      	ldr	r3, [r7, #12]
 8009426:	2200      	movs	r2, #0
 8009428:	725a      	strb	r2, [r3, #9]
    self->error = false;
 800942a:	68fb      	ldr	r3, [r7, #12]
 800942c:	2200      	movs	r2, #0
 800942e:	729a      	strb	r2, [r3, #10]
}
 8009430:	46c0      	nop			; (mov r8, r8)
 8009432:	46bd      	mov	sp, r7
 8009434:	b004      	add	sp, #16
 8009436:	bd80      	pop	{r7, pc}

08009438 <LDL_Stream_initReadOnly>:

void LDL_Stream_initReadOnly(struct ldl_stream *self, const void *buf, uint8_t size)
{
 8009438:	b580      	push	{r7, lr}
 800943a:	b084      	sub	sp, #16
 800943c:	af00      	add	r7, sp, #0
 800943e:	60f8      	str	r0, [r7, #12]
 8009440:	60b9      	str	r1, [r7, #8]
 8009442:	1dfb      	adds	r3, r7, #7
 8009444:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(self != NULL)
    LDL_PEDANTIC((buf != NULL) || (size == 0U))
    
    self->write = NULL;
 8009446:	68fb      	ldr	r3, [r7, #12]
 8009448:	2200      	movs	r2, #0
 800944a:	601a      	str	r2, [r3, #0]
    self->read = buf;
 800944c:	68fb      	ldr	r3, [r7, #12]
 800944e:	68ba      	ldr	r2, [r7, #8]
 8009450:	605a      	str	r2, [r3, #4]
    self->size = size;
 8009452:	68fb      	ldr	r3, [r7, #12]
 8009454:	1dfa      	adds	r2, r7, #7
 8009456:	7812      	ldrb	r2, [r2, #0]
 8009458:	721a      	strb	r2, [r3, #8]
    self->pos = 0U;
 800945a:	68fb      	ldr	r3, [r7, #12]
 800945c:	2200      	movs	r2, #0
 800945e:	725a      	strb	r2, [r3, #9]
    self->error = false;
 8009460:	68fb      	ldr	r3, [r7, #12]
 8009462:	2200      	movs	r2, #0
 8009464:	729a      	strb	r2, [r3, #10]
}
 8009466:	46c0      	nop			; (mov r8, r8)
 8009468:	46bd      	mov	sp, r7
 800946a:	b004      	add	sp, #16
 800946c:	bd80      	pop	{r7, pc}

0800946e <LDL_Stream_read>:

bool LDL_Stream_read(struct ldl_stream *self, void *buf, uint8_t count)
{
 800946e:	b580      	push	{r7, lr}
 8009470:	b086      	sub	sp, #24
 8009472:	af00      	add	r7, sp, #0
 8009474:	60f8      	str	r0, [r7, #12]
 8009476:	60b9      	str	r1, [r7, #8]
 8009478:	1dfb      	adds	r3, r7, #7
 800947a:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(self != NULL)
    LDL_PEDANTIC(buf != NULL)
    
    bool retval = false;
 800947c:	2317      	movs	r3, #23
 800947e:	18fb      	adds	r3, r7, r3
 8009480:	2200      	movs	r2, #0
 8009482:	701a      	strb	r2, [r3, #0]
    
    if(!self->error){
 8009484:	68fb      	ldr	r3, [r7, #12]
 8009486:	7a9b      	ldrb	r3, [r3, #10]
 8009488:	2201      	movs	r2, #1
 800948a:	4053      	eors	r3, r2
 800948c:	b2db      	uxtb	r3, r3
 800948e:	2b00      	cmp	r3, #0
 8009490:	d024      	beq.n	80094dc <LDL_Stream_read+0x6e>
    
        if((self->size - self->pos) >= count){
 8009492:	68fb      	ldr	r3, [r7, #12]
 8009494:	7a1b      	ldrb	r3, [r3, #8]
 8009496:	001a      	movs	r2, r3
 8009498:	68fb      	ldr	r3, [r7, #12]
 800949a:	7a5b      	ldrb	r3, [r3, #9]
 800949c:	1ad2      	subs	r2, r2, r3
 800949e:	1dfb      	adds	r3, r7, #7
 80094a0:	781b      	ldrb	r3, [r3, #0]
 80094a2:	429a      	cmp	r2, r3
 80094a4:	db17      	blt.n	80094d6 <LDL_Stream_read+0x68>

            (void)memcpy(buf, &self->read[self->pos], count);
 80094a6:	68fb      	ldr	r3, [r7, #12]
 80094a8:	685b      	ldr	r3, [r3, #4]
 80094aa:	68fa      	ldr	r2, [r7, #12]
 80094ac:	7a52      	ldrb	r2, [r2, #9]
 80094ae:	1899      	adds	r1, r3, r2
 80094b0:	1dfb      	adds	r3, r7, #7
 80094b2:	781a      	ldrb	r2, [r3, #0]
 80094b4:	68bb      	ldr	r3, [r7, #8]
 80094b6:	0018      	movs	r0, r3
 80094b8:	f003 fa06 	bl	800c8c8 <memcpy>
            self->pos += count;
 80094bc:	68fb      	ldr	r3, [r7, #12]
 80094be:	7a5a      	ldrb	r2, [r3, #9]
 80094c0:	1dfb      	adds	r3, r7, #7
 80094c2:	781b      	ldrb	r3, [r3, #0]
 80094c4:	18d3      	adds	r3, r2, r3
 80094c6:	b2da      	uxtb	r2, r3
 80094c8:	68fb      	ldr	r3, [r7, #12]
 80094ca:	725a      	strb	r2, [r3, #9]
            retval = true;
 80094cc:	2317      	movs	r3, #23
 80094ce:	18fb      	adds	r3, r7, r3
 80094d0:	2201      	movs	r2, #1
 80094d2:	701a      	strb	r2, [r3, #0]
 80094d4:	e002      	b.n	80094dc <LDL_Stream_read+0x6e>
        }    
        else{
            
            self->error = true;
 80094d6:	68fb      	ldr	r3, [r7, #12]
 80094d8:	2201      	movs	r2, #1
 80094da:	729a      	strb	r2, [r3, #10]
        }
    }
    
    return retval;
 80094dc:	2317      	movs	r3, #23
 80094de:	18fb      	adds	r3, r7, r3
 80094e0:	781b      	ldrb	r3, [r3, #0]
}
 80094e2:	0018      	movs	r0, r3
 80094e4:	46bd      	mov	sp, r7
 80094e6:	b006      	add	sp, #24
 80094e8:	bd80      	pop	{r7, pc}

080094ea <LDL_Stream_write>:

bool LDL_Stream_write(struct ldl_stream *self, const void *buf, uint8_t count)
{
 80094ea:	b580      	push	{r7, lr}
 80094ec:	b086      	sub	sp, #24
 80094ee:	af00      	add	r7, sp, #0
 80094f0:	60f8      	str	r0, [r7, #12]
 80094f2:	60b9      	str	r1, [r7, #8]
 80094f4:	1dfb      	adds	r3, r7, #7
 80094f6:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(self != NULL)
    
    bool retval = false;
 80094f8:	2317      	movs	r3, #23
 80094fa:	18fb      	adds	r3, r7, r3
 80094fc:	2200      	movs	r2, #0
 80094fe:	701a      	strb	r2, [r3, #0]
    
    if(self->write != NULL){
 8009500:	68fb      	ldr	r3, [r7, #12]
 8009502:	681b      	ldr	r3, [r3, #0]
 8009504:	2b00      	cmp	r3, #0
 8009506:	d02b      	beq.n	8009560 <LDL_Stream_write+0x76>
        
        if(!self->error){
 8009508:	68fb      	ldr	r3, [r7, #12]
 800950a:	7a9b      	ldrb	r3, [r3, #10]
 800950c:	2201      	movs	r2, #1
 800950e:	4053      	eors	r3, r2
 8009510:	b2db      	uxtb	r3, r3
 8009512:	2b00      	cmp	r3, #0
 8009514:	d024      	beq.n	8009560 <LDL_Stream_write+0x76>
        
            if((self->size - self->pos) >= count){
 8009516:	68fb      	ldr	r3, [r7, #12]
 8009518:	7a1b      	ldrb	r3, [r3, #8]
 800951a:	001a      	movs	r2, r3
 800951c:	68fb      	ldr	r3, [r7, #12]
 800951e:	7a5b      	ldrb	r3, [r3, #9]
 8009520:	1ad2      	subs	r2, r2, r3
 8009522:	1dfb      	adds	r3, r7, #7
 8009524:	781b      	ldrb	r3, [r3, #0]
 8009526:	429a      	cmp	r2, r3
 8009528:	db17      	blt.n	800955a <LDL_Stream_write+0x70>
                
                (void)memcpy(&self->write[self->pos], buf, count);
 800952a:	68fb      	ldr	r3, [r7, #12]
 800952c:	681b      	ldr	r3, [r3, #0]
 800952e:	68fa      	ldr	r2, [r7, #12]
 8009530:	7a52      	ldrb	r2, [r2, #9]
 8009532:	1898      	adds	r0, r3, r2
 8009534:	1dfb      	adds	r3, r7, #7
 8009536:	781a      	ldrb	r2, [r3, #0]
 8009538:	68bb      	ldr	r3, [r7, #8]
 800953a:	0019      	movs	r1, r3
 800953c:	f003 f9c4 	bl	800c8c8 <memcpy>
                self->pos += count;
 8009540:	68fb      	ldr	r3, [r7, #12]
 8009542:	7a5a      	ldrb	r2, [r3, #9]
 8009544:	1dfb      	adds	r3, r7, #7
 8009546:	781b      	ldrb	r3, [r3, #0]
 8009548:	18d3      	adds	r3, r2, r3
 800954a:	b2da      	uxtb	r2, r3
 800954c:	68fb      	ldr	r3, [r7, #12]
 800954e:	725a      	strb	r2, [r3, #9]
                retval = true;
 8009550:	2317      	movs	r3, #23
 8009552:	18fb      	adds	r3, r7, r3
 8009554:	2201      	movs	r2, #1
 8009556:	701a      	strb	r2, [r3, #0]
 8009558:	e002      	b.n	8009560 <LDL_Stream_write+0x76>
            }
            else{
                
                self->error = true;
 800955a:	68fb      	ldr	r3, [r7, #12]
 800955c:	2201      	movs	r2, #1
 800955e:	729a      	strb	r2, [r3, #10]
            }
        }
    }
    
    return retval;
 8009560:	2317      	movs	r3, #23
 8009562:	18fb      	adds	r3, r7, r3
 8009564:	781b      	ldrb	r3, [r3, #0]
}
 8009566:	0018      	movs	r0, r3
 8009568:	46bd      	mov	sp, r7
 800956a:	b006      	add	sp, #24
 800956c:	bd80      	pop	{r7, pc}

0800956e <LDL_Stream_tell>:

uint8_t LDL_Stream_tell(const struct ldl_stream *self)
{
 800956e:	b580      	push	{r7, lr}
 8009570:	b082      	sub	sp, #8
 8009572:	af00      	add	r7, sp, #0
 8009574:	6078      	str	r0, [r7, #4]
    LDL_PEDANTIC(self != NULL)
    
    return self->pos;
 8009576:	687b      	ldr	r3, [r7, #4]
 8009578:	7a5b      	ldrb	r3, [r3, #9]
}
 800957a:	0018      	movs	r0, r3
 800957c:	46bd      	mov	sp, r7
 800957e:	b002      	add	sp, #8
 8009580:	bd80      	pop	{r7, pc}

08009582 <LDL_Stream_remaining>:

uint8_t LDL_Stream_remaining(const struct ldl_stream *self)
{
 8009582:	b580      	push	{r7, lr}
 8009584:	b082      	sub	sp, #8
 8009586:	af00      	add	r7, sp, #0
 8009588:	6078      	str	r0, [r7, #4]
    LDL_PEDANTIC(self != NULL)
    
    return (self->size - self->pos);
 800958a:	687b      	ldr	r3, [r7, #4]
 800958c:	7a1a      	ldrb	r2, [r3, #8]
 800958e:	687b      	ldr	r3, [r7, #4]
 8009590:	7a5b      	ldrb	r3, [r3, #9]
 8009592:	1ad3      	subs	r3, r2, r3
 8009594:	b2db      	uxtb	r3, r3
}
 8009596:	0018      	movs	r0, r3
 8009598:	46bd      	mov	sp, r7
 800959a:	b002      	add	sp, #8
 800959c:	bd80      	pop	{r7, pc}

0800959e <LDL_Stream_peek>:

bool LDL_Stream_peek(const struct ldl_stream *self, void *out)
{
 800959e:	b580      	push	{r7, lr}
 80095a0:	b084      	sub	sp, #16
 80095a2:	af00      	add	r7, sp, #0
 80095a4:	6078      	str	r0, [r7, #4]
 80095a6:	6039      	str	r1, [r7, #0]
    LDL_PEDANTIC(self != NULL)
    
    bool retval = false;
 80095a8:	230f      	movs	r3, #15
 80095aa:	18fb      	adds	r3, r7, r3
 80095ac:	2200      	movs	r2, #0
 80095ae:	701a      	strb	r2, [r3, #0]
    
    if(LDL_Stream_remaining(self) > 0U){
 80095b0:	687b      	ldr	r3, [r7, #4]
 80095b2:	0018      	movs	r0, r3
 80095b4:	f7ff ffe5 	bl	8009582 <LDL_Stream_remaining>
 80095b8:	1e03      	subs	r3, r0, #0
 80095ba:	d00b      	beq.n	80095d4 <LDL_Stream_peek+0x36>
        
        (void)memcpy(out, &self->read[self->pos], 1U);
 80095bc:	687b      	ldr	r3, [r7, #4]
 80095be:	685b      	ldr	r3, [r3, #4]
 80095c0:	687a      	ldr	r2, [r7, #4]
 80095c2:	7a52      	ldrb	r2, [r2, #9]
 80095c4:	189b      	adds	r3, r3, r2
 80095c6:	781a      	ldrb	r2, [r3, #0]
 80095c8:	683b      	ldr	r3, [r7, #0]
 80095ca:	701a      	strb	r2, [r3, #0]
        retval = true;
 80095cc:	230f      	movs	r3, #15
 80095ce:	18fb      	adds	r3, r7, r3
 80095d0:	2201      	movs	r2, #1
 80095d2:	701a      	strb	r2, [r3, #0]
    }
    
    return retval;
 80095d4:	230f      	movs	r3, #15
 80095d6:	18fb      	adds	r3, r7, r3
 80095d8:	781b      	ldrb	r3, [r3, #0]
}
 80095da:	0018      	movs	r0, r3
 80095dc:	46bd      	mov	sp, r7
 80095de:	b004      	add	sp, #16
 80095e0:	bd80      	pop	{r7, pc}

080095e2 <LDL_Stream_seekSet>:

bool LDL_Stream_seekSet(struct ldl_stream *self, uint8_t offset)
{
 80095e2:	b580      	push	{r7, lr}
 80095e4:	b084      	sub	sp, #16
 80095e6:	af00      	add	r7, sp, #0
 80095e8:	6078      	str	r0, [r7, #4]
 80095ea:	000a      	movs	r2, r1
 80095ec:	1cfb      	adds	r3, r7, #3
 80095ee:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(self != NULL)
    
    bool retval = false;
 80095f0:	230f      	movs	r3, #15
 80095f2:	18fb      	adds	r3, r7, r3
 80095f4:	2200      	movs	r2, #0
 80095f6:	701a      	strb	r2, [r3, #0]

    if(self->size >= offset){
 80095f8:	687b      	ldr	r3, [r7, #4]
 80095fa:	7a1b      	ldrb	r3, [r3, #8]
 80095fc:	1cfa      	adds	r2, r7, #3
 80095fe:	7812      	ldrb	r2, [r2, #0]
 8009600:	429a      	cmp	r2, r3
 8009602:	d807      	bhi.n	8009614 <LDL_Stream_seekSet+0x32>

        self->pos = offset;        
 8009604:	687b      	ldr	r3, [r7, #4]
 8009606:	1cfa      	adds	r2, r7, #3
 8009608:	7812      	ldrb	r2, [r2, #0]
 800960a:	725a      	strb	r2, [r3, #9]
        retval = true;
 800960c:	230f      	movs	r3, #15
 800960e:	18fb      	adds	r3, r7, r3
 8009610:	2201      	movs	r2, #1
 8009612:	701a      	strb	r2, [r3, #0]
    }    

    return retval;
 8009614:	230f      	movs	r3, #15
 8009616:	18fb      	adds	r3, r7, r3
 8009618:	781b      	ldrb	r3, [r3, #0]
}
 800961a:	0018      	movs	r0, r3
 800961c:	46bd      	mov	sp, r7
 800961e:	b004      	add	sp, #16
 8009620:	bd80      	pop	{r7, pc}

08009622 <LDL_Stream_seekCur>:

bool LDL_Stream_seekCur(struct ldl_stream *self, int16_t offset)
{
 8009622:	b580      	push	{r7, lr}
 8009624:	b086      	sub	sp, #24
 8009626:	af00      	add	r7, sp, #0
 8009628:	6078      	str	r0, [r7, #4]
 800962a:	000a      	movs	r2, r1
 800962c:	1cbb      	adds	r3, r7, #2
 800962e:	801a      	strh	r2, [r3, #0]
    LDL_PEDANTIC(self != NULL)
    
    bool retval = false;
 8009630:	2317      	movs	r3, #23
 8009632:	18fb      	adds	r3, r7, r3
 8009634:	2200      	movs	r2, #0
 8009636:	701a      	strb	r2, [r3, #0]
    
    int32_t pos = ((int32_t)self->pos) + ((int32_t)offset);
 8009638:	687b      	ldr	r3, [r7, #4]
 800963a:	7a5b      	ldrb	r3, [r3, #9]
 800963c:	001a      	movs	r2, r3
 800963e:	1cbb      	adds	r3, r7, #2
 8009640:	2100      	movs	r1, #0
 8009642:	5e5b      	ldrsh	r3, [r3, r1]
 8009644:	18d3      	adds	r3, r2, r3
 8009646:	613b      	str	r3, [r7, #16]
    int32_t size = (int32_t)self->size;
 8009648:	687b      	ldr	r3, [r7, #4]
 800964a:	7a1b      	ldrb	r3, [r3, #8]
 800964c:	60fb      	str	r3, [r7, #12]

    if((pos >= 0) && (pos <= size)){
 800964e:	693b      	ldr	r3, [r7, #16]
 8009650:	2b00      	cmp	r3, #0
 8009652:	db1f      	blt.n	8009694 <LDL_Stream_seekCur+0x72>
 8009654:	693a      	ldr	r2, [r7, #16]
 8009656:	68fb      	ldr	r3, [r7, #12]
 8009658:	429a      	cmp	r2, r3
 800965a:	dc1b      	bgt.n	8009694 <LDL_Stream_seekCur+0x72>

        if(offset >= 0){
 800965c:	1cbb      	adds	r3, r7, #2
 800965e:	2200      	movs	r2, #0
 8009660:	5e9b      	ldrsh	r3, [r3, r2]
 8009662:	2b00      	cmp	r3, #0
 8009664:	db09      	blt.n	800967a <LDL_Stream_seekCur+0x58>
            
            self->pos += (uint8_t)offset;   
 8009666:	687b      	ldr	r3, [r7, #4]
 8009668:	7a5a      	ldrb	r2, [r3, #9]
 800966a:	1cbb      	adds	r3, r7, #2
 800966c:	881b      	ldrh	r3, [r3, #0]
 800966e:	b2db      	uxtb	r3, r3
 8009670:	18d3      	adds	r3, r2, r3
 8009672:	b2da      	uxtb	r2, r3
 8009674:	687b      	ldr	r3, [r7, #4]
 8009676:	725a      	strb	r2, [r3, #9]
 8009678:	e008      	b.n	800968c <LDL_Stream_seekCur+0x6a>
        }
        else{
            
            self->pos -= (uint8_t)offset; 
 800967a:	687b      	ldr	r3, [r7, #4]
 800967c:	7a5a      	ldrb	r2, [r3, #9]
 800967e:	1cbb      	adds	r3, r7, #2
 8009680:	881b      	ldrh	r3, [r3, #0]
 8009682:	b2db      	uxtb	r3, r3
 8009684:	1ad3      	subs	r3, r2, r3
 8009686:	b2da      	uxtb	r2, r3
 8009688:	687b      	ldr	r3, [r7, #4]
 800968a:	725a      	strb	r2, [r3, #9]
        }

        retval = true;
 800968c:	2317      	movs	r3, #23
 800968e:	18fb      	adds	r3, r7, r3
 8009690:	2201      	movs	r2, #1
 8009692:	701a      	strb	r2, [r3, #0]
    }

    return retval;
 8009694:	2317      	movs	r3, #23
 8009696:	18fb      	adds	r3, r7, r3
 8009698:	781b      	ldrb	r3, [r3, #0]
}
 800969a:	0018      	movs	r0, r3
 800969c:	46bd      	mov	sp, r7
 800969e:	b006      	add	sp, #24
 80096a0:	bd80      	pop	{r7, pc}

080096a2 <LDL_Stream_putU8>:

bool LDL_Stream_putU8(struct ldl_stream *self, uint8_t value)
{
 80096a2:	b580      	push	{r7, lr}
 80096a4:	b082      	sub	sp, #8
 80096a6:	af00      	add	r7, sp, #0
 80096a8:	6078      	str	r0, [r7, #4]
 80096aa:	000a      	movs	r2, r1
 80096ac:	1cfb      	adds	r3, r7, #3
 80096ae:	701a      	strb	r2, [r3, #0]
    LDL_PEDANTIC(self != NULL)
    
    return LDL_Stream_write(self, &value, sizeof(value));
 80096b0:	1cf9      	adds	r1, r7, #3
 80096b2:	687b      	ldr	r3, [r7, #4]
 80096b4:	2201      	movs	r2, #1
 80096b6:	0018      	movs	r0, r3
 80096b8:	f7ff ff17 	bl	80094ea <LDL_Stream_write>
 80096bc:	0003      	movs	r3, r0
}
 80096be:	0018      	movs	r0, r3
 80096c0:	46bd      	mov	sp, r7
 80096c2:	b002      	add	sp, #8
 80096c4:	bd80      	pop	{r7, pc}

080096c6 <LDL_Stream_putU16>:

bool LDL_Stream_putU16(struct ldl_stream *self, uint16_t value)
{
 80096c6:	b5b0      	push	{r4, r5, r7, lr}
 80096c8:	b084      	sub	sp, #16
 80096ca:	af00      	add	r7, sp, #0
 80096cc:	6078      	str	r0, [r7, #4]
 80096ce:	000a      	movs	r2, r1
 80096d0:	1cbb      	adds	r3, r7, #2
 80096d2:	801a      	strh	r2, [r3, #0]
    bool retval;
    
#ifdef LDL_LITTLE_ENDIAN    
    retval = LDL_Stream_write(self, &value, 2U);
#else
    uint8_t out[] = {
 80096d4:	1cbb      	adds	r3, r7, #2
 80096d6:	881b      	ldrh	r3, [r3, #0]
 80096d8:	b2da      	uxtb	r2, r3
 80096da:	210c      	movs	r1, #12
 80096dc:	187b      	adds	r3, r7, r1
 80096de:	701a      	strb	r2, [r3, #0]
 80096e0:	1cbb      	adds	r3, r7, #2
 80096e2:	881b      	ldrh	r3, [r3, #0]
 80096e4:	0a1b      	lsrs	r3, r3, #8
 80096e6:	b29b      	uxth	r3, r3
 80096e8:	b2da      	uxtb	r2, r3
 80096ea:	187b      	adds	r3, r7, r1
 80096ec:	705a      	strb	r2, [r3, #1]
        value, 
        value >> 8        
    };
    
    retval = LDL_Stream_write(self, out, sizeof(out));
 80096ee:	250f      	movs	r5, #15
 80096f0:	197c      	adds	r4, r7, r5
 80096f2:	1879      	adds	r1, r7, r1
 80096f4:	687b      	ldr	r3, [r7, #4]
 80096f6:	2202      	movs	r2, #2
 80096f8:	0018      	movs	r0, r3
 80096fa:	f7ff fef6 	bl	80094ea <LDL_Stream_write>
 80096fe:	0003      	movs	r3, r0
 8009700:	7023      	strb	r3, [r4, #0]
#endif    
    
    return retval;
 8009702:	197b      	adds	r3, r7, r5
 8009704:	781b      	ldrb	r3, [r3, #0]
}
 8009706:	0018      	movs	r0, r3
 8009708:	46bd      	mov	sp, r7
 800970a:	b004      	add	sp, #16
 800970c:	bdb0      	pop	{r4, r5, r7, pc}

0800970e <LDL_Stream_putU32>:
    
    return retval;
}

bool LDL_Stream_putU32(struct ldl_stream *self, uint32_t value)
{
 800970e:	b5b0      	push	{r4, r5, r7, lr}
 8009710:	b084      	sub	sp, #16
 8009712:	af00      	add	r7, sp, #0
 8009714:	6078      	str	r0, [r7, #4]
 8009716:	6039      	str	r1, [r7, #0]
    bool retval;
    
#ifdef LDL_LITTLE_ENDIAN    
    retval = LDL_Stream_write(self, &value, 4U);
#else    
    uint8_t out[] = {
 8009718:	683b      	ldr	r3, [r7, #0]
 800971a:	b2da      	uxtb	r2, r3
 800971c:	2108      	movs	r1, #8
 800971e:	187b      	adds	r3, r7, r1
 8009720:	701a      	strb	r2, [r3, #0]
        value, 
        value >> 8,        
 8009722:	683b      	ldr	r3, [r7, #0]
 8009724:	0a1b      	lsrs	r3, r3, #8
    uint8_t out[] = {
 8009726:	b2da      	uxtb	r2, r3
 8009728:	187b      	adds	r3, r7, r1
 800972a:	705a      	strb	r2, [r3, #1]
        value >> 16,        
 800972c:	683b      	ldr	r3, [r7, #0]
 800972e:	0c1b      	lsrs	r3, r3, #16
    uint8_t out[] = {
 8009730:	b2da      	uxtb	r2, r3
 8009732:	187b      	adds	r3, r7, r1
 8009734:	709a      	strb	r2, [r3, #2]
        value >> 24        
 8009736:	683b      	ldr	r3, [r7, #0]
 8009738:	0e1b      	lsrs	r3, r3, #24
    uint8_t out[] = {
 800973a:	b2da      	uxtb	r2, r3
 800973c:	187b      	adds	r3, r7, r1
 800973e:	70da      	strb	r2, [r3, #3]
    };
    
    retval = LDL_Stream_write(self, out, sizeof(out));
 8009740:	250f      	movs	r5, #15
 8009742:	197c      	adds	r4, r7, r5
 8009744:	1879      	adds	r1, r7, r1
 8009746:	687b      	ldr	r3, [r7, #4]
 8009748:	2204      	movs	r2, #4
 800974a:	0018      	movs	r0, r3
 800974c:	f7ff fecd 	bl	80094ea <LDL_Stream_write>
 8009750:	0003      	movs	r3, r0
 8009752:	7023      	strb	r3, [r4, #0]
#endif    
    
    return retval;
 8009754:	197b      	adds	r3, r7, r5
 8009756:	781b      	ldrb	r3, [r3, #0]
}
 8009758:	0018      	movs	r0, r3
 800975a:	46bd      	mov	sp, r7
 800975c:	b004      	add	sp, #16
 800975e:	bdb0      	pop	{r4, r5, r7, pc}

08009760 <LDL_Stream_putEUI>:

bool LDL_Stream_putEUI(struct ldl_stream *self, const uint8_t *value)
{
 8009760:	b580      	push	{r7, lr}
 8009762:	b084      	sub	sp, #16
 8009764:	af00      	add	r7, sp, #0
 8009766:	6078      	str	r0, [r7, #4]
 8009768:	6039      	str	r1, [r7, #0]
    LDL_PEDANTIC(self != NULL)
    
    uint8_t out[] = {
 800976a:	683b      	ldr	r3, [r7, #0]
 800976c:	79da      	ldrb	r2, [r3, #7]
 800976e:	2108      	movs	r1, #8
 8009770:	187b      	adds	r3, r7, r1
 8009772:	701a      	strb	r2, [r3, #0]
 8009774:	683b      	ldr	r3, [r7, #0]
 8009776:	799a      	ldrb	r2, [r3, #6]
 8009778:	187b      	adds	r3, r7, r1
 800977a:	705a      	strb	r2, [r3, #1]
 800977c:	683b      	ldr	r3, [r7, #0]
 800977e:	795a      	ldrb	r2, [r3, #5]
 8009780:	187b      	adds	r3, r7, r1
 8009782:	709a      	strb	r2, [r3, #2]
 8009784:	683b      	ldr	r3, [r7, #0]
 8009786:	791a      	ldrb	r2, [r3, #4]
 8009788:	187b      	adds	r3, r7, r1
 800978a:	70da      	strb	r2, [r3, #3]
 800978c:	683b      	ldr	r3, [r7, #0]
 800978e:	78da      	ldrb	r2, [r3, #3]
 8009790:	187b      	adds	r3, r7, r1
 8009792:	711a      	strb	r2, [r3, #4]
 8009794:	683b      	ldr	r3, [r7, #0]
 8009796:	789a      	ldrb	r2, [r3, #2]
 8009798:	187b      	adds	r3, r7, r1
 800979a:	715a      	strb	r2, [r3, #5]
 800979c:	683b      	ldr	r3, [r7, #0]
 800979e:	785a      	ldrb	r2, [r3, #1]
 80097a0:	187b      	adds	r3, r7, r1
 80097a2:	719a      	strb	r2, [r3, #6]
        value[5],
        value[4],
        value[3],
        value[2],
        value[1],
        value[0],
 80097a4:	683b      	ldr	r3, [r7, #0]
 80097a6:	781a      	ldrb	r2, [r3, #0]
    uint8_t out[] = {
 80097a8:	187b      	adds	r3, r7, r1
 80097aa:	71da      	strb	r2, [r3, #7]
    };
    
    return LDL_Stream_write(self, out, sizeof(out));    
 80097ac:	1879      	adds	r1, r7, r1
 80097ae:	687b      	ldr	r3, [r7, #4]
 80097b0:	2208      	movs	r2, #8
 80097b2:	0018      	movs	r0, r3
 80097b4:	f7ff fe99 	bl	80094ea <LDL_Stream_write>
 80097b8:	0003      	movs	r3, r0
}
 80097ba:	0018      	movs	r0, r3
 80097bc:	46bd      	mov	sp, r7
 80097be:	b004      	add	sp, #16
 80097c0:	bd80      	pop	{r7, pc}

080097c2 <LDL_Stream_getU8>:

bool LDL_Stream_getU8(struct ldl_stream *self, uint8_t *value)
{
 80097c2:	b580      	push	{r7, lr}
 80097c4:	b082      	sub	sp, #8
 80097c6:	af00      	add	r7, sp, #0
 80097c8:	6078      	str	r0, [r7, #4]
 80097ca:	6039      	str	r1, [r7, #0]
    LDL_PEDANTIC(self != NULL)
    
    return LDL_Stream_read(self, value, sizeof(*value));
 80097cc:	6839      	ldr	r1, [r7, #0]
 80097ce:	687b      	ldr	r3, [r7, #4]
 80097d0:	2201      	movs	r2, #1
 80097d2:	0018      	movs	r0, r3
 80097d4:	f7ff fe4b 	bl	800946e <LDL_Stream_read>
 80097d8:	0003      	movs	r3, r0
}
 80097da:	0018      	movs	r0, r3
 80097dc:	46bd      	mov	sp, r7
 80097de:	b002      	add	sp, #8
 80097e0:	bd80      	pop	{r7, pc}

080097e2 <LDL_Stream_getU16>:

bool LDL_Stream_getU16(struct ldl_stream *self, uint16_t *value)
{
 80097e2:	b5f0      	push	{r4, r5, r6, r7, lr}
 80097e4:	b085      	sub	sp, #20
 80097e6:	af00      	add	r7, sp, #0
 80097e8:	6078      	str	r0, [r7, #4]
 80097ea:	6039      	str	r1, [r7, #0]
#ifdef LDL_LITTLE_ENDIAN    
    retval = LDL_Stream_read(self, &value, 2U);
#else    
    uint8_t buf[2U];
    
    retval = LDL_Stream_read(self, buf, sizeof(buf));
 80097ec:	260f      	movs	r6, #15
 80097ee:	19bc      	adds	r4, r7, r6
 80097f0:	210c      	movs	r1, #12
 80097f2:	000d      	movs	r5, r1
 80097f4:	1879      	adds	r1, r7, r1
 80097f6:	687b      	ldr	r3, [r7, #4]
 80097f8:	2202      	movs	r2, #2
 80097fa:	0018      	movs	r0, r3
 80097fc:	f7ff fe37 	bl	800946e <LDL_Stream_read>
 8009800:	0003      	movs	r3, r0
 8009802:	7023      	strb	r3, [r4, #0]
    
    *value = buf[1];
 8009804:	0029      	movs	r1, r5
 8009806:	187b      	adds	r3, r7, r1
 8009808:	785b      	ldrb	r3, [r3, #1]
 800980a:	b29a      	uxth	r2, r3
 800980c:	683b      	ldr	r3, [r7, #0]
 800980e:	801a      	strh	r2, [r3, #0]
    *value <<= 8;
 8009810:	683b      	ldr	r3, [r7, #0]
 8009812:	881b      	ldrh	r3, [r3, #0]
 8009814:	021b      	lsls	r3, r3, #8
 8009816:	b29a      	uxth	r2, r3
 8009818:	683b      	ldr	r3, [r7, #0]
 800981a:	801a      	strh	r2, [r3, #0]
    *value |= buf[0];
 800981c:	683b      	ldr	r3, [r7, #0]
 800981e:	881a      	ldrh	r2, [r3, #0]
 8009820:	187b      	adds	r3, r7, r1
 8009822:	781b      	ldrb	r3, [r3, #0]
 8009824:	b29b      	uxth	r3, r3
 8009826:	4313      	orrs	r3, r2
 8009828:	b29a      	uxth	r2, r3
 800982a:	683b      	ldr	r3, [r7, #0]
 800982c:	801a      	strh	r2, [r3, #0]
#endif    
        
    return retval;
 800982e:	19bb      	adds	r3, r7, r6
 8009830:	781b      	ldrb	r3, [r3, #0]
}
 8009832:	0018      	movs	r0, r3
 8009834:	46bd      	mov	sp, r7
 8009836:	b005      	add	sp, #20
 8009838:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800983a <LDL_Stream_getU24>:

bool LDL_Stream_getU24(struct ldl_stream *self, uint32_t *value)
{
 800983a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800983c:	b085      	sub	sp, #20
 800983e:	af00      	add	r7, sp, #0
 8009840:	6078      	str	r0, [r7, #4]
 8009842:	6039      	str	r1, [r7, #0]
    *value = 0U;
    retval = LDL_Stream_read(self, &value, 3U);
#else        
    uint8_t buf[3U];

    retval = LDL_Stream_read(self, buf, sizeof(buf));
 8009844:	260f      	movs	r6, #15
 8009846:	19bc      	adds	r4, r7, r6
 8009848:	210c      	movs	r1, #12
 800984a:	000d      	movs	r5, r1
 800984c:	1879      	adds	r1, r7, r1
 800984e:	687b      	ldr	r3, [r7, #4]
 8009850:	2203      	movs	r2, #3
 8009852:	0018      	movs	r0, r3
 8009854:	f7ff fe0b 	bl	800946e <LDL_Stream_read>
 8009858:	0003      	movs	r3, r0
 800985a:	7023      	strb	r3, [r4, #0]
        
    *value = buf[2];
 800985c:	0029      	movs	r1, r5
 800985e:	187b      	adds	r3, r7, r1
 8009860:	789b      	ldrb	r3, [r3, #2]
 8009862:	001a      	movs	r2, r3
 8009864:	683b      	ldr	r3, [r7, #0]
 8009866:	601a      	str	r2, [r3, #0]
    *value <<= 8;
 8009868:	683b      	ldr	r3, [r7, #0]
 800986a:	681b      	ldr	r3, [r3, #0]
 800986c:	021a      	lsls	r2, r3, #8
 800986e:	683b      	ldr	r3, [r7, #0]
 8009870:	601a      	str	r2, [r3, #0]
    *value |= buf[1];
 8009872:	683b      	ldr	r3, [r7, #0]
 8009874:	681b      	ldr	r3, [r3, #0]
 8009876:	187a      	adds	r2, r7, r1
 8009878:	7852      	ldrb	r2, [r2, #1]
 800987a:	431a      	orrs	r2, r3
 800987c:	683b      	ldr	r3, [r7, #0]
 800987e:	601a      	str	r2, [r3, #0]
    *value <<= 8;
 8009880:	683b      	ldr	r3, [r7, #0]
 8009882:	681b      	ldr	r3, [r3, #0]
 8009884:	021a      	lsls	r2, r3, #8
 8009886:	683b      	ldr	r3, [r7, #0]
 8009888:	601a      	str	r2, [r3, #0]
    *value |= buf[0];
 800988a:	683b      	ldr	r3, [r7, #0]
 800988c:	681b      	ldr	r3, [r3, #0]
 800988e:	187a      	adds	r2, r7, r1
 8009890:	7812      	ldrb	r2, [r2, #0]
 8009892:	431a      	orrs	r2, r3
 8009894:	683b      	ldr	r3, [r7, #0]
 8009896:	601a      	str	r2, [r3, #0]
#endif    
    return retval;
 8009898:	19bb      	adds	r3, r7, r6
 800989a:	781b      	ldrb	r3, [r3, #0]
}
 800989c:	0018      	movs	r0, r3
 800989e:	46bd      	mov	sp, r7
 80098a0:	b005      	add	sp, #20
 80098a2:	bdf0      	pop	{r4, r5, r6, r7, pc}

080098a4 <LDL_Stream_getU32>:

bool LDL_Stream_getU32(struct ldl_stream *self, uint32_t *value)
{
 80098a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80098a6:	b085      	sub	sp, #20
 80098a8:	af00      	add	r7, sp, #0
 80098aa:	6078      	str	r0, [r7, #4]
 80098ac:	6039      	str	r1, [r7, #0]
#ifdef LDL_LITTLE_ENDIAN    
    retval = LDL_Stream_read(self, &value, 4U);
#else        
    uint8_t buf[4U];

    retval = LDL_Stream_read(self, buf, sizeof(buf));
 80098ae:	260f      	movs	r6, #15
 80098b0:	19bc      	adds	r4, r7, r6
 80098b2:	2108      	movs	r1, #8
 80098b4:	000d      	movs	r5, r1
 80098b6:	1879      	adds	r1, r7, r1
 80098b8:	687b      	ldr	r3, [r7, #4]
 80098ba:	2204      	movs	r2, #4
 80098bc:	0018      	movs	r0, r3
 80098be:	f7ff fdd6 	bl	800946e <LDL_Stream_read>
 80098c2:	0003      	movs	r3, r0
 80098c4:	7023      	strb	r3, [r4, #0]
        
    *value = buf[3];
 80098c6:	0029      	movs	r1, r5
 80098c8:	187b      	adds	r3, r7, r1
 80098ca:	78db      	ldrb	r3, [r3, #3]
 80098cc:	001a      	movs	r2, r3
 80098ce:	683b      	ldr	r3, [r7, #0]
 80098d0:	601a      	str	r2, [r3, #0]
    *value <<= 8;
 80098d2:	683b      	ldr	r3, [r7, #0]
 80098d4:	681b      	ldr	r3, [r3, #0]
 80098d6:	021a      	lsls	r2, r3, #8
 80098d8:	683b      	ldr	r3, [r7, #0]
 80098da:	601a      	str	r2, [r3, #0]
    *value |= buf[2];
 80098dc:	683b      	ldr	r3, [r7, #0]
 80098de:	681b      	ldr	r3, [r3, #0]
 80098e0:	187a      	adds	r2, r7, r1
 80098e2:	7892      	ldrb	r2, [r2, #2]
 80098e4:	431a      	orrs	r2, r3
 80098e6:	683b      	ldr	r3, [r7, #0]
 80098e8:	601a      	str	r2, [r3, #0]
    *value <<= 8;
 80098ea:	683b      	ldr	r3, [r7, #0]
 80098ec:	681b      	ldr	r3, [r3, #0]
 80098ee:	021a      	lsls	r2, r3, #8
 80098f0:	683b      	ldr	r3, [r7, #0]
 80098f2:	601a      	str	r2, [r3, #0]
    *value |= buf[1];
 80098f4:	683b      	ldr	r3, [r7, #0]
 80098f6:	681b      	ldr	r3, [r3, #0]
 80098f8:	187a      	adds	r2, r7, r1
 80098fa:	7852      	ldrb	r2, [r2, #1]
 80098fc:	431a      	orrs	r2, r3
 80098fe:	683b      	ldr	r3, [r7, #0]
 8009900:	601a      	str	r2, [r3, #0]
    *value <<= 8;
 8009902:	683b      	ldr	r3, [r7, #0]
 8009904:	681b      	ldr	r3, [r3, #0]
 8009906:	021a      	lsls	r2, r3, #8
 8009908:	683b      	ldr	r3, [r7, #0]
 800990a:	601a      	str	r2, [r3, #0]
    *value |= buf[0];
 800990c:	683b      	ldr	r3, [r7, #0]
 800990e:	681b      	ldr	r3, [r3, #0]
 8009910:	187a      	adds	r2, r7, r1
 8009912:	7812      	ldrb	r2, [r2, #0]
 8009914:	431a      	orrs	r2, r3
 8009916:	683b      	ldr	r3, [r7, #0]
 8009918:	601a      	str	r2, [r3, #0]
#endif    
    
    return retval;
 800991a:	19bb      	adds	r3, r7, r6
 800991c:	781b      	ldrb	r3, [r3, #0]
}
 800991e:	0018      	movs	r0, r3
 8009920:	46bd      	mov	sp, r7
 8009922:	b005      	add	sp, #20
 8009924:	bdf0      	pop	{r4, r5, r6, r7, pc}

08009926 <LDL_Stream_error>:
    
    return retval;        
}

bool LDL_Stream_error(struct ldl_stream *self)
{
 8009926:	b580      	push	{r7, lr}
 8009928:	b082      	sub	sp, #8
 800992a:	af00      	add	r7, sp, #0
 800992c:	6078      	str	r0, [r7, #4]
    LDL_PEDANTIC(self != NULL)
    
    return self->error;
 800992e:	687b      	ldr	r3, [r7, #4]
 8009930:	7a9b      	ldrb	r3, [r3, #10]
}
 8009932:	0018      	movs	r0, r3
 8009934:	46bd      	mov	sp, r7
 8009936:	b002      	add	sp, #8
 8009938:	bd80      	pop	{r7, pc}

0800993a <LDL_System_rand>:
uint8_t LDL_System_getBatteryLevel(void *app) __attribute__((weak));
uint32_t LDL_System_advance(void) __attribute__((weak));

/**! [LDL_System_rand] */
uint8_t LDL_System_rand(void *app)
{
 800993a:	b580      	push	{r7, lr}
 800993c:	b082      	sub	sp, #8
 800993e:	af00      	add	r7, sp, #0
 8009940:	6078      	str	r0, [r7, #4]
    (void)app;
    return (uint8_t)rand();
 8009942:	f003 f87b 	bl	800ca3c <rand>
 8009946:	0003      	movs	r3, r0
 8009948:	b2db      	uxtb	r3, r3
}
 800994a:	0018      	movs	r0, r3
 800994c:	46bd      	mov	sp, r7
 800994e:	b002      	add	sp, #8
 8009950:	bd80      	pop	{r7, pc}

08009952 <LDL_System_getBatteryLevel>:
/**! [LDL_System_rand] */

/**! [LDL_System_getBatteryLevel] */
uint8_t LDL_System_getBatteryLevel(void *app)
{
 8009952:	b580      	push	{r7, lr}
 8009954:	b082      	sub	sp, #8
 8009956:	af00      	add	r7, sp, #0
 8009958:	6078      	str	r0, [r7, #4]
    (void)app;
    return 255U;    /* not available */
 800995a:	23ff      	movs	r3, #255	; 0xff
}
 800995c:	0018      	movs	r0, r3
 800995e:	46bd      	mov	sp, r7
 8009960:	b002      	add	sp, #8
 8009962:	bd80      	pop	{r7, pc}

08009964 <LDL_System_advance>:
/**! [LDL_System_getBatteryLevel] */

/**! [LDL_System_advance] */
uint32_t LDL_System_advance(void)
{
 8009964:	b580      	push	{r7, lr}
 8009966:	af00      	add	r7, sp, #0
    return 0UL;
 8009968:	2300      	movs	r3, #0
}
 800996a:	0018      	movs	r0, r3
 800996c:	46bd      	mov	sp, r7
 800996e:	bd80      	pop	{r7, pc}

08009970 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8009970:	b580      	push	{r7, lr}
 8009972:	b08c      	sub	sp, #48	; 0x30
 8009974:	af02      	add	r7, sp, #8
  

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8009976:	f000 ff95 	bl	800a8a4 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 800997a:	f000 f905 	bl	8009b88 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 800997e:	f000 fa31 	bl	8009de4 <MX_GPIO_Init>
  MX_I2C1_Init();
 8009982:	f000 f97d 	bl	8009c80 <MX_I2C1_Init>
  MX_LPTIM1_Init();
 8009986:	f000 f9c3 	bl	8009d10 <MX_LPTIM1_Init>
  MX_SPI1_Init();
 800998a:	f000 f9ef 	bl	8009d6c <MX_SPI1_Init>
  /* USER CODE BEGIN 2 */
  //PAST HERE
  initialize();
 800998e:	f7f6 fe7b 	bl	8000688 <initialize>
  printf("hello world");
 8009992:	4b66      	ldr	r3, [pc, #408]	; (8009b2c <main+0x1bc>)
 8009994:	0018      	movs	r0, r3
 8009996:	f002 ffa9 	bl	800c8ec <iprintf>

//Initialize security module
  LDL_SM_init(&sm, application_key, nwk_key_ptr);
 800999a:	4a65      	ldr	r2, [pc, #404]	; (8009b30 <main+0x1c0>)
 800999c:	4965      	ldr	r1, [pc, #404]	; (8009b34 <main+0x1c4>)
 800999e:	4b66      	ldr	r3, [pc, #408]	; (8009b38 <main+0x1c8>)
 80099a0:	0018      	movs	r0, r3
 80099a2:	f7ff fbd7 	bl	8009154 <LDL_SM_init>
  LDL_INFO(TAG,"SM INIT");
 80099a6:	4b65      	ldr	r3, [pc, #404]	; (8009b3c <main+0x1cc>)
 80099a8:	0018      	movs	r0, r3
 80099aa:	f002 ff9f 	bl	800c8ec <iprintf>
 80099ae:	4b64      	ldr	r3, [pc, #400]	; (8009b40 <main+0x1d0>)
 80099b0:	0018      	movs	r0, r3
 80099b2:	f002 ff9b 	bl	800c8ec <iprintf>
 80099b6:	4b63      	ldr	r3, [pc, #396]	; (8009b44 <main+0x1d4>)
 80099b8:	0018      	movs	r0, r3
 80099ba:	f003 f811 	bl	800c9e0 <puts>

//Initialise the radio

  LDL_Radio_init(&radio, LDL_RADIO_SX1272, NULL);
 80099be:	4b62      	ldr	r3, [pc, #392]	; (8009b48 <main+0x1d8>)
 80099c0:	2200      	movs	r2, #0
 80099c2:	2100      	movs	r1, #0
 80099c4:	0018      	movs	r0, r3
 80099c6:	f7fe fa35 	bl	8007e34 <LDL_Radio_init>
  LDL_INFO(TAG,"RADIO INIT");
 80099ca:	4b5c      	ldr	r3, [pc, #368]	; (8009b3c <main+0x1cc>)
 80099cc:	0018      	movs	r0, r3
 80099ce:	f002 ff8d 	bl	800c8ec <iprintf>
 80099d2:	4b5e      	ldr	r3, [pc, #376]	; (8009b4c <main+0x1dc>)
 80099d4:	0018      	movs	r0, r3
 80099d6:	f002 ff89 	bl	800c8ec <iprintf>
 80099da:	4b5a      	ldr	r3, [pc, #360]	; (8009b44 <main+0x1d4>)
 80099dc:	0018      	movs	r0, r3
 80099de:	f002 ffff 	bl	800c9e0 <puts>
   *
   * - The Semtech MBED SX1272 shield uses LDL_RADIO_PA_RFO
   * - The HopeRF RFM95 SX1276 module uses LDL_RADIO_PA_BOOST
   *
   * */
  LDL_Radio_setPA(&radio, LDL_RADIO_PA_RFO);
 80099e2:	4b59      	ldr	r3, [pc, #356]	; (8009b48 <main+0x1d8>)
 80099e4:	2100      	movs	r1, #0
 80099e6:	0018      	movs	r0, r3
 80099e8:	f7fe fa3e 	bl	8007e68 <LDL_Radio_setPA>
  LDL_INFO(TAG,"RADIO PA INIT")
 80099ec:	4b53      	ldr	r3, [pc, #332]	; (8009b3c <main+0x1cc>)
 80099ee:	0018      	movs	r0, r3
 80099f0:	f002 ff7c 	bl	800c8ec <iprintf>
 80099f4:	4b56      	ldr	r3, [pc, #344]	; (8009b50 <main+0x1e0>)
 80099f6:	0018      	movs	r0, r3
 80099f8:	f002 ff78 	bl	800c8ec <iprintf>
 80099fc:	4b51      	ldr	r3, [pc, #324]	; (8009b44 <main+0x1d4>)
 80099fe:	0018      	movs	r0, r3
 8009a00:	f002 ffee 	bl	800c9e0 <puts>


//Initialise The MAC LAYER
  struct ldl_mac_init_arg arg = {0};
 8009a04:	003b      	movs	r3, r7
 8009a06:	0018      	movs	r0, r3
 8009a08:	2328      	movs	r3, #40	; 0x28
 8009a0a:	001a      	movs	r2, r3
 8009a0c:	2100      	movs	r1, #0
 8009a0e:	f002 ff64 	bl	800c8da <memset>

  arg.radio = &radio;
 8009a12:	003b      	movs	r3, r7
 8009a14:	4a4c      	ldr	r2, [pc, #304]	; (8009b48 <main+0x1d8>)
 8009a16:	605a      	str	r2, [r3, #4]
  arg.handler = app_handler;
 8009a18:	003b      	movs	r3, r7
 8009a1a:	4a4e      	ldr	r2, [pc, #312]	; (8009b54 <main+0x1e4>)
 8009a1c:	60da      	str	r2, [r3, #12]
  arg.app = NULL;
 8009a1e:	003b      	movs	r3, r7
 8009a20:	2200      	movs	r2, #0
 8009a22:	601a      	str	r2, [r3, #0]
  arg.sm = &sm;
 8009a24:	003b      	movs	r3, r7
 8009a26:	4a44      	ldr	r2, [pc, #272]	; (8009b38 <main+0x1c8>)
 8009a28:	609a      	str	r2, [r3, #8]
  arg.joinEUI = application_eui;
 8009a2a:	003b      	movs	r3, r7
 8009a2c:	4a4a      	ldr	r2, [pc, #296]	; (8009b58 <main+0x1e8>)
 8009a2e:	615a      	str	r2, [r3, #20]
  arg.devEUI = device_eui;
 8009a30:	003b      	movs	r3, r7
 8009a32:	4a4a      	ldr	r2, [pc, #296]	; (8009b5c <main+0x1ec>)
 8009a34:	619a      	str	r2, [r3, #24]

  LDL_MAC_init(&mac, LDL_EU_863_870, &arg);
 8009a36:	003a      	movs	r2, r7
 8009a38:	4b49      	ldr	r3, [pc, #292]	; (8009b60 <main+0x1f0>)
 8009a3a:	2100      	movs	r1, #0
 8009a3c:	0018      	movs	r0, r3
 8009a3e:	f7f8 feb9 	bl	80027b4 <LDL_MAC_init>
  LDL_INFO(TAG,"MAC INIT");
 8009a42:	4b3e      	ldr	r3, [pc, #248]	; (8009b3c <main+0x1cc>)
 8009a44:	0018      	movs	r0, r3
 8009a46:	f002 ff51 	bl	800c8ec <iprintf>
 8009a4a:	4b46      	ldr	r3, [pc, #280]	; (8009b64 <main+0x1f4>)
 8009a4c:	0018      	movs	r0, r3
 8009a4e:	f002 ff4d 	bl	800c8ec <iprintf>
 8009a52:	4b3c      	ldr	r3, [pc, #240]	; (8009b44 <main+0x1d4>)
 8009a54:	0018      	movs	r0, r3
 8009a56:	f002 ffc3 	bl	800c9e0 <puts>

  enable_interrupts();
 8009a5a:	f000 fba1 	bl	800a1a0 <enable_interrupts>
  LDL_INFO(TAG,"INTERRUPT ENABLE");
 8009a5e:	4b37      	ldr	r3, [pc, #220]	; (8009b3c <main+0x1cc>)
 8009a60:	0018      	movs	r0, r3
 8009a62:	f002 ff43 	bl	800c8ec <iprintf>
 8009a66:	4b40      	ldr	r3, [pc, #256]	; (8009b68 <main+0x1f8>)
 8009a68:	0018      	movs	r0, r3
 8009a6a:	f002 ff3f 	bl	800c8ec <iprintf>
 8009a6e:	4b35      	ldr	r3, [pc, #212]	; (8009b44 <main+0x1d4>)
 8009a70:	0018      	movs	r0, r3
 8009a72:	f002 ffb5 	bl	800c9e0 <puts>




  HAL_LPTIM_Counter_Start_IT(&hlptim1, 0xffff);
 8009a76:	4a3d      	ldr	r2, [pc, #244]	; (8009b6c <main+0x1fc>)
 8009a78:	4b3d      	ldr	r3, [pc, #244]	; (8009b70 <main+0x200>)
 8009a7a:	0011      	movs	r1, r2
 8009a7c:	0018      	movs	r0, r3
 8009a7e:	f001 fbb1 	bl	800b1e4 <HAL_LPTIM_Counter_Start_IT>
//  transmit++;
//  HAL_Delay(1000);
//
//  }
  /* USER CODE END 2 */
test1=(LDL_System_tps()) << 4U;
 8009a82:	f000 fa30 	bl	8009ee6 <LDL_System_tps>
 8009a86:	0003      	movs	r3, r0
 8009a88:	011a      	lsls	r2, r3, #4
 8009a8a:	4b3a      	ldr	r3, [pc, #232]	; (8009b74 <main+0x204>)
 8009a8c:	601a      	str	r2, [r3, #0]
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	  if(LDL_MAC_ready(&mac)){
 8009a8e:	4b34      	ldr	r3, [pc, #208]	; (8009b60 <main+0x1f0>)
 8009a90:	0018      	movs	r0, r3
 8009a92:	f7fa f927 	bl	8003ce4 <LDL_MAC_ready>
 8009a96:	1e03      	subs	r3, r0, #0
 8009a98:	d042      	beq.n	8009b20 <main+0x1b0>
		  LDL_INFO(TAG,"MAC READY");
 8009a9a:	4b28      	ldr	r3, [pc, #160]	; (8009b3c <main+0x1cc>)
 8009a9c:	0018      	movs	r0, r3
 8009a9e:	f002 ff25 	bl	800c8ec <iprintf>
 8009aa2:	4b35      	ldr	r3, [pc, #212]	; (8009b78 <main+0x208>)
 8009aa4:	0018      	movs	r0, r3
 8009aa6:	f002 ff21 	bl	800c8ec <iprintf>
 8009aaa:	4b26      	ldr	r3, [pc, #152]	; (8009b44 <main+0x1d4>)
 8009aac:	0018      	movs	r0, r3
 8009aae:	f002 ff97 	bl	800c9e0 <puts>
	             if(LDL_MAC_joined(&mac)){
 8009ab2:	4b2b      	ldr	r3, [pc, #172]	; (8009b60 <main+0x1f0>)
 8009ab4:	0018      	movs	r0, r3
 8009ab6:	f7f9 f84f 	bl	8002b58 <LDL_MAC_joined>
 8009aba:	1e03      	subs	r3, r0, #0
 8009abc:	d020      	beq.n	8009b00 <main+0x190>
	            	 LDL_INFO(TAG,"JOINED ...");
 8009abe:	4b1f      	ldr	r3, [pc, #124]	; (8009b3c <main+0x1cc>)
 8009ac0:	0018      	movs	r0, r3
 8009ac2:	f002 ff13 	bl	800c8ec <iprintf>
 8009ac6:	4b2d      	ldr	r3, [pc, #180]	; (8009b7c <main+0x20c>)
 8009ac8:	0018      	movs	r0, r3
 8009aca:	f002 ff0f 	bl	800c8ec <iprintf>
 8009ace:	4b1d      	ldr	r3, [pc, #116]	; (8009b44 <main+0x1d4>)
 8009ad0:	0018      	movs	r0, r3
 8009ad2:	f002 ff85 	bl	800c9e0 <puts>
	                 LDL_MAC_unconfirmedData(&mac, 1U, NULL, 0U, NULL);
 8009ad6:	4822      	ldr	r0, [pc, #136]	; (8009b60 <main+0x1f0>)
 8009ad8:	2300      	movs	r3, #0
 8009ada:	9300      	str	r3, [sp, #0]
 8009adc:	2300      	movs	r3, #0
 8009ade:	2200      	movs	r2, #0
 8009ae0:	2101      	movs	r1, #1
 8009ae2:	f7f8 ff35 	bl	8002950 <LDL_MAC_unconfirmedData>
	                 LDL_INFO(TAG,"UNCONFIRMED DATA");
 8009ae6:	4b15      	ldr	r3, [pc, #84]	; (8009b3c <main+0x1cc>)
 8009ae8:	0018      	movs	r0, r3
 8009aea:	f002 feff 	bl	800c8ec <iprintf>
 8009aee:	4b24      	ldr	r3, [pc, #144]	; (8009b80 <main+0x210>)
 8009af0:	0018      	movs	r0, r3
 8009af2:	f002 fefb 	bl	800c8ec <iprintf>
 8009af6:	4b13      	ldr	r3, [pc, #76]	; (8009b44 <main+0x1d4>)
 8009af8:	0018      	movs	r0, r3
 8009afa:	f002 ff71 	bl	800c9e0 <puts>
 8009afe:	e00f      	b.n	8009b20 <main+0x1b0>
	             }
	             else{

	                 LDL_MAC_otaa(&mac);
 8009b00:	4b17      	ldr	r3, [pc, #92]	; (8009b60 <main+0x1f0>)
 8009b02:	0018      	movs	r0, r3
 8009b04:	f7f8 ff46 	bl	8002994 <LDL_MAC_otaa>
	                 LDL_INFO(TAG,"OTAA");
 8009b08:	4b0c      	ldr	r3, [pc, #48]	; (8009b3c <main+0x1cc>)
 8009b0a:	0018      	movs	r0, r3
 8009b0c:	f002 feee 	bl	800c8ec <iprintf>
 8009b10:	4b1c      	ldr	r3, [pc, #112]	; (8009b84 <main+0x214>)
 8009b12:	0018      	movs	r0, r3
 8009b14:	f002 feea 	bl	800c8ec <iprintf>
 8009b18:	4b0a      	ldr	r3, [pc, #40]	; (8009b44 <main+0x1d4>)
 8009b1a:	0018      	movs	r0, r3
 8009b1c:	f002 ff60 	bl	800c9e0 <puts>
	             }
	         }
	  LDL_MAC_process(&mac);
 8009b20:	4b0f      	ldr	r3, [pc, #60]	; (8009b60 <main+0x1f0>)
 8009b22:	0018      	movs	r0, r3
 8009b24:	f7f9 f858 	bl	8002bd8 <LDL_MAC_process>
	  if(LDL_MAC_ready(&mac)){
 8009b28:	e7b1      	b.n	8009a8e <main+0x11e>
 8009b2a:	46c0      	nop			; (mov r8, r8)
 8009b2c:	0800e120 	.word	0x0800e120
 8009b30:	0800e618 	.word	0x0800e618
 8009b34:	0800e608 	.word	0x0800e608
 8009b38:	20000528 	.word	0x20000528
 8009b3c:	0800e12c 	.word	0x0800e12c
 8009b40:	0800e134 	.word	0x0800e134
 8009b44:	0800e13c 	.word	0x0800e13c
 8009b48:	20000490 	.word	0x20000490
 8009b4c:	0800e140 	.word	0x0800e140
 8009b50:	0800e14c 	.word	0x0800e14c
 8009b54:	0800a1dd 	.word	0x0800a1dd
 8009b58:	0800e600 	.word	0x0800e600
 8009b5c:	0800e5f8 	.word	0x0800e5f8
 8009b60:	200001bc 	.word	0x200001bc
 8009b64:	0800e15c 	.word	0x0800e15c
 8009b68:	0800e168 	.word	0x0800e168
 8009b6c:	0000ffff 	.word	0x0000ffff
 8009b70:	200004a0 	.word	0x200004a0
 8009b74:	200001b8 	.word	0x200001b8
 8009b78:	0800e17c 	.word	0x0800e17c
 8009b7c:	0800e188 	.word	0x0800e188
 8009b80:	0800e194 	.word	0x0800e194
 8009b84:	0800e1a8 	.word	0x0800e1a8

08009b88 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8009b88:	b590      	push	{r4, r7, lr}
 8009b8a:	b09f      	sub	sp, #124	; 0x7c
 8009b8c:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8009b8e:	2440      	movs	r4, #64	; 0x40
 8009b90:	193b      	adds	r3, r7, r4
 8009b92:	0018      	movs	r0, r3
 8009b94:	2338      	movs	r3, #56	; 0x38
 8009b96:	001a      	movs	r2, r3
 8009b98:	2100      	movs	r1, #0
 8009b9a:	f002 fe9e 	bl	800c8da <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8009b9e:	232c      	movs	r3, #44	; 0x2c
 8009ba0:	18fb      	adds	r3, r7, r3
 8009ba2:	0018      	movs	r0, r3
 8009ba4:	2314      	movs	r3, #20
 8009ba6:	001a      	movs	r2, r3
 8009ba8:	2100      	movs	r1, #0
 8009baa:	f002 fe96 	bl	800c8da <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8009bae:	1d3b      	adds	r3, r7, #4
 8009bb0:	0018      	movs	r0, r3
 8009bb2:	2328      	movs	r3, #40	; 0x28
 8009bb4:	001a      	movs	r2, r3
 8009bb6:	2100      	movs	r1, #0
 8009bb8:	f002 fe8f 	bl	800c8da <memset>

  /** Configure the main internal regulator output voltage 
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8009bbc:	4b2d      	ldr	r3, [pc, #180]	; (8009c74 <SystemClock_Config+0xec>)
 8009bbe:	681b      	ldr	r3, [r3, #0]
 8009bc0:	4a2d      	ldr	r2, [pc, #180]	; (8009c78 <SystemClock_Config+0xf0>)
 8009bc2:	401a      	ands	r2, r3
 8009bc4:	4b2b      	ldr	r3, [pc, #172]	; (8009c74 <SystemClock_Config+0xec>)
 8009bc6:	2180      	movs	r1, #128	; 0x80
 8009bc8:	0109      	lsls	r1, r1, #4
 8009bca:	430a      	orrs	r2, r1
 8009bcc:	601a      	str	r2, [r3, #0]
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
 8009bce:	0021      	movs	r1, r4
 8009bd0:	187b      	adds	r3, r7, r1
 8009bd2:	2214      	movs	r2, #20
 8009bd4:	601a      	str	r2, [r3, #0]
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 8009bd6:	187b      	adds	r3, r7, r1
 8009bd8:	2280      	movs	r2, #128	; 0x80
 8009bda:	0052      	lsls	r2, r2, #1
 8009bdc:	609a      	str	r2, [r3, #8]
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 8009bde:	187b      	adds	r3, r7, r1
 8009be0:	2201      	movs	r2, #1
 8009be2:	61da      	str	r2, [r3, #28]
  RCC_OscInitStruct.MSICalibrationValue = 0;
 8009be4:	187b      	adds	r3, r7, r1
 8009be6:	2200      	movs	r2, #0
 8009be8:	621a      	str	r2, [r3, #32]
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5;
 8009bea:	187b      	adds	r3, r7, r1
 8009bec:	22a0      	movs	r2, #160	; 0xa0
 8009bee:	0212      	lsls	r2, r2, #8
 8009bf0:	625a      	str	r2, [r3, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 8009bf2:	187b      	adds	r3, r7, r1
 8009bf4:	2200      	movs	r2, #0
 8009bf6:	629a      	str	r2, [r3, #40]	; 0x28
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8009bf8:	187b      	adds	r3, r7, r1
 8009bfa:	0018      	movs	r0, r3
 8009bfc:	f001 fc3e 	bl	800b47c <HAL_RCC_OscConfig>
 8009c00:	1e03      	subs	r3, r0, #0
 8009c02:	d003      	beq.n	8009c0c <SystemClock_Config+0x84>
  {
    Error_Handler(__func__);
 8009c04:	4b1d      	ldr	r3, [pc, #116]	; (8009c7c <SystemClock_Config+0xf4>)
 8009c06:	0018      	movs	r0, r3
 8009c08:	f000 fc1c 	bl	800a444 <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8009c0c:	212c      	movs	r1, #44	; 0x2c
 8009c0e:	187b      	adds	r3, r7, r1
 8009c10:	220f      	movs	r2, #15
 8009c12:	601a      	str	r2, [r3, #0]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
 8009c14:	187b      	adds	r3, r7, r1
 8009c16:	2200      	movs	r2, #0
 8009c18:	605a      	str	r2, [r3, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8009c1a:	187b      	adds	r3, r7, r1
 8009c1c:	2200      	movs	r2, #0
 8009c1e:	609a      	str	r2, [r3, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8009c20:	187b      	adds	r3, r7, r1
 8009c22:	2200      	movs	r2, #0
 8009c24:	60da      	str	r2, [r3, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8009c26:	187b      	adds	r3, r7, r1
 8009c28:	2200      	movs	r2, #0
 8009c2a:	611a      	str	r2, [r3, #16]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 8009c2c:	187b      	adds	r3, r7, r1
 8009c2e:	2100      	movs	r1, #0
 8009c30:	0018      	movs	r0, r3
 8009c32:	f001 fff3 	bl	800bc1c <HAL_RCC_ClockConfig>
 8009c36:	1e03      	subs	r3, r0, #0
 8009c38:	d003      	beq.n	8009c42 <SystemClock_Config+0xba>
  {
    Error_Handler(__func__);
 8009c3a:	4b10      	ldr	r3, [pc, #64]	; (8009c7c <SystemClock_Config+0xf4>)
 8009c3c:	0018      	movs	r0, r3
 8009c3e:	f000 fc01 	bl	800a444 <Error_Handler>
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_I2C1|RCC_PERIPHCLK_LPTIM1;
 8009c42:	1d3b      	adds	r3, r7, #4
 8009c44:	2288      	movs	r2, #136	; 0x88
 8009c46:	601a      	str	r2, [r3, #0]
  PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
 8009c48:	1d3b      	adds	r3, r7, #4
 8009c4a:	2200      	movs	r2, #0
 8009c4c:	619a      	str	r2, [r3, #24]
  PeriphClkInit.LptimClockSelection = RCC_LPTIM1CLKSOURCE_LSE;
 8009c4e:	1d3b      	adds	r3, r7, #4
 8009c50:	22c0      	movs	r2, #192	; 0xc0
 8009c52:	0312      	lsls	r2, r2, #12
 8009c54:	621a      	str	r2, [r3, #32]

  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8009c56:	1d3b      	adds	r3, r7, #4
 8009c58:	0018      	movs	r0, r3
 8009c5a:	f002 f9c3 	bl	800bfe4 <HAL_RCCEx_PeriphCLKConfig>
 8009c5e:	1e03      	subs	r3, r0, #0
 8009c60:	d003      	beq.n	8009c6a <SystemClock_Config+0xe2>
  {
    Error_Handler(__func__);
 8009c62:	4b06      	ldr	r3, [pc, #24]	; (8009c7c <SystemClock_Config+0xf4>)
 8009c64:	0018      	movs	r0, r3
 8009c66:	f000 fbed 	bl	800a444 <Error_Handler>
  }
}
 8009c6a:	46c0      	nop			; (mov r8, r8)
 8009c6c:	46bd      	mov	sp, r7
 8009c6e:	b01f      	add	sp, #124	; 0x7c
 8009c70:	bd90      	pop	{r4, r7, pc}
 8009c72:	46c0      	nop			; (mov r8, r8)
 8009c74:	40007000 	.word	0x40007000
 8009c78:	ffffe7ff 	.word	0xffffe7ff
 8009c7c:	0800e668 	.word	0x0800e668

08009c80 <MX_I2C1_Init>:
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{
 8009c80:	b580      	push	{r7, lr}
 8009c82:	af00      	add	r7, sp, #0
  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
 8009c84:	4b1f      	ldr	r3, [pc, #124]	; (8009d04 <MX_I2C1_Init+0x84>)
 8009c86:	4a20      	ldr	r2, [pc, #128]	; (8009d08 <MX_I2C1_Init+0x88>)
 8009c88:	601a      	str	r2, [r3, #0]
  hi2c1.Init.Timing = 0x00000708;
 8009c8a:	4b1e      	ldr	r3, [pc, #120]	; (8009d04 <MX_I2C1_Init+0x84>)
 8009c8c:	22e1      	movs	r2, #225	; 0xe1
 8009c8e:	00d2      	lsls	r2, r2, #3
 8009c90:	605a      	str	r2, [r3, #4]
  hi2c1.Init.OwnAddress1 = 0;
 8009c92:	4b1c      	ldr	r3, [pc, #112]	; (8009d04 <MX_I2C1_Init+0x84>)
 8009c94:	2200      	movs	r2, #0
 8009c96:	609a      	str	r2, [r3, #8]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8009c98:	4b1a      	ldr	r3, [pc, #104]	; (8009d04 <MX_I2C1_Init+0x84>)
 8009c9a:	2201      	movs	r2, #1
 8009c9c:	60da      	str	r2, [r3, #12]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 8009c9e:	4b19      	ldr	r3, [pc, #100]	; (8009d04 <MX_I2C1_Init+0x84>)
 8009ca0:	2200      	movs	r2, #0
 8009ca2:	611a      	str	r2, [r3, #16]
  hi2c1.Init.OwnAddress2 = 0;
 8009ca4:	4b17      	ldr	r3, [pc, #92]	; (8009d04 <MX_I2C1_Init+0x84>)
 8009ca6:	2200      	movs	r2, #0
 8009ca8:	615a      	str	r2, [r3, #20]
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 8009caa:	4b16      	ldr	r3, [pc, #88]	; (8009d04 <MX_I2C1_Init+0x84>)
 8009cac:	2200      	movs	r2, #0
 8009cae:	619a      	str	r2, [r3, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8009cb0:	4b14      	ldr	r3, [pc, #80]	; (8009d04 <MX_I2C1_Init+0x84>)
 8009cb2:	2200      	movs	r2, #0
 8009cb4:	61da      	str	r2, [r3, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8009cb6:	4b13      	ldr	r3, [pc, #76]	; (8009d04 <MX_I2C1_Init+0x84>)
 8009cb8:	2200      	movs	r2, #0
 8009cba:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8009cbc:	4b11      	ldr	r3, [pc, #68]	; (8009d04 <MX_I2C1_Init+0x84>)
 8009cbe:	0018      	movs	r0, r3
 8009cc0:	f001 f8e2 	bl	800ae88 <HAL_I2C_Init>
 8009cc4:	1e03      	subs	r3, r0, #0
 8009cc6:	d003      	beq.n	8009cd0 <MX_I2C1_Init+0x50>
  {
    Error_Handler(__func__);
 8009cc8:	4b10      	ldr	r3, [pc, #64]	; (8009d0c <MX_I2C1_Init+0x8c>)
 8009cca:	0018      	movs	r0, r3
 8009ccc:	f000 fbba 	bl	800a444 <Error_Handler>
  }
  /** Configure Analogue filter 
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 8009cd0:	4b0c      	ldr	r3, [pc, #48]	; (8009d04 <MX_I2C1_Init+0x84>)
 8009cd2:	2100      	movs	r1, #0
 8009cd4:	0018      	movs	r0, r3
 8009cd6:	f001 f96d 	bl	800afb4 <HAL_I2CEx_ConfigAnalogFilter>
 8009cda:	1e03      	subs	r3, r0, #0
 8009cdc:	d003      	beq.n	8009ce6 <MX_I2C1_Init+0x66>
  {
    Error_Handler(__func__);
 8009cde:	4b0b      	ldr	r3, [pc, #44]	; (8009d0c <MX_I2C1_Init+0x8c>)
 8009ce0:	0018      	movs	r0, r3
 8009ce2:	f000 fbaf 	bl	800a444 <Error_Handler>
  }
  /** Configure Digital filter 
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 8009ce6:	4b07      	ldr	r3, [pc, #28]	; (8009d04 <MX_I2C1_Init+0x84>)
 8009ce8:	2100      	movs	r1, #0
 8009cea:	0018      	movs	r0, r3
 8009cec:	f001 f9ae 	bl	800b04c <HAL_I2CEx_ConfigDigitalFilter>
 8009cf0:	1e03      	subs	r3, r0, #0
 8009cf2:	d003      	beq.n	8009cfc <MX_I2C1_Init+0x7c>
  {
    Error_Handler(__func__);
 8009cf4:	4b05      	ldr	r3, [pc, #20]	; (8009d0c <MX_I2C1_Init+0x8c>)
 8009cf6:	0018      	movs	r0, r3
 8009cf8:	f000 fba4 	bl	800a444 <Error_Handler>
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}
 8009cfc:	46c0      	nop			; (mov r8, r8)
 8009cfe:	46bd      	mov	sp, r7
 8009d00:	bd80      	pop	{r7, pc}
 8009d02:	46c0      	nop			; (mov r8, r8)
 8009d04:	20000110 	.word	0x20000110
 8009d08:	40005400 	.word	0x40005400
 8009d0c:	0800e67c 	.word	0x0800e67c

08009d10 <MX_LPTIM1_Init>:
  * @brief LPTIM1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_LPTIM1_Init(void)
{
 8009d10:	b580      	push	{r7, lr}
 8009d12:	af00      	add	r7, sp, #0
  /* USER CODE END LPTIM1_Init 0 */

  /* USER CODE BEGIN LPTIM1_Init 1 */

  /* USER CODE END LPTIM1_Init 1 */
  hlptim1.Instance = LPTIM1;
 8009d14:	4b11      	ldr	r3, [pc, #68]	; (8009d5c <MX_LPTIM1_Init+0x4c>)
 8009d16:	4a12      	ldr	r2, [pc, #72]	; (8009d60 <MX_LPTIM1_Init+0x50>)
 8009d18:	601a      	str	r2, [r3, #0]
  hlptim1.Init.Clock.Source = LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC;
 8009d1a:	4b10      	ldr	r3, [pc, #64]	; (8009d5c <MX_LPTIM1_Init+0x4c>)
 8009d1c:	2200      	movs	r2, #0
 8009d1e:	605a      	str	r2, [r3, #4]
  hlptim1.Init.Clock.Prescaler = LPTIM_PRESCALER_DIV2;
 8009d20:	4b0e      	ldr	r3, [pc, #56]	; (8009d5c <MX_LPTIM1_Init+0x4c>)
 8009d22:	2280      	movs	r2, #128	; 0x80
 8009d24:	0092      	lsls	r2, r2, #2
 8009d26:	609a      	str	r2, [r3, #8]
  hlptim1.Init.Trigger.Source = LPTIM_TRIGSOURCE_SOFTWARE;
 8009d28:	4b0c      	ldr	r3, [pc, #48]	; (8009d5c <MX_LPTIM1_Init+0x4c>)
 8009d2a:	4a0e      	ldr	r2, [pc, #56]	; (8009d64 <MX_LPTIM1_Init+0x54>)
 8009d2c:	615a      	str	r2, [r3, #20]
  hlptim1.Init.OutputPolarity = LPTIM_OUTPUTPOLARITY_HIGH;
 8009d2e:	4b0b      	ldr	r3, [pc, #44]	; (8009d5c <MX_LPTIM1_Init+0x4c>)
 8009d30:	2200      	movs	r2, #0
 8009d32:	621a      	str	r2, [r3, #32]
  hlptim1.Init.UpdateMode = LPTIM_UPDATE_IMMEDIATE;
 8009d34:	4b09      	ldr	r3, [pc, #36]	; (8009d5c <MX_LPTIM1_Init+0x4c>)
 8009d36:	2200      	movs	r2, #0
 8009d38:	625a      	str	r2, [r3, #36]	; 0x24
  hlptim1.Init.CounterSource = LPTIM_COUNTERSOURCE_INTERNAL;
 8009d3a:	4b08      	ldr	r3, [pc, #32]	; (8009d5c <MX_LPTIM1_Init+0x4c>)
 8009d3c:	2200      	movs	r2, #0
 8009d3e:	629a      	str	r2, [r3, #40]	; 0x28
  if (HAL_LPTIM_Init(&hlptim1) != HAL_OK)
 8009d40:	4b06      	ldr	r3, [pc, #24]	; (8009d5c <MX_LPTIM1_Init+0x4c>)
 8009d42:	0018      	movs	r0, r3
 8009d44:	f001 f9ce 	bl	800b0e4 <HAL_LPTIM_Init>
 8009d48:	1e03      	subs	r3, r0, #0
 8009d4a:	d003      	beq.n	8009d54 <MX_LPTIM1_Init+0x44>
  {
    Error_Handler(__func__);
 8009d4c:	4b06      	ldr	r3, [pc, #24]	; (8009d68 <MX_LPTIM1_Init+0x58>)
 8009d4e:	0018      	movs	r0, r3
 8009d50:	f000 fb78 	bl	800a444 <Error_Handler>
  }
  /* USER CODE BEGIN LPTIM1_Init 2 */

  /* USER CODE END LPTIM1_Init 2 */

}
 8009d54:	46c0      	nop			; (mov r8, r8)
 8009d56:	46bd      	mov	sp, r7
 8009d58:	bd80      	pop	{r7, pc}
 8009d5a:	46c0      	nop			; (mov r8, r8)
 8009d5c:	200004a0 	.word	0x200004a0
 8009d60:	40007c00 	.word	0x40007c00
 8009d64:	0000ffff 	.word	0x0000ffff
 8009d68:	0800e68c 	.word	0x0800e68c

08009d6c <MX_SPI1_Init>:
  * @brief SPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI1_Init(void)
{
 8009d6c:	b580      	push	{r7, lr}
 8009d6e:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
 8009d70:	4b19      	ldr	r3, [pc, #100]	; (8009dd8 <MX_SPI1_Init+0x6c>)
 8009d72:	4a1a      	ldr	r2, [pc, #104]	; (8009ddc <MX_SPI1_Init+0x70>)
 8009d74:	601a      	str	r2, [r3, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 8009d76:	4b18      	ldr	r3, [pc, #96]	; (8009dd8 <MX_SPI1_Init+0x6c>)
 8009d78:	2282      	movs	r2, #130	; 0x82
 8009d7a:	0052      	lsls	r2, r2, #1
 8009d7c:	605a      	str	r2, [r3, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 8009d7e:	4b16      	ldr	r3, [pc, #88]	; (8009dd8 <MX_SPI1_Init+0x6c>)
 8009d80:	2200      	movs	r2, #0
 8009d82:	609a      	str	r2, [r3, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 8009d84:	4b14      	ldr	r3, [pc, #80]	; (8009dd8 <MX_SPI1_Init+0x6c>)
 8009d86:	2200      	movs	r2, #0
 8009d88:	60da      	str	r2, [r3, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 8009d8a:	4b13      	ldr	r3, [pc, #76]	; (8009dd8 <MX_SPI1_Init+0x6c>)
 8009d8c:	2200      	movs	r2, #0
 8009d8e:	611a      	str	r2, [r3, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 8009d90:	4b11      	ldr	r3, [pc, #68]	; (8009dd8 <MX_SPI1_Init+0x6c>)
 8009d92:	2200      	movs	r2, #0
 8009d94:	615a      	str	r2, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 8009d96:	4b10      	ldr	r3, [pc, #64]	; (8009dd8 <MX_SPI1_Init+0x6c>)
 8009d98:	2280      	movs	r2, #128	; 0x80
 8009d9a:	0092      	lsls	r2, r2, #2
 8009d9c:	619a      	str	r2, [r3, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 8009d9e:	4b0e      	ldr	r3, [pc, #56]	; (8009dd8 <MX_SPI1_Init+0x6c>)
 8009da0:	2200      	movs	r2, #0
 8009da2:	61da      	str	r2, [r3, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8009da4:	4b0c      	ldr	r3, [pc, #48]	; (8009dd8 <MX_SPI1_Init+0x6c>)
 8009da6:	2200      	movs	r2, #0
 8009da8:	621a      	str	r2, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 8009daa:	4b0b      	ldr	r3, [pc, #44]	; (8009dd8 <MX_SPI1_Init+0x6c>)
 8009dac:	2200      	movs	r2, #0
 8009dae:	625a      	str	r2, [r3, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8009db0:	4b09      	ldr	r3, [pc, #36]	; (8009dd8 <MX_SPI1_Init+0x6c>)
 8009db2:	2200      	movs	r2, #0
 8009db4:	629a      	str	r2, [r3, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 7;
 8009db6:	4b08      	ldr	r3, [pc, #32]	; (8009dd8 <MX_SPI1_Init+0x6c>)
 8009db8:	2207      	movs	r2, #7
 8009dba:	62da      	str	r2, [r3, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 8009dbc:	4b06      	ldr	r3, [pc, #24]	; (8009dd8 <MX_SPI1_Init+0x6c>)
 8009dbe:	0018      	movs	r0, r3
 8009dc0:	f002 fa84 	bl	800c2cc <HAL_SPI_Init>
 8009dc4:	1e03      	subs	r3, r0, #0
 8009dc6:	d003      	beq.n	8009dd0 <MX_SPI1_Init+0x64>
  {
    Error_Handler(__func__);
 8009dc8:	4b05      	ldr	r3, [pc, #20]	; (8009de0 <MX_SPI1_Init+0x74>)
 8009dca:	0018      	movs	r0, r3
 8009dcc:	f000 fb3a 	bl	800a444 <Error_Handler>
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}
 8009dd0:	46c0      	nop			; (mov r8, r8)
 8009dd2:	46bd      	mov	sp, r7
 8009dd4:	bd80      	pop	{r7, pc}
 8009dd6:	46c0      	nop			; (mov r8, r8)
 8009dd8:	200004d0 	.word	0x200004d0
 8009ddc:	40013000 	.word	0x40013000
 8009de0:	0800e69c 	.word	0x0800e69c

08009de4 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 8009de4:	b590      	push	{r4, r7, lr}
 8009de6:	b089      	sub	sp, #36	; 0x24
 8009de8:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8009dea:	240c      	movs	r4, #12
 8009dec:	193b      	adds	r3, r7, r4
 8009dee:	0018      	movs	r0, r3
 8009df0:	2314      	movs	r3, #20
 8009df2:	001a      	movs	r2, r3
 8009df4:	2100      	movs	r1, #0
 8009df6:	f002 fd70 	bl	800c8da <memset>

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8009dfa:	4b32      	ldr	r3, [pc, #200]	; (8009ec4 <MX_GPIO_Init+0xe0>)
 8009dfc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8009dfe:	4b31      	ldr	r3, [pc, #196]	; (8009ec4 <MX_GPIO_Init+0xe0>)
 8009e00:	2101      	movs	r1, #1
 8009e02:	430a      	orrs	r2, r1
 8009e04:	62da      	str	r2, [r3, #44]	; 0x2c
 8009e06:	4b2f      	ldr	r3, [pc, #188]	; (8009ec4 <MX_GPIO_Init+0xe0>)
 8009e08:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009e0a:	2201      	movs	r2, #1
 8009e0c:	4013      	ands	r3, r2
 8009e0e:	60bb      	str	r3, [r7, #8]
 8009e10:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8009e12:	4b2c      	ldr	r3, [pc, #176]	; (8009ec4 <MX_GPIO_Init+0xe0>)
 8009e14:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8009e16:	4b2b      	ldr	r3, [pc, #172]	; (8009ec4 <MX_GPIO_Init+0xe0>)
 8009e18:	2102      	movs	r1, #2
 8009e1a:	430a      	orrs	r2, r1
 8009e1c:	62da      	str	r2, [r3, #44]	; 0x2c
 8009e1e:	4b29      	ldr	r3, [pc, #164]	; (8009ec4 <MX_GPIO_Init+0xe0>)
 8009e20:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009e22:	2202      	movs	r2, #2
 8009e24:	4013      	ands	r3, r2
 8009e26:	607b      	str	r3, [r7, #4]
 8009e28:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin : Reset_Pin */
  GPIO_InitStruct.Pin = Reset_Pin;
 8009e2a:	193b      	adds	r3, r7, r4
 8009e2c:	2201      	movs	r2, #1
 8009e2e:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8009e30:	193b      	adds	r3, r7, r4
 8009e32:	2201      	movs	r2, #1
 8009e34:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8009e36:	193b      	adds	r3, r7, r4
 8009e38:	2201      	movs	r2, #1
 8009e3a:	609a      	str	r2, [r3, #8]
  HAL_GPIO_Init(Reset_GPIO_Port, &GPIO_InitStruct);
 8009e3c:	193a      	adds	r2, r7, r4
 8009e3e:	23a0      	movs	r3, #160	; 0xa0
 8009e40:	05db      	lsls	r3, r3, #23
 8009e42:	0011      	movs	r1, r2
 8009e44:	0018      	movs	r0, r3
 8009e46:	f000 fe67 	bl	800ab18 <HAL_GPIO_Init>

  /*Configure GPIO pin : DIO0_Pin */
  GPIO_InitStruct.Pin = DIO0_Pin;
 8009e4a:	193b      	adds	r3, r7, r4
 8009e4c:	2280      	movs	r2, #128	; 0x80
 8009e4e:	00d2      	lsls	r2, r2, #3
 8009e50:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8009e52:	193b      	adds	r3, r7, r4
 8009e54:	4a1c      	ldr	r2, [pc, #112]	; (8009ec8 <MX_GPIO_Init+0xe4>)
 8009e56:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009e58:	193b      	adds	r3, r7, r4
 8009e5a:	2200      	movs	r2, #0
 8009e5c:	609a      	str	r2, [r3, #8]
  HAL_GPIO_Init(DIO0_GPIO_Port, &GPIO_InitStruct);
 8009e5e:	193a      	adds	r2, r7, r4
 8009e60:	23a0      	movs	r3, #160	; 0xa0
 8009e62:	05db      	lsls	r3, r3, #23
 8009e64:	0011      	movs	r1, r2
 8009e66:	0018      	movs	r0, r3
 8009e68:	f000 fe56 	bl	800ab18 <HAL_GPIO_Init>

  /*Configure GPIO pins : DIO1_Pin DIO3_Pin DIO2_Pin */
  GPIO_InitStruct.Pin = DIO1_Pin|DIO3_Pin|DIO2_Pin;
 8009e6c:	0021      	movs	r1, r4
 8009e6e:	187b      	adds	r3, r7, r1
 8009e70:	2238      	movs	r2, #56	; 0x38
 8009e72:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8009e74:	187b      	adds	r3, r7, r1
 8009e76:	4a14      	ldr	r2, [pc, #80]	; (8009ec8 <MX_GPIO_Init+0xe4>)
 8009e78:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009e7a:	187b      	adds	r3, r7, r1
 8009e7c:	2200      	movs	r2, #0
 8009e7e:	609a      	str	r2, [r3, #8]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8009e80:	000c      	movs	r4, r1
 8009e82:	187b      	adds	r3, r7, r1
 8009e84:	4a11      	ldr	r2, [pc, #68]	; (8009ecc <MX_GPIO_Init+0xe8>)
 8009e86:	0019      	movs	r1, r3
 8009e88:	0010      	movs	r0, r2
 8009e8a:	f000 fe45 	bl	800ab18 <HAL_GPIO_Init>

  /*Configure GPIO pin : NSS_Pin */
  GPIO_InitStruct.Pin = NSS_Pin;
 8009e8e:	0021      	movs	r1, r4
 8009e90:	187b      	adds	r3, r7, r1
 8009e92:	2240      	movs	r2, #64	; 0x40
 8009e94:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8009e96:	187b      	adds	r3, r7, r1
 8009e98:	2201      	movs	r2, #1
 8009e9a:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009e9c:	187b      	adds	r3, r7, r1
 8009e9e:	2200      	movs	r2, #0
 8009ea0:	609a      	str	r2, [r3, #8]
  HAL_GPIO_Init(NSS_GPIO_Port, &GPIO_InitStruct);
 8009ea2:	187b      	adds	r3, r7, r1
 8009ea4:	4a09      	ldr	r2, [pc, #36]	; (8009ecc <MX_GPIO_Init+0xe8>)
 8009ea6:	0019      	movs	r1, r3
 8009ea8:	0010      	movs	r0, r2
 8009eaa:	f000 fe35 	bl	800ab18 <HAL_GPIO_Init>

  HAL_GPIO_WritePin(NSS_GPIO_Port, NSS_Pin, GPIO_PIN_SET);
 8009eae:	4b07      	ldr	r3, [pc, #28]	; (8009ecc <MX_GPIO_Init+0xe8>)
 8009eb0:	2201      	movs	r2, #1
 8009eb2:	2140      	movs	r1, #64	; 0x40
 8009eb4:	0018      	movs	r0, r3
 8009eb6:	f000 ffad 	bl	800ae14 <HAL_GPIO_WritePin>



}
 8009eba:	46c0      	nop			; (mov r8, r8)
 8009ebc:	46bd      	mov	sp, r7
 8009ebe:	b009      	add	sp, #36	; 0x24
 8009ec0:	bd90      	pop	{r4, r7, pc}
 8009ec2:	46c0      	nop			; (mov r8, r8)
 8009ec4:	40021000 	.word	0x40021000
 8009ec8:	10110000 	.word	0x10110000
 8009ecc:	50000400 	.word	0x50000400

08009ed0 <LDL_System_ticks>:



//UNCOM get system time (ticks)
uint32_t LDL_System_ticks(void *app)
{
 8009ed0:	b580      	push	{r7, lr}
 8009ed2:	b082      	sub	sp, #8
 8009ed4:	af00      	add	r7, sp, #0
 8009ed6:	6078      	str	r0, [r7, #4]
    return GetTimer(); // Provide a tick value in millisecond.
 8009ed8:	f000 fa8a 	bl	800a3f0 <GetTimer>
 8009edc:	0003      	movs	r3, r0
}
 8009ede:	0018      	movs	r0, r3
 8009ee0:	46bd      	mov	sp, r7
 8009ee2:	b002      	add	sp, #8
 8009ee4:	bd80      	pop	{r7, pc}

08009ee6 <LDL_System_tps>:

//UNCOM ticks per second
uint32_t LDL_System_tps(void)
{
 8009ee6:	b580      	push	{r7, lr}
 8009ee8:	af00      	add	r7, sp, #0
    return 16384UL;  // Return tick frequency.
 8009eea:	2380      	movs	r3, #128	; 0x80
 8009eec:	01db      	lsls	r3, r3, #7
}
 8009eee:	0018      	movs	r0, r3
 8009ef0:	46bd      	mov	sp, r7
 8009ef2:	bd80      	pop	{r7, pc}

08009ef4 <LDL_System_eps>:

// UNCOM error per second
uint32_t LDL_System_eps(void)
{
 8009ef4:	b580      	push	{r7, lr}
 8009ef6:	af00      	add	r7, sp, #0

    return 0UL;
 8009ef8:	2300      	movs	r3, #0
}
 8009efa:	0018      	movs	r0, r3
 8009efc:	46bd      	mov	sp, r7
 8009efe:	bd80      	pop	{r7, pc}

08009f00 <SPI_InOut>:
//////////////////////// email contact@cjh.id.au



uint16_t SPI_InOut(uint16_t txData)
{
 8009f00:	b5b0      	push	{r4, r5, r7, lr}
 8009f02:	b086      	sub	sp, #24
 8009f04:	af02      	add	r7, sp, #8
 8009f06:	0002      	movs	r2, r0
 8009f08:	1dbb      	adds	r3, r7, #6
 8009f0a:	801a      	strh	r2, [r3, #0]
  uint16_t rxData ;
  HAL_StatusTypeDef status;
  status =HAL_SPI_TransmitReceive(&hspi1, (uint8_t *) &txData, (uint8_t *) &rxData, 1, HAL_MAX_DELAY);
 8009f0c:	250f      	movs	r5, #15
 8009f0e:	197c      	adds	r4, r7, r5
 8009f10:	230c      	movs	r3, #12
 8009f12:	18fa      	adds	r2, r7, r3
 8009f14:	1db9      	adds	r1, r7, #6
 8009f16:	4810      	ldr	r0, [pc, #64]	; (8009f58 <SPI_InOut+0x58>)
 8009f18:	2301      	movs	r3, #1
 8009f1a:	425b      	negs	r3, r3
 8009f1c:	9300      	str	r3, [sp, #0]
 8009f1e:	2301      	movs	r3, #1
 8009f20:	f002 fa3e 	bl	800c3a0 <HAL_SPI_TransmitReceive>
 8009f24:	0003      	movs	r3, r0
 8009f26:	7023      	strb	r3, [r4, #0]
  if(status!=HAL_OK)LDL_ERROR(TAG,"Error SPI");
 8009f28:	197b      	adds	r3, r7, r5
 8009f2a:	781b      	ldrb	r3, [r3, #0]
 8009f2c:	2b00      	cmp	r3, #0
 8009f2e:	d00b      	beq.n	8009f48 <SPI_InOut+0x48>
 8009f30:	4b0a      	ldr	r3, [pc, #40]	; (8009f5c <SPI_InOut+0x5c>)
 8009f32:	0018      	movs	r0, r3
 8009f34:	f002 fcda 	bl	800c8ec <iprintf>
 8009f38:	4b09      	ldr	r3, [pc, #36]	; (8009f60 <SPI_InOut+0x60>)
 8009f3a:	0018      	movs	r0, r3
 8009f3c:	f002 fcd6 	bl	800c8ec <iprintf>
 8009f40:	4b08      	ldr	r3, [pc, #32]	; (8009f64 <SPI_InOut+0x64>)
 8009f42:	0018      	movs	r0, r3
 8009f44:	f002 fd4c 	bl	800c9e0 <puts>
  return rxData;
 8009f48:	230c      	movs	r3, #12
 8009f4a:	18fb      	adds	r3, r7, r3
 8009f4c:	881b      	ldrh	r3, [r3, #0]
}
 8009f4e:	0018      	movs	r0, r3
 8009f50:	46bd      	mov	sp, r7
 8009f52:	b004      	add	sp, #16
 8009f54:	bdb0      	pop	{r4, r5, r7, pc}
 8009f56:	46c0      	nop			; (mov r8, r8)
 8009f58:	200004d0 	.word	0x200004d0
 8009f5c:	0800e1b0 	.word	0x0800e1b0
 8009f60:	0800e1bc 	.word	0x0800e1bc
 8009f64:	0800e13c 	.word	0x0800e13c

08009f68 <LDL_Chip_write>:

//UNCOM chip write
void LDL_Chip_write(void *self, uint8_t addr, const void *data, uint8_t size)
{
 8009f68:	b590      	push	{r4, r7, lr}
 8009f6a:	b087      	sub	sp, #28
 8009f6c:	af00      	add	r7, sp, #0
 8009f6e:	60f8      	str	r0, [r7, #12]
 8009f70:	0008      	movs	r0, r1
 8009f72:	607a      	str	r2, [r7, #4]
 8009f74:	0019      	movs	r1, r3
 8009f76:	240b      	movs	r4, #11
 8009f78:	193b      	adds	r3, r7, r4
 8009f7a:	1c02      	adds	r2, r0, #0
 8009f7c:	701a      	strb	r2, [r3, #0]
 8009f7e:	230a      	movs	r3, #10
 8009f80:	18fb      	adds	r3, r7, r3
 8009f82:	1c0a      	adds	r2, r1, #0
 8009f84:	701a      	strb	r2, [r3, #0]
    /* unused in this example */
    (void)self;

    const uint8_t *ptr = (uint8_t *)data;
 8009f86:	687b      	ldr	r3, [r7, #4]
 8009f88:	613b      	str	r3, [r7, #16]
    uint8_t i;
    //NSS = 0;
    HAL_GPIO_WritePin( NSS_GPIO_Port, NSS_Pin, GPIO_PIN_RESET );
 8009f8a:	4b1b      	ldr	r3, [pc, #108]	; (8009ff8 <LDL_Chip_write+0x90>)
 8009f8c:	2200      	movs	r2, #0
 8009f8e:	2140      	movs	r1, #64	; 0x40
 8009f90:	0018      	movs	r0, r3
 8009f92:	f000 ff3f 	bl	800ae14 <HAL_GPIO_WritePin>

    {
        /* SX1272/6 set the MSb of address indicate write */
    	SPI_InOut(addr |0x80);
 8009f96:	193b      	adds	r3, r7, r4
 8009f98:	781b      	ldrb	r3, [r3, #0]
 8009f9a:	2280      	movs	r2, #128	; 0x80
 8009f9c:	4252      	negs	r2, r2
 8009f9e:	4313      	orrs	r3, r2
 8009fa0:	b2db      	uxtb	r3, r3
 8009fa2:	b29b      	uxth	r3, r3
 8009fa4:	0018      	movs	r0, r3
 8009fa6:	f7ff ffab 	bl	8009f00 <SPI_InOut>

 //   	    LDL_INFO("SPI Transmit %d",addr)
    	  for(i=0; i < size; i++){
 8009faa:	2317      	movs	r3, #23
 8009fac:	18fb      	adds	r3, r7, r3
 8009fae:	2200      	movs	r2, #0
 8009fb0:	701a      	strb	r2, [r3, #0]
 8009fb2:	e00e      	b.n	8009fd2 <LDL_Chip_write+0x6a>
    		  SPI_InOut(ptr[i]);
 8009fb4:	2417      	movs	r4, #23
 8009fb6:	193b      	adds	r3, r7, r4
 8009fb8:	781b      	ldrb	r3, [r3, #0]
 8009fba:	693a      	ldr	r2, [r7, #16]
 8009fbc:	18d3      	adds	r3, r2, r3
 8009fbe:	781b      	ldrb	r3, [r3, #0]
 8009fc0:	b29b      	uxth	r3, r3
 8009fc2:	0018      	movs	r0, r3
 8009fc4:	f7ff ff9c 	bl	8009f00 <SPI_InOut>
    	  for(i=0; i < size; i++){
 8009fc8:	193b      	adds	r3, r7, r4
 8009fca:	781a      	ldrb	r2, [r3, #0]
 8009fcc:	193b      	adds	r3, r7, r4
 8009fce:	3201      	adds	r2, #1
 8009fd0:	701a      	strb	r2, [r3, #0]
 8009fd2:	2317      	movs	r3, #23
 8009fd4:	18fa      	adds	r2, r7, r3
 8009fd6:	230a      	movs	r3, #10
 8009fd8:	18fb      	adds	r3, r7, r3
 8009fda:	7812      	ldrb	r2, [r2, #0]
 8009fdc:	781b      	ldrb	r3, [r3, #0]
 8009fde:	429a      	cmp	r2, r3
 8009fe0:	d3e8      	bcc.n	8009fb4 <LDL_Chip_write+0x4c>
 //       	LDL_INFO("data transmiting %d ",ptr[i])
    	  }
    }
    //NSS = 1;
    HAL_GPIO_WritePin( NSS_GPIO_Port, NSS_Pin, GPIO_PIN_SET );
 8009fe2:	4b05      	ldr	r3, [pc, #20]	; (8009ff8 <LDL_Chip_write+0x90>)
 8009fe4:	2201      	movs	r2, #1
 8009fe6:	2140      	movs	r1, #64	; 0x40
 8009fe8:	0018      	movs	r0, r3
 8009fea:	f000 ff13 	bl	800ae14 <HAL_GPIO_WritePin>
}
 8009fee:	46c0      	nop			; (mov r8, r8)
 8009ff0:	46bd      	mov	sp, r7
 8009ff2:	b007      	add	sp, #28
 8009ff4:	bd90      	pop	{r4, r7, pc}
 8009ff6:	46c0      	nop			; (mov r8, r8)
 8009ff8:	50000400 	.word	0x50000400

08009ffc <LDL_Chip_read>:


//UNCOM chip Read
void LDL_Chip_read(void *self, uint8_t addr, void *data, uint8_t size)
{
 8009ffc:	b590      	push	{r4, r7, lr}
 8009ffe:	b087      	sub	sp, #28
 800a000:	af00      	add	r7, sp, #0
 800a002:	60f8      	str	r0, [r7, #12]
 800a004:	0008      	movs	r0, r1
 800a006:	607a      	str	r2, [r7, #4]
 800a008:	0019      	movs	r1, r3
 800a00a:	240b      	movs	r4, #11
 800a00c:	193b      	adds	r3, r7, r4
 800a00e:	1c02      	adds	r2, r0, #0
 800a010:	701a      	strb	r2, [r3, #0]
 800a012:	230a      	movs	r3, #10
 800a014:	18fb      	adds	r3, r7, r3
 800a016:	1c0a      	adds	r2, r1, #0
 800a018:	701a      	strb	r2, [r3, #0]
    /* unused in this example */
    (void)self;

    uint8_t *ptr = (uint8_t *)data;
 800a01a:	687b      	ldr	r3, [r7, #4]
 800a01c:	613b      	str	r3, [r7, #16]
    uint8_t i;
    //NSS = 0;
    HAL_GPIO_WritePin( NSS_GPIO_Port, NSS_Pin, GPIO_PIN_RESET );
 800a01e:	4b1b      	ldr	r3, [pc, #108]	; (800a08c <LDL_Chip_read+0x90>)
 800a020:	2200      	movs	r2, #0
 800a022:	2140      	movs	r1, #64	; 0x40
 800a024:	0018      	movs	r0, r3
 800a026:	f000 fef5 	bl	800ae14 <HAL_GPIO_WritePin>
    {
        /* SX1272/6 clear the MSb of address to indicate read */

    	SPI_InOut(addr&0x7fU);
 800a02a:	193b      	adds	r3, r7, r4
 800a02c:	781b      	ldrb	r3, [r3, #0]
 800a02e:	b29b      	uxth	r3, r3
 800a030:	227f      	movs	r2, #127	; 0x7f
 800a032:	4013      	ands	r3, r2
 800a034:	b29b      	uxth	r3, r3
 800a036:	0018      	movs	r0, r3
 800a038:	f7ff ff62 	bl	8009f00 <SPI_InOut>

  //	 LDL_INFO("SPI Receive %d",addr)

  	  for(i=0U; i < size; i++){
 800a03c:	2317      	movs	r3, #23
 800a03e:	18fb      	adds	r3, r7, r3
 800a040:	2200      	movs	r2, #0
 800a042:	701a      	strb	r2, [r3, #0]
 800a044:	e010      	b.n	800a068 <LDL_Chip_read+0x6c>

      ptr[i]=SPI_InOut(0);
 800a046:	2000      	movs	r0, #0
 800a048:	f7ff ff5a 	bl	8009f00 <SPI_InOut>
 800a04c:	0003      	movs	r3, r0
 800a04e:	0019      	movs	r1, r3
 800a050:	2017      	movs	r0, #23
 800a052:	183b      	adds	r3, r7, r0
 800a054:	781b      	ldrb	r3, [r3, #0]
 800a056:	693a      	ldr	r2, [r7, #16]
 800a058:	18d3      	adds	r3, r2, r3
 800a05a:	b2ca      	uxtb	r2, r1
 800a05c:	701a      	strb	r2, [r3, #0]
  	  for(i=0U; i < size; i++){
 800a05e:	183b      	adds	r3, r7, r0
 800a060:	781a      	ldrb	r2, [r3, #0]
 800a062:	183b      	adds	r3, r7, r0
 800a064:	3201      	adds	r2, #1
 800a066:	701a      	strb	r2, [r3, #0]
 800a068:	2317      	movs	r3, #23
 800a06a:	18fa      	adds	r2, r7, r3
 800a06c:	230a      	movs	r3, #10
 800a06e:	18fb      	adds	r3, r7, r3
 800a070:	7812      	ldrb	r2, [r2, #0]
 800a072:	781b      	ldrb	r3, [r3, #0]
 800a074:	429a      	cmp	r2, r3
 800a076:	d3e6      	bcc.n	800a046 <LDL_Chip_read+0x4a>

 // 	 LDL_INFO("SPI Receive %d",ptr[i])
        }
    }
    //NSS = 1;
    HAL_GPIO_WritePin( NSS_GPIO_Port, NSS_Pin, GPIO_PIN_SET );
 800a078:	4b04      	ldr	r3, [pc, #16]	; (800a08c <LDL_Chip_read+0x90>)
 800a07a:	2201      	movs	r2, #1
 800a07c:	2140      	movs	r1, #64	; 0x40
 800a07e:	0018      	movs	r0, r3
 800a080:	f000 fec8 	bl	800ae14 <HAL_GPIO_WritePin>
}
 800a084:	46c0      	nop			; (mov r8, r8)
 800a086:	46bd      	mov	sp, r7
 800a088:	b007      	add	sp, #28
 800a08a:	bd90      	pop	{r4, r7, pc}
 800a08c:	50000400 	.word	0x50000400

0800a090 <LDL_Chip_reset>:


//UNCOM chip reset
void LDL_Chip_reset(void *self, bool state)
{
 800a090:	b590      	push	{r4, r7, lr}
 800a092:	b089      	sub	sp, #36	; 0x24
 800a094:	af00      	add	r7, sp, #0
 800a096:	6078      	str	r0, [r7, #4]
 800a098:	000a      	movs	r2, r1
 800a09a:	1cfb      	adds	r3, r7, #3
 800a09c:	701a      	strb	r2, [r3, #0]

 __HAL_RCC_GPIOA_CLK_ENABLE();
 800a09e:	4b25      	ldr	r3, [pc, #148]	; (800a134 <LDL_Chip_reset+0xa4>)
 800a0a0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a0a2:	4b24      	ldr	r3, [pc, #144]	; (800a134 <LDL_Chip_reset+0xa4>)
 800a0a4:	2101      	movs	r1, #1
 800a0a6:	430a      	orrs	r2, r1
 800a0a8:	62da      	str	r2, [r3, #44]	; 0x2c
 800a0aa:	4b22      	ldr	r3, [pc, #136]	; (800a134 <LDL_Chip_reset+0xa4>)
 800a0ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a0ae:	2201      	movs	r2, #1
 800a0b0:	4013      	ands	r3, r2
 800a0b2:	60bb      	str	r3, [r7, #8]
 800a0b4:	68bb      	ldr	r3, [r7, #8]


   GPIO_InitTypeDef initStruct = { 0 };
 800a0b6:	240c      	movs	r4, #12
 800a0b8:	193b      	adds	r3, r7, r4
 800a0ba:	0018      	movs	r0, r3
 800a0bc:	2314      	movs	r3, #20
 800a0be:	001a      	movs	r2, r3
 800a0c0:	2100      	movs	r1, #0
 800a0c2:	f002 fc0a 	bl	800c8da <memset>

   initStruct.Pin = Reset_Pin ;
 800a0c6:	0021      	movs	r1, r4
 800a0c8:	187b      	adds	r3, r7, r1
 800a0ca:	2201      	movs	r2, #1
 800a0cc:	601a      	str	r2, [r3, #0]
   initStruct.Mode =GPIO_MODE_OUTPUT_PP;
 800a0ce:	187b      	adds	r3, r7, r1
 800a0d0:	2201      	movs	r2, #1
 800a0d2:	605a      	str	r2, [r3, #4]
   initStruct.Pull = GPIO_NOPULL;
 800a0d4:	187b      	adds	r3, r7, r1
 800a0d6:	2200      	movs	r2, #0
 800a0d8:	609a      	str	r2, [r3, #8]
   initStruct.Speed = GPIO_SPEED_HIGH;
 800a0da:	187b      	adds	r3, r7, r1
 800a0dc:	2203      	movs	r2, #3
 800a0de:	60da      	str	r2, [r3, #12]
   HAL_GPIO_Init(Reset_GPIO_Port, &initStruct);
 800a0e0:	187a      	adds	r2, r7, r1
 800a0e2:	23a0      	movs	r3, #160	; 0xa0
 800a0e4:	05db      	lsls	r3, r3, #23
 800a0e6:	0011      	movs	r1, r2
 800a0e8:	0018      	movs	r0, r3
 800a0ea:	f000 fd15 	bl	800ab18 <HAL_GPIO_Init>
     if(state){
 800a0ee:	1cfb      	adds	r3, r7, #3
 800a0f0:	781b      	ldrb	r3, [r3, #0]
 800a0f2:	2b00      	cmp	r3, #0
 800a0f4:	d00f      	beq.n	800a116 <LDL_Chip_reset+0x86>

         // pull down
           HAL_GPIO_Init(Reset_GPIO_Port, &initStruct);
 800a0f6:	230c      	movs	r3, #12
 800a0f8:	18fa      	adds	r2, r7, r3
 800a0fa:	23a0      	movs	r3, #160	; 0xa0
 800a0fc:	05db      	lsls	r3, r3, #23
 800a0fe:	0011      	movs	r1, r2
 800a100:	0018      	movs	r0, r3
 800a102:	f000 fd09 	bl	800ab18 <HAL_GPIO_Init>

           HAL_GPIO_WritePin( Reset_GPIO_Port, Reset_Pin, SET );
 800a106:	23a0      	movs	r3, #160	; 0xa0
 800a108:	05db      	lsls	r3, r3, #23
 800a10a:	2201      	movs	r2, #1
 800a10c:	2101      	movs	r1, #1
 800a10e:	0018      	movs	r0, r3
 800a110:	f000 fe80 	bl	800ae14 <HAL_GPIO_WritePin>
     else{
           initStruct.Mode = GPIO_NOPULL;
           HAL_GPIO_Init(Reset_GPIO_Port, &initStruct);
         // hiz
     }
}
 800a114:	e00a      	b.n	800a12c <LDL_Chip_reset+0x9c>
           initStruct.Mode = GPIO_NOPULL;
 800a116:	210c      	movs	r1, #12
 800a118:	187b      	adds	r3, r7, r1
 800a11a:	2200      	movs	r2, #0
 800a11c:	605a      	str	r2, [r3, #4]
           HAL_GPIO_Init(Reset_GPIO_Port, &initStruct);
 800a11e:	187a      	adds	r2, r7, r1
 800a120:	23a0      	movs	r3, #160	; 0xa0
 800a122:	05db      	lsls	r3, r3, #23
 800a124:	0011      	movs	r1, r2
 800a126:	0018      	movs	r0, r3
 800a128:	f000 fcf6 	bl	800ab18 <HAL_GPIO_Init>
}
 800a12c:	46c0      	nop			; (mov r8, r8)
 800a12e:	46bd      	mov	sp, r7
 800a130:	b009      	add	sp, #36	; 0x24
 800a132:	bd90      	pop	{r4, r7, pc}
 800a134:	40021000 	.word	0x40021000

0800a138 <HAL_GPIO_EXTI_Callback>:
////////////////////////

//UNCOM EXTI_CALLBACkS
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
 800a138:	b580      	push	{r7, lr}
 800a13a:	b082      	sub	sp, #8
 800a13c:	af00      	add	r7, sp, #0
 800a13e:	0002      	movs	r2, r0
 800a140:	1dbb      	adds	r3, r7, #6
 800a142:	801a      	strh	r2, [r3, #0]
	switch (GPIO_Pin) {
 800a144:	1dbb      	adds	r3, r7, #6
 800a146:	881b      	ldrh	r3, [r3, #0]
 800a148:	2b10      	cmp	r3, #16
 800a14a:	d01c      	beq.n	800a186 <HAL_GPIO_EXTI_Callback+0x4e>
 800a14c:	dc02      	bgt.n	800a154 <HAL_GPIO_EXTI_Callback+0x1c>
 800a14e:	2b08      	cmp	r3, #8
 800a150:	d00d      	beq.n	800a16e <HAL_GPIO_EXTI_Callback+0x36>
		break;
	case DIO3_Pin:
		LDL_Radio_interrupt(&radio, 3);
		break;
	default:
		break;
 800a152:	e01e      	b.n	800a192 <HAL_GPIO_EXTI_Callback+0x5a>
	switch (GPIO_Pin) {
 800a154:	2b20      	cmp	r3, #32
 800a156:	d010      	beq.n	800a17a <HAL_GPIO_EXTI_Callback+0x42>
 800a158:	2280      	movs	r2, #128	; 0x80
 800a15a:	00d2      	lsls	r2, r2, #3
 800a15c:	4293      	cmp	r3, r2
 800a15e:	d000      	beq.n	800a162 <HAL_GPIO_EXTI_Callback+0x2a>
		break;
 800a160:	e017      	b.n	800a192 <HAL_GPIO_EXTI_Callback+0x5a>
		LDL_Radio_interrupt(&radio, 0);
 800a162:	4b0e      	ldr	r3, [pc, #56]	; (800a19c <HAL_GPIO_EXTI_Callback+0x64>)
 800a164:	2100      	movs	r1, #0
 800a166:	0018      	movs	r0, r3
 800a168:	f7fd fe9d 	bl	8007ea6 <LDL_Radio_interrupt>
		break;
 800a16c:	e011      	b.n	800a192 <HAL_GPIO_EXTI_Callback+0x5a>
		LDL_Radio_interrupt(&radio, 1);
 800a16e:	4b0b      	ldr	r3, [pc, #44]	; (800a19c <HAL_GPIO_EXTI_Callback+0x64>)
 800a170:	2101      	movs	r1, #1
 800a172:	0018      	movs	r0, r3
 800a174:	f7fd fe97 	bl	8007ea6 <LDL_Radio_interrupt>
		break;
 800a178:	e00b      	b.n	800a192 <HAL_GPIO_EXTI_Callback+0x5a>
		LDL_Radio_interrupt(&radio, 2);
 800a17a:	4b08      	ldr	r3, [pc, #32]	; (800a19c <HAL_GPIO_EXTI_Callback+0x64>)
 800a17c:	2102      	movs	r1, #2
 800a17e:	0018      	movs	r0, r3
 800a180:	f7fd fe91 	bl	8007ea6 <LDL_Radio_interrupt>
		break;
 800a184:	e005      	b.n	800a192 <HAL_GPIO_EXTI_Callback+0x5a>
		LDL_Radio_interrupt(&radio, 3);
 800a186:	4b05      	ldr	r3, [pc, #20]	; (800a19c <HAL_GPIO_EXTI_Callback+0x64>)
 800a188:	2103      	movs	r1, #3
 800a18a:	0018      	movs	r0, r3
 800a18c:	f7fd fe8b 	bl	8007ea6 <LDL_Radio_interrupt>
		break;
 800a190:	46c0      	nop			; (mov r8, r8)
	}
}
 800a192:	46c0      	nop			; (mov r8, r8)
 800a194:	46bd      	mov	sp, r7
 800a196:	b002      	add	sp, #8
 800a198:	bd80      	pop	{r7, pc}
 800a19a:	46c0      	nop			; (mov r8, r8)
 800a19c:	20000490 	.word	0x20000490

0800a1a0 <enable_interrupts>:

void enable_interrupts(void){
 800a1a0:	b580      	push	{r7, lr}
 800a1a2:	af00      	add	r7, sp, #0

	  HAL_NVIC_SetPriority(EXTI2_3_IRQn, 0, 0);
 800a1a4:	2200      	movs	r2, #0
 800a1a6:	2100      	movs	r1, #0
 800a1a8:	2006      	movs	r0, #6
 800a1aa:	f000 fc83 	bl	800aab4 <HAL_NVIC_SetPriority>
	  HAL_NVIC_EnableIRQ(EXTI2_3_IRQn);
 800a1ae:	2006      	movs	r0, #6
 800a1b0:	f000 fc95 	bl	800aade <HAL_NVIC_EnableIRQ>

	  HAL_NVIC_SetPriority(EXTI4_15_IRQn, 0, 0);
 800a1b4:	2200      	movs	r2, #0
 800a1b6:	2100      	movs	r1, #0
 800a1b8:	2007      	movs	r0, #7
 800a1ba:	f000 fc7b 	bl	800aab4 <HAL_NVIC_SetPriority>
	  HAL_NVIC_EnableIRQ(EXTI4_15_IRQn);
 800a1be:	2007      	movs	r0, #7
 800a1c0:	f000 fc8d 	bl	800aade <HAL_NVIC_EnableIRQ>

	  HAL_NVIC_SetPriority(LPTIM1_IRQn, 0, 0);
 800a1c4:	2200      	movs	r2, #0
 800a1c6:	2100      	movs	r1, #0
 800a1c8:	200d      	movs	r0, #13
 800a1ca:	f000 fc73 	bl	800aab4 <HAL_NVIC_SetPriority>
	  HAL_NVIC_EnableIRQ(LPTIM1_IRQn);
 800a1ce:	200d      	movs	r0, #13
 800a1d0:	f000 fc85 	bl	800aade <HAL_NVIC_EnableIRQ>

}
 800a1d4:	46c0      	nop			; (mov r8, r8)
 800a1d6:	46bd      	mov	sp, r7
 800a1d8:	bd80      	pop	{r7, pc}
	...

0800a1dc <app_handler>:
//////////////////// application handler


void app_handler(void *app, enum ldl_mac_response_type type, const union ldl_mac_response_arg *arg)
{
 800a1dc:	b580      	push	{r7, lr}
 800a1de:	b084      	sub	sp, #16
 800a1e0:	af00      	add	r7, sp, #0
 800a1e2:	60f8      	str	r0, [r7, #12]
 800a1e4:	607a      	str	r2, [r7, #4]
 800a1e6:	200b      	movs	r0, #11
 800a1e8:	183b      	adds	r3, r7, r0
 800a1ea:	1c0a      	adds	r2, r1, #0
 800a1ec:	701a      	strb	r2, [r3, #0]

    switch(type){
 800a1ee:	183b      	adds	r3, r7, r0
 800a1f0:	781b      	ldrb	r3, [r3, #0]
 800a1f2:	2b0f      	cmp	r3, #15
 800a1f4:	d900      	bls.n	800a1f8 <app_handler+0x1c>
 800a1f6:	e0cf      	b.n	800a398 <app_handler+0x1bc>
 800a1f8:	009a      	lsls	r2, r3, #2
 800a1fa:	4b6a      	ldr	r3, [pc, #424]	; (800a3a4 <app_handler+0x1c8>)
 800a1fc:	18d3      	adds	r3, r2, r3
 800a1fe:	681b      	ldr	r3, [r3, #0]
 800a200:	469f      	mov	pc, r3
     * Applications that have no better source of entropy will use this
     * event to seed the stdlib random generator.
     *
     * */
    case LDL_MAC_STARTUP:
    	LDL_INFO(TAG,"LDL_MAC_STARTUP");
 800a202:	4b69      	ldr	r3, [pc, #420]	; (800a3a8 <app_handler+0x1cc>)
 800a204:	0018      	movs	r0, r3
 800a206:	f002 fb71 	bl	800c8ec <iprintf>
 800a20a:	4b68      	ldr	r3, [pc, #416]	; (800a3ac <app_handler+0x1d0>)
 800a20c:	0018      	movs	r0, r3
 800a20e:	f002 fb6d 	bl	800c8ec <iprintf>
 800a212:	4b67      	ldr	r3, [pc, #412]	; (800a3b0 <app_handler+0x1d4>)
 800a214:	0018      	movs	r0, r3
 800a216:	f002 fbe3 	bl	800c9e0 <puts>
        srand(arg->startup.entropy);
 800a21a:	687b      	ldr	r3, [r7, #4]
 800a21c:	681b      	ldr	r3, [r3, #0]
 800a21e:	0018      	movs	r0, r3
 800a220:	f002 fbe8 	bl	800c9f4 <srand>
        break;
 800a224:	e0b9      	b.n	800a39a <app_handler+0x1be>

    /* this is data from confirmed/unconfirmed down frames */
    case LDL_MAC_RX:
    	LDL_INFO(TAG,"LDL_MAC_RX");
 800a226:	4b60      	ldr	r3, [pc, #384]	; (800a3a8 <app_handler+0x1cc>)
 800a228:	0018      	movs	r0, r3
 800a22a:	f002 fb5f 	bl	800c8ec <iprintf>
 800a22e:	4b61      	ldr	r3, [pc, #388]	; (800a3b4 <app_handler+0x1d8>)
 800a230:	0018      	movs	r0, r3
 800a232:	f002 fb5b 	bl	800c8ec <iprintf>
 800a236:	4b5e      	ldr	r3, [pc, #376]	; (800a3b0 <app_handler+0x1d4>)
 800a238:	0018      	movs	r0, r3
 800a23a:	f002 fbd1 	bl	800c9e0 <puts>
        (void)arg->rx.port;
        (void)arg->rx.data;
        (void)arg->rx.size;
        break;
 800a23e:	e0ac      	b.n	800a39a <app_handler+0x1be>

    /* an opportunity for application to cache session */
    case LDL_MAC_SESSION_UPDATED:
    	LDL_INFO(TAG,"LDL_MAC_SESSION_UPDATED");
 800a240:	4b59      	ldr	r3, [pc, #356]	; (800a3a8 <app_handler+0x1cc>)
 800a242:	0018      	movs	r0, r3
 800a244:	f002 fb52 	bl	800c8ec <iprintf>
 800a248:	4b5b      	ldr	r3, [pc, #364]	; (800a3b8 <app_handler+0x1dc>)
 800a24a:	0018      	movs	r0, r3
 800a24c:	f002 fb4e 	bl	800c8ec <iprintf>
 800a250:	4b57      	ldr	r3, [pc, #348]	; (800a3b0 <app_handler+0x1d4>)
 800a252:	0018      	movs	r0, r3
 800a254:	f002 fbc4 	bl	800c9e0 <puts>
        (void)arg->session_updated.session;
        break;
 800a258:	e09f      	b.n	800a39a <app_handler+0x1be>
     * - cache session keys
     * - view join parameters (which are stored as part of session state)
     *
     * */
    case LDL_MAC_JOIN_COMPLETE:
    	LDL_INFO(TAG, "LDL_MAC_JOIN_COMPLETE nextDevNonce=%d joinNonce=%d", arg->join_complete.nextDevNonce, arg->join_complete.joinNonce);
 800a25a:	4b53      	ldr	r3, [pc, #332]	; (800a3a8 <app_handler+0x1cc>)
 800a25c:	0018      	movs	r0, r3
 800a25e:	f002 fb45 	bl	800c8ec <iprintf>
 800a262:	687b      	ldr	r3, [r7, #4]
 800a264:	889b      	ldrh	r3, [r3, #4]
 800a266:	0019      	movs	r1, r3
 800a268:	687b      	ldr	r3, [r7, #4]
 800a26a:	681a      	ldr	r2, [r3, #0]
 800a26c:	4b53      	ldr	r3, [pc, #332]	; (800a3bc <app_handler+0x1e0>)
 800a26e:	0018      	movs	r0, r3
 800a270:	f002 fb3c 	bl	800c8ec <iprintf>
 800a274:	4b4e      	ldr	r3, [pc, #312]	; (800a3b0 <app_handler+0x1d4>)
 800a276:	0018      	movs	r0, r3
 800a278:	f002 fbb2 	bl	800c9e0 <puts>


        break;
 800a27c:	e08d      	b.n	800a39a <app_handler+0x1be>

    case LDL_MAC_CHIP_ERROR:LDL_INFO(TAG,"LDL_MAC_CHIP_ERROR");
 800a27e:	4b4a      	ldr	r3, [pc, #296]	; (800a3a8 <app_handler+0x1cc>)
 800a280:	0018      	movs	r0, r3
 800a282:	f002 fb33 	bl	800c8ec <iprintf>
 800a286:	4b4e      	ldr	r3, [pc, #312]	; (800a3c0 <app_handler+0x1e4>)
 800a288:	0018      	movs	r0, r3
 800a28a:	f002 fb2f 	bl	800c8ec <iprintf>
 800a28e:	4b48      	ldr	r3, [pc, #288]	; (800a3b0 <app_handler+0x1d4>)
 800a290:	0018      	movs	r0, r3
 800a292:	f002 fba5 	bl	800c9e0 <puts>
    case LDL_MAC_RESET:LDL_INFO(TAG,"LDL_MAC_RESET");
 800a296:	4b44      	ldr	r3, [pc, #272]	; (800a3a8 <app_handler+0x1cc>)
 800a298:	0018      	movs	r0, r3
 800a29a:	f002 fb27 	bl	800c8ec <iprintf>
 800a29e:	4b49      	ldr	r3, [pc, #292]	; (800a3c4 <app_handler+0x1e8>)
 800a2a0:	0018      	movs	r0, r3
 800a2a2:	f002 fb23 	bl	800c8ec <iprintf>
 800a2a6:	4b42      	ldr	r3, [pc, #264]	; (800a3b0 <app_handler+0x1d4>)
 800a2a8:	0018      	movs	r0, r3
 800a2aa:	f002 fb99 	bl	800c9e0 <puts>
    case LDL_MAC_JOIN_TIMEOUT:LDL_INFO(TAG,"LDL_MAC_JOIN_TIMEOUT");
 800a2ae:	4b3e      	ldr	r3, [pc, #248]	; (800a3a8 <app_handler+0x1cc>)
 800a2b0:	0018      	movs	r0, r3
 800a2b2:	f002 fb1b 	bl	800c8ec <iprintf>
 800a2b6:	4b44      	ldr	r3, [pc, #272]	; (800a3c8 <app_handler+0x1ec>)
 800a2b8:	0018      	movs	r0, r3
 800a2ba:	f002 fb17 	bl	800c8ec <iprintf>
 800a2be:	4b3c      	ldr	r3, [pc, #240]	; (800a3b0 <app_handler+0x1d4>)
 800a2c0:	0018      	movs	r0, r3
 800a2c2:	f002 fb8d 	bl	800c9e0 <puts>
    case LDL_MAC_DATA_COMPLETE:LDL_INFO(TAG,"LDL_MAC_DATA_COMPLETE");
 800a2c6:	4b38      	ldr	r3, [pc, #224]	; (800a3a8 <app_handler+0x1cc>)
 800a2c8:	0018      	movs	r0, r3
 800a2ca:	f002 fb0f 	bl	800c8ec <iprintf>
 800a2ce:	4b3f      	ldr	r3, [pc, #252]	; (800a3cc <app_handler+0x1f0>)
 800a2d0:	0018      	movs	r0, r3
 800a2d2:	f002 fb0b 	bl	800c8ec <iprintf>
 800a2d6:	4b36      	ldr	r3, [pc, #216]	; (800a3b0 <app_handler+0x1d4>)
 800a2d8:	0018      	movs	r0, r3
 800a2da:	f002 fb81 	bl	800c9e0 <puts>
    case LDL_MAC_DATA_TIMEOUT:LDL_INFO(TAG,"LDL_MAC_DATA_TIMEOUT");
 800a2de:	4b32      	ldr	r3, [pc, #200]	; (800a3a8 <app_handler+0x1cc>)
 800a2e0:	0018      	movs	r0, r3
 800a2e2:	f002 fb03 	bl	800c8ec <iprintf>
 800a2e6:	4b3a      	ldr	r3, [pc, #232]	; (800a3d0 <app_handler+0x1f4>)
 800a2e8:	0018      	movs	r0, r3
 800a2ea:	f002 faff 	bl	800c8ec <iprintf>
 800a2ee:	4b30      	ldr	r3, [pc, #192]	; (800a3b0 <app_handler+0x1d4>)
 800a2f0:	0018      	movs	r0, r3
 800a2f2:	f002 fb75 	bl	800c9e0 <puts>
    case LDL_MAC_DATA_NAK:LDL_INFO(TAG,"LDL_MAC_DATA_NAK");
 800a2f6:	4b2c      	ldr	r3, [pc, #176]	; (800a3a8 <app_handler+0x1cc>)
 800a2f8:	0018      	movs	r0, r3
 800a2fa:	f002 faf7 	bl	800c8ec <iprintf>
 800a2fe:	4b35      	ldr	r3, [pc, #212]	; (800a3d4 <app_handler+0x1f8>)
 800a300:	0018      	movs	r0, r3
 800a302:	f002 faf3 	bl	800c8ec <iprintf>
 800a306:	4b2a      	ldr	r3, [pc, #168]	; (800a3b0 <app_handler+0x1d4>)
 800a308:	0018      	movs	r0, r3
 800a30a:	f002 fb69 	bl	800c9e0 <puts>
    case LDL_MAC_LINK_STATUS:LDL_INFO(TAG,"LDL_MAC_LINK_STATUS");
 800a30e:	4b26      	ldr	r3, [pc, #152]	; (800a3a8 <app_handler+0x1cc>)
 800a310:	0018      	movs	r0, r3
 800a312:	f002 faeb 	bl	800c8ec <iprintf>
 800a316:	4b30      	ldr	r3, [pc, #192]	; (800a3d8 <app_handler+0x1fc>)
 800a318:	0018      	movs	r0, r3
 800a31a:	f002 fae7 	bl	800c8ec <iprintf>
 800a31e:	4b24      	ldr	r3, [pc, #144]	; (800a3b0 <app_handler+0x1d4>)
 800a320:	0018      	movs	r0, r3
 800a322:	f002 fb5d 	bl	800c9e0 <puts>
    case LDL_MAC_RX1_SLOT:LDL_INFO(TAG,"LDL_MAC_RX1_SLOT");
 800a326:	4b20      	ldr	r3, [pc, #128]	; (800a3a8 <app_handler+0x1cc>)
 800a328:	0018      	movs	r0, r3
 800a32a:	f002 fadf 	bl	800c8ec <iprintf>
 800a32e:	4b2b      	ldr	r3, [pc, #172]	; (800a3dc <app_handler+0x200>)
 800a330:	0018      	movs	r0, r3
 800a332:	f002 fadb 	bl	800c8ec <iprintf>
 800a336:	4b1e      	ldr	r3, [pc, #120]	; (800a3b0 <app_handler+0x1d4>)
 800a338:	0018      	movs	r0, r3
 800a33a:	f002 fb51 	bl	800c9e0 <puts>
    case LDL_MAC_RX2_SLOT:LDL_INFO(TAG,"LDL_MAC_RX2_SLOT");
 800a33e:	4b1a      	ldr	r3, [pc, #104]	; (800a3a8 <app_handler+0x1cc>)
 800a340:	0018      	movs	r0, r3
 800a342:	f002 fad3 	bl	800c8ec <iprintf>
 800a346:	4b26      	ldr	r3, [pc, #152]	; (800a3e0 <app_handler+0x204>)
 800a348:	0018      	movs	r0, r3
 800a34a:	f002 facf 	bl	800c8ec <iprintf>
 800a34e:	4b18      	ldr	r3, [pc, #96]	; (800a3b0 <app_handler+0x1d4>)
 800a350:	0018      	movs	r0, r3
 800a352:	f002 fb45 	bl	800c9e0 <puts>
    case LDL_MAC_TX_COMPLETE:LDL_INFO(TAG,"LDL_MAC_TX_COMPLETE");
 800a356:	4b14      	ldr	r3, [pc, #80]	; (800a3a8 <app_handler+0x1cc>)
 800a358:	0018      	movs	r0, r3
 800a35a:	f002 fac7 	bl	800c8ec <iprintf>
 800a35e:	4b21      	ldr	r3, [pc, #132]	; (800a3e4 <app_handler+0x208>)
 800a360:	0018      	movs	r0, r3
 800a362:	f002 fac3 	bl	800c8ec <iprintf>
 800a366:	4b12      	ldr	r3, [pc, #72]	; (800a3b0 <app_handler+0x1d4>)
 800a368:	0018      	movs	r0, r3
 800a36a:	f002 fb39 	bl	800c9e0 <puts>
    case LDL_MAC_TX_BEGIN:LDL_INFO(TAG, "LDL_MAC_TX_BEGIN devNonce=%d joinNonce=%d", mac.devNonce, mac.joinNonce);
 800a36e:	4b0e      	ldr	r3, [pc, #56]	; (800a3a8 <app_handler+0x1cc>)
 800a370:	0018      	movs	r0, r3
 800a372:	f002 fabb 	bl	800c8ec <iprintf>
 800a376:	4a1c      	ldr	r2, [pc, #112]	; (800a3e8 <app_handler+0x20c>)
 800a378:	239a      	movs	r3, #154	; 0x9a
 800a37a:	005b      	lsls	r3, r3, #1
 800a37c:	5ad3      	ldrh	r3, [r2, r3]
 800a37e:	0019      	movs	r1, r3
 800a380:	4a19      	ldr	r2, [pc, #100]	; (800a3e8 <app_handler+0x20c>)
 800a382:	239c      	movs	r3, #156	; 0x9c
 800a384:	005b      	lsls	r3, r3, #1
 800a386:	58d2      	ldr	r2, [r2, r3]
 800a388:	4b18      	ldr	r3, [pc, #96]	; (800a3ec <app_handler+0x210>)
 800a38a:	0018      	movs	r0, r3
 800a38c:	f002 faae 	bl	800c8ec <iprintf>
 800a390:	4b07      	ldr	r3, [pc, #28]	; (800a3b0 <app_handler+0x1d4>)
 800a392:	0018      	movs	r0, r3
 800a394:	f002 fb24 	bl	800c9e0 <puts>
    default:
        break;
 800a398:	46c0      	nop			; (mov r8, r8)
    }
}
 800a39a:	46c0      	nop			; (mov r8, r8)
 800a39c:	46bd      	mov	sp, r7
 800a39e:	b004      	add	sp, #16
 800a3a0:	bd80      	pop	{r7, pc}
 800a3a2:	46c0      	nop			; (mov r8, r8)
 800a3a4:	0800e628 	.word	0x0800e628
 800a3a8:	0800e12c 	.word	0x0800e12c
 800a3ac:	0800e1c8 	.word	0x0800e1c8
 800a3b0:	0800e13c 	.word	0x0800e13c
 800a3b4:	0800e1d8 	.word	0x0800e1d8
 800a3b8:	0800e1e4 	.word	0x0800e1e4
 800a3bc:	0800e1fc 	.word	0x0800e1fc
 800a3c0:	0800e230 	.word	0x0800e230
 800a3c4:	0800e244 	.word	0x0800e244
 800a3c8:	0800e254 	.word	0x0800e254
 800a3cc:	0800e26c 	.word	0x0800e26c
 800a3d0:	0800e284 	.word	0x0800e284
 800a3d4:	0800e29c 	.word	0x0800e29c
 800a3d8:	0800e2b0 	.word	0x0800e2b0
 800a3dc:	0800e2c4 	.word	0x0800e2c4
 800a3e0:	0800e2d8 	.word	0x0800e2d8
 800a3e4:	0800e2ec 	.word	0x0800e2ec
 800a3e8:	200001bc 	.word	0x200001bc
 800a3ec:	0800e300 	.word	0x0800e300

0800a3f0 <GetTimer>:

uint32_t GetTimer(){
 800a3f0:	b580      	push	{r7, lr}
 800a3f2:	b082      	sub	sp, #8
 800a3f4:	af00      	add	r7, sp, #0

	uint32_t temp2 =(uint16_t)Lpcounter;
 800a3f6:	4b09      	ldr	r3, [pc, #36]	; (800a41c <GetTimer+0x2c>)
 800a3f8:	881b      	ldrh	r3, [r3, #0]
 800a3fa:	607b      	str	r3, [r7, #4]
	temp2 = (temp2 << 16);
 800a3fc:	687b      	ldr	r3, [r7, #4]
 800a3fe:	041b      	lsls	r3, r3, #16
 800a400:	607b      	str	r3, [r7, #4]
	temp2|= HAL_LPTIM_ReadCounter(&hlptim1);
 800a402:	4b07      	ldr	r3, [pc, #28]	; (800a420 <GetTimer+0x30>)
 800a404:	0018      	movs	r0, r3
 800a406:	f000 ff41 	bl	800b28c <HAL_LPTIM_ReadCounter>
 800a40a:	0002      	movs	r2, r0
 800a40c:	687b      	ldr	r3, [r7, #4]
 800a40e:	4313      	orrs	r3, r2
 800a410:	607b      	str	r3, [r7, #4]

	return temp2;
 800a412:	687b      	ldr	r3, [r7, #4]
}
 800a414:	0018      	movs	r0, r3
 800a416:	46bd      	mov	sp, r7
 800a418:	b002      	add	sp, #8
 800a41a:	bd80      	pop	{r7, pc}
 800a41c:	200005a8 	.word	0x200005a8
 800a420:	200004a0 	.word	0x200004a0

0800a424 <HAL_LPTIM_AutoReloadMatchCallback>:

void HAL_LPTIM_AutoReloadMatchCallback(LPTIM_HandleTypeDef *hlptim)
{
 800a424:	b580      	push	{r7, lr}
 800a426:	b082      	sub	sp, #8
 800a428:	af00      	add	r7, sp, #0
 800a42a:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
	Lpcounter++;
 800a42c:	4b04      	ldr	r3, [pc, #16]	; (800a440 <HAL_LPTIM_AutoReloadMatchCallback+0x1c>)
 800a42e:	881b      	ldrh	r3, [r3, #0]
 800a430:	3301      	adds	r3, #1
 800a432:	b29a      	uxth	r2, r3
 800a434:	4b02      	ldr	r3, [pc, #8]	; (800a440 <HAL_LPTIM_AutoReloadMatchCallback+0x1c>)
 800a436:	801a      	strh	r2, [r3, #0]
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_AutoReloadWriteCallback could be implemented in the user file
   */
}
 800a438:	46c0      	nop			; (mov r8, r8)
 800a43a:	46bd      	mov	sp, r7
 800a43c:	b002      	add	sp, #8
 800a43e:	bd80      	pop	{r7, pc}
 800a440:	200005a8 	.word	0x200005a8

0800a444 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(char const * caller_name)
{
 800a444:	b580      	push	{r7, lr}
 800a446:	b082      	sub	sp, #8
 800a448:	af00      	add	r7, sp, #0
 800a44a:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}
 800a44c:	46c0      	nop			; (mov r8, r8)
 800a44e:	46bd      	mov	sp, r7
 800a450:	b002      	add	sp, #8
 800a452:	bd80      	pop	{r7, pc}

0800a454 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800a454:	b580      	push	{r7, lr}
 800a456:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800a458:	4b0b      	ldr	r3, [pc, #44]	; (800a488 <HAL_MspInit+0x34>)
 800a45a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800a45c:	4b0a      	ldr	r3, [pc, #40]	; (800a488 <HAL_MspInit+0x34>)
 800a45e:	2101      	movs	r1, #1
 800a460:	430a      	orrs	r2, r1
 800a462:	635a      	str	r2, [r3, #52]	; 0x34
  __HAL_RCC_PWR_CLK_ENABLE();
 800a464:	4b08      	ldr	r3, [pc, #32]	; (800a488 <HAL_MspInit+0x34>)
 800a466:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800a468:	4b07      	ldr	r3, [pc, #28]	; (800a488 <HAL_MspInit+0x34>)
 800a46a:	2180      	movs	r1, #128	; 0x80
 800a46c:	0549      	lsls	r1, r1, #21
 800a46e:	430a      	orrs	r2, r1
 800a470:	639a      	str	r2, [r3, #56]	; 0x38

  /* System interrupt init*/

  /* Peripheral interrupt init */
  /* PVD_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PVD_IRQn, 0, 0);
 800a472:	2200      	movs	r2, #0
 800a474:	2100      	movs	r1, #0
 800a476:	2001      	movs	r0, #1
 800a478:	f000 fb1c 	bl	800aab4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(PVD_IRQn);
 800a47c:	2001      	movs	r0, #1
 800a47e:	f000 fb2e 	bl	800aade <HAL_NVIC_EnableIRQ>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800a482:	46c0      	nop			; (mov r8, r8)
 800a484:	46bd      	mov	sp, r7
 800a486:	bd80      	pop	{r7, pc}
 800a488:	40021000 	.word	0x40021000

0800a48c <HAL_I2C_MspInit>:
* This function configures the hardware resources used in this example
* @param hi2c: I2C handle pointer
* @retval None
*/
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 800a48c:	b590      	push	{r4, r7, lr}
 800a48e:	b08b      	sub	sp, #44	; 0x2c
 800a490:	af00      	add	r7, sp, #0
 800a492:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800a494:	2314      	movs	r3, #20
 800a496:	18fb      	adds	r3, r7, r3
 800a498:	0018      	movs	r0, r3
 800a49a:	2314      	movs	r3, #20
 800a49c:	001a      	movs	r2, r3
 800a49e:	2100      	movs	r1, #0
 800a4a0:	f002 fa1b 	bl	800c8da <memset>
  if(hi2c->Instance==I2C1)
 800a4a4:	687b      	ldr	r3, [r7, #4]
 800a4a6:	681b      	ldr	r3, [r3, #0]
 800a4a8:	4a2a      	ldr	r2, [pc, #168]	; (800a554 <HAL_I2C_MspInit+0xc8>)
 800a4aa:	4293      	cmp	r3, r2
 800a4ac:	d14d      	bne.n	800a54a <HAL_I2C_MspInit+0xbe>
  {
  /* USER CODE BEGIN I2C1_MspInit 0 */

  /* USER CODE END I2C1_MspInit 0 */
  
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800a4ae:	4b2a      	ldr	r3, [pc, #168]	; (800a558 <HAL_I2C_MspInit+0xcc>)
 800a4b0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a4b2:	4b29      	ldr	r3, [pc, #164]	; (800a558 <HAL_I2C_MspInit+0xcc>)
 800a4b4:	2101      	movs	r1, #1
 800a4b6:	430a      	orrs	r2, r1
 800a4b8:	62da      	str	r2, [r3, #44]	; 0x2c
 800a4ba:	4b27      	ldr	r3, [pc, #156]	; (800a558 <HAL_I2C_MspInit+0xcc>)
 800a4bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a4be:	2201      	movs	r2, #1
 800a4c0:	4013      	ands	r3, r2
 800a4c2:	613b      	str	r3, [r7, #16]
 800a4c4:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800a4c6:	4b24      	ldr	r3, [pc, #144]	; (800a558 <HAL_I2C_MspInit+0xcc>)
 800a4c8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a4ca:	4b23      	ldr	r3, [pc, #140]	; (800a558 <HAL_I2C_MspInit+0xcc>)
 800a4cc:	2102      	movs	r1, #2
 800a4ce:	430a      	orrs	r2, r1
 800a4d0:	62da      	str	r2, [r3, #44]	; 0x2c
 800a4d2:	4b21      	ldr	r3, [pc, #132]	; (800a558 <HAL_I2C_MspInit+0xcc>)
 800a4d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a4d6:	2202      	movs	r2, #2
 800a4d8:	4013      	ands	r3, r2
 800a4da:	60fb      	str	r3, [r7, #12]
 800a4dc:	68fb      	ldr	r3, [r7, #12]
    /**I2C1 GPIO Configuration    
    PA9     ------> I2C1_SCL
    PB7     ------> I2C1_SDA 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9;
 800a4de:	2114      	movs	r1, #20
 800a4e0:	187b      	adds	r3, r7, r1
 800a4e2:	2280      	movs	r2, #128	; 0x80
 800a4e4:	0092      	lsls	r2, r2, #2
 800a4e6:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 800a4e8:	000c      	movs	r4, r1
 800a4ea:	193b      	adds	r3, r7, r4
 800a4ec:	2212      	movs	r2, #18
 800a4ee:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800a4f0:	193b      	adds	r3, r7, r4
 800a4f2:	2201      	movs	r2, #1
 800a4f4:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a4f6:	193b      	adds	r3, r7, r4
 800a4f8:	2203      	movs	r2, #3
 800a4fa:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF6_I2C1;
 800a4fc:	193b      	adds	r3, r7, r4
 800a4fe:	2206      	movs	r2, #6
 800a500:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800a502:	193a      	adds	r2, r7, r4
 800a504:	23a0      	movs	r3, #160	; 0xa0
 800a506:	05db      	lsls	r3, r3, #23
 800a508:	0011      	movs	r1, r2
 800a50a:	0018      	movs	r0, r3
 800a50c:	f000 fb04 	bl	800ab18 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_7;
 800a510:	0021      	movs	r1, r4
 800a512:	187b      	adds	r3, r7, r1
 800a514:	2280      	movs	r2, #128	; 0x80
 800a516:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 800a518:	187b      	adds	r3, r7, r1
 800a51a:	2212      	movs	r2, #18
 800a51c:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800a51e:	187b      	adds	r3, r7, r1
 800a520:	2201      	movs	r2, #1
 800a522:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a524:	187b      	adds	r3, r7, r1
 800a526:	2203      	movs	r2, #3
 800a528:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF1_I2C1;
 800a52a:	187b      	adds	r3, r7, r1
 800a52c:	2201      	movs	r2, #1
 800a52e:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800a530:	187b      	adds	r3, r7, r1
 800a532:	4a0a      	ldr	r2, [pc, #40]	; (800a55c <HAL_I2C_MspInit+0xd0>)
 800a534:	0019      	movs	r1, r3
 800a536:	0010      	movs	r0, r2
 800a538:	f000 faee 	bl	800ab18 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
 800a53c:	4b06      	ldr	r3, [pc, #24]	; (800a558 <HAL_I2C_MspInit+0xcc>)
 800a53e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800a540:	4b05      	ldr	r3, [pc, #20]	; (800a558 <HAL_I2C_MspInit+0xcc>)
 800a542:	2180      	movs	r1, #128	; 0x80
 800a544:	0389      	lsls	r1, r1, #14
 800a546:	430a      	orrs	r2, r1
 800a548:	639a      	str	r2, [r3, #56]	; 0x38
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }

}
 800a54a:	46c0      	nop			; (mov r8, r8)
 800a54c:	46bd      	mov	sp, r7
 800a54e:	b00b      	add	sp, #44	; 0x2c
 800a550:	bd90      	pop	{r4, r7, pc}
 800a552:	46c0      	nop			; (mov r8, r8)
 800a554:	40005400 	.word	0x40005400
 800a558:	40021000 	.word	0x40021000
 800a55c:	50000400 	.word	0x50000400

0800a560 <HAL_LPTIM_MspInit>:
* This function configures the hardware resources used in this example
* @param hlptim: LPTIM handle pointer
* @retval None
*/
void HAL_LPTIM_MspInit(LPTIM_HandleTypeDef* hlptim)
{
 800a560:	b580      	push	{r7, lr}
 800a562:	b082      	sub	sp, #8
 800a564:	af00      	add	r7, sp, #0
 800a566:	6078      	str	r0, [r7, #4]
  if(hlptim->Instance==LPTIM1)
 800a568:	687b      	ldr	r3, [r7, #4]
 800a56a:	681b      	ldr	r3, [r3, #0]
 800a56c:	4a0a      	ldr	r2, [pc, #40]	; (800a598 <HAL_LPTIM_MspInit+0x38>)
 800a56e:	4293      	cmp	r3, r2
 800a570:	d10e      	bne.n	800a590 <HAL_LPTIM_MspInit+0x30>
  {
  /* USER CODE BEGIN LPTIM1_MspInit 0 */

  /* USER CODE END LPTIM1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_LPTIM1_CLK_ENABLE();
 800a572:	4b0a      	ldr	r3, [pc, #40]	; (800a59c <HAL_LPTIM_MspInit+0x3c>)
 800a574:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800a576:	4b09      	ldr	r3, [pc, #36]	; (800a59c <HAL_LPTIM_MspInit+0x3c>)
 800a578:	2180      	movs	r1, #128	; 0x80
 800a57a:	0609      	lsls	r1, r1, #24
 800a57c:	430a      	orrs	r2, r1
 800a57e:	639a      	str	r2, [r3, #56]	; 0x38
    /* LPTIM1 interrupt Init */
    HAL_NVIC_SetPriority(LPTIM1_IRQn, 0, 0);
 800a580:	2200      	movs	r2, #0
 800a582:	2100      	movs	r1, #0
 800a584:	200d      	movs	r0, #13
 800a586:	f000 fa95 	bl	800aab4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(LPTIM1_IRQn);
 800a58a:	200d      	movs	r0, #13
 800a58c:	f000 faa7 	bl	800aade <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN LPTIM1_MspInit 1 */

  /* USER CODE END LPTIM1_MspInit 1 */
  }

}
 800a590:	46c0      	nop			; (mov r8, r8)
 800a592:	46bd      	mov	sp, r7
 800a594:	b002      	add	sp, #8
 800a596:	bd80      	pop	{r7, pc}
 800a598:	40007c00 	.word	0x40007c00
 800a59c:	40021000 	.word	0x40021000

0800a5a0 <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 800a5a0:	b580      	push	{r7, lr}
 800a5a2:	b088      	sub	sp, #32
 800a5a4:	af00      	add	r7, sp, #0
 800a5a6:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800a5a8:	230c      	movs	r3, #12
 800a5aa:	18fb      	adds	r3, r7, r3
 800a5ac:	0018      	movs	r0, r3
 800a5ae:	2314      	movs	r3, #20
 800a5b0:	001a      	movs	r2, r3
 800a5b2:	2100      	movs	r1, #0
 800a5b4:	f002 f991 	bl	800c8da <memset>
  if(hspi->Instance==SPI1)
 800a5b8:	687b      	ldr	r3, [r7, #4]
 800a5ba:	681b      	ldr	r3, [r3, #0]
 800a5bc:	4a18      	ldr	r2, [pc, #96]	; (800a620 <HAL_SPI_MspInit+0x80>)
 800a5be:	4293      	cmp	r3, r2
 800a5c0:	d129      	bne.n	800a616 <HAL_SPI_MspInit+0x76>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 800a5c2:	4b18      	ldr	r3, [pc, #96]	; (800a624 <HAL_SPI_MspInit+0x84>)
 800a5c4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800a5c6:	4b17      	ldr	r3, [pc, #92]	; (800a624 <HAL_SPI_MspInit+0x84>)
 800a5c8:	2180      	movs	r1, #128	; 0x80
 800a5ca:	0149      	lsls	r1, r1, #5
 800a5cc:	430a      	orrs	r2, r1
 800a5ce:	635a      	str	r2, [r3, #52]	; 0x34
  
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800a5d0:	4b14      	ldr	r3, [pc, #80]	; (800a624 <HAL_SPI_MspInit+0x84>)
 800a5d2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a5d4:	4b13      	ldr	r3, [pc, #76]	; (800a624 <HAL_SPI_MspInit+0x84>)
 800a5d6:	2101      	movs	r1, #1
 800a5d8:	430a      	orrs	r2, r1
 800a5da:	62da      	str	r2, [r3, #44]	; 0x2c
 800a5dc:	4b11      	ldr	r3, [pc, #68]	; (800a624 <HAL_SPI_MspInit+0x84>)
 800a5de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a5e0:	2201      	movs	r2, #1
 800a5e2:	4013      	ands	r3, r2
 800a5e4:	60bb      	str	r3, [r7, #8]
 800a5e6:	68bb      	ldr	r3, [r7, #8]
    /**SPI1 GPIO Configuration    
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI 
    */
    GPIO_InitStruct.Pin = SCK_Pin|MISO_Pin|MOSI_Pin;
 800a5e8:	210c      	movs	r1, #12
 800a5ea:	187b      	adds	r3, r7, r1
 800a5ec:	22e0      	movs	r2, #224	; 0xe0
 800a5ee:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a5f0:	187b      	adds	r3, r7, r1
 800a5f2:	2202      	movs	r2, #2
 800a5f4:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a5f6:	187b      	adds	r3, r7, r1
 800a5f8:	2200      	movs	r2, #0
 800a5fa:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a5fc:	187b      	adds	r3, r7, r1
 800a5fe:	2203      	movs	r2, #3
 800a600:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF0_SPI1;
 800a602:	187b      	adds	r3, r7, r1
 800a604:	2200      	movs	r2, #0
 800a606:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800a608:	187a      	adds	r2, r7, r1
 800a60a:	23a0      	movs	r3, #160	; 0xa0
 800a60c:	05db      	lsls	r3, r3, #23
 800a60e:	0011      	movs	r1, r2
 800a610:	0018      	movs	r0, r3
 800a612:	f000 fa81 	bl	800ab18 <HAL_GPIO_Init>
  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }

}
 800a616:	46c0      	nop			; (mov r8, r8)
 800a618:	46bd      	mov	sp, r7
 800a61a:	b008      	add	sp, #32
 800a61c:	bd80      	pop	{r7, pc}
 800a61e:	46c0      	nop			; (mov r8, r8)
 800a620:	40013000 	.word	0x40013000
 800a624:	40021000 	.word	0x40021000

0800a628 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable Interrupt.
  */
void NMI_Handler(void)
{
 800a628:	b580      	push	{r7, lr}
 800a62a:	af00      	add	r7, sp, #0

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 800a62c:	46c0      	nop			; (mov r8, r8)
 800a62e:	46bd      	mov	sp, r7
 800a630:	bd80      	pop	{r7, pc}

0800a632 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 800a632:	b580      	push	{r7, lr}
 800a634:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800a636:	e7fe      	b.n	800a636 <HardFault_Handler+0x4>

0800a638 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 800a638:	b580      	push	{r7, lr}
 800a63a:	af00      	add	r7, sp, #0

  /* USER CODE END SVC_IRQn 0 */
  /* USER CODE BEGIN SVC_IRQn 1 */

  /* USER CODE END SVC_IRQn 1 */
}
 800a63c:	46c0      	nop			; (mov r8, r8)
 800a63e:	46bd      	mov	sp, r7
 800a640:	bd80      	pop	{r7, pc}

0800a642 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 800a642:	b580      	push	{r7, lr}
 800a644:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 800a646:	46c0      	nop			; (mov r8, r8)
 800a648:	46bd      	mov	sp, r7
 800a64a:	bd80      	pop	{r7, pc}

0800a64c <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 800a64c:	b580      	push	{r7, lr}
 800a64e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800a650:	f000 f972 	bl	800a938 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 800a654:	46c0      	nop			; (mov r8, r8)
 800a656:	46bd      	mov	sp, r7
 800a658:	bd80      	pop	{r7, pc}

0800a65a <PVD_IRQHandler>:

/**
  * @brief This function handles PVD interrupt through EXTI line 16.
  */
void PVD_IRQHandler(void)
{
 800a65a:	b580      	push	{r7, lr}
 800a65c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN PVD_IRQn 0 */

  /* USER CODE END PVD_IRQn 0 */
  HAL_PWR_PVD_IRQHandler();
 800a65e:	f000 fef3 	bl	800b448 <HAL_PWR_PVD_IRQHandler>
  /* USER CODE BEGIN PVD_IRQn 1 */

  /* USER CODE END PVD_IRQn 1 */
}
 800a662:	46c0      	nop			; (mov r8, r8)
 800a664:	46bd      	mov	sp, r7
 800a666:	bd80      	pop	{r7, pc}

0800a668 <EXTI2_3_IRQHandler>:

/**
  * @brief This function handles EXTI line 2 and line 3 interrupts.
  */
void EXTI2_3_IRQHandler(void)
{
 800a668:	b580      	push	{r7, lr}
 800a66a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI2_3_IRQn 0 */

  /* USER CODE END EXTI2_3_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_3);
 800a66c:	2008      	movs	r0, #8
 800a66e:	f000 fbef 	bl	800ae50 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI2_3_IRQn 1 */

  /* USER CODE END EXTI2_3_IRQn 1 */
}
 800a672:	46c0      	nop			; (mov r8, r8)
 800a674:	46bd      	mov	sp, r7
 800a676:	bd80      	pop	{r7, pc}

0800a678 <EXTI4_15_IRQHandler>:

/**
  * @brief This function handles EXTI line 4 to 15 interrupts.
  */
void EXTI4_15_IRQHandler(void)
{
 800a678:	b580      	push	{r7, lr}
 800a67a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI4_15_IRQn 0 */

  /* USER CODE END EXTI4_15_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);
 800a67c:	2010      	movs	r0, #16
 800a67e:	f000 fbe7 	bl	800ae50 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_5);
 800a682:	2020      	movs	r0, #32
 800a684:	f000 fbe4 	bl	800ae50 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_10);
 800a688:	2380      	movs	r3, #128	; 0x80
 800a68a:	00db      	lsls	r3, r3, #3
 800a68c:	0018      	movs	r0, r3
 800a68e:	f000 fbdf 	bl	800ae50 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI4_15_IRQn 1 */

  /* USER CODE END EXTI4_15_IRQn 1 */
}
 800a692:	46c0      	nop			; (mov r8, r8)
 800a694:	46bd      	mov	sp, r7
 800a696:	bd80      	pop	{r7, pc}

0800a698 <LPTIM1_IRQHandler>:

/**
  * @brief This function handles LPTIM1 global interrupt / LPTIM1 wake-up interrupt through EXTI line 29.
  */
void LPTIM1_IRQHandler(void)
{
 800a698:	b580      	push	{r7, lr}
 800a69a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN LPTIM1_IRQn 0 */

  /* USER CODE END LPTIM1_IRQn 0 */
  HAL_LPTIM_IRQHandler(&hlptim1);
 800a69c:	4b03      	ldr	r3, [pc, #12]	; (800a6ac <LPTIM1_IRQHandler+0x14>)
 800a69e:	0018      	movs	r0, r3
 800a6a0:	f000 fdff 	bl	800b2a2 <HAL_LPTIM_IRQHandler>
  /* USER CODE BEGIN LPTIM1_IRQn 1 */

  /* USER CODE END LPTIM1_IRQn 1 */
}
 800a6a4:	46c0      	nop			; (mov r8, r8)
 800a6a6:	46bd      	mov	sp, r7
 800a6a8:	bd80      	pop	{r7, pc}
 800a6aa:	46c0      	nop			; (mov r8, r8)
 800a6ac:	200004a0 	.word	0x200004a0

0800a6b0 <_read>:
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 800a6b0:	b580      	push	{r7, lr}
 800a6b2:	b086      	sub	sp, #24
 800a6b4:	af00      	add	r7, sp, #0
 800a6b6:	60f8      	str	r0, [r7, #12]
 800a6b8:	60b9      	str	r1, [r7, #8]
 800a6ba:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800a6bc:	2300      	movs	r3, #0
 800a6be:	617b      	str	r3, [r7, #20]
 800a6c0:	e00a      	b.n	800a6d8 <_read+0x28>
	{
		*ptr++ = __io_getchar();
 800a6c2:	e000      	b.n	800a6c6 <_read+0x16>
 800a6c4:	bf00      	nop
 800a6c6:	0001      	movs	r1, r0
 800a6c8:	68bb      	ldr	r3, [r7, #8]
 800a6ca:	1c5a      	adds	r2, r3, #1
 800a6cc:	60ba      	str	r2, [r7, #8]
 800a6ce:	b2ca      	uxtb	r2, r1
 800a6d0:	701a      	strb	r2, [r3, #0]
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800a6d2:	697b      	ldr	r3, [r7, #20]
 800a6d4:	3301      	adds	r3, #1
 800a6d6:	617b      	str	r3, [r7, #20]
 800a6d8:	697a      	ldr	r2, [r7, #20]
 800a6da:	687b      	ldr	r3, [r7, #4]
 800a6dc:	429a      	cmp	r2, r3
 800a6de:	dbf0      	blt.n	800a6c2 <_read+0x12>
	}

return len;
 800a6e0:	687b      	ldr	r3, [r7, #4]
}
 800a6e2:	0018      	movs	r0, r3
 800a6e4:	46bd      	mov	sp, r7
 800a6e6:	b006      	add	sp, #24
 800a6e8:	bd80      	pop	{r7, pc}

0800a6ea <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 800a6ea:	b580      	push	{r7, lr}
 800a6ec:	b086      	sub	sp, #24
 800a6ee:	af00      	add	r7, sp, #0
 800a6f0:	60f8      	str	r0, [r7, #12]
 800a6f2:	60b9      	str	r1, [r7, #8]
 800a6f4:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800a6f6:	2300      	movs	r3, #0
 800a6f8:	617b      	str	r3, [r7, #20]
 800a6fa:	e009      	b.n	800a710 <_write+0x26>
	{
		__io_putchar(*ptr++);
 800a6fc:	68bb      	ldr	r3, [r7, #8]
 800a6fe:	1c5a      	adds	r2, r3, #1
 800a700:	60ba      	str	r2, [r7, #8]
 800a702:	781b      	ldrb	r3, [r3, #0]
 800a704:	0018      	movs	r0, r3
 800a706:	f7f5 ffab 	bl	8000660 <__io_putchar>
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800a70a:	697b      	ldr	r3, [r7, #20]
 800a70c:	3301      	adds	r3, #1
 800a70e:	617b      	str	r3, [r7, #20]
 800a710:	697a      	ldr	r2, [r7, #20]
 800a712:	687b      	ldr	r3, [r7, #4]
 800a714:	429a      	cmp	r2, r3
 800a716:	dbf1      	blt.n	800a6fc <_write+0x12>
	}
	return len;
 800a718:	687b      	ldr	r3, [r7, #4]
}
 800a71a:	0018      	movs	r0, r3
 800a71c:	46bd      	mov	sp, r7
 800a71e:	b006      	add	sp, #24
 800a720:	bd80      	pop	{r7, pc}

0800a722 <_close>:

int _close(int file)
{
 800a722:	b580      	push	{r7, lr}
 800a724:	b082      	sub	sp, #8
 800a726:	af00      	add	r7, sp, #0
 800a728:	6078      	str	r0, [r7, #4]
	return -1;
 800a72a:	2301      	movs	r3, #1
 800a72c:	425b      	negs	r3, r3
}
 800a72e:	0018      	movs	r0, r3
 800a730:	46bd      	mov	sp, r7
 800a732:	b002      	add	sp, #8
 800a734:	bd80      	pop	{r7, pc}

0800a736 <_fstat>:


int _fstat(int file, struct stat *st)
{
 800a736:	b580      	push	{r7, lr}
 800a738:	b082      	sub	sp, #8
 800a73a:	af00      	add	r7, sp, #0
 800a73c:	6078      	str	r0, [r7, #4]
 800a73e:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
 800a740:	683b      	ldr	r3, [r7, #0]
 800a742:	2280      	movs	r2, #128	; 0x80
 800a744:	0192      	lsls	r2, r2, #6
 800a746:	605a      	str	r2, [r3, #4]
	return 0;
 800a748:	2300      	movs	r3, #0
}
 800a74a:	0018      	movs	r0, r3
 800a74c:	46bd      	mov	sp, r7
 800a74e:	b002      	add	sp, #8
 800a750:	bd80      	pop	{r7, pc}

0800a752 <_isatty>:

int _isatty(int file)
{
 800a752:	b580      	push	{r7, lr}
 800a754:	b082      	sub	sp, #8
 800a756:	af00      	add	r7, sp, #0
 800a758:	6078      	str	r0, [r7, #4]
	return 1;
 800a75a:	2301      	movs	r3, #1
}
 800a75c:	0018      	movs	r0, r3
 800a75e:	46bd      	mov	sp, r7
 800a760:	b002      	add	sp, #8
 800a762:	bd80      	pop	{r7, pc}

0800a764 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 800a764:	b580      	push	{r7, lr}
 800a766:	b084      	sub	sp, #16
 800a768:	af00      	add	r7, sp, #0
 800a76a:	60f8      	str	r0, [r7, #12]
 800a76c:	60b9      	str	r1, [r7, #8]
 800a76e:	607a      	str	r2, [r7, #4]
	return 0;
 800a770:	2300      	movs	r3, #0
}
 800a772:	0018      	movs	r0, r3
 800a774:	46bd      	mov	sp, r7
 800a776:	b004      	add	sp, #16
 800a778:	bd80      	pop	{r7, pc}
	...

0800a77c <_sbrk>:
/**
 _sbrk
 Increase program data space. Malloc and related functions depend on this
**/
caddr_t _sbrk(int incr)
{
 800a77c:	b580      	push	{r7, lr}
 800a77e:	b084      	sub	sp, #16
 800a780:	af00      	add	r7, sp, #0
 800a782:	6078      	str	r0, [r7, #4]
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 800a784:	4b11      	ldr	r3, [pc, #68]	; (800a7cc <_sbrk+0x50>)
 800a786:	681b      	ldr	r3, [r3, #0]
 800a788:	2b00      	cmp	r3, #0
 800a78a:	d102      	bne.n	800a792 <_sbrk+0x16>
		heap_end = &end;
 800a78c:	4b0f      	ldr	r3, [pc, #60]	; (800a7cc <_sbrk+0x50>)
 800a78e:	4a10      	ldr	r2, [pc, #64]	; (800a7d0 <_sbrk+0x54>)
 800a790:	601a      	str	r2, [r3, #0]

	prev_heap_end = heap_end;
 800a792:	4b0e      	ldr	r3, [pc, #56]	; (800a7cc <_sbrk+0x50>)
 800a794:	681b      	ldr	r3, [r3, #0]
 800a796:	60fb      	str	r3, [r7, #12]
	if (heap_end + incr > stack_ptr)
 800a798:	4b0c      	ldr	r3, [pc, #48]	; (800a7cc <_sbrk+0x50>)
 800a79a:	681a      	ldr	r2, [r3, #0]
 800a79c:	687b      	ldr	r3, [r7, #4]
 800a79e:	18d3      	adds	r3, r2, r3
 800a7a0:	466a      	mov	r2, sp
 800a7a2:	4293      	cmp	r3, r2
 800a7a4:	d907      	bls.n	800a7b6 <_sbrk+0x3a>
	{
		errno = ENOMEM;
 800a7a6:	f002 f865 	bl	800c874 <__errno>
 800a7aa:	0003      	movs	r3, r0
 800a7ac:	220c      	movs	r2, #12
 800a7ae:	601a      	str	r2, [r3, #0]
		return (caddr_t) -1;
 800a7b0:	2301      	movs	r3, #1
 800a7b2:	425b      	negs	r3, r3
 800a7b4:	e006      	b.n	800a7c4 <_sbrk+0x48>
	}

	heap_end += incr;
 800a7b6:	4b05      	ldr	r3, [pc, #20]	; (800a7cc <_sbrk+0x50>)
 800a7b8:	681a      	ldr	r2, [r3, #0]
 800a7ba:	687b      	ldr	r3, [r7, #4]
 800a7bc:	18d2      	adds	r2, r2, r3
 800a7be:	4b03      	ldr	r3, [pc, #12]	; (800a7cc <_sbrk+0x50>)
 800a7c0:	601a      	str	r2, [r3, #0]

	return (caddr_t) prev_heap_end;
 800a7c2:	68fb      	ldr	r3, [r7, #12]
}
 800a7c4:	0018      	movs	r0, r3
 800a7c6:	46bd      	mov	sp, r7
 800a7c8:	b004      	add	sp, #16
 800a7ca:	bd80      	pop	{r7, pc}
 800a7cc:	20000084 	.word	0x20000084
 800a7d0:	200005c0 	.word	0x200005c0

0800a7d4 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 800a7d4:	b580      	push	{r7, lr}
 800a7d6:	af00      	add	r7, sp, #0
/*!< Set MSION bit */
  RCC->CR |= (uint32_t)0x00000100U;
 800a7d8:	4b17      	ldr	r3, [pc, #92]	; (800a838 <SystemInit+0x64>)
 800a7da:	681a      	ldr	r2, [r3, #0]
 800a7dc:	4b16      	ldr	r3, [pc, #88]	; (800a838 <SystemInit+0x64>)
 800a7de:	2180      	movs	r1, #128	; 0x80
 800a7e0:	0049      	lsls	r1, r1, #1
 800a7e2:	430a      	orrs	r2, r1
 800a7e4:	601a      	str	r2, [r3, #0]

  /*!< Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], MCOSEL[2:0] and MCOPRE[2:0] bits */
  RCC->CFGR &= (uint32_t) 0x88FF400CU;
 800a7e6:	4b14      	ldr	r3, [pc, #80]	; (800a838 <SystemInit+0x64>)
 800a7e8:	68da      	ldr	r2, [r3, #12]
 800a7ea:	4b13      	ldr	r3, [pc, #76]	; (800a838 <SystemInit+0x64>)
 800a7ec:	4913      	ldr	r1, [pc, #76]	; (800a83c <SystemInit+0x68>)
 800a7ee:	400a      	ands	r2, r1
 800a7f0:	60da      	str	r2, [r3, #12]

  /*!< Reset HSION, HSIDIVEN, HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFF6U;
 800a7f2:	4b11      	ldr	r3, [pc, #68]	; (800a838 <SystemInit+0x64>)
 800a7f4:	681a      	ldr	r2, [r3, #0]
 800a7f6:	4b10      	ldr	r3, [pc, #64]	; (800a838 <SystemInit+0x64>)
 800a7f8:	4911      	ldr	r1, [pc, #68]	; (800a840 <SystemInit+0x6c>)
 800a7fa:	400a      	ands	r2, r1
 800a7fc:	601a      	str	r2, [r3, #0]

  /*!< Reset HSI48ON  bit */
  RCC->CRRCR &= (uint32_t)0xFFFFFFFEU;
 800a7fe:	4b0e      	ldr	r3, [pc, #56]	; (800a838 <SystemInit+0x64>)
 800a800:	689a      	ldr	r2, [r3, #8]
 800a802:	4b0d      	ldr	r3, [pc, #52]	; (800a838 <SystemInit+0x64>)
 800a804:	2101      	movs	r1, #1
 800a806:	438a      	bics	r2, r1
 800a808:	609a      	str	r2, [r3, #8]

  /*!< Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFFU;
 800a80a:	4b0b      	ldr	r3, [pc, #44]	; (800a838 <SystemInit+0x64>)
 800a80c:	681a      	ldr	r2, [r3, #0]
 800a80e:	4b0a      	ldr	r3, [pc, #40]	; (800a838 <SystemInit+0x64>)
 800a810:	490c      	ldr	r1, [pc, #48]	; (800a844 <SystemInit+0x70>)
 800a812:	400a      	ands	r2, r1
 800a814:	601a      	str	r2, [r3, #0]

  /*!< Reset PLLSRC, PLLMUL[3:0] and PLLDIV[1:0] bits */
  RCC->CFGR &= (uint32_t)0xFF02FFFFU;
 800a816:	4b08      	ldr	r3, [pc, #32]	; (800a838 <SystemInit+0x64>)
 800a818:	68da      	ldr	r2, [r3, #12]
 800a81a:	4b07      	ldr	r3, [pc, #28]	; (800a838 <SystemInit+0x64>)
 800a81c:	490a      	ldr	r1, [pc, #40]	; (800a848 <SystemInit+0x74>)
 800a81e:	400a      	ands	r2, r1
 800a820:	60da      	str	r2, [r3, #12]

  /*!< Disable all interrupts */
  RCC->CIER = 0x00000000U;
 800a822:	4b05      	ldr	r3, [pc, #20]	; (800a838 <SystemInit+0x64>)
 800a824:	2200      	movs	r2, #0
 800a826:	611a      	str	r2, [r3, #16]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800a828:	4b08      	ldr	r3, [pc, #32]	; (800a84c <SystemInit+0x78>)
 800a82a:	2280      	movs	r2, #128	; 0x80
 800a82c:	0512      	lsls	r2, r2, #20
 800a82e:	609a      	str	r2, [r3, #8]
#endif
}
 800a830:	46c0      	nop			; (mov r8, r8)
 800a832:	46bd      	mov	sp, r7
 800a834:	bd80      	pop	{r7, pc}
 800a836:	46c0      	nop			; (mov r8, r8)
 800a838:	40021000 	.word	0x40021000
 800a83c:	88ff400c 	.word	0x88ff400c
 800a840:	fef6fff6 	.word	0xfef6fff6
 800a844:	fffbffff 	.word	0xfffbffff
 800a848:	ff02ffff 	.word	0xff02ffff
 800a84c:	e000ed00 	.word	0xe000ed00

0800a850 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
   ldr   r0, =_estack
 800a850:	480d      	ldr	r0, [pc, #52]	; (800a888 <LoopForever+0x2>)
   mov   sp, r0          /* set stack pointer */
 800a852:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
 800a854:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800a856:	e003      	b.n	800a860 <LoopCopyDataInit>

0800a858 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800a858:	4b0c      	ldr	r3, [pc, #48]	; (800a88c <LoopForever+0x6>)
  ldr  r3, [r3, r1]
 800a85a:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800a85c:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800a85e:	3104      	adds	r1, #4

0800a860 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr  r0, =_sdata
 800a860:	480b      	ldr	r0, [pc, #44]	; (800a890 <LoopForever+0xa>)
  ldr  r3, =_edata
 800a862:	4b0c      	ldr	r3, [pc, #48]	; (800a894 <LoopForever+0xe>)
  adds  r2, r0, r1
 800a864:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800a866:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800a868:	d3f6      	bcc.n	800a858 <CopyDataInit>
  ldr  r2, =_sbss
 800a86a:	4a0b      	ldr	r2, [pc, #44]	; (800a898 <LoopForever+0x12>)
  b  LoopFillZerobss
 800a86c:	e002      	b.n	800a874 <LoopFillZerobss>

0800a86e <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs  r3, #0
 800a86e:	2300      	movs	r3, #0
  str  r3, [r2]
 800a870:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800a872:	3204      	adds	r2, #4

0800a874 <LoopFillZerobss>:


LoopFillZerobss:
  ldr  r3, = _ebss
 800a874:	4b09      	ldr	r3, [pc, #36]	; (800a89c <LoopForever+0x16>)
  cmp  r2, r3
 800a876:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800a878:	d3f9      	bcc.n	800a86e <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 800a87a:	f7ff ffab 	bl	800a7d4 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800a87e:	f001 ffff 	bl	800c880 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800a882:	f7ff f875 	bl	8009970 <main>

0800a886 <LoopForever>:

LoopForever:
    b LoopForever
 800a886:	e7fe      	b.n	800a886 <LoopForever>
   ldr   r0, =_estack
 800a888:	20005000 	.word	0x20005000
  ldr  r3, =_sidata
 800a88c:	0800e778 	.word	0x0800e778
  ldr  r0, =_sdata
 800a890:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800a894:	20000068 	.word	0x20000068
  ldr  r2, =_sbss
 800a898:	20000068 	.word	0x20000068
  ldr  r3, = _ebss
 800a89c:	200005c0 	.word	0x200005c0

0800a8a0 <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800a8a0:	e7fe      	b.n	800a8a0 <ADC1_COMP_IRQHandler>
	...

0800a8a4 <HAL_Init>:
  *        In the default implementation,Systick is used as source of time base.
  *        the tick variable is incremented each 1ms in its ISR.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800a8a4:	b580      	push	{r7, lr}
 800a8a6:	b082      	sub	sp, #8
 800a8a8:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 800a8aa:	1dfb      	adds	r3, r7, #7
 800a8ac:	2200      	movs	r2, #0
 800a8ae:	701a      	strb	r2, [r3, #0]
#if (BUFFER_CACHE_DISABLE != 0)
  __HAL_FLASH_BUFFER_CACHE_DISABLE();
#endif /* BUFFER_CACHE_DISABLE */

#if (PREREAD_ENABLE != 0)
  __HAL_FLASH_PREREAD_BUFFER_ENABLE();
 800a8b0:	4b0b      	ldr	r3, [pc, #44]	; (800a8e0 <HAL_Init+0x3c>)
 800a8b2:	681a      	ldr	r2, [r3, #0]
 800a8b4:	4b0a      	ldr	r3, [pc, #40]	; (800a8e0 <HAL_Init+0x3c>)
 800a8b6:	2140      	movs	r1, #64	; 0x40
 800a8b8:	430a      	orrs	r2, r1
 800a8ba:	601a      	str	r2, [r3, #0]
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 800a8bc:	2000      	movs	r0, #0
 800a8be:	f000 f811 	bl	800a8e4 <HAL_InitTick>
 800a8c2:	1e03      	subs	r3, r0, #0
 800a8c4:	d003      	beq.n	800a8ce <HAL_Init+0x2a>
  {
    status = HAL_ERROR;
 800a8c6:	1dfb      	adds	r3, r7, #7
 800a8c8:	2201      	movs	r2, #1
 800a8ca:	701a      	strb	r2, [r3, #0]
 800a8cc:	e001      	b.n	800a8d2 <HAL_Init+0x2e>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 800a8ce:	f7ff fdc1 	bl	800a454 <HAL_MspInit>
  }

  /* Return function status */
  return status;
 800a8d2:	1dfb      	adds	r3, r7, #7
 800a8d4:	781b      	ldrb	r3, [r3, #0]
}
 800a8d6:	0018      	movs	r0, r3
 800a8d8:	46bd      	mov	sp, r7
 800a8da:	b002      	add	sp, #8
 800a8dc:	bd80      	pop	{r7, pc}
 800a8de:	46c0      	nop			; (mov r8, r8)
 800a8e0:	40022000 	.word	0x40022000

0800a8e4 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800a8e4:	b580      	push	{r7, lr}
 800a8e6:	b084      	sub	sp, #16
 800a8e8:	af00      	add	r7, sp, #0
 800a8ea:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
 800a8ec:	230f      	movs	r3, #15
 800a8ee:	18fb      	adds	r3, r7, r3
 800a8f0:	2200      	movs	r2, #0
 800a8f2:	701a      	strb	r2, [r3, #0]

  /*Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock/1000UL) != 0U)
 800a8f4:	4b0f      	ldr	r3, [pc, #60]	; (800a934 <HAL_InitTick+0x50>)
 800a8f6:	681a      	ldr	r2, [r3, #0]
 800a8f8:	23fa      	movs	r3, #250	; 0xfa
 800a8fa:	0099      	lsls	r1, r3, #2
 800a8fc:	0010      	movs	r0, r2
 800a8fe:	f7f5 fc03 	bl	8000108 <__udivsi3>
 800a902:	0003      	movs	r3, r0
 800a904:	0018      	movs	r0, r3
 800a906:	f000 f8fa 	bl	800aafe <HAL_SYSTICK_Config>
 800a90a:	1e03      	subs	r3, r0, #0
 800a90c:	d004      	beq.n	800a918 <HAL_InitTick+0x34>
  {
    status = HAL_ERROR;
 800a90e:	230f      	movs	r3, #15
 800a910:	18fb      	adds	r3, r7, r3
 800a912:	2201      	movs	r2, #1
 800a914:	701a      	strb	r2, [r3, #0]
 800a916:	e006      	b.n	800a926 <HAL_InitTick+0x42>
  }
  else
  {
    /*Configure the SysTick IRQ priority */
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0);
 800a918:	6879      	ldr	r1, [r7, #4]
 800a91a:	2301      	movs	r3, #1
 800a91c:	425b      	negs	r3, r3
 800a91e:	2200      	movs	r2, #0
 800a920:	0018      	movs	r0, r3
 800a922:	f000 f8c7 	bl	800aab4 <HAL_NVIC_SetPriority>
  }

  /* Return function status */
  return status;
 800a926:	230f      	movs	r3, #15
 800a928:	18fb      	adds	r3, r7, r3
 800a92a:	781b      	ldrb	r3, [r3, #0]
}
 800a92c:	0018      	movs	r0, r3
 800a92e:	46bd      	mov	sp, r7
 800a930:	b004      	add	sp, #16
 800a932:	bd80      	pop	{r7, pc}
 800a934:	20000000 	.word	0x20000000

0800a938 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 800a938:	b580      	push	{r7, lr}
 800a93a:	af00      	add	r7, sp, #0
  uwTick++;
 800a93c:	4b03      	ldr	r3, [pc, #12]	; (800a94c <HAL_IncTick+0x14>)
 800a93e:	681b      	ldr	r3, [r3, #0]
 800a940:	1c5a      	adds	r2, r3, #1
 800a942:	4b02      	ldr	r3, [pc, #8]	; (800a94c <HAL_IncTick+0x14>)
 800a944:	601a      	str	r2, [r3, #0]
}
 800a946:	46c0      	nop			; (mov r8, r8)
 800a948:	46bd      	mov	sp, r7
 800a94a:	bd80      	pop	{r7, pc}
 800a94c:	200005b8 	.word	0x200005b8

0800a950 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 800a950:	b580      	push	{r7, lr}
 800a952:	af00      	add	r7, sp, #0
  return uwTick;
 800a954:	4b02      	ldr	r3, [pc, #8]	; (800a960 <HAL_GetTick+0x10>)
 800a956:	681b      	ldr	r3, [r3, #0]
}
 800a958:	0018      	movs	r0, r3
 800a95a:	46bd      	mov	sp, r7
 800a95c:	bd80      	pop	{r7, pc}
 800a95e:	46c0      	nop			; (mov r8, r8)
 800a960:	200005b8 	.word	0x200005b8

0800a964 <NVIC_EnableIRQ>:
  \brief   Enable External Interrupt
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800a964:	b580      	push	{r7, lr}
 800a966:	b082      	sub	sp, #8
 800a968:	af00      	add	r7, sp, #0
 800a96a:	0002      	movs	r2, r0
 800a96c:	1dfb      	adds	r3, r7, #7
 800a96e:	701a      	strb	r2, [r3, #0]
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800a970:	1dfb      	adds	r3, r7, #7
 800a972:	781b      	ldrb	r3, [r3, #0]
 800a974:	001a      	movs	r2, r3
 800a976:	231f      	movs	r3, #31
 800a978:	401a      	ands	r2, r3
 800a97a:	4b04      	ldr	r3, [pc, #16]	; (800a98c <NVIC_EnableIRQ+0x28>)
 800a97c:	2101      	movs	r1, #1
 800a97e:	4091      	lsls	r1, r2
 800a980:	000a      	movs	r2, r1
 800a982:	601a      	str	r2, [r3, #0]
}
 800a984:	46c0      	nop			; (mov r8, r8)
 800a986:	46bd      	mov	sp, r7
 800a988:	b002      	add	sp, #8
 800a98a:	bd80      	pop	{r7, pc}
 800a98c:	e000e100 	.word	0xe000e100

0800a990 <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800a990:	b590      	push	{r4, r7, lr}
 800a992:	b083      	sub	sp, #12
 800a994:	af00      	add	r7, sp, #0
 800a996:	0002      	movs	r2, r0
 800a998:	6039      	str	r1, [r7, #0]
 800a99a:	1dfb      	adds	r3, r7, #7
 800a99c:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) < 0)
 800a99e:	1dfb      	adds	r3, r7, #7
 800a9a0:	781b      	ldrb	r3, [r3, #0]
 800a9a2:	2b7f      	cmp	r3, #127	; 0x7f
 800a9a4:	d932      	bls.n	800aa0c <NVIC_SetPriority+0x7c>
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800a9a6:	4a2f      	ldr	r2, [pc, #188]	; (800aa64 <NVIC_SetPriority+0xd4>)
 800a9a8:	1dfb      	adds	r3, r7, #7
 800a9aa:	781b      	ldrb	r3, [r3, #0]
 800a9ac:	0019      	movs	r1, r3
 800a9ae:	230f      	movs	r3, #15
 800a9b0:	400b      	ands	r3, r1
 800a9b2:	3b08      	subs	r3, #8
 800a9b4:	089b      	lsrs	r3, r3, #2
 800a9b6:	3306      	adds	r3, #6
 800a9b8:	009b      	lsls	r3, r3, #2
 800a9ba:	18d3      	adds	r3, r2, r3
 800a9bc:	3304      	adds	r3, #4
 800a9be:	681b      	ldr	r3, [r3, #0]
 800a9c0:	1dfa      	adds	r2, r7, #7
 800a9c2:	7812      	ldrb	r2, [r2, #0]
 800a9c4:	0011      	movs	r1, r2
 800a9c6:	2203      	movs	r2, #3
 800a9c8:	400a      	ands	r2, r1
 800a9ca:	00d2      	lsls	r2, r2, #3
 800a9cc:	21ff      	movs	r1, #255	; 0xff
 800a9ce:	4091      	lsls	r1, r2
 800a9d0:	000a      	movs	r2, r1
 800a9d2:	43d2      	mvns	r2, r2
 800a9d4:	401a      	ands	r2, r3
 800a9d6:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 800a9d8:	683b      	ldr	r3, [r7, #0]
 800a9da:	019b      	lsls	r3, r3, #6
 800a9dc:	22ff      	movs	r2, #255	; 0xff
 800a9de:	401a      	ands	r2, r3
 800a9e0:	1dfb      	adds	r3, r7, #7
 800a9e2:	781b      	ldrb	r3, [r3, #0]
 800a9e4:	0018      	movs	r0, r3
 800a9e6:	2303      	movs	r3, #3
 800a9e8:	4003      	ands	r3, r0
 800a9ea:	00db      	lsls	r3, r3, #3
 800a9ec:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800a9ee:	481d      	ldr	r0, [pc, #116]	; (800aa64 <NVIC_SetPriority+0xd4>)
 800a9f0:	1dfb      	adds	r3, r7, #7
 800a9f2:	781b      	ldrb	r3, [r3, #0]
 800a9f4:	001c      	movs	r4, r3
 800a9f6:	230f      	movs	r3, #15
 800a9f8:	4023      	ands	r3, r4
 800a9fa:	3b08      	subs	r3, #8
 800a9fc:	089b      	lsrs	r3, r3, #2
 800a9fe:	430a      	orrs	r2, r1
 800aa00:	3306      	adds	r3, #6
 800aa02:	009b      	lsls	r3, r3, #2
 800aa04:	18c3      	adds	r3, r0, r3
 800aa06:	3304      	adds	r3, #4
 800aa08:	601a      	str	r2, [r3, #0]
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
 800aa0a:	e027      	b.n	800aa5c <NVIC_SetPriority+0xcc>
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800aa0c:	4a16      	ldr	r2, [pc, #88]	; (800aa68 <NVIC_SetPriority+0xd8>)
 800aa0e:	1dfb      	adds	r3, r7, #7
 800aa10:	781b      	ldrb	r3, [r3, #0]
 800aa12:	b25b      	sxtb	r3, r3
 800aa14:	089b      	lsrs	r3, r3, #2
 800aa16:	33c0      	adds	r3, #192	; 0xc0
 800aa18:	009b      	lsls	r3, r3, #2
 800aa1a:	589b      	ldr	r3, [r3, r2]
 800aa1c:	1dfa      	adds	r2, r7, #7
 800aa1e:	7812      	ldrb	r2, [r2, #0]
 800aa20:	0011      	movs	r1, r2
 800aa22:	2203      	movs	r2, #3
 800aa24:	400a      	ands	r2, r1
 800aa26:	00d2      	lsls	r2, r2, #3
 800aa28:	21ff      	movs	r1, #255	; 0xff
 800aa2a:	4091      	lsls	r1, r2
 800aa2c:	000a      	movs	r2, r1
 800aa2e:	43d2      	mvns	r2, r2
 800aa30:	401a      	ands	r2, r3
 800aa32:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 800aa34:	683b      	ldr	r3, [r7, #0]
 800aa36:	019b      	lsls	r3, r3, #6
 800aa38:	22ff      	movs	r2, #255	; 0xff
 800aa3a:	401a      	ands	r2, r3
 800aa3c:	1dfb      	adds	r3, r7, #7
 800aa3e:	781b      	ldrb	r3, [r3, #0]
 800aa40:	0018      	movs	r0, r3
 800aa42:	2303      	movs	r3, #3
 800aa44:	4003      	ands	r3, r0
 800aa46:	00db      	lsls	r3, r3, #3
 800aa48:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800aa4a:	4807      	ldr	r0, [pc, #28]	; (800aa68 <NVIC_SetPriority+0xd8>)
 800aa4c:	1dfb      	adds	r3, r7, #7
 800aa4e:	781b      	ldrb	r3, [r3, #0]
 800aa50:	b25b      	sxtb	r3, r3
 800aa52:	089b      	lsrs	r3, r3, #2
 800aa54:	430a      	orrs	r2, r1
 800aa56:	33c0      	adds	r3, #192	; 0xc0
 800aa58:	009b      	lsls	r3, r3, #2
 800aa5a:	501a      	str	r2, [r3, r0]
}
 800aa5c:	46c0      	nop			; (mov r8, r8)
 800aa5e:	46bd      	mov	sp, r7
 800aa60:	b003      	add	sp, #12
 800aa62:	bd90      	pop	{r4, r7, pc}
 800aa64:	e000ed00 	.word	0xe000ed00
 800aa68:	e000e100 	.word	0xe000e100

0800aa6c <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 800aa6c:	b580      	push	{r7, lr}
 800aa6e:	b082      	sub	sp, #8
 800aa70:	af00      	add	r7, sp, #0
 800aa72:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800aa74:	687b      	ldr	r3, [r7, #4]
 800aa76:	3b01      	subs	r3, #1
 800aa78:	4a0c      	ldr	r2, [pc, #48]	; (800aaac <SysTick_Config+0x40>)
 800aa7a:	4293      	cmp	r3, r2
 800aa7c:	d901      	bls.n	800aa82 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 800aa7e:	2301      	movs	r3, #1
 800aa80:	e010      	b.n	800aaa4 <SysTick_Config+0x38>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800aa82:	4b0b      	ldr	r3, [pc, #44]	; (800aab0 <SysTick_Config+0x44>)
 800aa84:	687a      	ldr	r2, [r7, #4]
 800aa86:	3a01      	subs	r2, #1
 800aa88:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 800aa8a:	2301      	movs	r3, #1
 800aa8c:	425b      	negs	r3, r3
 800aa8e:	2103      	movs	r1, #3
 800aa90:	0018      	movs	r0, r3
 800aa92:	f7ff ff7d 	bl	800a990 <NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800aa96:	4b06      	ldr	r3, [pc, #24]	; (800aab0 <SysTick_Config+0x44>)
 800aa98:	2200      	movs	r2, #0
 800aa9a:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800aa9c:	4b04      	ldr	r3, [pc, #16]	; (800aab0 <SysTick_Config+0x44>)
 800aa9e:	2207      	movs	r2, #7
 800aaa0:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800aaa2:	2300      	movs	r3, #0
}
 800aaa4:	0018      	movs	r0, r3
 800aaa6:	46bd      	mov	sp, r7
 800aaa8:	b002      	add	sp, #8
 800aaaa:	bd80      	pop	{r7, pc}
 800aaac:	00ffffff 	.word	0x00ffffff
 800aab0:	e000e010 	.word	0xe000e010

0800aab4 <HAL_NVIC_SetPriority>:
  *         with stm32l0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0+ based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800aab4:	b580      	push	{r7, lr}
 800aab6:	b084      	sub	sp, #16
 800aab8:	af00      	add	r7, sp, #0
 800aaba:	60b9      	str	r1, [r7, #8]
 800aabc:	607a      	str	r2, [r7, #4]
 800aabe:	210f      	movs	r1, #15
 800aac0:	187b      	adds	r3, r7, r1
 800aac2:	1c02      	adds	r2, r0, #0
 800aac4:	701a      	strb	r2, [r3, #0]
    /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
 800aac6:	68ba      	ldr	r2, [r7, #8]
 800aac8:	187b      	adds	r3, r7, r1
 800aaca:	781b      	ldrb	r3, [r3, #0]
 800aacc:	b25b      	sxtb	r3, r3
 800aace:	0011      	movs	r1, r2
 800aad0:	0018      	movs	r0, r3
 800aad2:	f7ff ff5d 	bl	800a990 <NVIC_SetPriority>
}
 800aad6:	46c0      	nop			; (mov r8, r8)
 800aad8:	46bd      	mov	sp, r7
 800aada:	b004      	add	sp, #16
 800aadc:	bd80      	pop	{r7, pc}

0800aade <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of  IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to stm32l0xx.h file)  
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800aade:	b580      	push	{r7, lr}
 800aae0:	b082      	sub	sp, #8
 800aae2:	af00      	add	r7, sp, #0
 800aae4:	0002      	movs	r2, r0
 800aae6:	1dfb      	adds	r3, r7, #7
 800aae8:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800aaea:	1dfb      	adds	r3, r7, #7
 800aaec:	781b      	ldrb	r3, [r3, #0]
 800aaee:	b25b      	sxtb	r3, r3
 800aaf0:	0018      	movs	r0, r3
 800aaf2:	f7ff ff37 	bl	800a964 <NVIC_EnableIRQ>
}
 800aaf6:	46c0      	nop			; (mov r8, r8)
 800aaf8:	46bd      	mov	sp, r7
 800aafa:	b002      	add	sp, #8
 800aafc:	bd80      	pop	{r7, pc}

0800aafe <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800aafe:	b580      	push	{r7, lr}
 800ab00:	b082      	sub	sp, #8
 800ab02:	af00      	add	r7, sp, #0
 800ab04:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 800ab06:	687b      	ldr	r3, [r7, #4]
 800ab08:	0018      	movs	r0, r3
 800ab0a:	f7ff ffaf 	bl	800aa6c <SysTick_Config>
 800ab0e:	0003      	movs	r3, r0
}
 800ab10:	0018      	movs	r0, r3
 800ab12:	46bd      	mov	sp, r7
 800ab14:	b002      	add	sp, #8
 800ab16:	bd80      	pop	{r7, pc}

0800ab18 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *                    the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800ab18:	b580      	push	{r7, lr}
 800ab1a:	b086      	sub	sp, #24
 800ab1c:	af00      	add	r7, sp, #0
 800ab1e:	6078      	str	r0, [r7, #4]
 800ab20:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
 800ab22:	2300      	movs	r3, #0
 800ab24:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 800ab26:	2300      	movs	r3, #0
 800ab28:	60fb      	str	r3, [r7, #12]
  uint32_t temp = 0x00U;
 800ab2a:	2300      	movs	r3, #0
 800ab2c:	613b      	str	r3, [r7, #16]
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,(GPIO_Init->Pin)));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
 800ab2e:	e155      	b.n	800addc <HAL_GPIO_Init+0x2c4>
  {
    /* Get the IO position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 800ab30:	683b      	ldr	r3, [r7, #0]
 800ab32:	681b      	ldr	r3, [r3, #0]
 800ab34:	2101      	movs	r1, #1
 800ab36:	697a      	ldr	r2, [r7, #20]
 800ab38:	4091      	lsls	r1, r2
 800ab3a:	000a      	movs	r2, r1
 800ab3c:	4013      	ands	r3, r2
 800ab3e:	60fb      	str	r3, [r7, #12]
    
    if(iocurrent)
 800ab40:	68fb      	ldr	r3, [r7, #12]
 800ab42:	2b00      	cmp	r3, #0
 800ab44:	d100      	bne.n	800ab48 <HAL_GPIO_Init+0x30>
 800ab46:	e146      	b.n	800add6 <HAL_GPIO_Init+0x2be>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
 800ab48:	683b      	ldr	r3, [r7, #0]
 800ab4a:	685b      	ldr	r3, [r3, #4]
 800ab4c:	2b02      	cmp	r3, #2
 800ab4e:	d003      	beq.n	800ab58 <HAL_GPIO_Init+0x40>
 800ab50:	683b      	ldr	r3, [r7, #0]
 800ab52:	685b      	ldr	r3, [r3, #4]
 800ab54:	2b12      	cmp	r3, #18
 800ab56:	d123      	bne.n	800aba0 <HAL_GPIO_Init+0x88>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */ 
        temp = GPIOx->AFR[position >> 3U];
 800ab58:	697b      	ldr	r3, [r7, #20]
 800ab5a:	08da      	lsrs	r2, r3, #3
 800ab5c:	687b      	ldr	r3, [r7, #4]
 800ab5e:	3208      	adds	r2, #8
 800ab60:	0092      	lsls	r2, r2, #2
 800ab62:	58d3      	ldr	r3, [r2, r3]
 800ab64:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 800ab66:	697b      	ldr	r3, [r7, #20]
 800ab68:	2207      	movs	r2, #7
 800ab6a:	4013      	ands	r3, r2
 800ab6c:	009b      	lsls	r3, r3, #2
 800ab6e:	220f      	movs	r2, #15
 800ab70:	409a      	lsls	r2, r3
 800ab72:	0013      	movs	r3, r2
 800ab74:	43da      	mvns	r2, r3
 800ab76:	693b      	ldr	r3, [r7, #16]
 800ab78:	4013      	ands	r3, r2
 800ab7a:	613b      	str	r3, [r7, #16]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U)) ;
 800ab7c:	683b      	ldr	r3, [r7, #0]
 800ab7e:	691a      	ldr	r2, [r3, #16]
 800ab80:	697b      	ldr	r3, [r7, #20]
 800ab82:	2107      	movs	r1, #7
 800ab84:	400b      	ands	r3, r1
 800ab86:	009b      	lsls	r3, r3, #2
 800ab88:	409a      	lsls	r2, r3
 800ab8a:	0013      	movs	r3, r2
 800ab8c:	693a      	ldr	r2, [r7, #16]
 800ab8e:	4313      	orrs	r3, r2
 800ab90:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3U] = temp;
 800ab92:	697b      	ldr	r3, [r7, #20]
 800ab94:	08da      	lsrs	r2, r3, #3
 800ab96:	687b      	ldr	r3, [r7, #4]
 800ab98:	3208      	adds	r2, #8
 800ab9a:	0092      	lsls	r2, r2, #2
 800ab9c:	6939      	ldr	r1, [r7, #16]
 800ab9e:	50d1      	str	r1, [r2, r3]
      } 

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800aba0:	683b      	ldr	r3, [r7, #0]
 800aba2:	685b      	ldr	r3, [r3, #4]
 800aba4:	2b01      	cmp	r3, #1
 800aba6:	d00b      	beq.n	800abc0 <HAL_GPIO_Init+0xa8>
 800aba8:	683b      	ldr	r3, [r7, #0]
 800abaa:	685b      	ldr	r3, [r3, #4]
 800abac:	2b02      	cmp	r3, #2
 800abae:	d007      	beq.n	800abc0 <HAL_GPIO_Init+0xa8>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800abb0:	683b      	ldr	r3, [r7, #0]
 800abb2:	685b      	ldr	r3, [r3, #4]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800abb4:	2b11      	cmp	r3, #17
 800abb6:	d003      	beq.n	800abc0 <HAL_GPIO_Init+0xa8>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800abb8:	683b      	ldr	r3, [r7, #0]
 800abba:	685b      	ldr	r3, [r3, #4]
 800abbc:	2b12      	cmp	r3, #18
 800abbe:	d130      	bne.n	800ac22 <HAL_GPIO_Init+0x10a>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 800abc0:	687b      	ldr	r3, [r7, #4]
 800abc2:	689b      	ldr	r3, [r3, #8]
 800abc4:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDER_OSPEED0 << (position * 2U));
 800abc6:	697b      	ldr	r3, [r7, #20]
 800abc8:	005b      	lsls	r3, r3, #1
 800abca:	2203      	movs	r2, #3
 800abcc:	409a      	lsls	r2, r3
 800abce:	0013      	movs	r3, r2
 800abd0:	43da      	mvns	r2, r3
 800abd2:	693b      	ldr	r3, [r7, #16]
 800abd4:	4013      	ands	r3, r2
 800abd6:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2U));
 800abd8:	683b      	ldr	r3, [r7, #0]
 800abda:	68da      	ldr	r2, [r3, #12]
 800abdc:	697b      	ldr	r3, [r7, #20]
 800abde:	005b      	lsls	r3, r3, #1
 800abe0:	409a      	lsls	r2, r3
 800abe2:	0013      	movs	r3, r2
 800abe4:	693a      	ldr	r2, [r7, #16]
 800abe6:	4313      	orrs	r3, r2
 800abe8:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 800abea:	687b      	ldr	r3, [r7, #4]
 800abec:	693a      	ldr	r2, [r7, #16]
 800abee:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp= GPIOx->OTYPER;
 800abf0:	687b      	ldr	r3, [r7, #4]
 800abf2:	685b      	ldr	r3, [r3, #4]
 800abf4:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 800abf6:	2201      	movs	r2, #1
 800abf8:	697b      	ldr	r3, [r7, #20]
 800abfa:	409a      	lsls	r2, r3
 800abfc:	0013      	movs	r3, r2
 800abfe:	43da      	mvns	r2, r3
 800ac00:	693b      	ldr	r3, [r7, #16]
 800ac02:	4013      	ands	r3, r2
 800ac04:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 800ac06:	683b      	ldr	r3, [r7, #0]
 800ac08:	685b      	ldr	r3, [r3, #4]
 800ac0a:	091b      	lsrs	r3, r3, #4
 800ac0c:	2201      	movs	r2, #1
 800ac0e:	401a      	ands	r2, r3
 800ac10:	697b      	ldr	r3, [r7, #20]
 800ac12:	409a      	lsls	r2, r3
 800ac14:	0013      	movs	r3, r2
 800ac16:	693a      	ldr	r2, [r7, #16]
 800ac18:	4313      	orrs	r3, r2
 800ac1a:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 800ac1c:	687b      	ldr	r3, [r7, #4]
 800ac1e:	693a      	ldr	r2, [r7, #16]
 800ac20:	605a      	str	r2, [r3, #4]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800ac22:	687b      	ldr	r3, [r7, #4]
 800ac24:	681b      	ldr	r3, [r3, #0]
 800ac26:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 800ac28:	697b      	ldr	r3, [r7, #20]
 800ac2a:	005b      	lsls	r3, r3, #1
 800ac2c:	2203      	movs	r2, #3
 800ac2e:	409a      	lsls	r2, r3
 800ac30:	0013      	movs	r3, r2
 800ac32:	43da      	mvns	r2, r3
 800ac34:	693b      	ldr	r3, [r7, #16]
 800ac36:	4013      	ands	r3, r2
 800ac38:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800ac3a:	683b      	ldr	r3, [r7, #0]
 800ac3c:	685b      	ldr	r3, [r3, #4]
 800ac3e:	2203      	movs	r2, #3
 800ac40:	401a      	ands	r2, r3
 800ac42:	697b      	ldr	r3, [r7, #20]
 800ac44:	005b      	lsls	r3, r3, #1
 800ac46:	409a      	lsls	r2, r3
 800ac48:	0013      	movs	r3, r2
 800ac4a:	693a      	ldr	r2, [r7, #16]
 800ac4c:	4313      	orrs	r3, r2
 800ac4e:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 800ac50:	687b      	ldr	r3, [r7, #4]
 800ac52:	693a      	ldr	r2, [r7, #16]
 800ac54:	601a      	str	r2, [r3, #0]

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 800ac56:	687b      	ldr	r3, [r7, #4]
 800ac58:	68db      	ldr	r3, [r3, #12]
 800ac5a:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 800ac5c:	697b      	ldr	r3, [r7, #20]
 800ac5e:	005b      	lsls	r3, r3, #1
 800ac60:	2203      	movs	r2, #3
 800ac62:	409a      	lsls	r2, r3
 800ac64:	0013      	movs	r3, r2
 800ac66:	43da      	mvns	r2, r3
 800ac68:	693b      	ldr	r3, [r7, #16]
 800ac6a:	4013      	ands	r3, r2
 800ac6c:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Pull) << (position * 2U)); 
 800ac6e:	683b      	ldr	r3, [r7, #0]
 800ac70:	689a      	ldr	r2, [r3, #8]
 800ac72:	697b      	ldr	r3, [r7, #20]
 800ac74:	005b      	lsls	r3, r3, #1
 800ac76:	409a      	lsls	r2, r3
 800ac78:	0013      	movs	r3, r2
 800ac7a:	693a      	ldr	r2, [r7, #16]
 800ac7c:	4313      	orrs	r3, r2
 800ac7e:	613b      	str	r3, [r7, #16]
      GPIOx->PUPDR = temp;
 800ac80:	687b      	ldr	r3, [r7, #4]
 800ac82:	693a      	ldr	r2, [r7, #16]
 800ac84:	60da      	str	r2, [r3, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 800ac86:	683b      	ldr	r3, [r7, #0]
 800ac88:	685a      	ldr	r2, [r3, #4]
 800ac8a:	2380      	movs	r3, #128	; 0x80
 800ac8c:	055b      	lsls	r3, r3, #21
 800ac8e:	4013      	ands	r3, r2
 800ac90:	d100      	bne.n	800ac94 <HAL_GPIO_Init+0x17c>
 800ac92:	e0a0      	b.n	800add6 <HAL_GPIO_Init+0x2be>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800ac94:	4b57      	ldr	r3, [pc, #348]	; (800adf4 <HAL_GPIO_Init+0x2dc>)
 800ac96:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ac98:	4b56      	ldr	r3, [pc, #344]	; (800adf4 <HAL_GPIO_Init+0x2dc>)
 800ac9a:	2101      	movs	r1, #1
 800ac9c:	430a      	orrs	r2, r1
 800ac9e:	635a      	str	r2, [r3, #52]	; 0x34
        
        temp = SYSCFG->EXTICR[position >> 2U];
 800aca0:	4a55      	ldr	r2, [pc, #340]	; (800adf8 <HAL_GPIO_Init+0x2e0>)
 800aca2:	697b      	ldr	r3, [r7, #20]
 800aca4:	089b      	lsrs	r3, r3, #2
 800aca6:	3302      	adds	r3, #2
 800aca8:	009b      	lsls	r3, r3, #2
 800acaa:	589b      	ldr	r3, [r3, r2]
 800acac:	613b      	str	r3, [r7, #16]
        CLEAR_BIT(temp, ((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 800acae:	697b      	ldr	r3, [r7, #20]
 800acb0:	2203      	movs	r2, #3
 800acb2:	4013      	ands	r3, r2
 800acb4:	009b      	lsls	r3, r3, #2
 800acb6:	220f      	movs	r2, #15
 800acb8:	409a      	lsls	r2, r3
 800acba:	0013      	movs	r3, r2
 800acbc:	43da      	mvns	r2, r3
 800acbe:	693b      	ldr	r3, [r7, #16]
 800acc0:	4013      	ands	r3, r2
 800acc2:	613b      	str	r3, [r7, #16]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
 800acc4:	687a      	ldr	r2, [r7, #4]
 800acc6:	23a0      	movs	r3, #160	; 0xa0
 800acc8:	05db      	lsls	r3, r3, #23
 800acca:	429a      	cmp	r2, r3
 800accc:	d01f      	beq.n	800ad0e <HAL_GPIO_Init+0x1f6>
 800acce:	687b      	ldr	r3, [r7, #4]
 800acd0:	4a4a      	ldr	r2, [pc, #296]	; (800adfc <HAL_GPIO_Init+0x2e4>)
 800acd2:	4293      	cmp	r3, r2
 800acd4:	d019      	beq.n	800ad0a <HAL_GPIO_Init+0x1f2>
 800acd6:	687b      	ldr	r3, [r7, #4]
 800acd8:	4a49      	ldr	r2, [pc, #292]	; (800ae00 <HAL_GPIO_Init+0x2e8>)
 800acda:	4293      	cmp	r3, r2
 800acdc:	d013      	beq.n	800ad06 <HAL_GPIO_Init+0x1ee>
 800acde:	687b      	ldr	r3, [r7, #4]
 800ace0:	4a48      	ldr	r2, [pc, #288]	; (800ae04 <HAL_GPIO_Init+0x2ec>)
 800ace2:	4293      	cmp	r3, r2
 800ace4:	d00d      	beq.n	800ad02 <HAL_GPIO_Init+0x1ea>
 800ace6:	687b      	ldr	r3, [r7, #4]
 800ace8:	4a47      	ldr	r2, [pc, #284]	; (800ae08 <HAL_GPIO_Init+0x2f0>)
 800acea:	4293      	cmp	r3, r2
 800acec:	d007      	beq.n	800acfe <HAL_GPIO_Init+0x1e6>
 800acee:	687b      	ldr	r3, [r7, #4]
 800acf0:	4a46      	ldr	r2, [pc, #280]	; (800ae0c <HAL_GPIO_Init+0x2f4>)
 800acf2:	4293      	cmp	r3, r2
 800acf4:	d101      	bne.n	800acfa <HAL_GPIO_Init+0x1e2>
 800acf6:	2305      	movs	r3, #5
 800acf8:	e00a      	b.n	800ad10 <HAL_GPIO_Init+0x1f8>
 800acfa:	2306      	movs	r3, #6
 800acfc:	e008      	b.n	800ad10 <HAL_GPIO_Init+0x1f8>
 800acfe:	2304      	movs	r3, #4
 800ad00:	e006      	b.n	800ad10 <HAL_GPIO_Init+0x1f8>
 800ad02:	2303      	movs	r3, #3
 800ad04:	e004      	b.n	800ad10 <HAL_GPIO_Init+0x1f8>
 800ad06:	2302      	movs	r3, #2
 800ad08:	e002      	b.n	800ad10 <HAL_GPIO_Init+0x1f8>
 800ad0a:	2301      	movs	r3, #1
 800ad0c:	e000      	b.n	800ad10 <HAL_GPIO_Init+0x1f8>
 800ad0e:	2300      	movs	r3, #0
 800ad10:	697a      	ldr	r2, [r7, #20]
 800ad12:	2103      	movs	r1, #3
 800ad14:	400a      	ands	r2, r1
 800ad16:	0092      	lsls	r2, r2, #2
 800ad18:	4093      	lsls	r3, r2
 800ad1a:	693a      	ldr	r2, [r7, #16]
 800ad1c:	4313      	orrs	r3, r2
 800ad1e:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2U] = temp;
 800ad20:	4935      	ldr	r1, [pc, #212]	; (800adf8 <HAL_GPIO_Init+0x2e0>)
 800ad22:	697b      	ldr	r3, [r7, #20]
 800ad24:	089b      	lsrs	r3, r3, #2
 800ad26:	3302      	adds	r3, #2
 800ad28:	009b      	lsls	r3, r3, #2
 800ad2a:	693a      	ldr	r2, [r7, #16]
 800ad2c:	505a      	str	r2, [r3, r1]
                  
        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800ad2e:	4b38      	ldr	r3, [pc, #224]	; (800ae10 <HAL_GPIO_Init+0x2f8>)
 800ad30:	681b      	ldr	r3, [r3, #0]
 800ad32:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 800ad34:	68fb      	ldr	r3, [r7, #12]
 800ad36:	43da      	mvns	r2, r3
 800ad38:	693b      	ldr	r3, [r7, #16]
 800ad3a:	4013      	ands	r3, r2
 800ad3c:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800ad3e:	683b      	ldr	r3, [r7, #0]
 800ad40:	685a      	ldr	r2, [r3, #4]
 800ad42:	2380      	movs	r3, #128	; 0x80
 800ad44:	025b      	lsls	r3, r3, #9
 800ad46:	4013      	ands	r3, r2
 800ad48:	d003      	beq.n	800ad52 <HAL_GPIO_Init+0x23a>
        {
          temp |= iocurrent;
 800ad4a:	693a      	ldr	r2, [r7, #16]
 800ad4c:	68fb      	ldr	r3, [r7, #12]
 800ad4e:	4313      	orrs	r3, r2
 800ad50:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR = temp;
 800ad52:	4b2f      	ldr	r3, [pc, #188]	; (800ae10 <HAL_GPIO_Init+0x2f8>)
 800ad54:	693a      	ldr	r2, [r7, #16]
 800ad56:	601a      	str	r2, [r3, #0]

        temp = EXTI->EMR;
 800ad58:	4b2d      	ldr	r3, [pc, #180]	; (800ae10 <HAL_GPIO_Init+0x2f8>)
 800ad5a:	685b      	ldr	r3, [r3, #4]
 800ad5c:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 800ad5e:	68fb      	ldr	r3, [r7, #12]
 800ad60:	43da      	mvns	r2, r3
 800ad62:	693b      	ldr	r3, [r7, #16]
 800ad64:	4013      	ands	r3, r2
 800ad66:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800ad68:	683b      	ldr	r3, [r7, #0]
 800ad6a:	685a      	ldr	r2, [r3, #4]
 800ad6c:	2380      	movs	r3, #128	; 0x80
 800ad6e:	029b      	lsls	r3, r3, #10
 800ad70:	4013      	ands	r3, r2
 800ad72:	d003      	beq.n	800ad7c <HAL_GPIO_Init+0x264>
        {
          temp |= iocurrent;
 800ad74:	693a      	ldr	r2, [r7, #16]
 800ad76:	68fb      	ldr	r3, [r7, #12]
 800ad78:	4313      	orrs	r3, r2
 800ad7a:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR = temp;
 800ad7c:	4b24      	ldr	r3, [pc, #144]	; (800ae10 <HAL_GPIO_Init+0x2f8>)
 800ad7e:	693a      	ldr	r2, [r7, #16]
 800ad80:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800ad82:	4b23      	ldr	r3, [pc, #140]	; (800ae10 <HAL_GPIO_Init+0x2f8>)
 800ad84:	689b      	ldr	r3, [r3, #8]
 800ad86:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 800ad88:	68fb      	ldr	r3, [r7, #12]
 800ad8a:	43da      	mvns	r2, r3
 800ad8c:	693b      	ldr	r3, [r7, #16]
 800ad8e:	4013      	ands	r3, r2
 800ad90:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800ad92:	683b      	ldr	r3, [r7, #0]
 800ad94:	685a      	ldr	r2, [r3, #4]
 800ad96:	2380      	movs	r3, #128	; 0x80
 800ad98:	035b      	lsls	r3, r3, #13
 800ad9a:	4013      	ands	r3, r2
 800ad9c:	d003      	beq.n	800ada6 <HAL_GPIO_Init+0x28e>
        {
          temp |= iocurrent;
 800ad9e:	693a      	ldr	r2, [r7, #16]
 800ada0:	68fb      	ldr	r3, [r7, #12]
 800ada2:	4313      	orrs	r3, r2
 800ada4:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR = temp;
 800ada6:	4b1a      	ldr	r3, [pc, #104]	; (800ae10 <HAL_GPIO_Init+0x2f8>)
 800ada8:	693a      	ldr	r2, [r7, #16]
 800adaa:	609a      	str	r2, [r3, #8]

        temp = EXTI->FTSR;
 800adac:	4b18      	ldr	r3, [pc, #96]	; (800ae10 <HAL_GPIO_Init+0x2f8>)
 800adae:	68db      	ldr	r3, [r3, #12]
 800adb0:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 800adb2:	68fb      	ldr	r3, [r7, #12]
 800adb4:	43da      	mvns	r2, r3
 800adb6:	693b      	ldr	r3, [r7, #16]
 800adb8:	4013      	ands	r3, r2
 800adba:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800adbc:	683b      	ldr	r3, [r7, #0]
 800adbe:	685a      	ldr	r2, [r3, #4]
 800adc0:	2380      	movs	r3, #128	; 0x80
 800adc2:	039b      	lsls	r3, r3, #14
 800adc4:	4013      	ands	r3, r2
 800adc6:	d003      	beq.n	800add0 <HAL_GPIO_Init+0x2b8>
        {
          temp |= iocurrent;
 800adc8:	693a      	ldr	r2, [r7, #16]
 800adca:	68fb      	ldr	r3, [r7, #12]
 800adcc:	4313      	orrs	r3, r2
 800adce:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR = temp;
 800add0:	4b0f      	ldr	r3, [pc, #60]	; (800ae10 <HAL_GPIO_Init+0x2f8>)
 800add2:	693a      	ldr	r2, [r7, #16]
 800add4:	60da      	str	r2, [r3, #12]
      }
    }
    position++;
 800add6:	697b      	ldr	r3, [r7, #20]
 800add8:	3301      	adds	r3, #1
 800adda:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0)
 800addc:	683b      	ldr	r3, [r7, #0]
 800adde:	681a      	ldr	r2, [r3, #0]
 800ade0:	697b      	ldr	r3, [r7, #20]
 800ade2:	40da      	lsrs	r2, r3
 800ade4:	1e13      	subs	r3, r2, #0
 800ade6:	d000      	beq.n	800adea <HAL_GPIO_Init+0x2d2>
 800ade8:	e6a2      	b.n	800ab30 <HAL_GPIO_Init+0x18>
  }
}
 800adea:	46c0      	nop			; (mov r8, r8)
 800adec:	46bd      	mov	sp, r7
 800adee:	b006      	add	sp, #24
 800adf0:	bd80      	pop	{r7, pc}
 800adf2:	46c0      	nop			; (mov r8, r8)
 800adf4:	40021000 	.word	0x40021000
 800adf8:	40010000 	.word	0x40010000
 800adfc:	50000400 	.word	0x50000400
 800ae00:	50000800 	.word	0x50000800
 800ae04:	50000c00 	.word	0x50000c00
 800ae08:	50001000 	.word	0x50001000
 800ae0c:	50001c00 	.word	0x50001c00
 800ae10:	40010400 	.word	0x40010400

0800ae14 <HAL_GPIO_WritePin>:
  *                        GPIO_PIN_RESET: to clear the port pin
  *                        GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800ae14:	b580      	push	{r7, lr}
 800ae16:	b082      	sub	sp, #8
 800ae18:	af00      	add	r7, sp, #0
 800ae1a:	6078      	str	r0, [r7, #4]
 800ae1c:	0008      	movs	r0, r1
 800ae1e:	0011      	movs	r1, r2
 800ae20:	1cbb      	adds	r3, r7, #2
 800ae22:	1c02      	adds	r2, r0, #0
 800ae24:	801a      	strh	r2, [r3, #0]
 800ae26:	1c7b      	adds	r3, r7, #1
 800ae28:	1c0a      	adds	r2, r1, #0
 800ae2a:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx,GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));
  
  if(PinState != GPIO_PIN_RESET)
 800ae2c:	1c7b      	adds	r3, r7, #1
 800ae2e:	781b      	ldrb	r3, [r3, #0]
 800ae30:	2b00      	cmp	r3, #0
 800ae32:	d004      	beq.n	800ae3e <HAL_GPIO_WritePin+0x2a>
  {
    GPIOx->BSRR = GPIO_Pin;
 800ae34:	1cbb      	adds	r3, r7, #2
 800ae36:	881a      	ldrh	r2, [r3, #0]
 800ae38:	687b      	ldr	r3, [r7, #4]
 800ae3a:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = GPIO_Pin ;
  }
}
 800ae3c:	e003      	b.n	800ae46 <HAL_GPIO_WritePin+0x32>
    GPIOx->BRR = GPIO_Pin ;
 800ae3e:	1cbb      	adds	r3, r7, #2
 800ae40:	881a      	ldrh	r2, [r3, #0]
 800ae42:	687b      	ldr	r3, [r7, #4]
 800ae44:	629a      	str	r2, [r3, #40]	; 0x28
}
 800ae46:	46c0      	nop			; (mov r8, r8)
 800ae48:	46bd      	mov	sp, r7
 800ae4a:	b002      	add	sp, #8
 800ae4c:	bd80      	pop	{r7, pc}
	...

0800ae50 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  This function handles EXTI interrupt request.
  * @param  GPIO_Pin Specifies the pins connected to the EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 800ae50:	b580      	push	{r7, lr}
 800ae52:	b082      	sub	sp, #8
 800ae54:	af00      	add	r7, sp, #0
 800ae56:	0002      	movs	r2, r0
 800ae58:	1dbb      	adds	r3, r7, #6
 800ae5a:	801a      	strh	r2, [r3, #0]
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) 
 800ae5c:	4b09      	ldr	r3, [pc, #36]	; (800ae84 <HAL_GPIO_EXTI_IRQHandler+0x34>)
 800ae5e:	695b      	ldr	r3, [r3, #20]
 800ae60:	1dba      	adds	r2, r7, #6
 800ae62:	8812      	ldrh	r2, [r2, #0]
 800ae64:	4013      	ands	r3, r2
 800ae66:	d008      	beq.n	800ae7a <HAL_GPIO_EXTI_IRQHandler+0x2a>
  { 
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 800ae68:	4b06      	ldr	r3, [pc, #24]	; (800ae84 <HAL_GPIO_EXTI_IRQHandler+0x34>)
 800ae6a:	1dba      	adds	r2, r7, #6
 800ae6c:	8812      	ldrh	r2, [r2, #0]
 800ae6e:	615a      	str	r2, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 800ae70:	1dbb      	adds	r3, r7, #6
 800ae72:	881b      	ldrh	r3, [r3, #0]
 800ae74:	0018      	movs	r0, r3
 800ae76:	f7ff f95f 	bl	800a138 <HAL_GPIO_EXTI_Callback>
  }
}
 800ae7a:	46c0      	nop			; (mov r8, r8)
 800ae7c:	46bd      	mov	sp, r7
 800ae7e:	b002      	add	sp, #8
 800ae80:	bd80      	pop	{r7, pc}
 800ae82:	46c0      	nop			; (mov r8, r8)
 800ae84:	40010400 	.word	0x40010400

0800ae88 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 800ae88:	b580      	push	{r7, lr}
 800ae8a:	b082      	sub	sp, #8
 800ae8c:	af00      	add	r7, sp, #0
 800ae8e:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 800ae90:	687b      	ldr	r3, [r7, #4]
 800ae92:	2b00      	cmp	r3, #0
 800ae94:	d101      	bne.n	800ae9a <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
 800ae96:	2301      	movs	r3, #1
 800ae98:	e082      	b.n	800afa0 <HAL_I2C_Init+0x118>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 800ae9a:	687b      	ldr	r3, [r7, #4]
 800ae9c:	2241      	movs	r2, #65	; 0x41
 800ae9e:	5c9b      	ldrb	r3, [r3, r2]
 800aea0:	b2db      	uxtb	r3, r3
 800aea2:	2b00      	cmp	r3, #0
 800aea4:	d107      	bne.n	800aeb6 <HAL_I2C_Init+0x2e>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 800aea6:	687b      	ldr	r3, [r7, #4]
 800aea8:	2240      	movs	r2, #64	; 0x40
 800aeaa:	2100      	movs	r1, #0
 800aeac:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
 800aeae:	687b      	ldr	r3, [r7, #4]
 800aeb0:	0018      	movs	r0, r3
 800aeb2:	f7ff faeb 	bl	800a48c <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 800aeb6:	687b      	ldr	r3, [r7, #4]
 800aeb8:	2241      	movs	r2, #65	; 0x41
 800aeba:	2124      	movs	r1, #36	; 0x24
 800aebc:	5499      	strb	r1, [r3, r2]

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 800aebe:	687b      	ldr	r3, [r7, #4]
 800aec0:	681b      	ldr	r3, [r3, #0]
 800aec2:	681a      	ldr	r2, [r3, #0]
 800aec4:	687b      	ldr	r3, [r7, #4]
 800aec6:	681b      	ldr	r3, [r3, #0]
 800aec8:	2101      	movs	r1, #1
 800aeca:	438a      	bics	r2, r1
 800aecc:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 800aece:	687b      	ldr	r3, [r7, #4]
 800aed0:	685a      	ldr	r2, [r3, #4]
 800aed2:	687b      	ldr	r3, [r7, #4]
 800aed4:	681b      	ldr	r3, [r3, #0]
 800aed6:	4934      	ldr	r1, [pc, #208]	; (800afa8 <HAL_I2C_Init+0x120>)
 800aed8:	400a      	ands	r2, r1
 800aeda:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 800aedc:	687b      	ldr	r3, [r7, #4]
 800aede:	681b      	ldr	r3, [r3, #0]
 800aee0:	689a      	ldr	r2, [r3, #8]
 800aee2:	687b      	ldr	r3, [r7, #4]
 800aee4:	681b      	ldr	r3, [r3, #0]
 800aee6:	4931      	ldr	r1, [pc, #196]	; (800afac <HAL_I2C_Init+0x124>)
 800aee8:	400a      	ands	r2, r1
 800aeea:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800aeec:	687b      	ldr	r3, [r7, #4]
 800aeee:	68db      	ldr	r3, [r3, #12]
 800aef0:	2b01      	cmp	r3, #1
 800aef2:	d108      	bne.n	800af06 <HAL_I2C_Init+0x7e>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 800aef4:	687b      	ldr	r3, [r7, #4]
 800aef6:	689a      	ldr	r2, [r3, #8]
 800aef8:	687b      	ldr	r3, [r7, #4]
 800aefa:	681b      	ldr	r3, [r3, #0]
 800aefc:	2180      	movs	r1, #128	; 0x80
 800aefe:	0209      	lsls	r1, r1, #8
 800af00:	430a      	orrs	r2, r1
 800af02:	609a      	str	r2, [r3, #8]
 800af04:	e007      	b.n	800af16 <HAL_I2C_Init+0x8e>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 800af06:	687b      	ldr	r3, [r7, #4]
 800af08:	689a      	ldr	r2, [r3, #8]
 800af0a:	687b      	ldr	r3, [r7, #4]
 800af0c:	681b      	ldr	r3, [r3, #0]
 800af0e:	2184      	movs	r1, #132	; 0x84
 800af10:	0209      	lsls	r1, r1, #8
 800af12:	430a      	orrs	r2, r1
 800af14:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 800af16:	687b      	ldr	r3, [r7, #4]
 800af18:	68db      	ldr	r3, [r3, #12]
 800af1a:	2b02      	cmp	r3, #2
 800af1c:	d104      	bne.n	800af28 <HAL_I2C_Init+0xa0>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 800af1e:	687b      	ldr	r3, [r7, #4]
 800af20:	681b      	ldr	r3, [r3, #0]
 800af22:	2280      	movs	r2, #128	; 0x80
 800af24:	0112      	lsls	r2, r2, #4
 800af26:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 800af28:	687b      	ldr	r3, [r7, #4]
 800af2a:	681b      	ldr	r3, [r3, #0]
 800af2c:	685a      	ldr	r2, [r3, #4]
 800af2e:	687b      	ldr	r3, [r7, #4]
 800af30:	681b      	ldr	r3, [r3, #0]
 800af32:	491f      	ldr	r1, [pc, #124]	; (800afb0 <HAL_I2C_Init+0x128>)
 800af34:	430a      	orrs	r2, r1
 800af36:	605a      	str	r2, [r3, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 800af38:	687b      	ldr	r3, [r7, #4]
 800af3a:	681b      	ldr	r3, [r3, #0]
 800af3c:	68da      	ldr	r2, [r3, #12]
 800af3e:	687b      	ldr	r3, [r7, #4]
 800af40:	681b      	ldr	r3, [r3, #0]
 800af42:	491a      	ldr	r1, [pc, #104]	; (800afac <HAL_I2C_Init+0x124>)
 800af44:	400a      	ands	r2, r1
 800af46:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 800af48:	687b      	ldr	r3, [r7, #4]
 800af4a:	691a      	ldr	r2, [r3, #16]
 800af4c:	687b      	ldr	r3, [r7, #4]
 800af4e:	695b      	ldr	r3, [r3, #20]
 800af50:	431a      	orrs	r2, r3
 800af52:	0011      	movs	r1, r2
 800af54:	687b      	ldr	r3, [r7, #4]
 800af56:	699b      	ldr	r3, [r3, #24]
 800af58:	021a      	lsls	r2, r3, #8
 800af5a:	687b      	ldr	r3, [r7, #4]
 800af5c:	681b      	ldr	r3, [r3, #0]
 800af5e:	430a      	orrs	r2, r1
 800af60:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 800af62:	687b      	ldr	r3, [r7, #4]
 800af64:	69d9      	ldr	r1, [r3, #28]
 800af66:	687b      	ldr	r3, [r7, #4]
 800af68:	6a1a      	ldr	r2, [r3, #32]
 800af6a:	687b      	ldr	r3, [r7, #4]
 800af6c:	681b      	ldr	r3, [r3, #0]
 800af6e:	430a      	orrs	r2, r1
 800af70:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 800af72:	687b      	ldr	r3, [r7, #4]
 800af74:	681b      	ldr	r3, [r3, #0]
 800af76:	681a      	ldr	r2, [r3, #0]
 800af78:	687b      	ldr	r3, [r7, #4]
 800af7a:	681b      	ldr	r3, [r3, #0]
 800af7c:	2101      	movs	r1, #1
 800af7e:	430a      	orrs	r2, r1
 800af80:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800af82:	687b      	ldr	r3, [r7, #4]
 800af84:	2200      	movs	r2, #0
 800af86:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 800af88:	687b      	ldr	r3, [r7, #4]
 800af8a:	2241      	movs	r2, #65	; 0x41
 800af8c:	2120      	movs	r1, #32
 800af8e:	5499      	strb	r1, [r3, r2]
  hi2c->PreviousState = I2C_STATE_NONE;
 800af90:	687b      	ldr	r3, [r7, #4]
 800af92:	2200      	movs	r2, #0
 800af94:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800af96:	687b      	ldr	r3, [r7, #4]
 800af98:	2242      	movs	r2, #66	; 0x42
 800af9a:	2100      	movs	r1, #0
 800af9c:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800af9e:	2300      	movs	r3, #0
}
 800afa0:	0018      	movs	r0, r3
 800afa2:	46bd      	mov	sp, r7
 800afa4:	b002      	add	sp, #8
 800afa6:	bd80      	pop	{r7, pc}
 800afa8:	f0ffffff 	.word	0xf0ffffff
 800afac:	ffff7fff 	.word	0xffff7fff
 800afb0:	02008000 	.word	0x02008000

0800afb4 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 800afb4:	b580      	push	{r7, lr}
 800afb6:	b082      	sub	sp, #8
 800afb8:	af00      	add	r7, sp, #0
 800afba:	6078      	str	r0, [r7, #4]
 800afbc:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800afbe:	687b      	ldr	r3, [r7, #4]
 800afc0:	2241      	movs	r2, #65	; 0x41
 800afc2:	5c9b      	ldrb	r3, [r3, r2]
 800afc4:	b2db      	uxtb	r3, r3
 800afc6:	2b20      	cmp	r3, #32
 800afc8:	d138      	bne.n	800b03c <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 800afca:	687b      	ldr	r3, [r7, #4]
 800afcc:	2240      	movs	r2, #64	; 0x40
 800afce:	5c9b      	ldrb	r3, [r3, r2]
 800afd0:	2b01      	cmp	r3, #1
 800afd2:	d101      	bne.n	800afd8 <HAL_I2CEx_ConfigAnalogFilter+0x24>
 800afd4:	2302      	movs	r3, #2
 800afd6:	e032      	b.n	800b03e <HAL_I2CEx_ConfigAnalogFilter+0x8a>
 800afd8:	687b      	ldr	r3, [r7, #4]
 800afda:	2240      	movs	r2, #64	; 0x40
 800afdc:	2101      	movs	r1, #1
 800afde:	5499      	strb	r1, [r3, r2]

    hi2c->State = HAL_I2C_STATE_BUSY;
 800afe0:	687b      	ldr	r3, [r7, #4]
 800afe2:	2241      	movs	r2, #65	; 0x41
 800afe4:	2124      	movs	r1, #36	; 0x24
 800afe6:	5499      	strb	r1, [r3, r2]

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 800afe8:	687b      	ldr	r3, [r7, #4]
 800afea:	681b      	ldr	r3, [r3, #0]
 800afec:	681a      	ldr	r2, [r3, #0]
 800afee:	687b      	ldr	r3, [r7, #4]
 800aff0:	681b      	ldr	r3, [r3, #0]
 800aff2:	2101      	movs	r1, #1
 800aff4:	438a      	bics	r2, r1
 800aff6:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 800aff8:	687b      	ldr	r3, [r7, #4]
 800affa:	681b      	ldr	r3, [r3, #0]
 800affc:	681a      	ldr	r2, [r3, #0]
 800affe:	687b      	ldr	r3, [r7, #4]
 800b000:	681b      	ldr	r3, [r3, #0]
 800b002:	4911      	ldr	r1, [pc, #68]	; (800b048 <HAL_I2CEx_ConfigAnalogFilter+0x94>)
 800b004:	400a      	ands	r2, r1
 800b006:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 800b008:	687b      	ldr	r3, [r7, #4]
 800b00a:	681b      	ldr	r3, [r3, #0]
 800b00c:	6819      	ldr	r1, [r3, #0]
 800b00e:	687b      	ldr	r3, [r7, #4]
 800b010:	681b      	ldr	r3, [r3, #0]
 800b012:	683a      	ldr	r2, [r7, #0]
 800b014:	430a      	orrs	r2, r1
 800b016:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 800b018:	687b      	ldr	r3, [r7, #4]
 800b01a:	681b      	ldr	r3, [r3, #0]
 800b01c:	681a      	ldr	r2, [r3, #0]
 800b01e:	687b      	ldr	r3, [r7, #4]
 800b020:	681b      	ldr	r3, [r3, #0]
 800b022:	2101      	movs	r1, #1
 800b024:	430a      	orrs	r2, r1
 800b026:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 800b028:	687b      	ldr	r3, [r7, #4]
 800b02a:	2241      	movs	r2, #65	; 0x41
 800b02c:	2120      	movs	r1, #32
 800b02e:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800b030:	687b      	ldr	r3, [r7, #4]
 800b032:	2240      	movs	r2, #64	; 0x40
 800b034:	2100      	movs	r1, #0
 800b036:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
 800b038:	2300      	movs	r3, #0
 800b03a:	e000      	b.n	800b03e <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
 800b03c:	2302      	movs	r3, #2
  }
}
 800b03e:	0018      	movs	r0, r3
 800b040:	46bd      	mov	sp, r7
 800b042:	b002      	add	sp, #8
 800b044:	bd80      	pop	{r7, pc}
 800b046:	46c0      	nop			; (mov r8, r8)
 800b048:	ffffefff 	.word	0xffffefff

0800b04c <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 800b04c:	b580      	push	{r7, lr}
 800b04e:	b084      	sub	sp, #16
 800b050:	af00      	add	r7, sp, #0
 800b052:	6078      	str	r0, [r7, #4]
 800b054:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800b056:	687b      	ldr	r3, [r7, #4]
 800b058:	2241      	movs	r2, #65	; 0x41
 800b05a:	5c9b      	ldrb	r3, [r3, r2]
 800b05c:	b2db      	uxtb	r3, r3
 800b05e:	2b20      	cmp	r3, #32
 800b060:	d139      	bne.n	800b0d6 <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 800b062:	687b      	ldr	r3, [r7, #4]
 800b064:	2240      	movs	r2, #64	; 0x40
 800b066:	5c9b      	ldrb	r3, [r3, r2]
 800b068:	2b01      	cmp	r3, #1
 800b06a:	d101      	bne.n	800b070 <HAL_I2CEx_ConfigDigitalFilter+0x24>
 800b06c:	2302      	movs	r3, #2
 800b06e:	e033      	b.n	800b0d8 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
 800b070:	687b      	ldr	r3, [r7, #4]
 800b072:	2240      	movs	r2, #64	; 0x40
 800b074:	2101      	movs	r1, #1
 800b076:	5499      	strb	r1, [r3, r2]

    hi2c->State = HAL_I2C_STATE_BUSY;
 800b078:	687b      	ldr	r3, [r7, #4]
 800b07a:	2241      	movs	r2, #65	; 0x41
 800b07c:	2124      	movs	r1, #36	; 0x24
 800b07e:	5499      	strb	r1, [r3, r2]

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 800b080:	687b      	ldr	r3, [r7, #4]
 800b082:	681b      	ldr	r3, [r3, #0]
 800b084:	681a      	ldr	r2, [r3, #0]
 800b086:	687b      	ldr	r3, [r7, #4]
 800b088:	681b      	ldr	r3, [r3, #0]
 800b08a:	2101      	movs	r1, #1
 800b08c:	438a      	bics	r2, r1
 800b08e:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 800b090:	687b      	ldr	r3, [r7, #4]
 800b092:	681b      	ldr	r3, [r3, #0]
 800b094:	681b      	ldr	r3, [r3, #0]
 800b096:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 800b098:	68fb      	ldr	r3, [r7, #12]
 800b09a:	4a11      	ldr	r2, [pc, #68]	; (800b0e0 <HAL_I2CEx_ConfigDigitalFilter+0x94>)
 800b09c:	4013      	ands	r3, r2
 800b09e:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 800b0a0:	683b      	ldr	r3, [r7, #0]
 800b0a2:	021b      	lsls	r3, r3, #8
 800b0a4:	68fa      	ldr	r2, [r7, #12]
 800b0a6:	4313      	orrs	r3, r2
 800b0a8:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 800b0aa:	687b      	ldr	r3, [r7, #4]
 800b0ac:	681b      	ldr	r3, [r3, #0]
 800b0ae:	68fa      	ldr	r2, [r7, #12]
 800b0b0:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 800b0b2:	687b      	ldr	r3, [r7, #4]
 800b0b4:	681b      	ldr	r3, [r3, #0]
 800b0b6:	681a      	ldr	r2, [r3, #0]
 800b0b8:	687b      	ldr	r3, [r7, #4]
 800b0ba:	681b      	ldr	r3, [r3, #0]
 800b0bc:	2101      	movs	r1, #1
 800b0be:	430a      	orrs	r2, r1
 800b0c0:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 800b0c2:	687b      	ldr	r3, [r7, #4]
 800b0c4:	2241      	movs	r2, #65	; 0x41
 800b0c6:	2120      	movs	r1, #32
 800b0c8:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800b0ca:	687b      	ldr	r3, [r7, #4]
 800b0cc:	2240      	movs	r2, #64	; 0x40
 800b0ce:	2100      	movs	r1, #0
 800b0d0:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
 800b0d2:	2300      	movs	r3, #0
 800b0d4:	e000      	b.n	800b0d8 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
 800b0d6:	2302      	movs	r3, #2
  }
}
 800b0d8:	0018      	movs	r0, r3
 800b0da:	46bd      	mov	sp, r7
 800b0dc:	b004      	add	sp, #16
 800b0de:	bd80      	pop	{r7, pc}
 800b0e0:	fffff0ff 	.word	0xfffff0ff

0800b0e4 <HAL_LPTIM_Init>:
  *         LPTIM_InitTypeDef and initialize the associated handle.
  * @param  hlptim LPTIM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LPTIM_Init(LPTIM_HandleTypeDef *hlptim)
{
 800b0e4:	b580      	push	{r7, lr}
 800b0e6:	b084      	sub	sp, #16
 800b0e8:	af00      	add	r7, sp, #0
 800b0ea:	6078      	str	r0, [r7, #4]
  uint32_t tmpcfgr;

  /* Check the LPTIM handle allocation */
  if (hlptim == NULL)
 800b0ec:	687b      	ldr	r3, [r7, #4]
 800b0ee:	2b00      	cmp	r3, #0
 800b0f0:	d101      	bne.n	800b0f6 <HAL_LPTIM_Init+0x12>
  {
    return HAL_ERROR;
 800b0f2:	2301      	movs	r3, #1
 800b0f4:	e06c      	b.n	800b1d0 <HAL_LPTIM_Init+0xec>
  }
  assert_param(IS_LPTIM_OUTPUT_POLARITY(hlptim->Init.OutputPolarity));
  assert_param(IS_LPTIM_UPDATE_MODE(hlptim->Init.UpdateMode));
  assert_param(IS_LPTIM_COUNTER_SOURCE(hlptim->Init.CounterSource));

  if (hlptim->State == HAL_LPTIM_STATE_RESET)
 800b0f6:	687b      	ldr	r3, [r7, #4]
 800b0f8:	222e      	movs	r2, #46	; 0x2e
 800b0fa:	5c9b      	ldrb	r3, [r3, r2]
 800b0fc:	b2db      	uxtb	r3, r3
 800b0fe:	2b00      	cmp	r3, #0
 800b100:	d107      	bne.n	800b112 <HAL_LPTIM_Init+0x2e>
  {
    /* Allocate lock resource and initialize it */
    hlptim->Lock = HAL_UNLOCKED;
 800b102:	687b      	ldr	r3, [r7, #4]
 800b104:	222d      	movs	r2, #45	; 0x2d
 800b106:	2100      	movs	r1, #0
 800b108:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    hlptim->MspInitCallback(hlptim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_LPTIM_MspInit(hlptim);
 800b10a:	687b      	ldr	r3, [r7, #4]
 800b10c:	0018      	movs	r0, r3
 800b10e:	f7ff fa27 	bl	800a560 <HAL_LPTIM_MspInit>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
  }

  /* Change the LPTIM state */
  hlptim->State = HAL_LPTIM_STATE_BUSY;
 800b112:	687b      	ldr	r3, [r7, #4]
 800b114:	222e      	movs	r2, #46	; 0x2e
 800b116:	2102      	movs	r1, #2
 800b118:	5499      	strb	r1, [r3, r2]

  /* Get the LPTIMx CFGR value */
  tmpcfgr = hlptim->Instance->CFGR;
 800b11a:	687b      	ldr	r3, [r7, #4]
 800b11c:	681b      	ldr	r3, [r3, #0]
 800b11e:	68db      	ldr	r3, [r3, #12]
 800b120:	60fb      	str	r3, [r7, #12]

  if (((hlptim->Init.Clock.Source) == LPTIM_CLOCKSOURCE_ULPTIM) || ((hlptim->Init.CounterSource) == LPTIM_COUNTERSOURCE_EXTERNAL))
 800b122:	687b      	ldr	r3, [r7, #4]
 800b124:	685b      	ldr	r3, [r3, #4]
 800b126:	2b01      	cmp	r3, #1
 800b128:	d005      	beq.n	800b136 <HAL_LPTIM_Init+0x52>
 800b12a:	687b      	ldr	r3, [r7, #4]
 800b12c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800b12e:	2380      	movs	r3, #128	; 0x80
 800b130:	041b      	lsls	r3, r3, #16
 800b132:	429a      	cmp	r2, r3
 800b134:	d103      	bne.n	800b13e <HAL_LPTIM_Init+0x5a>
  {
    tmpcfgr &= (uint32_t)(~(LPTIM_CFGR_CKPOL | LPTIM_CFGR_CKFLT));
 800b136:	68fb      	ldr	r3, [r7, #12]
 800b138:	221e      	movs	r2, #30
 800b13a:	4393      	bics	r3, r2
 800b13c:	60fb      	str	r3, [r7, #12]
  }
  if ((hlptim->Init.Trigger.Source) != LPTIM_TRIGSOURCE_SOFTWARE)
 800b13e:	687b      	ldr	r3, [r7, #4]
 800b140:	695b      	ldr	r3, [r3, #20]
 800b142:	4a25      	ldr	r2, [pc, #148]	; (800b1d8 <HAL_LPTIM_Init+0xf4>)
 800b144:	4293      	cmp	r3, r2
 800b146:	d003      	beq.n	800b150 <HAL_LPTIM_Init+0x6c>
  {
    tmpcfgr &= (uint32_t)(~(LPTIM_CFGR_TRGFLT | LPTIM_CFGR_TRIGSEL));
 800b148:	68fb      	ldr	r3, [r7, #12]
 800b14a:	4a24      	ldr	r2, [pc, #144]	; (800b1dc <HAL_LPTIM_Init+0xf8>)
 800b14c:	4013      	ands	r3, r2
 800b14e:	60fb      	str	r3, [r7, #12]
  }

  /* Clear CKSEL, CKPOL, PRESC, TRIGEN, TRGFLT, WAVPOL, PRELOAD & COUNTMODE bits */
  tmpcfgr &= (uint32_t)(~(LPTIM_CFGR_CKSEL | LPTIM_CFGR_CKPOL | LPTIM_CFGR_TRIGEN | LPTIM_CFGR_PRELOAD |
 800b150:	68fb      	ldr	r3, [r7, #12]
 800b152:	4a23      	ldr	r2, [pc, #140]	; (800b1e0 <HAL_LPTIM_Init+0xfc>)
 800b154:	4013      	ands	r3, r2
 800b156:	60fb      	str	r3, [r7, #12]
                          LPTIM_CFGR_WAVPOL | LPTIM_CFGR_PRESC | LPTIM_CFGR_COUNTMODE));

  /* Set initialization parameters */
  tmpcfgr |= (hlptim->Init.Clock.Source    |
 800b158:	687b      	ldr	r3, [r7, #4]
 800b15a:	685a      	ldr	r2, [r3, #4]
              hlptim->Init.Clock.Prescaler |
 800b15c:	687b      	ldr	r3, [r7, #4]
 800b15e:	689b      	ldr	r3, [r3, #8]
  tmpcfgr |= (hlptim->Init.Clock.Source    |
 800b160:	431a      	orrs	r2, r3
              hlptim->Init.OutputPolarity  |
 800b162:	687b      	ldr	r3, [r7, #4]
 800b164:	6a1b      	ldr	r3, [r3, #32]
              hlptim->Init.Clock.Prescaler |
 800b166:	431a      	orrs	r2, r3
              hlptim->Init.UpdateMode      |
 800b168:	687b      	ldr	r3, [r7, #4]
 800b16a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
              hlptim->Init.OutputPolarity  |
 800b16c:	431a      	orrs	r2, r3
              hlptim->Init.CounterSource);
 800b16e:	687b      	ldr	r3, [r7, #4]
 800b170:	6a9b      	ldr	r3, [r3, #40]	; 0x28
              hlptim->Init.UpdateMode      |
 800b172:	4313      	orrs	r3, r2
  tmpcfgr |= (hlptim->Init.Clock.Source    |
 800b174:	68fa      	ldr	r2, [r7, #12]
 800b176:	4313      	orrs	r3, r2
 800b178:	60fb      	str	r3, [r7, #12]

  if (((hlptim->Init.Clock.Source) == LPTIM_CLOCKSOURCE_ULPTIM) || ((hlptim->Init.CounterSource) == LPTIM_COUNTERSOURCE_EXTERNAL))
 800b17a:	687b      	ldr	r3, [r7, #4]
 800b17c:	685b      	ldr	r3, [r3, #4]
 800b17e:	2b01      	cmp	r3, #1
 800b180:	d005      	beq.n	800b18e <HAL_LPTIM_Init+0xaa>
 800b182:	687b      	ldr	r3, [r7, #4]
 800b184:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800b186:	2380      	movs	r3, #128	; 0x80
 800b188:	041b      	lsls	r3, r3, #16
 800b18a:	429a      	cmp	r2, r3
 800b18c:	d107      	bne.n	800b19e <HAL_LPTIM_Init+0xba>
  {
    tmpcfgr |= (hlptim->Init.UltraLowPowerClock.Polarity |
 800b18e:	687b      	ldr	r3, [r7, #4]
 800b190:	68da      	ldr	r2, [r3, #12]
                hlptim->Init.UltraLowPowerClock.SampleTime);
 800b192:	687b      	ldr	r3, [r7, #4]
 800b194:	691b      	ldr	r3, [r3, #16]
    tmpcfgr |= (hlptim->Init.UltraLowPowerClock.Polarity |
 800b196:	4313      	orrs	r3, r2
 800b198:	68fa      	ldr	r2, [r7, #12]
 800b19a:	4313      	orrs	r3, r2
 800b19c:	60fb      	str	r3, [r7, #12]
  }

  if ((hlptim->Init.Trigger.Source) != LPTIM_TRIGSOURCE_SOFTWARE)
 800b19e:	687b      	ldr	r3, [r7, #4]
 800b1a0:	695b      	ldr	r3, [r3, #20]
 800b1a2:	4a0d      	ldr	r2, [pc, #52]	; (800b1d8 <HAL_LPTIM_Init+0xf4>)
 800b1a4:	4293      	cmp	r3, r2
 800b1a6:	d00a      	beq.n	800b1be <HAL_LPTIM_Init+0xda>
  {
    /* Enable External trigger and set the trigger source */
    tmpcfgr |= (hlptim->Init.Trigger.Source     |
 800b1a8:	687b      	ldr	r3, [r7, #4]
 800b1aa:	695a      	ldr	r2, [r3, #20]
                hlptim->Init.Trigger.ActiveEdge |
 800b1ac:	687b      	ldr	r3, [r7, #4]
 800b1ae:	699b      	ldr	r3, [r3, #24]
    tmpcfgr |= (hlptim->Init.Trigger.Source     |
 800b1b0:	431a      	orrs	r2, r3
                hlptim->Init.Trigger.SampleTime);
 800b1b2:	687b      	ldr	r3, [r7, #4]
 800b1b4:	69db      	ldr	r3, [r3, #28]
                hlptim->Init.Trigger.ActiveEdge |
 800b1b6:	4313      	orrs	r3, r2
    tmpcfgr |= (hlptim->Init.Trigger.Source     |
 800b1b8:	68fa      	ldr	r2, [r7, #12]
 800b1ba:	4313      	orrs	r3, r2
 800b1bc:	60fb      	str	r3, [r7, #12]
  }

  /* Write to LPTIMx CFGR */
  hlptim->Instance->CFGR = tmpcfgr;
 800b1be:	687b      	ldr	r3, [r7, #4]
 800b1c0:	681b      	ldr	r3, [r3, #0]
 800b1c2:	68fa      	ldr	r2, [r7, #12]
 800b1c4:	60da      	str	r2, [r3, #12]

  /* Change the LPTIM state */
  hlptim->State = HAL_LPTIM_STATE_READY;
 800b1c6:	687b      	ldr	r3, [r7, #4]
 800b1c8:	222e      	movs	r2, #46	; 0x2e
 800b1ca:	2101      	movs	r1, #1
 800b1cc:	5499      	strb	r1, [r3, r2]

  /* Return function status */
  return HAL_OK;
 800b1ce:	2300      	movs	r3, #0
}
 800b1d0:	0018      	movs	r0, r3
 800b1d2:	46bd      	mov	sp, r7
 800b1d4:	b004      	add	sp, #16
 800b1d6:	bd80      	pop	{r7, pc}
 800b1d8:	0000ffff 	.word	0x0000ffff
 800b1dc:	ffff1f3f 	.word	0xffff1f3f
 800b1e0:	ff19f1f8 	.word	0xff19f1f8

0800b1e4 <HAL_LPTIM_Counter_Start_IT>:
  * @param  Period Specifies the Autoreload value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LPTIM_Counter_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period)
{
 800b1e4:	b580      	push	{r7, lr}
 800b1e6:	b082      	sub	sp, #8
 800b1e8:	af00      	add	r7, sp, #0
 800b1ea:	6078      	str	r0, [r7, #4]
 800b1ec:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));
  assert_param(IS_LPTIM_PERIOD(Period));

  /* Set the LPTIM state */
  hlptim->State = HAL_LPTIM_STATE_BUSY;
 800b1ee:	687b      	ldr	r3, [r7, #4]
 800b1f0:	222e      	movs	r2, #46	; 0x2e
 800b1f2:	2102      	movs	r1, #2
 800b1f4:	5499      	strb	r1, [r3, r2]

  /* Enable EXTI Line interrupt on the LPTIM Wake-up Timer */
  __HAL_LPTIM_WAKEUPTIMER_EXTI_ENABLE_IT();
 800b1f6:	4b23      	ldr	r3, [pc, #140]	; (800b284 <HAL_LPTIM_Counter_Start_IT+0xa0>)
 800b1f8:	681a      	ldr	r2, [r3, #0]
 800b1fa:	4b22      	ldr	r3, [pc, #136]	; (800b284 <HAL_LPTIM_Counter_Start_IT+0xa0>)
 800b1fc:	2180      	movs	r1, #128	; 0x80
 800b1fe:	0589      	lsls	r1, r1, #22
 800b200:	430a      	orrs	r2, r1
 800b202:	601a      	str	r2, [r3, #0]

  /* If clock source is not ULPTIM clock and counter source is external, then it must not be prescaled */
  if ((hlptim->Init.Clock.Source != LPTIM_CLOCKSOURCE_ULPTIM) && (hlptim->Init.CounterSource == LPTIM_COUNTERSOURCE_EXTERNAL))
 800b204:	687b      	ldr	r3, [r7, #4]
 800b206:	685b      	ldr	r3, [r3, #4]
 800b208:	2b01      	cmp	r3, #1
 800b20a:	d00d      	beq.n	800b228 <HAL_LPTIM_Counter_Start_IT+0x44>
 800b20c:	687b      	ldr	r3, [r7, #4]
 800b20e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800b210:	2380      	movs	r3, #128	; 0x80
 800b212:	041b      	lsls	r3, r3, #16
 800b214:	429a      	cmp	r2, r3
 800b216:	d107      	bne.n	800b228 <HAL_LPTIM_Counter_Start_IT+0x44>
  {
    /* Check if clock is prescaled */
    assert_param(IS_LPTIM_CLOCK_PRESCALERDIV1(hlptim->Init.Clock.Prescaler));
    /* Set clock prescaler to 0 */
    hlptim->Instance->CFGR &= ~LPTIM_CFGR_PRESC;
 800b218:	687b      	ldr	r3, [r7, #4]
 800b21a:	681b      	ldr	r3, [r3, #0]
 800b21c:	68da      	ldr	r2, [r3, #12]
 800b21e:	687b      	ldr	r3, [r7, #4]
 800b220:	681b      	ldr	r3, [r3, #0]
 800b222:	4919      	ldr	r1, [pc, #100]	; (800b288 <HAL_LPTIM_Counter_Start_IT+0xa4>)
 800b224:	400a      	ands	r2, r1
 800b226:	60da      	str	r2, [r3, #12]
  }

  /* Enable Autoreload write complete interrupt */
  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_ARROK);
 800b228:	687b      	ldr	r3, [r7, #4]
 800b22a:	681b      	ldr	r3, [r3, #0]
 800b22c:	689a      	ldr	r2, [r3, #8]
 800b22e:	687b      	ldr	r3, [r7, #4]
 800b230:	681b      	ldr	r3, [r3, #0]
 800b232:	2110      	movs	r1, #16
 800b234:	430a      	orrs	r2, r1
 800b236:	609a      	str	r2, [r3, #8]

  /* Enable Autoreload match interrupt */
  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_ARRM);
 800b238:	687b      	ldr	r3, [r7, #4]
 800b23a:	681b      	ldr	r3, [r3, #0]
 800b23c:	689a      	ldr	r2, [r3, #8]
 800b23e:	687b      	ldr	r3, [r7, #4]
 800b240:	681b      	ldr	r3, [r3, #0]
 800b242:	2102      	movs	r1, #2
 800b244:	430a      	orrs	r2, r1
 800b246:	609a      	str	r2, [r3, #8]

  /* Enable the Peripheral */
  __HAL_LPTIM_ENABLE(hlptim);
 800b248:	687b      	ldr	r3, [r7, #4]
 800b24a:	681b      	ldr	r3, [r3, #0]
 800b24c:	691a      	ldr	r2, [r3, #16]
 800b24e:	687b      	ldr	r3, [r7, #4]
 800b250:	681b      	ldr	r3, [r3, #0]
 800b252:	2101      	movs	r1, #1
 800b254:	430a      	orrs	r2, r1
 800b256:	611a      	str	r2, [r3, #16]

  /* Load the period value in the autoreload register */
  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);
 800b258:	687b      	ldr	r3, [r7, #4]
 800b25a:	681b      	ldr	r3, [r3, #0]
 800b25c:	683a      	ldr	r2, [r7, #0]
 800b25e:	619a      	str	r2, [r3, #24]

  /* Start timer in continuous mode */
  __HAL_LPTIM_START_CONTINUOUS(hlptim);
 800b260:	687b      	ldr	r3, [r7, #4]
 800b262:	681b      	ldr	r3, [r3, #0]
 800b264:	691a      	ldr	r2, [r3, #16]
 800b266:	687b      	ldr	r3, [r7, #4]
 800b268:	681b      	ldr	r3, [r3, #0]
 800b26a:	2104      	movs	r1, #4
 800b26c:	430a      	orrs	r2, r1
 800b26e:	611a      	str	r2, [r3, #16]

  /* Change the TIM state*/
  hlptim->State = HAL_LPTIM_STATE_READY;
 800b270:	687b      	ldr	r3, [r7, #4]
 800b272:	222e      	movs	r2, #46	; 0x2e
 800b274:	2101      	movs	r1, #1
 800b276:	5499      	strb	r1, [r3, r2]

  /* Return function status */
  return HAL_OK;
 800b278:	2300      	movs	r3, #0
}
 800b27a:	0018      	movs	r0, r3
 800b27c:	46bd      	mov	sp, r7
 800b27e:	b002      	add	sp, #8
 800b280:	bd80      	pop	{r7, pc}
 800b282:	46c0      	nop			; (mov r8, r8)
 800b284:	40010400 	.word	0x40010400
 800b288:	fffff1ff 	.word	0xfffff1ff

0800b28c <HAL_LPTIM_ReadCounter>:
  * @brief  Return the current counter value.
  * @param  hlptim LPTIM handle
  * @retval Counter value.
  */
uint32_t HAL_LPTIM_ReadCounter(LPTIM_HandleTypeDef *hlptim)
{
 800b28c:	b580      	push	{r7, lr}
 800b28e:	b082      	sub	sp, #8
 800b290:	af00      	add	r7, sp, #0
 800b292:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));

  return (hlptim->Instance->CNT);
 800b294:	687b      	ldr	r3, [r7, #4]
 800b296:	681b      	ldr	r3, [r3, #0]
 800b298:	69db      	ldr	r3, [r3, #28]
}
 800b29a:	0018      	movs	r0, r3
 800b29c:	46bd      	mov	sp, r7
 800b29e:	b002      	add	sp, #8
 800b2a0:	bd80      	pop	{r7, pc}

0800b2a2 <HAL_LPTIM_IRQHandler>:
  * @brief  Handle LPTIM interrupt request.
  * @param  hlptim LPTIM handle
  * @retval None
  */
void HAL_LPTIM_IRQHandler(LPTIM_HandleTypeDef *hlptim)
{
 800b2a2:	b580      	push	{r7, lr}
 800b2a4:	b082      	sub	sp, #8
 800b2a6:	af00      	add	r7, sp, #0
 800b2a8:	6078      	str	r0, [r7, #4]
  /* Compare match interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_CMPM) != RESET)
 800b2aa:	687b      	ldr	r3, [r7, #4]
 800b2ac:	681b      	ldr	r3, [r3, #0]
 800b2ae:	681b      	ldr	r3, [r3, #0]
 800b2b0:	2201      	movs	r2, #1
 800b2b2:	4013      	ands	r3, r2
 800b2b4:	2b01      	cmp	r3, #1
 800b2b6:	d10e      	bne.n	800b2d6 <HAL_LPTIM_IRQHandler+0x34>
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_CMPM) != RESET)
 800b2b8:	687b      	ldr	r3, [r7, #4]
 800b2ba:	681b      	ldr	r3, [r3, #0]
 800b2bc:	689b      	ldr	r3, [r3, #8]
 800b2be:	2201      	movs	r2, #1
 800b2c0:	4013      	ands	r3, r2
 800b2c2:	2b01      	cmp	r3, #1
 800b2c4:	d107      	bne.n	800b2d6 <HAL_LPTIM_IRQHandler+0x34>
    {
      /* Clear Compare match flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPM);
 800b2c6:	687b      	ldr	r3, [r7, #4]
 800b2c8:	681b      	ldr	r3, [r3, #0]
 800b2ca:	2201      	movs	r2, #1
 800b2cc:	605a      	str	r2, [r3, #4]

      /* Compare match Callback */
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
      hlptim->CompareMatchCallback(hlptim);
#else
      HAL_LPTIM_CompareMatchCallback(hlptim);
 800b2ce:	687b      	ldr	r3, [r7, #4]
 800b2d0:	0018      	movs	r0, r3
 800b2d2:	f000 f888 	bl	800b3e6 <HAL_LPTIM_CompareMatchCallback>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
    }
  }

  /* Autoreload match interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_ARRM) != RESET)
 800b2d6:	687b      	ldr	r3, [r7, #4]
 800b2d8:	681b      	ldr	r3, [r3, #0]
 800b2da:	681b      	ldr	r3, [r3, #0]
 800b2dc:	2202      	movs	r2, #2
 800b2de:	4013      	ands	r3, r2
 800b2e0:	2b02      	cmp	r3, #2
 800b2e2:	d10e      	bne.n	800b302 <HAL_LPTIM_IRQHandler+0x60>
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_ARRM) != RESET)
 800b2e4:	687b      	ldr	r3, [r7, #4]
 800b2e6:	681b      	ldr	r3, [r3, #0]
 800b2e8:	689b      	ldr	r3, [r3, #8]
 800b2ea:	2202      	movs	r2, #2
 800b2ec:	4013      	ands	r3, r2
 800b2ee:	2b02      	cmp	r3, #2
 800b2f0:	d107      	bne.n	800b302 <HAL_LPTIM_IRQHandler+0x60>
    {
      /* Clear Autoreload match flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARRM);
 800b2f2:	687b      	ldr	r3, [r7, #4]
 800b2f4:	681b      	ldr	r3, [r3, #0]
 800b2f6:	2202      	movs	r2, #2
 800b2f8:	605a      	str	r2, [r3, #4]

      /* Autoreload match Callback */
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
      hlptim->AutoReloadMatchCallback(hlptim);
#else
      HAL_LPTIM_AutoReloadMatchCallback(hlptim);
 800b2fa:	687b      	ldr	r3, [r7, #4]
 800b2fc:	0018      	movs	r0, r3
 800b2fe:	f7ff f891 	bl	800a424 <HAL_LPTIM_AutoReloadMatchCallback>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
    }
  }

  /* Trigger detected interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_EXTTRIG) != RESET)
 800b302:	687b      	ldr	r3, [r7, #4]
 800b304:	681b      	ldr	r3, [r3, #0]
 800b306:	681b      	ldr	r3, [r3, #0]
 800b308:	2204      	movs	r2, #4
 800b30a:	4013      	ands	r3, r2
 800b30c:	2b04      	cmp	r3, #4
 800b30e:	d10e      	bne.n	800b32e <HAL_LPTIM_IRQHandler+0x8c>
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_EXTTRIG) != RESET)
 800b310:	687b      	ldr	r3, [r7, #4]
 800b312:	681b      	ldr	r3, [r3, #0]
 800b314:	689b      	ldr	r3, [r3, #8]
 800b316:	2204      	movs	r2, #4
 800b318:	4013      	ands	r3, r2
 800b31a:	2b04      	cmp	r3, #4
 800b31c:	d107      	bne.n	800b32e <HAL_LPTIM_IRQHandler+0x8c>
    {
      /* Clear Trigger detected flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_EXTTRIG);
 800b31e:	687b      	ldr	r3, [r7, #4]
 800b320:	681b      	ldr	r3, [r3, #0]
 800b322:	2204      	movs	r2, #4
 800b324:	605a      	str	r2, [r3, #4]

      /* Trigger detected callback */
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
      hlptim->TriggerCallback(hlptim);
#else
      HAL_LPTIM_TriggerCallback(hlptim);
 800b326:	687b      	ldr	r3, [r7, #4]
 800b328:	0018      	movs	r0, r3
 800b32a:	f000 f864 	bl	800b3f6 <HAL_LPTIM_TriggerCallback>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
    }
  }

  /* Compare write interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_CMPOK) != RESET)
 800b32e:	687b      	ldr	r3, [r7, #4]
 800b330:	681b      	ldr	r3, [r3, #0]
 800b332:	681b      	ldr	r3, [r3, #0]
 800b334:	2208      	movs	r2, #8
 800b336:	4013      	ands	r3, r2
 800b338:	2b08      	cmp	r3, #8
 800b33a:	d10e      	bne.n	800b35a <HAL_LPTIM_IRQHandler+0xb8>
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_CMPOK) != RESET)
 800b33c:	687b      	ldr	r3, [r7, #4]
 800b33e:	681b      	ldr	r3, [r3, #0]
 800b340:	689b      	ldr	r3, [r3, #8]
 800b342:	2208      	movs	r2, #8
 800b344:	4013      	ands	r3, r2
 800b346:	2b08      	cmp	r3, #8
 800b348:	d107      	bne.n	800b35a <HAL_LPTIM_IRQHandler+0xb8>
    {
      /* Clear Compare write flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);
 800b34a:	687b      	ldr	r3, [r7, #4]
 800b34c:	681b      	ldr	r3, [r3, #0]
 800b34e:	2208      	movs	r2, #8
 800b350:	605a      	str	r2, [r3, #4]

      /* Compare write Callback */
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
      hlptim->CompareWriteCallback(hlptim);
#else
      HAL_LPTIM_CompareWriteCallback(hlptim);
 800b352:	687b      	ldr	r3, [r7, #4]
 800b354:	0018      	movs	r0, r3
 800b356:	f000 f856 	bl	800b406 <HAL_LPTIM_CompareWriteCallback>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
    }
  }

  /* Autoreload write interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_ARROK) != RESET)
 800b35a:	687b      	ldr	r3, [r7, #4]
 800b35c:	681b      	ldr	r3, [r3, #0]
 800b35e:	681b      	ldr	r3, [r3, #0]
 800b360:	2210      	movs	r2, #16
 800b362:	4013      	ands	r3, r2
 800b364:	2b10      	cmp	r3, #16
 800b366:	d10e      	bne.n	800b386 <HAL_LPTIM_IRQHandler+0xe4>
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_ARROK) != RESET)
 800b368:	687b      	ldr	r3, [r7, #4]
 800b36a:	681b      	ldr	r3, [r3, #0]
 800b36c:	689b      	ldr	r3, [r3, #8]
 800b36e:	2210      	movs	r2, #16
 800b370:	4013      	ands	r3, r2
 800b372:	2b10      	cmp	r3, #16
 800b374:	d107      	bne.n	800b386 <HAL_LPTIM_IRQHandler+0xe4>
    {
      /* Clear Autoreload write flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);
 800b376:	687b      	ldr	r3, [r7, #4]
 800b378:	681b      	ldr	r3, [r3, #0]
 800b37a:	2210      	movs	r2, #16
 800b37c:	605a      	str	r2, [r3, #4]

      /* Autoreload write Callback */
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
      hlptim->AutoReloadWriteCallback(hlptim);
#else
      HAL_LPTIM_AutoReloadWriteCallback(hlptim);
 800b37e:	687b      	ldr	r3, [r7, #4]
 800b380:	0018      	movs	r0, r3
 800b382:	f000 f848 	bl	800b416 <HAL_LPTIM_AutoReloadWriteCallback>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
    }
  }

  /* Direction counter changed from Down to Up interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_UP) != RESET)
 800b386:	687b      	ldr	r3, [r7, #4]
 800b388:	681b      	ldr	r3, [r3, #0]
 800b38a:	681b      	ldr	r3, [r3, #0]
 800b38c:	2220      	movs	r2, #32
 800b38e:	4013      	ands	r3, r2
 800b390:	2b20      	cmp	r3, #32
 800b392:	d10e      	bne.n	800b3b2 <HAL_LPTIM_IRQHandler+0x110>
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_UP) != RESET)
 800b394:	687b      	ldr	r3, [r7, #4]
 800b396:	681b      	ldr	r3, [r3, #0]
 800b398:	689b      	ldr	r3, [r3, #8]
 800b39a:	2220      	movs	r2, #32
 800b39c:	4013      	ands	r3, r2
 800b39e:	2b20      	cmp	r3, #32
 800b3a0:	d107      	bne.n	800b3b2 <HAL_LPTIM_IRQHandler+0x110>
    {
      /* Clear Direction counter changed from Down to Up flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_UP);
 800b3a2:	687b      	ldr	r3, [r7, #4]
 800b3a4:	681b      	ldr	r3, [r3, #0]
 800b3a6:	2220      	movs	r2, #32
 800b3a8:	605a      	str	r2, [r3, #4]

      /* Direction counter changed from Down to Up Callback */
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
      hlptim->DirectionUpCallback(hlptim);
#else
      HAL_LPTIM_DirectionUpCallback(hlptim);
 800b3aa:	687b      	ldr	r3, [r7, #4]
 800b3ac:	0018      	movs	r0, r3
 800b3ae:	f000 f83a 	bl	800b426 <HAL_LPTIM_DirectionUpCallback>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
    }
  }

  /* Direction counter changed from Up to Down interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_DOWN) != RESET)
 800b3b2:	687b      	ldr	r3, [r7, #4]
 800b3b4:	681b      	ldr	r3, [r3, #0]
 800b3b6:	681b      	ldr	r3, [r3, #0]
 800b3b8:	2240      	movs	r2, #64	; 0x40
 800b3ba:	4013      	ands	r3, r2
 800b3bc:	2b40      	cmp	r3, #64	; 0x40
 800b3be:	d10e      	bne.n	800b3de <HAL_LPTIM_IRQHandler+0x13c>
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_DOWN) != RESET)
 800b3c0:	687b      	ldr	r3, [r7, #4]
 800b3c2:	681b      	ldr	r3, [r3, #0]
 800b3c4:	689b      	ldr	r3, [r3, #8]
 800b3c6:	2240      	movs	r2, #64	; 0x40
 800b3c8:	4013      	ands	r3, r2
 800b3ca:	2b40      	cmp	r3, #64	; 0x40
 800b3cc:	d107      	bne.n	800b3de <HAL_LPTIM_IRQHandler+0x13c>
    {
      /* Clear Direction counter changed from Up to Down flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_DOWN);
 800b3ce:	687b      	ldr	r3, [r7, #4]
 800b3d0:	681b      	ldr	r3, [r3, #0]
 800b3d2:	2240      	movs	r2, #64	; 0x40
 800b3d4:	605a      	str	r2, [r3, #4]

      /* Direction counter changed from Up to Down Callback */
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
      hlptim->DirectionDownCallback(hlptim);
#else
      HAL_LPTIM_DirectionDownCallback(hlptim);
 800b3d6:	687b      	ldr	r3, [r7, #4]
 800b3d8:	0018      	movs	r0, r3
 800b3da:	f000 f82c 	bl	800b436 <HAL_LPTIM_DirectionDownCallback>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
    }
  }
}
 800b3de:	46c0      	nop			; (mov r8, r8)
 800b3e0:	46bd      	mov	sp, r7
 800b3e2:	b002      	add	sp, #8
 800b3e4:	bd80      	pop	{r7, pc}

0800b3e6 <HAL_LPTIM_CompareMatchCallback>:
  * @brief  Compare match callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */
__weak void HAL_LPTIM_CompareMatchCallback(LPTIM_HandleTypeDef *hlptim)
{
 800b3e6:	b580      	push	{r7, lr}
 800b3e8:	b082      	sub	sp, #8
 800b3ea:	af00      	add	r7, sp, #0
 800b3ec:	6078      	str	r0, [r7, #4]
  UNUSED(hlptim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_CompareMatchCallback could be implemented in the user file
   */
}
 800b3ee:	46c0      	nop			; (mov r8, r8)
 800b3f0:	46bd      	mov	sp, r7
 800b3f2:	b002      	add	sp, #8
 800b3f4:	bd80      	pop	{r7, pc}

0800b3f6 <HAL_LPTIM_TriggerCallback>:
  * @brief  Trigger detected callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */
__weak void HAL_LPTIM_TriggerCallback(LPTIM_HandleTypeDef *hlptim)
{
 800b3f6:	b580      	push	{r7, lr}
 800b3f8:	b082      	sub	sp, #8
 800b3fa:	af00      	add	r7, sp, #0
 800b3fc:	6078      	str	r0, [r7, #4]
  UNUSED(hlptim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_TriggerCallback could be implemented in the user file
   */
}
 800b3fe:	46c0      	nop			; (mov r8, r8)
 800b400:	46bd      	mov	sp, r7
 800b402:	b002      	add	sp, #8
 800b404:	bd80      	pop	{r7, pc}

0800b406 <HAL_LPTIM_CompareWriteCallback>:
  * @brief  Compare write callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */
__weak void HAL_LPTIM_CompareWriteCallback(LPTIM_HandleTypeDef *hlptim)
{
 800b406:	b580      	push	{r7, lr}
 800b408:	b082      	sub	sp, #8
 800b40a:	af00      	add	r7, sp, #0
 800b40c:	6078      	str	r0, [r7, #4]
  UNUSED(hlptim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_CompareWriteCallback could be implemented in the user file
   */
}
 800b40e:	46c0      	nop			; (mov r8, r8)
 800b410:	46bd      	mov	sp, r7
 800b412:	b002      	add	sp, #8
 800b414:	bd80      	pop	{r7, pc}

0800b416 <HAL_LPTIM_AutoReloadWriteCallback>:
  * @brief  Autoreload write callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */
__weak void HAL_LPTIM_AutoReloadWriteCallback(LPTIM_HandleTypeDef *hlptim)
{
 800b416:	b580      	push	{r7, lr}
 800b418:	b082      	sub	sp, #8
 800b41a:	af00      	add	r7, sp, #0
 800b41c:	6078      	str	r0, [r7, #4]
  UNUSED(hlptim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_AutoReloadWriteCallback could be implemented in the user file
   */
}
 800b41e:	46c0      	nop			; (mov r8, r8)
 800b420:	46bd      	mov	sp, r7
 800b422:	b002      	add	sp, #8
 800b424:	bd80      	pop	{r7, pc}

0800b426 <HAL_LPTIM_DirectionUpCallback>:
  * @brief  Direction counter changed from Down to Up callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */
__weak void HAL_LPTIM_DirectionUpCallback(LPTIM_HandleTypeDef *hlptim)
{
 800b426:	b580      	push	{r7, lr}
 800b428:	b082      	sub	sp, #8
 800b42a:	af00      	add	r7, sp, #0
 800b42c:	6078      	str	r0, [r7, #4]
  UNUSED(hlptim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_DirectionUpCallback could be implemented in the user file
   */
}
 800b42e:	46c0      	nop			; (mov r8, r8)
 800b430:	46bd      	mov	sp, r7
 800b432:	b002      	add	sp, #8
 800b434:	bd80      	pop	{r7, pc}

0800b436 <HAL_LPTIM_DirectionDownCallback>:
  * @brief  Direction counter changed from Up to Down callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */
__weak void HAL_LPTIM_DirectionDownCallback(LPTIM_HandleTypeDef *hlptim)
{
 800b436:	b580      	push	{r7, lr}
 800b438:	b082      	sub	sp, #8
 800b43a:	af00      	add	r7, sp, #0
 800b43c:	6078      	str	r0, [r7, #4]
  UNUSED(hlptim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_DirectionDownCallback could be implemented in the user file
   */
}
 800b43e:	46c0      	nop			; (mov r8, r8)
 800b440:	46bd      	mov	sp, r7
 800b442:	b002      	add	sp, #8
 800b444:	bd80      	pop	{r7, pc}
	...

0800b448 <HAL_PWR_PVD_IRQHandler>:
  * @brief This function handles the PWR PVD interrupt request.
  * @note This API should be called under the PVD_IRQHandler().
  * @retval None
  */
void HAL_PWR_PVD_IRQHandler(void)
{
 800b448:	b580      	push	{r7, lr}
 800b44a:	af00      	add	r7, sp, #0
  /* Check PWR exti flag */
  if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
 800b44c:	4b07      	ldr	r3, [pc, #28]	; (800b46c <HAL_PWR_PVD_IRQHandler+0x24>)
 800b44e:	695a      	ldr	r2, [r3, #20]
 800b450:	2380      	movs	r3, #128	; 0x80
 800b452:	025b      	lsls	r3, r3, #9
 800b454:	4013      	ands	r3, r2
 800b456:	d005      	beq.n	800b464 <HAL_PWR_PVD_IRQHandler+0x1c>
  {
    /* PWR PVD interrupt user callback */
    HAL_PWR_PVDCallback();
 800b458:	f000 f80a 	bl	800b470 <HAL_PWR_PVDCallback>

    /* Clear PWR Exti pending bit */
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
 800b45c:	4b03      	ldr	r3, [pc, #12]	; (800b46c <HAL_PWR_PVD_IRQHandler+0x24>)
 800b45e:	2280      	movs	r2, #128	; 0x80
 800b460:	0252      	lsls	r2, r2, #9
 800b462:	615a      	str	r2, [r3, #20]
  }
}
 800b464:	46c0      	nop			; (mov r8, r8)
 800b466:	46bd      	mov	sp, r7
 800b468:	bd80      	pop	{r7, pc}
 800b46a:	46c0      	nop			; (mov r8, r8)
 800b46c:	40010400 	.word	0x40010400

0800b470 <HAL_PWR_PVDCallback>:
/**
  * @brief  PWR PVD interrupt callback
  * @retval None
  */
__weak void HAL_PWR_PVDCallback(void)
{
 800b470:	b580      	push	{r7, lr}
 800b472:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_PWR_PVDCallback could be implemented in the user file
   */ 
}
 800b474:	46c0      	nop			; (mov r8, r8)
 800b476:	46bd      	mov	sp, r7
 800b478:	bd80      	pop	{r7, pc}
	...

0800b47c <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800b47c:	b5b0      	push	{r4, r5, r7, lr}
 800b47e:	b08a      	sub	sp, #40	; 0x28
 800b480:	af00      	add	r7, sp, #0
 800b482:	6078      	str	r0, [r7, #4]
  uint32_t hsi_state;
  HAL_StatusTypeDef status;
  uint32_t sysclk_source, pll_config;

  /* Check the parameters */
  if(RCC_OscInitStruct == NULL)
 800b484:	687b      	ldr	r3, [r7, #4]
 800b486:	2b00      	cmp	r3, #0
 800b488:	d102      	bne.n	800b490 <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
 800b48a:	2301      	movs	r3, #1
 800b48c:	f000 fbbc 	bl	800bc08 <HAL_RCC_OscConfig+0x78c>
  }

  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 800b490:	4bc8      	ldr	r3, [pc, #800]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b492:	68db      	ldr	r3, [r3, #12]
 800b494:	220c      	movs	r2, #12
 800b496:	4013      	ands	r3, r2
 800b498:	61fb      	str	r3, [r7, #28]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 800b49a:	4bc6      	ldr	r3, [pc, #792]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b49c:	68da      	ldr	r2, [r3, #12]
 800b49e:	2380      	movs	r3, #128	; 0x80
 800b4a0:	025b      	lsls	r3, r3, #9
 800b4a2:	4013      	ands	r3, r2
 800b4a4:	61bb      	str	r3, [r7, #24]

  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800b4a6:	687b      	ldr	r3, [r7, #4]
 800b4a8:	681b      	ldr	r3, [r3, #0]
 800b4aa:	2201      	movs	r2, #1
 800b4ac:	4013      	ands	r3, r2
 800b4ae:	d100      	bne.n	800b4b2 <HAL_RCC_OscConfig+0x36>
 800b4b0:	e07e      	b.n	800b5b0 <HAL_RCC_OscConfig+0x134>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 800b4b2:	69fb      	ldr	r3, [r7, #28]
 800b4b4:	2b08      	cmp	r3, #8
 800b4b6:	d007      	beq.n	800b4c8 <HAL_RCC_OscConfig+0x4c>
       || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 800b4b8:	69fb      	ldr	r3, [r7, #28]
 800b4ba:	2b0c      	cmp	r3, #12
 800b4bc:	d112      	bne.n	800b4e4 <HAL_RCC_OscConfig+0x68>
 800b4be:	69ba      	ldr	r2, [r7, #24]
 800b4c0:	2380      	movs	r3, #128	; 0x80
 800b4c2:	025b      	lsls	r3, r3, #9
 800b4c4:	429a      	cmp	r2, r3
 800b4c6:	d10d      	bne.n	800b4e4 <HAL_RCC_OscConfig+0x68>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800b4c8:	4bba      	ldr	r3, [pc, #744]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b4ca:	681a      	ldr	r2, [r3, #0]
 800b4cc:	2380      	movs	r3, #128	; 0x80
 800b4ce:	029b      	lsls	r3, r3, #10
 800b4d0:	4013      	ands	r3, r2
 800b4d2:	d100      	bne.n	800b4d6 <HAL_RCC_OscConfig+0x5a>
 800b4d4:	e06b      	b.n	800b5ae <HAL_RCC_OscConfig+0x132>
 800b4d6:	687b      	ldr	r3, [r7, #4]
 800b4d8:	685b      	ldr	r3, [r3, #4]
 800b4da:	2b00      	cmp	r3, #0
 800b4dc:	d167      	bne.n	800b5ae <HAL_RCC_OscConfig+0x132>
      {
        return HAL_ERROR;
 800b4de:	2301      	movs	r3, #1
 800b4e0:	f000 fb92 	bl	800bc08 <HAL_RCC_OscConfig+0x78c>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800b4e4:	687b      	ldr	r3, [r7, #4]
 800b4e6:	685a      	ldr	r2, [r3, #4]
 800b4e8:	2380      	movs	r3, #128	; 0x80
 800b4ea:	025b      	lsls	r3, r3, #9
 800b4ec:	429a      	cmp	r2, r3
 800b4ee:	d107      	bne.n	800b500 <HAL_RCC_OscConfig+0x84>
 800b4f0:	4bb0      	ldr	r3, [pc, #704]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b4f2:	681a      	ldr	r2, [r3, #0]
 800b4f4:	4baf      	ldr	r3, [pc, #700]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b4f6:	2180      	movs	r1, #128	; 0x80
 800b4f8:	0249      	lsls	r1, r1, #9
 800b4fa:	430a      	orrs	r2, r1
 800b4fc:	601a      	str	r2, [r3, #0]
 800b4fe:	e027      	b.n	800b550 <HAL_RCC_OscConfig+0xd4>
 800b500:	687b      	ldr	r3, [r7, #4]
 800b502:	685a      	ldr	r2, [r3, #4]
 800b504:	23a0      	movs	r3, #160	; 0xa0
 800b506:	02db      	lsls	r3, r3, #11
 800b508:	429a      	cmp	r2, r3
 800b50a:	d10e      	bne.n	800b52a <HAL_RCC_OscConfig+0xae>
 800b50c:	4ba9      	ldr	r3, [pc, #676]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b50e:	681a      	ldr	r2, [r3, #0]
 800b510:	4ba8      	ldr	r3, [pc, #672]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b512:	2180      	movs	r1, #128	; 0x80
 800b514:	02c9      	lsls	r1, r1, #11
 800b516:	430a      	orrs	r2, r1
 800b518:	601a      	str	r2, [r3, #0]
 800b51a:	4ba6      	ldr	r3, [pc, #664]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b51c:	681a      	ldr	r2, [r3, #0]
 800b51e:	4ba5      	ldr	r3, [pc, #660]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b520:	2180      	movs	r1, #128	; 0x80
 800b522:	0249      	lsls	r1, r1, #9
 800b524:	430a      	orrs	r2, r1
 800b526:	601a      	str	r2, [r3, #0]
 800b528:	e012      	b.n	800b550 <HAL_RCC_OscConfig+0xd4>
 800b52a:	4ba2      	ldr	r3, [pc, #648]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b52c:	681a      	ldr	r2, [r3, #0]
 800b52e:	4ba1      	ldr	r3, [pc, #644]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b530:	49a1      	ldr	r1, [pc, #644]	; (800b7b8 <HAL_RCC_OscConfig+0x33c>)
 800b532:	400a      	ands	r2, r1
 800b534:	601a      	str	r2, [r3, #0]
 800b536:	4b9f      	ldr	r3, [pc, #636]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b538:	681a      	ldr	r2, [r3, #0]
 800b53a:	2380      	movs	r3, #128	; 0x80
 800b53c:	025b      	lsls	r3, r3, #9
 800b53e:	4013      	ands	r3, r2
 800b540:	60fb      	str	r3, [r7, #12]
 800b542:	68fb      	ldr	r3, [r7, #12]
 800b544:	4b9b      	ldr	r3, [pc, #620]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b546:	681a      	ldr	r2, [r3, #0]
 800b548:	4b9a      	ldr	r3, [pc, #616]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b54a:	499c      	ldr	r1, [pc, #624]	; (800b7bc <HAL_RCC_OscConfig+0x340>)
 800b54c:	400a      	ands	r2, r1
 800b54e:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800b550:	687b      	ldr	r3, [r7, #4]
 800b552:	685b      	ldr	r3, [r3, #4]
 800b554:	2b00      	cmp	r3, #0
 800b556:	d015      	beq.n	800b584 <HAL_RCC_OscConfig+0x108>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800b558:	f7ff f9fa 	bl	800a950 <HAL_GetTick>
 800b55c:	0003      	movs	r3, r0
 800b55e:	617b      	str	r3, [r7, #20]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800b560:	e009      	b.n	800b576 <HAL_RCC_OscConfig+0xfa>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800b562:	f7ff f9f5 	bl	800a950 <HAL_GetTick>
 800b566:	0002      	movs	r2, r0
 800b568:	697b      	ldr	r3, [r7, #20]
 800b56a:	1ad3      	subs	r3, r2, r3
 800b56c:	2b64      	cmp	r3, #100	; 0x64
 800b56e:	d902      	bls.n	800b576 <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 800b570:	2303      	movs	r3, #3
 800b572:	f000 fb49 	bl	800bc08 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800b576:	4b8f      	ldr	r3, [pc, #572]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b578:	681a      	ldr	r2, [r3, #0]
 800b57a:	2380      	movs	r3, #128	; 0x80
 800b57c:	029b      	lsls	r3, r3, #10
 800b57e:	4013      	ands	r3, r2
 800b580:	d0ef      	beq.n	800b562 <HAL_RCC_OscConfig+0xe6>
 800b582:	e015      	b.n	800b5b0 <HAL_RCC_OscConfig+0x134>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800b584:	f7ff f9e4 	bl	800a950 <HAL_GetTick>
 800b588:	0003      	movs	r3, r0
 800b58a:	617b      	str	r3, [r7, #20]

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 800b58c:	e008      	b.n	800b5a0 <HAL_RCC_OscConfig+0x124>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800b58e:	f7ff f9df 	bl	800a950 <HAL_GetTick>
 800b592:	0002      	movs	r2, r0
 800b594:	697b      	ldr	r3, [r7, #20]
 800b596:	1ad3      	subs	r3, r2, r3
 800b598:	2b64      	cmp	r3, #100	; 0x64
 800b59a:	d901      	bls.n	800b5a0 <HAL_RCC_OscConfig+0x124>
          {
            return HAL_TIMEOUT;
 800b59c:	2303      	movs	r3, #3
 800b59e:	e333      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 800b5a0:	4b84      	ldr	r3, [pc, #528]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b5a2:	681a      	ldr	r2, [r3, #0]
 800b5a4:	2380      	movs	r3, #128	; 0x80
 800b5a6:	029b      	lsls	r3, r3, #10
 800b5a8:	4013      	ands	r3, r2
 800b5aa:	d1f0      	bne.n	800b58e <HAL_RCC_OscConfig+0x112>
 800b5ac:	e000      	b.n	800b5b0 <HAL_RCC_OscConfig+0x134>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800b5ae:	46c0      	nop			; (mov r8, r8)
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800b5b0:	687b      	ldr	r3, [r7, #4]
 800b5b2:	681b      	ldr	r3, [r3, #0]
 800b5b4:	2202      	movs	r2, #2
 800b5b6:	4013      	ands	r3, r2
 800b5b8:	d100      	bne.n	800b5bc <HAL_RCC_OscConfig+0x140>
 800b5ba:	e098      	b.n	800b6ee <HAL_RCC_OscConfig+0x272>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    hsi_state = RCC_OscInitStruct->HSIState;
 800b5bc:	687b      	ldr	r3, [r7, #4]
 800b5be:	68db      	ldr	r3, [r3, #12]
 800b5c0:	627b      	str	r3, [r7, #36]	; 0x24

#if defined(RCC_CR_HSIOUTEN)
    if((hsi_state & RCC_HSI_OUTEN) != 0U)
 800b5c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b5c4:	2220      	movs	r2, #32
 800b5c6:	4013      	ands	r3, r2
 800b5c8:	d009      	beq.n	800b5de <HAL_RCC_OscConfig+0x162>
    {
      /* HSI Output enable for timer requested */
      SET_BIT(RCC->CR, RCC_CR_HSIOUTEN);
 800b5ca:	4b7a      	ldr	r3, [pc, #488]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b5cc:	681a      	ldr	r2, [r3, #0]
 800b5ce:	4b79      	ldr	r3, [pc, #484]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b5d0:	2120      	movs	r1, #32
 800b5d2:	430a      	orrs	r2, r1
 800b5d4:	601a      	str	r2, [r3, #0]

      hsi_state &= ~RCC_CR_HSIOUTEN;
 800b5d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b5d8:	2220      	movs	r2, #32
 800b5da:	4393      	bics	r3, r2
 800b5dc:	627b      	str	r3, [r7, #36]	; 0x24
    }
#endif

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 800b5de:	69fb      	ldr	r3, [r7, #28]
 800b5e0:	2b04      	cmp	r3, #4
 800b5e2:	d005      	beq.n	800b5f0 <HAL_RCC_OscConfig+0x174>
       || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 800b5e4:	69fb      	ldr	r3, [r7, #28]
 800b5e6:	2b0c      	cmp	r3, #12
 800b5e8:	d13d      	bne.n	800b666 <HAL_RCC_OscConfig+0x1ea>
 800b5ea:	69bb      	ldr	r3, [r7, #24]
 800b5ec:	2b00      	cmp	r3, #0
 800b5ee:	d13a      	bne.n	800b666 <HAL_RCC_OscConfig+0x1ea>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (hsi_state == RCC_HSI_OFF))
 800b5f0:	4b70      	ldr	r3, [pc, #448]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b5f2:	681b      	ldr	r3, [r3, #0]
 800b5f4:	2204      	movs	r2, #4
 800b5f6:	4013      	ands	r3, r2
 800b5f8:	d004      	beq.n	800b604 <HAL_RCC_OscConfig+0x188>
 800b5fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b5fc:	2b00      	cmp	r3, #0
 800b5fe:	d101      	bne.n	800b604 <HAL_RCC_OscConfig+0x188>
      {
        return HAL_ERROR;
 800b600:	2301      	movs	r3, #1
 800b602:	e301      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
      }
      /* Otherwise, just the calibration and HSI or HSIdiv4 are allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800b604:	4b6b      	ldr	r3, [pc, #428]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b606:	685b      	ldr	r3, [r3, #4]
 800b608:	4a6d      	ldr	r2, [pc, #436]	; (800b7c0 <HAL_RCC_OscConfig+0x344>)
 800b60a:	4013      	ands	r3, r2
 800b60c:	0019      	movs	r1, r3
 800b60e:	687b      	ldr	r3, [r7, #4]
 800b610:	691b      	ldr	r3, [r3, #16]
 800b612:	021a      	lsls	r2, r3, #8
 800b614:	4b67      	ldr	r3, [pc, #412]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b616:	430a      	orrs	r2, r1
 800b618:	605a      	str	r2, [r3, #4]

        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
        __HAL_RCC_HSI_CONFIG(hsi_state);
 800b61a:	4b66      	ldr	r3, [pc, #408]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b61c:	681b      	ldr	r3, [r3, #0]
 800b61e:	2209      	movs	r2, #9
 800b620:	4393      	bics	r3, r2
 800b622:	0019      	movs	r1, r3
 800b624:	4b63      	ldr	r3, [pc, #396]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b626:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b628:	430a      	orrs	r2, r1
 800b62a:	601a      	str	r2, [r3, #0]
      }

      /* Update the SystemCoreClock global variable */
      SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 800b62c:	f000 fc20 	bl	800be70 <HAL_RCC_GetSysClockFreq>
 800b630:	0001      	movs	r1, r0
 800b632:	4b60      	ldr	r3, [pc, #384]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b634:	68db      	ldr	r3, [r3, #12]
 800b636:	091b      	lsrs	r3, r3, #4
 800b638:	220f      	movs	r2, #15
 800b63a:	4013      	ands	r3, r2
 800b63c:	4a61      	ldr	r2, [pc, #388]	; (800b7c4 <HAL_RCC_OscConfig+0x348>)
 800b63e:	5cd3      	ldrb	r3, [r2, r3]
 800b640:	000a      	movs	r2, r1
 800b642:	40da      	lsrs	r2, r3
 800b644:	4b60      	ldr	r3, [pc, #384]	; (800b7c8 <HAL_RCC_OscConfig+0x34c>)
 800b646:	601a      	str	r2, [r3, #0]

      /* Configure the source of time base considering new system clocks settings*/
      status = HAL_InitTick (TICK_INT_PRIORITY);
 800b648:	2513      	movs	r5, #19
 800b64a:	197c      	adds	r4, r7, r5
 800b64c:	2000      	movs	r0, #0
 800b64e:	f7ff f949 	bl	800a8e4 <HAL_InitTick>
 800b652:	0003      	movs	r3, r0
 800b654:	7023      	strb	r3, [r4, #0]
      if(status != HAL_OK)
 800b656:	197b      	adds	r3, r7, r5
 800b658:	781b      	ldrb	r3, [r3, #0]
 800b65a:	2b00      	cmp	r3, #0
 800b65c:	d047      	beq.n	800b6ee <HAL_RCC_OscConfig+0x272>
      {
        return status;
 800b65e:	2313      	movs	r3, #19
 800b660:	18fb      	adds	r3, r7, r3
 800b662:	781b      	ldrb	r3, [r3, #0]
 800b664:	e2d0      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
      }
    }
    else
    {
      /* Check the HSI State */
      if(hsi_state != RCC_HSI_OFF)
 800b666:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b668:	2b00      	cmp	r3, #0
 800b66a:	d027      	beq.n	800b6bc <HAL_RCC_OscConfig+0x240>
      {
        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
        __HAL_RCC_HSI_CONFIG(hsi_state);
 800b66c:	4b51      	ldr	r3, [pc, #324]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b66e:	681b      	ldr	r3, [r3, #0]
 800b670:	2209      	movs	r2, #9
 800b672:	4393      	bics	r3, r2
 800b674:	0019      	movs	r1, r3
 800b676:	4b4f      	ldr	r3, [pc, #316]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b678:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b67a:	430a      	orrs	r2, r1
 800b67c:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800b67e:	f7ff f967 	bl	800a950 <HAL_GetTick>
 800b682:	0003      	movs	r3, r0
 800b684:	617b      	str	r3, [r7, #20]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800b686:	e008      	b.n	800b69a <HAL_RCC_OscConfig+0x21e>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800b688:	f7ff f962 	bl	800a950 <HAL_GetTick>
 800b68c:	0002      	movs	r2, r0
 800b68e:	697b      	ldr	r3, [r7, #20]
 800b690:	1ad3      	subs	r3, r2, r3
 800b692:	2b02      	cmp	r3, #2
 800b694:	d901      	bls.n	800b69a <HAL_RCC_OscConfig+0x21e>
          {
            return HAL_TIMEOUT;
 800b696:	2303      	movs	r3, #3
 800b698:	e2b6      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800b69a:	4b46      	ldr	r3, [pc, #280]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b69c:	681b      	ldr	r3, [r3, #0]
 800b69e:	2204      	movs	r2, #4
 800b6a0:	4013      	ands	r3, r2
 800b6a2:	d0f1      	beq.n	800b688 <HAL_RCC_OscConfig+0x20c>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800b6a4:	4b43      	ldr	r3, [pc, #268]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b6a6:	685b      	ldr	r3, [r3, #4]
 800b6a8:	4a45      	ldr	r2, [pc, #276]	; (800b7c0 <HAL_RCC_OscConfig+0x344>)
 800b6aa:	4013      	ands	r3, r2
 800b6ac:	0019      	movs	r1, r3
 800b6ae:	687b      	ldr	r3, [r7, #4]
 800b6b0:	691b      	ldr	r3, [r3, #16]
 800b6b2:	021a      	lsls	r2, r3, #8
 800b6b4:	4b3f      	ldr	r3, [pc, #252]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b6b6:	430a      	orrs	r2, r1
 800b6b8:	605a      	str	r2, [r3, #4]
 800b6ba:	e018      	b.n	800b6ee <HAL_RCC_OscConfig+0x272>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800b6bc:	4b3d      	ldr	r3, [pc, #244]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b6be:	681a      	ldr	r2, [r3, #0]
 800b6c0:	4b3c      	ldr	r3, [pc, #240]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b6c2:	2101      	movs	r1, #1
 800b6c4:	438a      	bics	r2, r1
 800b6c6:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800b6c8:	f7ff f942 	bl	800a950 <HAL_GetTick>
 800b6cc:	0003      	movs	r3, r0
 800b6ce:	617b      	str	r3, [r7, #20]

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 800b6d0:	e008      	b.n	800b6e4 <HAL_RCC_OscConfig+0x268>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800b6d2:	f7ff f93d 	bl	800a950 <HAL_GetTick>
 800b6d6:	0002      	movs	r2, r0
 800b6d8:	697b      	ldr	r3, [r7, #20]
 800b6da:	1ad3      	subs	r3, r2, r3
 800b6dc:	2b02      	cmp	r3, #2
 800b6de:	d901      	bls.n	800b6e4 <HAL_RCC_OscConfig+0x268>
          {
            return HAL_TIMEOUT;
 800b6e0:	2303      	movs	r3, #3
 800b6e2:	e291      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 800b6e4:	4b33      	ldr	r3, [pc, #204]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b6e6:	681b      	ldr	r3, [r3, #0]
 800b6e8:	2204      	movs	r2, #4
 800b6ea:	4013      	ands	r3, r2
 800b6ec:	d1f1      	bne.n	800b6d2 <HAL_RCC_OscConfig+0x256>
        }
      }
    }
  }
  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 800b6ee:	687b      	ldr	r3, [r7, #4]
 800b6f0:	681b      	ldr	r3, [r3, #0]
 800b6f2:	2210      	movs	r2, #16
 800b6f4:	4013      	ands	r3, r2
 800b6f6:	d100      	bne.n	800b6fa <HAL_RCC_OscConfig+0x27e>
 800b6f8:	e09f      	b.n	800b83a <HAL_RCC_OscConfig+0x3be>
  {
    /* When the MSI is used as system clock it will not be disabled */
    if((sysclk_source == RCC_CFGR_SWS_MSI) )
 800b6fa:	69fb      	ldr	r3, [r7, #28]
 800b6fc:	2b00      	cmp	r3, #0
 800b6fe:	d13f      	bne.n	800b780 <HAL_RCC_OscConfig+0x304>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 800b700:	4b2c      	ldr	r3, [pc, #176]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b702:	681a      	ldr	r2, [r3, #0]
 800b704:	2380      	movs	r3, #128	; 0x80
 800b706:	009b      	lsls	r3, r3, #2
 800b708:	4013      	ands	r3, r2
 800b70a:	d005      	beq.n	800b718 <HAL_RCC_OscConfig+0x29c>
 800b70c:	687b      	ldr	r3, [r7, #4]
 800b70e:	69db      	ldr	r3, [r3, #28]
 800b710:	2b00      	cmp	r3, #0
 800b712:	d101      	bne.n	800b718 <HAL_RCC_OscConfig+0x29c>
      {
        return HAL_ERROR;
 800b714:	2301      	movs	r3, #1
 800b716:	e277      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800b718:	4b26      	ldr	r3, [pc, #152]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b71a:	685b      	ldr	r3, [r3, #4]
 800b71c:	4a2b      	ldr	r2, [pc, #172]	; (800b7cc <HAL_RCC_OscConfig+0x350>)
 800b71e:	4013      	ands	r3, r2
 800b720:	0019      	movs	r1, r3
 800b722:	687b      	ldr	r3, [r7, #4]
 800b724:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b726:	4b23      	ldr	r3, [pc, #140]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b728:	430a      	orrs	r2, r1
 800b72a:	605a      	str	r2, [r3, #4]
        /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800b72c:	4b21      	ldr	r3, [pc, #132]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b72e:	685b      	ldr	r3, [r3, #4]
 800b730:	021b      	lsls	r3, r3, #8
 800b732:	0a19      	lsrs	r1, r3, #8
 800b734:	687b      	ldr	r3, [r7, #4]
 800b736:	6a1b      	ldr	r3, [r3, #32]
 800b738:	061a      	lsls	r2, r3, #24
 800b73a:	4b1e      	ldr	r3, [pc, #120]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b73c:	430a      	orrs	r2, r1
 800b73e:	605a      	str	r2, [r3, #4]


        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1UL << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_Pos) + 1U)))
 800b740:	687b      	ldr	r3, [r7, #4]
 800b742:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b744:	0b5b      	lsrs	r3, r3, #13
 800b746:	3301      	adds	r3, #1
 800b748:	2280      	movs	r2, #128	; 0x80
 800b74a:	0212      	lsls	r2, r2, #8
 800b74c:	409a      	lsls	r2, r3
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos)];
 800b74e:	4b19      	ldr	r3, [pc, #100]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b750:	68db      	ldr	r3, [r3, #12]
 800b752:	091b      	lsrs	r3, r3, #4
 800b754:	210f      	movs	r1, #15
 800b756:	400b      	ands	r3, r1
 800b758:	491a      	ldr	r1, [pc, #104]	; (800b7c4 <HAL_RCC_OscConfig+0x348>)
 800b75a:	5ccb      	ldrb	r3, [r1, r3]
 800b75c:	40da      	lsrs	r2, r3
        SystemCoreClock =  (32768U * (1UL << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_Pos) + 1U)))
 800b75e:	4b1a      	ldr	r3, [pc, #104]	; (800b7c8 <HAL_RCC_OscConfig+0x34c>)
 800b760:	601a      	str	r2, [r3, #0]

        /* Configure the source of time base considering new system clocks settings*/
        status = HAL_InitTick (TICK_INT_PRIORITY);
 800b762:	2513      	movs	r5, #19
 800b764:	197c      	adds	r4, r7, r5
 800b766:	2000      	movs	r0, #0
 800b768:	f7ff f8bc 	bl	800a8e4 <HAL_InitTick>
 800b76c:	0003      	movs	r3, r0
 800b76e:	7023      	strb	r3, [r4, #0]
        if(status != HAL_OK)
 800b770:	197b      	adds	r3, r7, r5
 800b772:	781b      	ldrb	r3, [r3, #0]
 800b774:	2b00      	cmp	r3, #0
 800b776:	d060      	beq.n	800b83a <HAL_RCC_OscConfig+0x3be>
        {
          return status;
 800b778:	2313      	movs	r3, #19
 800b77a:	18fb      	adds	r3, r7, r3
 800b77c:	781b      	ldrb	r3, [r3, #0]
 800b77e:	e243      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
    {
      /* Check MSI State */
      assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));

      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 800b780:	687b      	ldr	r3, [r7, #4]
 800b782:	69db      	ldr	r3, [r3, #28]
 800b784:	2b00      	cmp	r3, #0
 800b786:	d03e      	beq.n	800b806 <HAL_RCC_OscConfig+0x38a>
      {
        /* Enable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 800b788:	4b0a      	ldr	r3, [pc, #40]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b78a:	681a      	ldr	r2, [r3, #0]
 800b78c:	4b09      	ldr	r3, [pc, #36]	; (800b7b4 <HAL_RCC_OscConfig+0x338>)
 800b78e:	2180      	movs	r1, #128	; 0x80
 800b790:	0049      	lsls	r1, r1, #1
 800b792:	430a      	orrs	r2, r1
 800b794:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800b796:	f7ff f8db 	bl	800a950 <HAL_GetTick>
 800b79a:	0003      	movs	r3, r0
 800b79c:	617b      	str	r3, [r7, #20]

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 800b79e:	e017      	b.n	800b7d0 <HAL_RCC_OscConfig+0x354>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800b7a0:	f7ff f8d6 	bl	800a950 <HAL_GetTick>
 800b7a4:	0002      	movs	r2, r0
 800b7a6:	697b      	ldr	r3, [r7, #20]
 800b7a8:	1ad3      	subs	r3, r2, r3
 800b7aa:	2b02      	cmp	r3, #2
 800b7ac:	d910      	bls.n	800b7d0 <HAL_RCC_OscConfig+0x354>
          {
            return HAL_TIMEOUT;
 800b7ae:	2303      	movs	r3, #3
 800b7b0:	e22a      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
 800b7b2:	46c0      	nop			; (mov r8, r8)
 800b7b4:	40021000 	.word	0x40021000
 800b7b8:	fffeffff 	.word	0xfffeffff
 800b7bc:	fffbffff 	.word	0xfffbffff
 800b7c0:	ffffe0ff 	.word	0xffffe0ff
 800b7c4:	0800e6ac 	.word	0x0800e6ac
 800b7c8:	20000000 	.word	0x20000000
 800b7cc:	ffff1fff 	.word	0xffff1fff
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 800b7d0:	4bc6      	ldr	r3, [pc, #792]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b7d2:	681a      	ldr	r2, [r3, #0]
 800b7d4:	2380      	movs	r3, #128	; 0x80
 800b7d6:	009b      	lsls	r3, r3, #2
 800b7d8:	4013      	ands	r3, r2
 800b7da:	d0e1      	beq.n	800b7a0 <HAL_RCC_OscConfig+0x324>
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800b7dc:	4bc3      	ldr	r3, [pc, #780]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b7de:	685b      	ldr	r3, [r3, #4]
 800b7e0:	4ac3      	ldr	r2, [pc, #780]	; (800baf0 <HAL_RCC_OscConfig+0x674>)
 800b7e2:	4013      	ands	r3, r2
 800b7e4:	0019      	movs	r1, r3
 800b7e6:	687b      	ldr	r3, [r7, #4]
 800b7e8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b7ea:	4bc0      	ldr	r3, [pc, #768]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b7ec:	430a      	orrs	r2, r1
 800b7ee:	605a      	str	r2, [r3, #4]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800b7f0:	4bbe      	ldr	r3, [pc, #760]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b7f2:	685b      	ldr	r3, [r3, #4]
 800b7f4:	021b      	lsls	r3, r3, #8
 800b7f6:	0a19      	lsrs	r1, r3, #8
 800b7f8:	687b      	ldr	r3, [r7, #4]
 800b7fa:	6a1b      	ldr	r3, [r3, #32]
 800b7fc:	061a      	lsls	r2, r3, #24
 800b7fe:	4bbb      	ldr	r3, [pc, #748]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b800:	430a      	orrs	r2, r1
 800b802:	605a      	str	r2, [r3, #4]
 800b804:	e019      	b.n	800b83a <HAL_RCC_OscConfig+0x3be>
      }
      else
      {
        /* Disable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 800b806:	4bb9      	ldr	r3, [pc, #740]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b808:	681a      	ldr	r2, [r3, #0]
 800b80a:	4bb8      	ldr	r3, [pc, #736]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b80c:	49b9      	ldr	r1, [pc, #740]	; (800baf4 <HAL_RCC_OscConfig+0x678>)
 800b80e:	400a      	ands	r2, r1
 800b810:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800b812:	f7ff f89d 	bl	800a950 <HAL_GetTick>
 800b816:	0003      	movs	r3, r0
 800b818:	617b      	str	r3, [r7, #20]

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U)
 800b81a:	e008      	b.n	800b82e <HAL_RCC_OscConfig+0x3b2>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800b81c:	f7ff f898 	bl	800a950 <HAL_GetTick>
 800b820:	0002      	movs	r2, r0
 800b822:	697b      	ldr	r3, [r7, #20]
 800b824:	1ad3      	subs	r3, r2, r3
 800b826:	2b02      	cmp	r3, #2
 800b828:	d901      	bls.n	800b82e <HAL_RCC_OscConfig+0x3b2>
          {
            return HAL_TIMEOUT;
 800b82a:	2303      	movs	r3, #3
 800b82c:	e1ec      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U)
 800b82e:	4baf      	ldr	r3, [pc, #700]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b830:	681a      	ldr	r2, [r3, #0]
 800b832:	2380      	movs	r3, #128	; 0x80
 800b834:	009b      	lsls	r3, r3, #2
 800b836:	4013      	ands	r3, r2
 800b838:	d1f0      	bne.n	800b81c <HAL_RCC_OscConfig+0x3a0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800b83a:	687b      	ldr	r3, [r7, #4]
 800b83c:	681b      	ldr	r3, [r3, #0]
 800b83e:	2208      	movs	r2, #8
 800b840:	4013      	ands	r3, r2
 800b842:	d036      	beq.n	800b8b2 <HAL_RCC_OscConfig+0x436>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800b844:	687b      	ldr	r3, [r7, #4]
 800b846:	695b      	ldr	r3, [r3, #20]
 800b848:	2b00      	cmp	r3, #0
 800b84a:	d019      	beq.n	800b880 <HAL_RCC_OscConfig+0x404>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800b84c:	4ba7      	ldr	r3, [pc, #668]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b84e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b850:	4ba6      	ldr	r3, [pc, #664]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b852:	2101      	movs	r1, #1
 800b854:	430a      	orrs	r2, r1
 800b856:	651a      	str	r2, [r3, #80]	; 0x50

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800b858:	f7ff f87a 	bl	800a950 <HAL_GetTick>
 800b85c:	0003      	movs	r3, r0
 800b85e:	617b      	str	r3, [r7, #20]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 800b860:	e008      	b.n	800b874 <HAL_RCC_OscConfig+0x3f8>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800b862:	f7ff f875 	bl	800a950 <HAL_GetTick>
 800b866:	0002      	movs	r2, r0
 800b868:	697b      	ldr	r3, [r7, #20]
 800b86a:	1ad3      	subs	r3, r2, r3
 800b86c:	2b02      	cmp	r3, #2
 800b86e:	d901      	bls.n	800b874 <HAL_RCC_OscConfig+0x3f8>
        {
          return HAL_TIMEOUT;
 800b870:	2303      	movs	r3, #3
 800b872:	e1c9      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 800b874:	4b9d      	ldr	r3, [pc, #628]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b876:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800b878:	2202      	movs	r2, #2
 800b87a:	4013      	ands	r3, r2
 800b87c:	d0f1      	beq.n	800b862 <HAL_RCC_OscConfig+0x3e6>
 800b87e:	e018      	b.n	800b8b2 <HAL_RCC_OscConfig+0x436>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800b880:	4b9a      	ldr	r3, [pc, #616]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b882:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b884:	4b99      	ldr	r3, [pc, #612]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b886:	2101      	movs	r1, #1
 800b888:	438a      	bics	r2, r1
 800b88a:	651a      	str	r2, [r3, #80]	; 0x50

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800b88c:	f7ff f860 	bl	800a950 <HAL_GetTick>
 800b890:	0003      	movs	r3, r0
 800b892:	617b      	str	r3, [r7, #20]

      /* Wait till LSI is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 800b894:	e008      	b.n	800b8a8 <HAL_RCC_OscConfig+0x42c>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800b896:	f7ff f85b 	bl	800a950 <HAL_GetTick>
 800b89a:	0002      	movs	r2, r0
 800b89c:	697b      	ldr	r3, [r7, #20]
 800b89e:	1ad3      	subs	r3, r2, r3
 800b8a0:	2b02      	cmp	r3, #2
 800b8a2:	d901      	bls.n	800b8a8 <HAL_RCC_OscConfig+0x42c>
        {
          return HAL_TIMEOUT;
 800b8a4:	2303      	movs	r3, #3
 800b8a6:	e1af      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 800b8a8:	4b90      	ldr	r3, [pc, #576]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b8aa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800b8ac:	2202      	movs	r2, #2
 800b8ae:	4013      	ands	r3, r2
 800b8b0:	d1f1      	bne.n	800b896 <HAL_RCC_OscConfig+0x41a>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800b8b2:	687b      	ldr	r3, [r7, #4]
 800b8b4:	681b      	ldr	r3, [r3, #0]
 800b8b6:	2204      	movs	r2, #4
 800b8b8:	4013      	ands	r3, r2
 800b8ba:	d100      	bne.n	800b8be <HAL_RCC_OscConfig+0x442>
 800b8bc:	e0af      	b.n	800ba1e <HAL_RCC_OscConfig+0x5a2>
  {
    FlagStatus       pwrclkchanged = RESET;
 800b8be:	2323      	movs	r3, #35	; 0x23
 800b8c0:	18fb      	adds	r3, r7, r3
 800b8c2:	2200      	movs	r2, #0
 800b8c4:	701a      	strb	r2, [r3, #0]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800b8c6:	4b89      	ldr	r3, [pc, #548]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b8c8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800b8ca:	2380      	movs	r3, #128	; 0x80
 800b8cc:	055b      	lsls	r3, r3, #21
 800b8ce:	4013      	ands	r3, r2
 800b8d0:	d10a      	bne.n	800b8e8 <HAL_RCC_OscConfig+0x46c>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800b8d2:	4b86      	ldr	r3, [pc, #536]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b8d4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800b8d6:	4b85      	ldr	r3, [pc, #532]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b8d8:	2180      	movs	r1, #128	; 0x80
 800b8da:	0549      	lsls	r1, r1, #21
 800b8dc:	430a      	orrs	r2, r1
 800b8de:	639a      	str	r2, [r3, #56]	; 0x38
      pwrclkchanged = SET;
 800b8e0:	2323      	movs	r3, #35	; 0x23
 800b8e2:	18fb      	adds	r3, r7, r3
 800b8e4:	2201      	movs	r2, #1
 800b8e6:	701a      	strb	r2, [r3, #0]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800b8e8:	4b83      	ldr	r3, [pc, #524]	; (800baf8 <HAL_RCC_OscConfig+0x67c>)
 800b8ea:	681a      	ldr	r2, [r3, #0]
 800b8ec:	2380      	movs	r3, #128	; 0x80
 800b8ee:	005b      	lsls	r3, r3, #1
 800b8f0:	4013      	ands	r3, r2
 800b8f2:	d11a      	bne.n	800b92a <HAL_RCC_OscConfig+0x4ae>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800b8f4:	4b80      	ldr	r3, [pc, #512]	; (800baf8 <HAL_RCC_OscConfig+0x67c>)
 800b8f6:	681a      	ldr	r2, [r3, #0]
 800b8f8:	4b7f      	ldr	r3, [pc, #508]	; (800baf8 <HAL_RCC_OscConfig+0x67c>)
 800b8fa:	2180      	movs	r1, #128	; 0x80
 800b8fc:	0049      	lsls	r1, r1, #1
 800b8fe:	430a      	orrs	r2, r1
 800b900:	601a      	str	r2, [r3, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800b902:	f7ff f825 	bl	800a950 <HAL_GetTick>
 800b906:	0003      	movs	r3, r0
 800b908:	617b      	str	r3, [r7, #20]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800b90a:	e008      	b.n	800b91e <HAL_RCC_OscConfig+0x4a2>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800b90c:	f7ff f820 	bl	800a950 <HAL_GetTick>
 800b910:	0002      	movs	r2, r0
 800b912:	697b      	ldr	r3, [r7, #20]
 800b914:	1ad3      	subs	r3, r2, r3
 800b916:	2b64      	cmp	r3, #100	; 0x64
 800b918:	d901      	bls.n	800b91e <HAL_RCC_OscConfig+0x4a2>
        {
          return HAL_TIMEOUT;
 800b91a:	2303      	movs	r3, #3
 800b91c:	e174      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800b91e:	4b76      	ldr	r3, [pc, #472]	; (800baf8 <HAL_RCC_OscConfig+0x67c>)
 800b920:	681a      	ldr	r2, [r3, #0]
 800b922:	2380      	movs	r3, #128	; 0x80
 800b924:	005b      	lsls	r3, r3, #1
 800b926:	4013      	ands	r3, r2
 800b928:	d0f0      	beq.n	800b90c <HAL_RCC_OscConfig+0x490>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800b92a:	687b      	ldr	r3, [r7, #4]
 800b92c:	689a      	ldr	r2, [r3, #8]
 800b92e:	2380      	movs	r3, #128	; 0x80
 800b930:	005b      	lsls	r3, r3, #1
 800b932:	429a      	cmp	r2, r3
 800b934:	d107      	bne.n	800b946 <HAL_RCC_OscConfig+0x4ca>
 800b936:	4b6d      	ldr	r3, [pc, #436]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b938:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b93a:	4b6c      	ldr	r3, [pc, #432]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b93c:	2180      	movs	r1, #128	; 0x80
 800b93e:	0049      	lsls	r1, r1, #1
 800b940:	430a      	orrs	r2, r1
 800b942:	651a      	str	r2, [r3, #80]	; 0x50
 800b944:	e031      	b.n	800b9aa <HAL_RCC_OscConfig+0x52e>
 800b946:	687b      	ldr	r3, [r7, #4]
 800b948:	689b      	ldr	r3, [r3, #8]
 800b94a:	2b00      	cmp	r3, #0
 800b94c:	d10c      	bne.n	800b968 <HAL_RCC_OscConfig+0x4ec>
 800b94e:	4b67      	ldr	r3, [pc, #412]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b950:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b952:	4b66      	ldr	r3, [pc, #408]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b954:	4967      	ldr	r1, [pc, #412]	; (800baf4 <HAL_RCC_OscConfig+0x678>)
 800b956:	400a      	ands	r2, r1
 800b958:	651a      	str	r2, [r3, #80]	; 0x50
 800b95a:	4b64      	ldr	r3, [pc, #400]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b95c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b95e:	4b63      	ldr	r3, [pc, #396]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b960:	4966      	ldr	r1, [pc, #408]	; (800bafc <HAL_RCC_OscConfig+0x680>)
 800b962:	400a      	ands	r2, r1
 800b964:	651a      	str	r2, [r3, #80]	; 0x50
 800b966:	e020      	b.n	800b9aa <HAL_RCC_OscConfig+0x52e>
 800b968:	687b      	ldr	r3, [r7, #4]
 800b96a:	689a      	ldr	r2, [r3, #8]
 800b96c:	23a0      	movs	r3, #160	; 0xa0
 800b96e:	00db      	lsls	r3, r3, #3
 800b970:	429a      	cmp	r2, r3
 800b972:	d10e      	bne.n	800b992 <HAL_RCC_OscConfig+0x516>
 800b974:	4b5d      	ldr	r3, [pc, #372]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b976:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b978:	4b5c      	ldr	r3, [pc, #368]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b97a:	2180      	movs	r1, #128	; 0x80
 800b97c:	00c9      	lsls	r1, r1, #3
 800b97e:	430a      	orrs	r2, r1
 800b980:	651a      	str	r2, [r3, #80]	; 0x50
 800b982:	4b5a      	ldr	r3, [pc, #360]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b984:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b986:	4b59      	ldr	r3, [pc, #356]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b988:	2180      	movs	r1, #128	; 0x80
 800b98a:	0049      	lsls	r1, r1, #1
 800b98c:	430a      	orrs	r2, r1
 800b98e:	651a      	str	r2, [r3, #80]	; 0x50
 800b990:	e00b      	b.n	800b9aa <HAL_RCC_OscConfig+0x52e>
 800b992:	4b56      	ldr	r3, [pc, #344]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b994:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b996:	4b55      	ldr	r3, [pc, #340]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b998:	4956      	ldr	r1, [pc, #344]	; (800baf4 <HAL_RCC_OscConfig+0x678>)
 800b99a:	400a      	ands	r2, r1
 800b99c:	651a      	str	r2, [r3, #80]	; 0x50
 800b99e:	4b53      	ldr	r3, [pc, #332]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b9a0:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b9a2:	4b52      	ldr	r3, [pc, #328]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b9a4:	4955      	ldr	r1, [pc, #340]	; (800bafc <HAL_RCC_OscConfig+0x680>)
 800b9a6:	400a      	ands	r2, r1
 800b9a8:	651a      	str	r2, [r3, #80]	; 0x50
    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 800b9aa:	687b      	ldr	r3, [r7, #4]
 800b9ac:	689b      	ldr	r3, [r3, #8]
 800b9ae:	2b00      	cmp	r3, #0
 800b9b0:	d015      	beq.n	800b9de <HAL_RCC_OscConfig+0x562>
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800b9b2:	f7fe ffcd 	bl	800a950 <HAL_GetTick>
 800b9b6:	0003      	movs	r3, r0
 800b9b8:	617b      	str	r3, [r7, #20]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800b9ba:	e009      	b.n	800b9d0 <HAL_RCC_OscConfig+0x554>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800b9bc:	f7fe ffc8 	bl	800a950 <HAL_GetTick>
 800b9c0:	0002      	movs	r2, r0
 800b9c2:	697b      	ldr	r3, [r7, #20]
 800b9c4:	1ad3      	subs	r3, r2, r3
 800b9c6:	4a4e      	ldr	r2, [pc, #312]	; (800bb00 <HAL_RCC_OscConfig+0x684>)
 800b9c8:	4293      	cmp	r3, r2
 800b9ca:	d901      	bls.n	800b9d0 <HAL_RCC_OscConfig+0x554>
        {
          return HAL_TIMEOUT;
 800b9cc:	2303      	movs	r3, #3
 800b9ce:	e11b      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800b9d0:	4b46      	ldr	r3, [pc, #280]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b9d2:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800b9d4:	2380      	movs	r3, #128	; 0x80
 800b9d6:	009b      	lsls	r3, r3, #2
 800b9d8:	4013      	ands	r3, r2
 800b9da:	d0ef      	beq.n	800b9bc <HAL_RCC_OscConfig+0x540>
 800b9dc:	e014      	b.n	800ba08 <HAL_RCC_OscConfig+0x58c>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800b9de:	f7fe ffb7 	bl	800a950 <HAL_GetTick>
 800b9e2:	0003      	movs	r3, r0
 800b9e4:	617b      	str	r3, [r7, #20]

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 800b9e6:	e009      	b.n	800b9fc <HAL_RCC_OscConfig+0x580>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800b9e8:	f7fe ffb2 	bl	800a950 <HAL_GetTick>
 800b9ec:	0002      	movs	r2, r0
 800b9ee:	697b      	ldr	r3, [r7, #20]
 800b9f0:	1ad3      	subs	r3, r2, r3
 800b9f2:	4a43      	ldr	r2, [pc, #268]	; (800bb00 <HAL_RCC_OscConfig+0x684>)
 800b9f4:	4293      	cmp	r3, r2
 800b9f6:	d901      	bls.n	800b9fc <HAL_RCC_OscConfig+0x580>
        {
          return HAL_TIMEOUT;
 800b9f8:	2303      	movs	r3, #3
 800b9fa:	e105      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 800b9fc:	4b3b      	ldr	r3, [pc, #236]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800b9fe:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800ba00:	2380      	movs	r3, #128	; 0x80
 800ba02:	009b      	lsls	r3, r3, #2
 800ba04:	4013      	ands	r3, r2
 800ba06:	d1ef      	bne.n	800b9e8 <HAL_RCC_OscConfig+0x56c>
        }
      }
    }

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 800ba08:	2323      	movs	r3, #35	; 0x23
 800ba0a:	18fb      	adds	r3, r7, r3
 800ba0c:	781b      	ldrb	r3, [r3, #0]
 800ba0e:	2b01      	cmp	r3, #1
 800ba10:	d105      	bne.n	800ba1e <HAL_RCC_OscConfig+0x5a2>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800ba12:	4b36      	ldr	r3, [pc, #216]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800ba14:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800ba16:	4b35      	ldr	r3, [pc, #212]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800ba18:	493a      	ldr	r1, [pc, #232]	; (800bb04 <HAL_RCC_OscConfig+0x688>)
 800ba1a:	400a      	ands	r2, r1
 800ba1c:	639a      	str	r2, [r3, #56]	; 0x38
    }
  }

#if defined(RCC_HSI48_SUPPORT)
  /*----------------------------- HSI48 Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 800ba1e:	687b      	ldr	r3, [r7, #4]
 800ba20:	681b      	ldr	r3, [r3, #0]
 800ba22:	2220      	movs	r2, #32
 800ba24:	4013      	ands	r3, r2
 800ba26:	d049      	beq.n	800babc <HAL_RCC_OscConfig+0x640>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

      /* Check the HSI48 State */
      if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 800ba28:	687b      	ldr	r3, [r7, #4]
 800ba2a:	699b      	ldr	r3, [r3, #24]
 800ba2c:	2b00      	cmp	r3, #0
 800ba2e:	d026      	beq.n	800ba7e <HAL_RCC_OscConfig+0x602>
      {
        /* Enable the Internal High Speed oscillator (HSI48). */
        __HAL_RCC_HSI48_ENABLE();
 800ba30:	4b2e      	ldr	r3, [pc, #184]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800ba32:	689a      	ldr	r2, [r3, #8]
 800ba34:	4b2d      	ldr	r3, [pc, #180]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800ba36:	2101      	movs	r1, #1
 800ba38:	430a      	orrs	r2, r1
 800ba3a:	609a      	str	r2, [r3, #8]
 800ba3c:	4b2b      	ldr	r3, [pc, #172]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800ba3e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ba40:	4b2a      	ldr	r3, [pc, #168]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800ba42:	2101      	movs	r1, #1
 800ba44:	430a      	orrs	r2, r1
 800ba46:	635a      	str	r2, [r3, #52]	; 0x34
 800ba48:	4b2f      	ldr	r3, [pc, #188]	; (800bb08 <HAL_RCC_OscConfig+0x68c>)
 800ba4a:	6a1a      	ldr	r2, [r3, #32]
 800ba4c:	4b2e      	ldr	r3, [pc, #184]	; (800bb08 <HAL_RCC_OscConfig+0x68c>)
 800ba4e:	2180      	movs	r1, #128	; 0x80
 800ba50:	0189      	lsls	r1, r1, #6
 800ba52:	430a      	orrs	r2, r1
 800ba54:	621a      	str	r2, [r3, #32]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800ba56:	f7fe ff7b 	bl	800a950 <HAL_GetTick>
 800ba5a:	0003      	movs	r3, r0
 800ba5c:	617b      	str	r3, [r7, #20]

        /* Wait till HSI48 is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 800ba5e:	e008      	b.n	800ba72 <HAL_RCC_OscConfig+0x5f6>
        {
          if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800ba60:	f7fe ff76 	bl	800a950 <HAL_GetTick>
 800ba64:	0002      	movs	r2, r0
 800ba66:	697b      	ldr	r3, [r7, #20]
 800ba68:	1ad3      	subs	r3, r2, r3
 800ba6a:	2b02      	cmp	r3, #2
 800ba6c:	d901      	bls.n	800ba72 <HAL_RCC_OscConfig+0x5f6>
          {
            return HAL_TIMEOUT;
 800ba6e:	2303      	movs	r3, #3
 800ba70:	e0ca      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 800ba72:	4b1e      	ldr	r3, [pc, #120]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800ba74:	689b      	ldr	r3, [r3, #8]
 800ba76:	2202      	movs	r2, #2
 800ba78:	4013      	ands	r3, r2
 800ba7a:	d0f1      	beq.n	800ba60 <HAL_RCC_OscConfig+0x5e4>
 800ba7c:	e01e      	b.n	800babc <HAL_RCC_OscConfig+0x640>
        }
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI48). */
        __HAL_RCC_HSI48_DISABLE();
 800ba7e:	4b1b      	ldr	r3, [pc, #108]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800ba80:	689a      	ldr	r2, [r3, #8]
 800ba82:	4b1a      	ldr	r3, [pc, #104]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800ba84:	2101      	movs	r1, #1
 800ba86:	438a      	bics	r2, r1
 800ba88:	609a      	str	r2, [r3, #8]
 800ba8a:	4b1f      	ldr	r3, [pc, #124]	; (800bb08 <HAL_RCC_OscConfig+0x68c>)
 800ba8c:	6a1a      	ldr	r2, [r3, #32]
 800ba8e:	4b1e      	ldr	r3, [pc, #120]	; (800bb08 <HAL_RCC_OscConfig+0x68c>)
 800ba90:	491e      	ldr	r1, [pc, #120]	; (800bb0c <HAL_RCC_OscConfig+0x690>)
 800ba92:	400a      	ands	r2, r1
 800ba94:	621a      	str	r2, [r3, #32]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800ba96:	f7fe ff5b 	bl	800a950 <HAL_GetTick>
 800ba9a:	0003      	movs	r3, r0
 800ba9c:	617b      	str	r3, [r7, #20]

        /* Wait till HSI48 is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 800ba9e:	e008      	b.n	800bab2 <HAL_RCC_OscConfig+0x636>
        {
          if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800baa0:	f7fe ff56 	bl	800a950 <HAL_GetTick>
 800baa4:	0002      	movs	r2, r0
 800baa6:	697b      	ldr	r3, [r7, #20]
 800baa8:	1ad3      	subs	r3, r2, r3
 800baaa:	2b02      	cmp	r3, #2
 800baac:	d901      	bls.n	800bab2 <HAL_RCC_OscConfig+0x636>
          {
            return HAL_TIMEOUT;
 800baae:	2303      	movs	r3, #3
 800bab0:	e0aa      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 800bab2:	4b0e      	ldr	r3, [pc, #56]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800bab4:	689b      	ldr	r3, [r3, #8]
 800bab6:	2202      	movs	r2, #2
 800bab8:	4013      	ands	r3, r2
 800baba:	d1f1      	bne.n	800baa0 <HAL_RCC_OscConfig+0x624>
#endif /* RCC_HSI48_SUPPORT */

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800babc:	687b      	ldr	r3, [r7, #4]
 800babe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800bac0:	2b00      	cmp	r3, #0
 800bac2:	d100      	bne.n	800bac6 <HAL_RCC_OscConfig+0x64a>
 800bac4:	e09f      	b.n	800bc06 <HAL_RCC_OscConfig+0x78a>
  {
    /* Check if the PLL is used as system clock or not */
    if(sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800bac6:	69fb      	ldr	r3, [r7, #28]
 800bac8:	2b0c      	cmp	r3, #12
 800baca:	d100      	bne.n	800bace <HAL_RCC_OscConfig+0x652>
 800bacc:	e078      	b.n	800bbc0 <HAL_RCC_OscConfig+0x744>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800bace:	687b      	ldr	r3, [r7, #4]
 800bad0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800bad2:	2b02      	cmp	r3, #2
 800bad4:	d159      	bne.n	800bb8a <HAL_RCC_OscConfig+0x70e>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
        assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800bad6:	4b05      	ldr	r3, [pc, #20]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800bad8:	681a      	ldr	r2, [r3, #0]
 800bada:	4b04      	ldr	r3, [pc, #16]	; (800baec <HAL_RCC_OscConfig+0x670>)
 800badc:	490c      	ldr	r1, [pc, #48]	; (800bb10 <HAL_RCC_OscConfig+0x694>)
 800bade:	400a      	ands	r2, r1
 800bae0:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800bae2:	f7fe ff35 	bl	800a950 <HAL_GetTick>
 800bae6:	0003      	movs	r3, r0
 800bae8:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 800baea:	e01c      	b.n	800bb26 <HAL_RCC_OscConfig+0x6aa>
 800baec:	40021000 	.word	0x40021000
 800baf0:	ffff1fff 	.word	0xffff1fff
 800baf4:	fffffeff 	.word	0xfffffeff
 800baf8:	40007000 	.word	0x40007000
 800bafc:	fffffbff 	.word	0xfffffbff
 800bb00:	00001388 	.word	0x00001388
 800bb04:	efffffff 	.word	0xefffffff
 800bb08:	40010000 	.word	0x40010000
 800bb0c:	ffffdfff 	.word	0xffffdfff
 800bb10:	feffffff 	.word	0xfeffffff
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800bb14:	f7fe ff1c 	bl	800a950 <HAL_GetTick>
 800bb18:	0002      	movs	r2, r0
 800bb1a:	697b      	ldr	r3, [r7, #20]
 800bb1c:	1ad3      	subs	r3, r2, r3
 800bb1e:	2b02      	cmp	r3, #2
 800bb20:	d901      	bls.n	800bb26 <HAL_RCC_OscConfig+0x6aa>
          {
            return HAL_TIMEOUT;
 800bb22:	2303      	movs	r3, #3
 800bb24:	e070      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 800bb26:	4b3a      	ldr	r3, [pc, #232]	; (800bc10 <HAL_RCC_OscConfig+0x794>)
 800bb28:	681a      	ldr	r2, [r3, #0]
 800bb2a:	2380      	movs	r3, #128	; 0x80
 800bb2c:	049b      	lsls	r3, r3, #18
 800bb2e:	4013      	ands	r3, r2
 800bb30:	d1f0      	bne.n	800bb14 <HAL_RCC_OscConfig+0x698>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800bb32:	4b37      	ldr	r3, [pc, #220]	; (800bc10 <HAL_RCC_OscConfig+0x794>)
 800bb34:	68db      	ldr	r3, [r3, #12]
 800bb36:	4a37      	ldr	r2, [pc, #220]	; (800bc14 <HAL_RCC_OscConfig+0x798>)
 800bb38:	4013      	ands	r3, r2
 800bb3a:	0019      	movs	r1, r3
 800bb3c:	687b      	ldr	r3, [r7, #4]
 800bb3e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800bb40:	687b      	ldr	r3, [r7, #4]
 800bb42:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bb44:	431a      	orrs	r2, r3
 800bb46:	687b      	ldr	r3, [r7, #4]
 800bb48:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800bb4a:	431a      	orrs	r2, r3
 800bb4c:	4b30      	ldr	r3, [pc, #192]	; (800bc10 <HAL_RCC_OscConfig+0x794>)
 800bb4e:	430a      	orrs	r2, r1
 800bb50:	60da      	str	r2, [r3, #12]
                             RCC_OscInitStruct->PLL.PLLMUL,
                             RCC_OscInitStruct->PLL.PLLDIV);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800bb52:	4b2f      	ldr	r3, [pc, #188]	; (800bc10 <HAL_RCC_OscConfig+0x794>)
 800bb54:	681a      	ldr	r2, [r3, #0]
 800bb56:	4b2e      	ldr	r3, [pc, #184]	; (800bc10 <HAL_RCC_OscConfig+0x794>)
 800bb58:	2180      	movs	r1, #128	; 0x80
 800bb5a:	0449      	lsls	r1, r1, #17
 800bb5c:	430a      	orrs	r2, r1
 800bb5e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800bb60:	f7fe fef6 	bl	800a950 <HAL_GetTick>
 800bb64:	0003      	movs	r3, r0
 800bb66:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == 0U)
 800bb68:	e008      	b.n	800bb7c <HAL_RCC_OscConfig+0x700>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800bb6a:	f7fe fef1 	bl	800a950 <HAL_GetTick>
 800bb6e:	0002      	movs	r2, r0
 800bb70:	697b      	ldr	r3, [r7, #20]
 800bb72:	1ad3      	subs	r3, r2, r3
 800bb74:	2b02      	cmp	r3, #2
 800bb76:	d901      	bls.n	800bb7c <HAL_RCC_OscConfig+0x700>
          {
            return HAL_TIMEOUT;
 800bb78:	2303      	movs	r3, #3
 800bb7a:	e045      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == 0U)
 800bb7c:	4b24      	ldr	r3, [pc, #144]	; (800bc10 <HAL_RCC_OscConfig+0x794>)
 800bb7e:	681a      	ldr	r2, [r3, #0]
 800bb80:	2380      	movs	r3, #128	; 0x80
 800bb82:	049b      	lsls	r3, r3, #18
 800bb84:	4013      	ands	r3, r2
 800bb86:	d0f0      	beq.n	800bb6a <HAL_RCC_OscConfig+0x6ee>
 800bb88:	e03d      	b.n	800bc06 <HAL_RCC_OscConfig+0x78a>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800bb8a:	4b21      	ldr	r3, [pc, #132]	; (800bc10 <HAL_RCC_OscConfig+0x794>)
 800bb8c:	681a      	ldr	r2, [r3, #0]
 800bb8e:	4b20      	ldr	r3, [pc, #128]	; (800bc10 <HAL_RCC_OscConfig+0x794>)
 800bb90:	4921      	ldr	r1, [pc, #132]	; (800bc18 <HAL_RCC_OscConfig+0x79c>)
 800bb92:	400a      	ands	r2, r1
 800bb94:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800bb96:	f7fe fedb 	bl	800a950 <HAL_GetTick>
 800bb9a:	0003      	movs	r3, r0
 800bb9c:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 800bb9e:	e008      	b.n	800bbb2 <HAL_RCC_OscConfig+0x736>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800bba0:	f7fe fed6 	bl	800a950 <HAL_GetTick>
 800bba4:	0002      	movs	r2, r0
 800bba6:	697b      	ldr	r3, [r7, #20]
 800bba8:	1ad3      	subs	r3, r2, r3
 800bbaa:	2b02      	cmp	r3, #2
 800bbac:	d901      	bls.n	800bbb2 <HAL_RCC_OscConfig+0x736>
          {
            return HAL_TIMEOUT;
 800bbae:	2303      	movs	r3, #3
 800bbb0:	e02a      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 800bbb2:	4b17      	ldr	r3, [pc, #92]	; (800bc10 <HAL_RCC_OscConfig+0x794>)
 800bbb4:	681a      	ldr	r2, [r3, #0]
 800bbb6:	2380      	movs	r3, #128	; 0x80
 800bbb8:	049b      	lsls	r3, r3, #18
 800bbba:	4013      	ands	r3, r2
 800bbbc:	d1f0      	bne.n	800bba0 <HAL_RCC_OscConfig+0x724>
 800bbbe:	e022      	b.n	800bc06 <HAL_RCC_OscConfig+0x78a>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800bbc0:	687b      	ldr	r3, [r7, #4]
 800bbc2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800bbc4:	2b01      	cmp	r3, #1
 800bbc6:	d101      	bne.n	800bbcc <HAL_RCC_OscConfig+0x750>
      {
        return HAL_ERROR;
 800bbc8:	2301      	movs	r3, #1
 800bbca:	e01d      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->CFGR;
 800bbcc:	4b10      	ldr	r3, [pc, #64]	; (800bc10 <HAL_RCC_OscConfig+0x794>)
 800bbce:	68db      	ldr	r3, [r3, #12]
 800bbd0:	61bb      	str	r3, [r7, #24]
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800bbd2:	69ba      	ldr	r2, [r7, #24]
 800bbd4:	2380      	movs	r3, #128	; 0x80
 800bbd6:	025b      	lsls	r3, r3, #9
 800bbd8:	401a      	ands	r2, r3
 800bbda:	687b      	ldr	r3, [r7, #4]
 800bbdc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bbde:	429a      	cmp	r2, r3
 800bbe0:	d10f      	bne.n	800bc02 <HAL_RCC_OscConfig+0x786>
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL) != RCC_OscInitStruct->PLL.PLLMUL) ||
 800bbe2:	69ba      	ldr	r2, [r7, #24]
 800bbe4:	23f0      	movs	r3, #240	; 0xf0
 800bbe6:	039b      	lsls	r3, r3, #14
 800bbe8:	401a      	ands	r2, r3
 800bbea:	687b      	ldr	r3, [r7, #4]
 800bbec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800bbee:	429a      	cmp	r2, r3
 800bbf0:	d107      	bne.n	800bc02 <HAL_RCC_OscConfig+0x786>
           (READ_BIT(pll_config, RCC_CFGR_PLLDIV) != RCC_OscInitStruct->PLL.PLLDIV))
 800bbf2:	69ba      	ldr	r2, [r7, #24]
 800bbf4:	23c0      	movs	r3, #192	; 0xc0
 800bbf6:	041b      	lsls	r3, r3, #16
 800bbf8:	401a      	ands	r2, r3
 800bbfa:	687b      	ldr	r3, [r7, #4]
 800bbfc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL) != RCC_OscInitStruct->PLL.PLLMUL) ||
 800bbfe:	429a      	cmp	r2, r3
 800bc00:	d001      	beq.n	800bc06 <HAL_RCC_OscConfig+0x78a>
        {
          return HAL_ERROR;
 800bc02:	2301      	movs	r3, #1
 800bc04:	e000      	b.n	800bc08 <HAL_RCC_OscConfig+0x78c>
        }
      }
    }
  }

  return HAL_OK;
 800bc06:	2300      	movs	r3, #0
}
 800bc08:	0018      	movs	r0, r3
 800bc0a:	46bd      	mov	sp, r7
 800bc0c:	b00a      	add	sp, #40	; 0x28
 800bc0e:	bdb0      	pop	{r4, r5, r7, pc}
 800bc10:	40021000 	.word	0x40021000
 800bc14:	ff02ffff 	.word	0xff02ffff
 800bc18:	feffffff 	.word	0xfeffffff

0800bc1c <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800bc1c:	b5b0      	push	{r4, r5, r7, lr}
 800bc1e:	b084      	sub	sp, #16
 800bc20:	af00      	add	r7, sp, #0
 800bc22:	6078      	str	r0, [r7, #4]
 800bc24:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status;

  /* Check the parameters */
  if(RCC_ClkInitStruct == NULL)
 800bc26:	687b      	ldr	r3, [r7, #4]
 800bc28:	2b00      	cmp	r3, #0
 800bc2a:	d101      	bne.n	800bc30 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 800bc2c:	2301      	movs	r3, #1
 800bc2e:	e10d      	b.n	800be4c <HAL_RCC_ClockConfig+0x230>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
  must be correctly programmed according to the frequency of the CPU clock
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800bc30:	4b88      	ldr	r3, [pc, #544]	; (800be54 <HAL_RCC_ClockConfig+0x238>)
 800bc32:	681b      	ldr	r3, [r3, #0]
 800bc34:	2201      	movs	r2, #1
 800bc36:	4013      	ands	r3, r2
 800bc38:	683a      	ldr	r2, [r7, #0]
 800bc3a:	429a      	cmp	r2, r3
 800bc3c:	d911      	bls.n	800bc62 <HAL_RCC_ClockConfig+0x46>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800bc3e:	4b85      	ldr	r3, [pc, #532]	; (800be54 <HAL_RCC_ClockConfig+0x238>)
 800bc40:	681b      	ldr	r3, [r3, #0]
 800bc42:	2201      	movs	r2, #1
 800bc44:	4393      	bics	r3, r2
 800bc46:	0019      	movs	r1, r3
 800bc48:	4b82      	ldr	r3, [pc, #520]	; (800be54 <HAL_RCC_ClockConfig+0x238>)
 800bc4a:	683a      	ldr	r2, [r7, #0]
 800bc4c:	430a      	orrs	r2, r1
 800bc4e:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800bc50:	4b80      	ldr	r3, [pc, #512]	; (800be54 <HAL_RCC_ClockConfig+0x238>)
 800bc52:	681b      	ldr	r3, [r3, #0]
 800bc54:	2201      	movs	r2, #1
 800bc56:	4013      	ands	r3, r2
 800bc58:	683a      	ldr	r2, [r7, #0]
 800bc5a:	429a      	cmp	r2, r3
 800bc5c:	d001      	beq.n	800bc62 <HAL_RCC_ClockConfig+0x46>
    {
      return HAL_ERROR;
 800bc5e:	2301      	movs	r3, #1
 800bc60:	e0f4      	b.n	800be4c <HAL_RCC_ClockConfig+0x230>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800bc62:	687b      	ldr	r3, [r7, #4]
 800bc64:	681b      	ldr	r3, [r3, #0]
 800bc66:	2202      	movs	r2, #2
 800bc68:	4013      	ands	r3, r2
 800bc6a:	d009      	beq.n	800bc80 <HAL_RCC_ClockConfig+0x64>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800bc6c:	4b7a      	ldr	r3, [pc, #488]	; (800be58 <HAL_RCC_ClockConfig+0x23c>)
 800bc6e:	68db      	ldr	r3, [r3, #12]
 800bc70:	22f0      	movs	r2, #240	; 0xf0
 800bc72:	4393      	bics	r3, r2
 800bc74:	0019      	movs	r1, r3
 800bc76:	687b      	ldr	r3, [r7, #4]
 800bc78:	689a      	ldr	r2, [r3, #8]
 800bc7a:	4b77      	ldr	r3, [pc, #476]	; (800be58 <HAL_RCC_ClockConfig+0x23c>)
 800bc7c:	430a      	orrs	r2, r1
 800bc7e:	60da      	str	r2, [r3, #12]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800bc80:	687b      	ldr	r3, [r7, #4]
 800bc82:	681b      	ldr	r3, [r3, #0]
 800bc84:	2201      	movs	r2, #1
 800bc86:	4013      	ands	r3, r2
 800bc88:	d100      	bne.n	800bc8c <HAL_RCC_ClockConfig+0x70>
 800bc8a:	e089      	b.n	800bda0 <HAL_RCC_ClockConfig+0x184>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800bc8c:	687b      	ldr	r3, [r7, #4]
 800bc8e:	685b      	ldr	r3, [r3, #4]
 800bc90:	2b02      	cmp	r3, #2
 800bc92:	d107      	bne.n	800bca4 <HAL_RCC_ClockConfig+0x88>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800bc94:	4b70      	ldr	r3, [pc, #448]	; (800be58 <HAL_RCC_ClockConfig+0x23c>)
 800bc96:	681a      	ldr	r2, [r3, #0]
 800bc98:	2380      	movs	r3, #128	; 0x80
 800bc9a:	029b      	lsls	r3, r3, #10
 800bc9c:	4013      	ands	r3, r2
 800bc9e:	d120      	bne.n	800bce2 <HAL_RCC_ClockConfig+0xc6>
      {
        return HAL_ERROR;
 800bca0:	2301      	movs	r3, #1
 800bca2:	e0d3      	b.n	800be4c <HAL_RCC_ClockConfig+0x230>
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800bca4:	687b      	ldr	r3, [r7, #4]
 800bca6:	685b      	ldr	r3, [r3, #4]
 800bca8:	2b03      	cmp	r3, #3
 800bcaa:	d107      	bne.n	800bcbc <HAL_RCC_ClockConfig+0xa0>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 800bcac:	4b6a      	ldr	r3, [pc, #424]	; (800be58 <HAL_RCC_ClockConfig+0x23c>)
 800bcae:	681a      	ldr	r2, [r3, #0]
 800bcb0:	2380      	movs	r3, #128	; 0x80
 800bcb2:	049b      	lsls	r3, r3, #18
 800bcb4:	4013      	ands	r3, r2
 800bcb6:	d114      	bne.n	800bce2 <HAL_RCC_ClockConfig+0xc6>
      {
        return HAL_ERROR;
 800bcb8:	2301      	movs	r3, #1
 800bcba:	e0c7      	b.n	800be4c <HAL_RCC_ClockConfig+0x230>
      }
    }
    /* HSI is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 800bcbc:	687b      	ldr	r3, [r7, #4]
 800bcbe:	685b      	ldr	r3, [r3, #4]
 800bcc0:	2b01      	cmp	r3, #1
 800bcc2:	d106      	bne.n	800bcd2 <HAL_RCC_ClockConfig+0xb6>
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800bcc4:	4b64      	ldr	r3, [pc, #400]	; (800be58 <HAL_RCC_ClockConfig+0x23c>)
 800bcc6:	681b      	ldr	r3, [r3, #0]
 800bcc8:	2204      	movs	r2, #4
 800bcca:	4013      	ands	r3, r2
 800bccc:	d109      	bne.n	800bce2 <HAL_RCC_ClockConfig+0xc6>
      {
        return HAL_ERROR;
 800bcce:	2301      	movs	r3, #1
 800bcd0:	e0bc      	b.n	800be4c <HAL_RCC_ClockConfig+0x230>
    }
    /* MSI is selected as System Clock Source */
    else
    {
      /* Check the MSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 800bcd2:	4b61      	ldr	r3, [pc, #388]	; (800be58 <HAL_RCC_ClockConfig+0x23c>)
 800bcd4:	681a      	ldr	r2, [r3, #0]
 800bcd6:	2380      	movs	r3, #128	; 0x80
 800bcd8:	009b      	lsls	r3, r3, #2
 800bcda:	4013      	ands	r3, r2
 800bcdc:	d101      	bne.n	800bce2 <HAL_RCC_ClockConfig+0xc6>
      {
        return HAL_ERROR;
 800bcde:	2301      	movs	r3, #1
 800bce0:	e0b4      	b.n	800be4c <HAL_RCC_ClockConfig+0x230>
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800bce2:	4b5d      	ldr	r3, [pc, #372]	; (800be58 <HAL_RCC_ClockConfig+0x23c>)
 800bce4:	68db      	ldr	r3, [r3, #12]
 800bce6:	2203      	movs	r2, #3
 800bce8:	4393      	bics	r3, r2
 800bcea:	0019      	movs	r1, r3
 800bcec:	687b      	ldr	r3, [r7, #4]
 800bcee:	685a      	ldr	r2, [r3, #4]
 800bcf0:	4b59      	ldr	r3, [pc, #356]	; (800be58 <HAL_RCC_ClockConfig+0x23c>)
 800bcf2:	430a      	orrs	r2, r1
 800bcf4:	60da      	str	r2, [r3, #12]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 800bcf6:	f7fe fe2b 	bl	800a950 <HAL_GetTick>
 800bcfa:	0003      	movs	r3, r0
 800bcfc:	60fb      	str	r3, [r7, #12]

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800bcfe:	687b      	ldr	r3, [r7, #4]
 800bd00:	685b      	ldr	r3, [r3, #4]
 800bd02:	2b02      	cmp	r3, #2
 800bd04:	d111      	bne.n	800bd2a <HAL_RCC_ClockConfig+0x10e>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800bd06:	e009      	b.n	800bd1c <HAL_RCC_ClockConfig+0x100>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800bd08:	f7fe fe22 	bl	800a950 <HAL_GetTick>
 800bd0c:	0002      	movs	r2, r0
 800bd0e:	68fb      	ldr	r3, [r7, #12]
 800bd10:	1ad3      	subs	r3, r2, r3
 800bd12:	4a52      	ldr	r2, [pc, #328]	; (800be5c <HAL_RCC_ClockConfig+0x240>)
 800bd14:	4293      	cmp	r3, r2
 800bd16:	d901      	bls.n	800bd1c <HAL_RCC_ClockConfig+0x100>
        {
          return HAL_TIMEOUT;
 800bd18:	2303      	movs	r3, #3
 800bd1a:	e097      	b.n	800be4c <HAL_RCC_ClockConfig+0x230>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800bd1c:	4b4e      	ldr	r3, [pc, #312]	; (800be58 <HAL_RCC_ClockConfig+0x23c>)
 800bd1e:	68db      	ldr	r3, [r3, #12]
 800bd20:	220c      	movs	r2, #12
 800bd22:	4013      	ands	r3, r2
 800bd24:	2b08      	cmp	r3, #8
 800bd26:	d1ef      	bne.n	800bd08 <HAL_RCC_ClockConfig+0xec>
 800bd28:	e03a      	b.n	800bda0 <HAL_RCC_ClockConfig+0x184>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800bd2a:	687b      	ldr	r3, [r7, #4]
 800bd2c:	685b      	ldr	r3, [r3, #4]
 800bd2e:	2b03      	cmp	r3, #3
 800bd30:	d111      	bne.n	800bd56 <HAL_RCC_ClockConfig+0x13a>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800bd32:	e009      	b.n	800bd48 <HAL_RCC_ClockConfig+0x12c>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800bd34:	f7fe fe0c 	bl	800a950 <HAL_GetTick>
 800bd38:	0002      	movs	r2, r0
 800bd3a:	68fb      	ldr	r3, [r7, #12]
 800bd3c:	1ad3      	subs	r3, r2, r3
 800bd3e:	4a47      	ldr	r2, [pc, #284]	; (800be5c <HAL_RCC_ClockConfig+0x240>)
 800bd40:	4293      	cmp	r3, r2
 800bd42:	d901      	bls.n	800bd48 <HAL_RCC_ClockConfig+0x12c>
        {
          return HAL_TIMEOUT;
 800bd44:	2303      	movs	r3, #3
 800bd46:	e081      	b.n	800be4c <HAL_RCC_ClockConfig+0x230>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800bd48:	4b43      	ldr	r3, [pc, #268]	; (800be58 <HAL_RCC_ClockConfig+0x23c>)
 800bd4a:	68db      	ldr	r3, [r3, #12]
 800bd4c:	220c      	movs	r2, #12
 800bd4e:	4013      	ands	r3, r2
 800bd50:	2b0c      	cmp	r3, #12
 800bd52:	d1ef      	bne.n	800bd34 <HAL_RCC_ClockConfig+0x118>
 800bd54:	e024      	b.n	800bda0 <HAL_RCC_ClockConfig+0x184>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 800bd56:	687b      	ldr	r3, [r7, #4]
 800bd58:	685b      	ldr	r3, [r3, #4]
 800bd5a:	2b01      	cmp	r3, #1
 800bd5c:	d11b      	bne.n	800bd96 <HAL_RCC_ClockConfig+0x17a>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800bd5e:	e009      	b.n	800bd74 <HAL_RCC_ClockConfig+0x158>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800bd60:	f7fe fdf6 	bl	800a950 <HAL_GetTick>
 800bd64:	0002      	movs	r2, r0
 800bd66:	68fb      	ldr	r3, [r7, #12]
 800bd68:	1ad3      	subs	r3, r2, r3
 800bd6a:	4a3c      	ldr	r2, [pc, #240]	; (800be5c <HAL_RCC_ClockConfig+0x240>)
 800bd6c:	4293      	cmp	r3, r2
 800bd6e:	d901      	bls.n	800bd74 <HAL_RCC_ClockConfig+0x158>
        {
          return HAL_TIMEOUT;
 800bd70:	2303      	movs	r3, #3
 800bd72:	e06b      	b.n	800be4c <HAL_RCC_ClockConfig+0x230>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800bd74:	4b38      	ldr	r3, [pc, #224]	; (800be58 <HAL_RCC_ClockConfig+0x23c>)
 800bd76:	68db      	ldr	r3, [r3, #12]
 800bd78:	220c      	movs	r2, #12
 800bd7a:	4013      	ands	r3, r2
 800bd7c:	2b04      	cmp	r3, #4
 800bd7e:	d1ef      	bne.n	800bd60 <HAL_RCC_ClockConfig+0x144>
 800bd80:	e00e      	b.n	800bda0 <HAL_RCC_ClockConfig+0x184>
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800bd82:	f7fe fde5 	bl	800a950 <HAL_GetTick>
 800bd86:	0002      	movs	r2, r0
 800bd88:	68fb      	ldr	r3, [r7, #12]
 800bd8a:	1ad3      	subs	r3, r2, r3
 800bd8c:	4a33      	ldr	r2, [pc, #204]	; (800be5c <HAL_RCC_ClockConfig+0x240>)
 800bd8e:	4293      	cmp	r3, r2
 800bd90:	d901      	bls.n	800bd96 <HAL_RCC_ClockConfig+0x17a>
        {
          return HAL_TIMEOUT;
 800bd92:	2303      	movs	r3, #3
 800bd94:	e05a      	b.n	800be4c <HAL_RCC_ClockConfig+0x230>
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 800bd96:	4b30      	ldr	r3, [pc, #192]	; (800be58 <HAL_RCC_ClockConfig+0x23c>)
 800bd98:	68db      	ldr	r3, [r3, #12]
 800bd9a:	220c      	movs	r2, #12
 800bd9c:	4013      	ands	r3, r2
 800bd9e:	d1f0      	bne.n	800bd82 <HAL_RCC_ClockConfig+0x166>
        }
      }
    }
  }
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 800bda0:	4b2c      	ldr	r3, [pc, #176]	; (800be54 <HAL_RCC_ClockConfig+0x238>)
 800bda2:	681b      	ldr	r3, [r3, #0]
 800bda4:	2201      	movs	r2, #1
 800bda6:	4013      	ands	r3, r2
 800bda8:	683a      	ldr	r2, [r7, #0]
 800bdaa:	429a      	cmp	r2, r3
 800bdac:	d211      	bcs.n	800bdd2 <HAL_RCC_ClockConfig+0x1b6>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800bdae:	4b29      	ldr	r3, [pc, #164]	; (800be54 <HAL_RCC_ClockConfig+0x238>)
 800bdb0:	681b      	ldr	r3, [r3, #0]
 800bdb2:	2201      	movs	r2, #1
 800bdb4:	4393      	bics	r3, r2
 800bdb6:	0019      	movs	r1, r3
 800bdb8:	4b26      	ldr	r3, [pc, #152]	; (800be54 <HAL_RCC_ClockConfig+0x238>)
 800bdba:	683a      	ldr	r2, [r7, #0]
 800bdbc:	430a      	orrs	r2, r1
 800bdbe:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800bdc0:	4b24      	ldr	r3, [pc, #144]	; (800be54 <HAL_RCC_ClockConfig+0x238>)
 800bdc2:	681b      	ldr	r3, [r3, #0]
 800bdc4:	2201      	movs	r2, #1
 800bdc6:	4013      	ands	r3, r2
 800bdc8:	683a      	ldr	r2, [r7, #0]
 800bdca:	429a      	cmp	r2, r3
 800bdcc:	d001      	beq.n	800bdd2 <HAL_RCC_ClockConfig+0x1b6>
    {
      return HAL_ERROR;
 800bdce:	2301      	movs	r3, #1
 800bdd0:	e03c      	b.n	800be4c <HAL_RCC_ClockConfig+0x230>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800bdd2:	687b      	ldr	r3, [r7, #4]
 800bdd4:	681b      	ldr	r3, [r3, #0]
 800bdd6:	2204      	movs	r2, #4
 800bdd8:	4013      	ands	r3, r2
 800bdda:	d009      	beq.n	800bdf0 <HAL_RCC_ClockConfig+0x1d4>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800bddc:	4b1e      	ldr	r3, [pc, #120]	; (800be58 <HAL_RCC_ClockConfig+0x23c>)
 800bdde:	68db      	ldr	r3, [r3, #12]
 800bde0:	4a1f      	ldr	r2, [pc, #124]	; (800be60 <HAL_RCC_ClockConfig+0x244>)
 800bde2:	4013      	ands	r3, r2
 800bde4:	0019      	movs	r1, r3
 800bde6:	687b      	ldr	r3, [r7, #4]
 800bde8:	68da      	ldr	r2, [r3, #12]
 800bdea:	4b1b      	ldr	r3, [pc, #108]	; (800be58 <HAL_RCC_ClockConfig+0x23c>)
 800bdec:	430a      	orrs	r2, r1
 800bdee:	60da      	str	r2, [r3, #12]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800bdf0:	687b      	ldr	r3, [r7, #4]
 800bdf2:	681b      	ldr	r3, [r3, #0]
 800bdf4:	2208      	movs	r2, #8
 800bdf6:	4013      	ands	r3, r2
 800bdf8:	d00a      	beq.n	800be10 <HAL_RCC_ClockConfig+0x1f4>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 800bdfa:	4b17      	ldr	r3, [pc, #92]	; (800be58 <HAL_RCC_ClockConfig+0x23c>)
 800bdfc:	68db      	ldr	r3, [r3, #12]
 800bdfe:	4a19      	ldr	r2, [pc, #100]	; (800be64 <HAL_RCC_ClockConfig+0x248>)
 800be00:	4013      	ands	r3, r2
 800be02:	0019      	movs	r1, r3
 800be04:	687b      	ldr	r3, [r7, #4]
 800be06:	691b      	ldr	r3, [r3, #16]
 800be08:	00da      	lsls	r2, r3, #3
 800be0a:	4b13      	ldr	r3, [pc, #76]	; (800be58 <HAL_RCC_ClockConfig+0x23c>)
 800be0c:	430a      	orrs	r2, r1
 800be0e:	60da      	str	r2, [r3, #12]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 800be10:	f000 f82e 	bl	800be70 <HAL_RCC_GetSysClockFreq>
 800be14:	0001      	movs	r1, r0
 800be16:	4b10      	ldr	r3, [pc, #64]	; (800be58 <HAL_RCC_ClockConfig+0x23c>)
 800be18:	68db      	ldr	r3, [r3, #12]
 800be1a:	091b      	lsrs	r3, r3, #4
 800be1c:	220f      	movs	r2, #15
 800be1e:	4013      	ands	r3, r2
 800be20:	4a11      	ldr	r2, [pc, #68]	; (800be68 <HAL_RCC_ClockConfig+0x24c>)
 800be22:	5cd3      	ldrb	r3, [r2, r3]
 800be24:	000a      	movs	r2, r1
 800be26:	40da      	lsrs	r2, r3
 800be28:	4b10      	ldr	r3, [pc, #64]	; (800be6c <HAL_RCC_ClockConfig+0x250>)
 800be2a:	601a      	str	r2, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(TICK_INT_PRIORITY);
 800be2c:	250b      	movs	r5, #11
 800be2e:	197c      	adds	r4, r7, r5
 800be30:	2000      	movs	r0, #0
 800be32:	f7fe fd57 	bl	800a8e4 <HAL_InitTick>
 800be36:	0003      	movs	r3, r0
 800be38:	7023      	strb	r3, [r4, #0]
  if(status != HAL_OK)
 800be3a:	197b      	adds	r3, r7, r5
 800be3c:	781b      	ldrb	r3, [r3, #0]
 800be3e:	2b00      	cmp	r3, #0
 800be40:	d003      	beq.n	800be4a <HAL_RCC_ClockConfig+0x22e>
  {
    return status;
 800be42:	230b      	movs	r3, #11
 800be44:	18fb      	adds	r3, r7, r3
 800be46:	781b      	ldrb	r3, [r3, #0]
 800be48:	e000      	b.n	800be4c <HAL_RCC_ClockConfig+0x230>
  }

  return HAL_OK;
 800be4a:	2300      	movs	r3, #0
}
 800be4c:	0018      	movs	r0, r3
 800be4e:	46bd      	mov	sp, r7
 800be50:	b004      	add	sp, #16
 800be52:	bdb0      	pop	{r4, r5, r7, pc}
 800be54:	40022000 	.word	0x40022000
 800be58:	40021000 	.word	0x40021000
 800be5c:	00001388 	.word	0x00001388
 800be60:	fffff8ff 	.word	0xfffff8ff
 800be64:	ffffc7ff 	.word	0xffffc7ff
 800be68:	0800e6ac 	.word	0x0800e6ac
 800be6c:	20000000 	.word	0x20000000

0800be70 <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800be70:	b580      	push	{r7, lr}
 800be72:	b086      	sub	sp, #24
 800be74:	af00      	add	r7, sp, #0
  uint32_t tmpreg, pllm, plld, pllvco, msiclkrange;    /* no init needed */
  uint32_t sysclockfreq;

  tmpreg = RCC->CFGR;
 800be76:	4b3b      	ldr	r3, [pc, #236]	; (800bf64 <HAL_RCC_GetSysClockFreq+0xf4>)
 800be78:	68db      	ldr	r3, [r3, #12]
 800be7a:	60fb      	str	r3, [r7, #12]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 800be7c:	68fb      	ldr	r3, [r7, #12]
 800be7e:	220c      	movs	r2, #12
 800be80:	4013      	ands	r3, r2
 800be82:	2b08      	cmp	r3, #8
 800be84:	d00e      	beq.n	800bea4 <HAL_RCC_GetSysClockFreq+0x34>
 800be86:	2b0c      	cmp	r3, #12
 800be88:	d00f      	beq.n	800beaa <HAL_RCC_GetSysClockFreq+0x3a>
 800be8a:	2b04      	cmp	r3, #4
 800be8c:	d157      	bne.n	800bf3e <HAL_RCC_GetSysClockFreq+0xce>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      if ((RCC->CR & RCC_CR_HSIDIVF) != 0U)
 800be8e:	4b35      	ldr	r3, [pc, #212]	; (800bf64 <HAL_RCC_GetSysClockFreq+0xf4>)
 800be90:	681b      	ldr	r3, [r3, #0]
 800be92:	2210      	movs	r2, #16
 800be94:	4013      	ands	r3, r2
 800be96:	d002      	beq.n	800be9e <HAL_RCC_GetSysClockFreq+0x2e>
      {
        sysclockfreq =  (HSI_VALUE >> 2);
 800be98:	4b33      	ldr	r3, [pc, #204]	; (800bf68 <HAL_RCC_GetSysClockFreq+0xf8>)
 800be9a:	613b      	str	r3, [r7, #16]
      }
      else
      {
        sysclockfreq =  HSI_VALUE;
      }
      break;
 800be9c:	e05d      	b.n	800bf5a <HAL_RCC_GetSysClockFreq+0xea>
        sysclockfreq =  HSI_VALUE;
 800be9e:	4b33      	ldr	r3, [pc, #204]	; (800bf6c <HAL_RCC_GetSysClockFreq+0xfc>)
 800bea0:	613b      	str	r3, [r7, #16]
      break;
 800bea2:	e05a      	b.n	800bf5a <HAL_RCC_GetSysClockFreq+0xea>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 800bea4:	4b32      	ldr	r3, [pc, #200]	; (800bf70 <HAL_RCC_GetSysClockFreq+0x100>)
 800bea6:	613b      	str	r3, [r7, #16]
      break;
 800bea8:	e057      	b.n	800bf5a <HAL_RCC_GetSysClockFreq+0xea>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllm = PLLMulTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_Pos];
 800beaa:	68fb      	ldr	r3, [r7, #12]
 800beac:	0c9b      	lsrs	r3, r3, #18
 800beae:	220f      	movs	r2, #15
 800beb0:	4013      	ands	r3, r2
 800beb2:	4a30      	ldr	r2, [pc, #192]	; (800bf74 <HAL_RCC_GetSysClockFreq+0x104>)
 800beb4:	5cd3      	ldrb	r3, [r2, r3]
 800beb6:	60bb      	str	r3, [r7, #8]
      plld = ((uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> RCC_CFGR_PLLDIV_Pos) + 1U;
 800beb8:	68fb      	ldr	r3, [r7, #12]
 800beba:	0d9b      	lsrs	r3, r3, #22
 800bebc:	2203      	movs	r2, #3
 800bebe:	4013      	ands	r3, r2
 800bec0:	3301      	adds	r3, #1
 800bec2:	607b      	str	r3, [r7, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 800bec4:	4b27      	ldr	r3, [pc, #156]	; (800bf64 <HAL_RCC_GetSysClockFreq+0xf4>)
 800bec6:	68da      	ldr	r2, [r3, #12]
 800bec8:	2380      	movs	r3, #128	; 0x80
 800beca:	025b      	lsls	r3, r3, #9
 800becc:	4013      	ands	r3, r2
 800bece:	d00f      	beq.n	800bef0 <HAL_RCC_GetSysClockFreq+0x80>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE * pllm) / plld;
 800bed0:	68b9      	ldr	r1, [r7, #8]
 800bed2:	000a      	movs	r2, r1
 800bed4:	0152      	lsls	r2, r2, #5
 800bed6:	1a52      	subs	r2, r2, r1
 800bed8:	0193      	lsls	r3, r2, #6
 800beda:	1a9b      	subs	r3, r3, r2
 800bedc:	00db      	lsls	r3, r3, #3
 800bede:	185b      	adds	r3, r3, r1
 800bee0:	025b      	lsls	r3, r3, #9
 800bee2:	6879      	ldr	r1, [r7, #4]
 800bee4:	0018      	movs	r0, r3
 800bee6:	f7f4 f90f 	bl	8000108 <__udivsi3>
 800beea:	0003      	movs	r3, r0
 800beec:	617b      	str	r3, [r7, #20]
 800beee:	e023      	b.n	800bf38 <HAL_RCC_GetSysClockFreq+0xc8>
      }
      else
      {
        if ((RCC->CR & RCC_CR_HSIDIVF) != 0U)
 800bef0:	4b1c      	ldr	r3, [pc, #112]	; (800bf64 <HAL_RCC_GetSysClockFreq+0xf4>)
 800bef2:	681b      	ldr	r3, [r3, #0]
 800bef4:	2210      	movs	r2, #16
 800bef6:	4013      	ands	r3, r2
 800bef8:	d00f      	beq.n	800bf1a <HAL_RCC_GetSysClockFreq+0xaa>
        {
          pllvco = ((HSI_VALUE >> 2) * pllm) / plld;
 800befa:	68b9      	ldr	r1, [r7, #8]
 800befc:	000a      	movs	r2, r1
 800befe:	0152      	lsls	r2, r2, #5
 800bf00:	1a52      	subs	r2, r2, r1
 800bf02:	0193      	lsls	r3, r2, #6
 800bf04:	1a9b      	subs	r3, r3, r2
 800bf06:	00db      	lsls	r3, r3, #3
 800bf08:	185b      	adds	r3, r3, r1
 800bf0a:	021b      	lsls	r3, r3, #8
 800bf0c:	6879      	ldr	r1, [r7, #4]
 800bf0e:	0018      	movs	r0, r3
 800bf10:	f7f4 f8fa 	bl	8000108 <__udivsi3>
 800bf14:	0003      	movs	r3, r0
 800bf16:	617b      	str	r3, [r7, #20]
 800bf18:	e00e      	b.n	800bf38 <HAL_RCC_GetSysClockFreq+0xc8>
        }
        else
        {
         pllvco = (HSI_VALUE * pllm) / plld;
 800bf1a:	68b9      	ldr	r1, [r7, #8]
 800bf1c:	000a      	movs	r2, r1
 800bf1e:	0152      	lsls	r2, r2, #5
 800bf20:	1a52      	subs	r2, r2, r1
 800bf22:	0193      	lsls	r3, r2, #6
 800bf24:	1a9b      	subs	r3, r3, r2
 800bf26:	00db      	lsls	r3, r3, #3
 800bf28:	185b      	adds	r3, r3, r1
 800bf2a:	029b      	lsls	r3, r3, #10
 800bf2c:	6879      	ldr	r1, [r7, #4]
 800bf2e:	0018      	movs	r0, r3
 800bf30:	f7f4 f8ea 	bl	8000108 <__udivsi3>
 800bf34:	0003      	movs	r3, r0
 800bf36:	617b      	str	r3, [r7, #20]
        }
      }
      sysclockfreq = pllvco;
 800bf38:	697b      	ldr	r3, [r7, #20]
 800bf3a:	613b      	str	r3, [r7, #16]
      break;
 800bf3c:	e00d      	b.n	800bf5a <HAL_RCC_GetSysClockFreq+0xea>
    }
    case RCC_SYSCLKSOURCE_STATUS_MSI:  /* MSI used as system clock source */
    default: /* MSI used as system clock */
    {
      msiclkrange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> RCC_ICSCR_MSIRANGE_Pos;
 800bf3e:	4b09      	ldr	r3, [pc, #36]	; (800bf64 <HAL_RCC_GetSysClockFreq+0xf4>)
 800bf40:	685b      	ldr	r3, [r3, #4]
 800bf42:	0b5b      	lsrs	r3, r3, #13
 800bf44:	2207      	movs	r2, #7
 800bf46:	4013      	ands	r3, r2
 800bf48:	603b      	str	r3, [r7, #0]
      sysclockfreq = (32768U * (1UL << (msiclkrange + 1U)));
 800bf4a:	683b      	ldr	r3, [r7, #0]
 800bf4c:	3301      	adds	r3, #1
 800bf4e:	2280      	movs	r2, #128	; 0x80
 800bf50:	0212      	lsls	r2, r2, #8
 800bf52:	409a      	lsls	r2, r3
 800bf54:	0013      	movs	r3, r2
 800bf56:	613b      	str	r3, [r7, #16]
      break;
 800bf58:	46c0      	nop			; (mov r8, r8)
    }
  }
  return sysclockfreq;
 800bf5a:	693b      	ldr	r3, [r7, #16]
}
 800bf5c:	0018      	movs	r0, r3
 800bf5e:	46bd      	mov	sp, r7
 800bf60:	b006      	add	sp, #24
 800bf62:	bd80      	pop	{r7, pc}
 800bf64:	40021000 	.word	0x40021000
 800bf68:	003d0900 	.word	0x003d0900
 800bf6c:	00f42400 	.word	0x00f42400
 800bf70:	007a1200 	.word	0x007a1200
 800bf74:	0800e6c4 	.word	0x0800e6c4

0800bf78 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800bf78:	b580      	push	{r7, lr}
 800bf7a:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 800bf7c:	4b02      	ldr	r3, [pc, #8]	; (800bf88 <HAL_RCC_GetHCLKFreq+0x10>)
 800bf7e:	681b      	ldr	r3, [r3, #0]
}
 800bf80:	0018      	movs	r0, r3
 800bf82:	46bd      	mov	sp, r7
 800bf84:	bd80      	pop	{r7, pc}
 800bf86:	46c0      	nop			; (mov r8, r8)
 800bf88:	20000000 	.word	0x20000000

0800bf8c <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800bf8c:	b580      	push	{r7, lr}
 800bf8e:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 800bf90:	f7ff fff2 	bl	800bf78 <HAL_RCC_GetHCLKFreq>
 800bf94:	0001      	movs	r1, r0
 800bf96:	4b06      	ldr	r3, [pc, #24]	; (800bfb0 <HAL_RCC_GetPCLK1Freq+0x24>)
 800bf98:	68db      	ldr	r3, [r3, #12]
 800bf9a:	0a1b      	lsrs	r3, r3, #8
 800bf9c:	2207      	movs	r2, #7
 800bf9e:	4013      	ands	r3, r2
 800bfa0:	4a04      	ldr	r2, [pc, #16]	; (800bfb4 <HAL_RCC_GetPCLK1Freq+0x28>)
 800bfa2:	5cd3      	ldrb	r3, [r2, r3]
 800bfa4:	40d9      	lsrs	r1, r3
 800bfa6:	000b      	movs	r3, r1
}
 800bfa8:	0018      	movs	r0, r3
 800bfaa:	46bd      	mov	sp, r7
 800bfac:	bd80      	pop	{r7, pc}
 800bfae:	46c0      	nop			; (mov r8, r8)
 800bfb0:	40021000 	.word	0x40021000
 800bfb4:	0800e6bc 	.word	0x0800e6bc

0800bfb8 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800bfb8:	b580      	push	{r7, lr}
 800bfba:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 800bfbc:	f7ff ffdc 	bl	800bf78 <HAL_RCC_GetHCLKFreq>
 800bfc0:	0001      	movs	r1, r0
 800bfc2:	4b06      	ldr	r3, [pc, #24]	; (800bfdc <HAL_RCC_GetPCLK2Freq+0x24>)
 800bfc4:	68db      	ldr	r3, [r3, #12]
 800bfc6:	0adb      	lsrs	r3, r3, #11
 800bfc8:	2207      	movs	r2, #7
 800bfca:	4013      	ands	r3, r2
 800bfcc:	4a04      	ldr	r2, [pc, #16]	; (800bfe0 <HAL_RCC_GetPCLK2Freq+0x28>)
 800bfce:	5cd3      	ldrb	r3, [r2, r3]
 800bfd0:	40d9      	lsrs	r1, r3
 800bfd2:	000b      	movs	r3, r1
}
 800bfd4:	0018      	movs	r0, r3
 800bfd6:	46bd      	mov	sp, r7
 800bfd8:	bd80      	pop	{r7, pc}
 800bfda:	46c0      	nop			; (mov r8, r8)
 800bfdc:	40021000 	.word	0x40021000
 800bfe0:	0800e6bc 	.word	0x0800e6bc

0800bfe4 <HAL_RCCEx_PeriphCLKConfig>:
  * @retval HAL status
  * @note   If HAL_ERROR returned, first switch-OFF HSE clock oscillator with @ref HAL_RCC_OscConfig()
  *         to possibly update HSE divider.
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 800bfe4:	b580      	push	{r7, lr}
 800bfe6:	b086      	sub	sp, #24
 800bfe8:	af00      	add	r7, sp, #0
 800bfea:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*------------------------------- RTC/LCD Configuration ------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 800bfec:	687b      	ldr	r3, [r7, #4]
 800bfee:	681b      	ldr	r3, [r3, #0]
 800bff0:	2220      	movs	r2, #32
 800bff2:	4013      	ands	r3, r2
 800bff4:	d106      	bne.n	800c004 <HAL_RCCEx_PeriphCLKConfig+0x20>
#if defined(LCD)
   || (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD)
 800bff6:	687b      	ldr	r3, [r7, #4]
 800bff8:	681a      	ldr	r2, [r3, #0]
 800bffa:	2380      	movs	r3, #128	; 0x80
 800bffc:	011b      	lsls	r3, r3, #4
 800bffe:	4013      	ands	r3, r2
 800c000:	d100      	bne.n	800c004 <HAL_RCCEx_PeriphCLKConfig+0x20>
 800c002:	e0dd      	b.n	800c1c0 <HAL_RCCEx_PeriphCLKConfig+0x1dc>
    {
      assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->LCDClockSelection));
    }
#endif /* LCD */

    FlagStatus       pwrclkchanged = RESET;
 800c004:	2317      	movs	r3, #23
 800c006:	18fb      	adds	r3, r7, r3
 800c008:	2200      	movs	r2, #0
 800c00a:	701a      	strb	r2, [r3, #0]

    /* As soon as function is called to change RTC clock source, activation of the
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800c00c:	4ba4      	ldr	r3, [pc, #656]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c00e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800c010:	2380      	movs	r3, #128	; 0x80
 800c012:	055b      	lsls	r3, r3, #21
 800c014:	4013      	ands	r3, r2
 800c016:	d10a      	bne.n	800c02e <HAL_RCCEx_PeriphCLKConfig+0x4a>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800c018:	4ba1      	ldr	r3, [pc, #644]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c01a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800c01c:	4ba0      	ldr	r3, [pc, #640]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c01e:	2180      	movs	r1, #128	; 0x80
 800c020:	0549      	lsls	r1, r1, #21
 800c022:	430a      	orrs	r2, r1
 800c024:	639a      	str	r2, [r3, #56]	; 0x38
      pwrclkchanged = SET;
 800c026:	2317      	movs	r3, #23
 800c028:	18fb      	adds	r3, r7, r3
 800c02a:	2201      	movs	r2, #1
 800c02c:	701a      	strb	r2, [r3, #0]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800c02e:	4b9d      	ldr	r3, [pc, #628]	; (800c2a4 <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 800c030:	681a      	ldr	r2, [r3, #0]
 800c032:	2380      	movs	r3, #128	; 0x80
 800c034:	005b      	lsls	r3, r3, #1
 800c036:	4013      	ands	r3, r2
 800c038:	d11a      	bne.n	800c070 <HAL_RCCEx_PeriphCLKConfig+0x8c>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800c03a:	4b9a      	ldr	r3, [pc, #616]	; (800c2a4 <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 800c03c:	681a      	ldr	r2, [r3, #0]
 800c03e:	4b99      	ldr	r3, [pc, #612]	; (800c2a4 <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 800c040:	2180      	movs	r1, #128	; 0x80
 800c042:	0049      	lsls	r1, r1, #1
 800c044:	430a      	orrs	r2, r1
 800c046:	601a      	str	r2, [r3, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800c048:	f7fe fc82 	bl	800a950 <HAL_GetTick>
 800c04c:	0003      	movs	r3, r0
 800c04e:	613b      	str	r3, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800c050:	e008      	b.n	800c064 <HAL_RCCEx_PeriphCLKConfig+0x80>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800c052:	f7fe fc7d 	bl	800a950 <HAL_GetTick>
 800c056:	0002      	movs	r2, r0
 800c058:	693b      	ldr	r3, [r7, #16]
 800c05a:	1ad3      	subs	r3, r2, r3
 800c05c:	2b64      	cmp	r3, #100	; 0x64
 800c05e:	d901      	bls.n	800c064 <HAL_RCCEx_PeriphCLKConfig+0x80>
        {
          return HAL_TIMEOUT;
 800c060:	2303      	movs	r3, #3
 800c062:	e118      	b.n	800c296 <HAL_RCCEx_PeriphCLKConfig+0x2b2>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800c064:	4b8f      	ldr	r3, [pc, #572]	; (800c2a4 <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 800c066:	681a      	ldr	r2, [r3, #0]
 800c068:	2380      	movs	r3, #128	; 0x80
 800c06a:	005b      	lsls	r3, r3, #1
 800c06c:	4013      	ands	r3, r2
 800c06e:	d0f0      	beq.n	800c052 <HAL_RCCEx_PeriphCLKConfig+0x6e>
        }
      }
    }

    /* Check if user wants to change HSE RTC prescaler whereas HSE is enabled */
    temp_reg = (RCC->CR & RCC_CR_RTCPRE);
 800c070:	4b8b      	ldr	r3, [pc, #556]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c072:	681a      	ldr	r2, [r3, #0]
 800c074:	23c0      	movs	r3, #192	; 0xc0
 800c076:	039b      	lsls	r3, r3, #14
 800c078:	4013      	ands	r3, r2
 800c07a:	60fb      	str	r3, [r7, #12]
    if ((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CR_RTCPRE))
 800c07c:	687b      	ldr	r3, [r7, #4]
 800c07e:	685a      	ldr	r2, [r3, #4]
 800c080:	23c0      	movs	r3, #192	; 0xc0
 800c082:	039b      	lsls	r3, r3, #14
 800c084:	4013      	ands	r3, r2
 800c086:	68fa      	ldr	r2, [r7, #12]
 800c088:	429a      	cmp	r2, r3
 800c08a:	d107      	bne.n	800c09c <HAL_RCCEx_PeriphCLKConfig+0xb8>
#if defined (LCD)
     || (temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CR_RTCPRE))
 800c08c:	687b      	ldr	r3, [r7, #4]
 800c08e:	689a      	ldr	r2, [r3, #8]
 800c090:	23c0      	movs	r3, #192	; 0xc0
 800c092:	039b      	lsls	r3, r3, #14
 800c094:	4013      	ands	r3, r2
 800c096:	68fa      	ldr	r2, [r7, #12]
 800c098:	429a      	cmp	r2, r3
 800c09a:	d013      	beq.n	800c0c4 <HAL_RCCEx_PeriphCLKConfig+0xe0>
#endif /* LCD */
       )
    { /* Check HSE State */
      if ((PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL) == RCC_CSR_RTCSEL_HSE)
 800c09c:	687b      	ldr	r3, [r7, #4]
 800c09e:	685a      	ldr	r2, [r3, #4]
 800c0a0:	23c0      	movs	r3, #192	; 0xc0
 800c0a2:	029b      	lsls	r3, r3, #10
 800c0a4:	401a      	ands	r2, r3
 800c0a6:	23c0      	movs	r3, #192	; 0xc0
 800c0a8:	029b      	lsls	r3, r3, #10
 800c0aa:	429a      	cmp	r2, r3
 800c0ac:	d10a      	bne.n	800c0c4 <HAL_RCCEx_PeriphCLKConfig+0xe0>
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 800c0ae:	4b7c      	ldr	r3, [pc, #496]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c0b0:	681a      	ldr	r2, [r3, #0]
 800c0b2:	2380      	movs	r3, #128	; 0x80
 800c0b4:	029b      	lsls	r3, r3, #10
 800c0b6:	401a      	ands	r2, r3
 800c0b8:	2380      	movs	r3, #128	; 0x80
 800c0ba:	029b      	lsls	r3, r3, #10
 800c0bc:	429a      	cmp	r2, r3
 800c0be:	d101      	bne.n	800c0c4 <HAL_RCCEx_PeriphCLKConfig+0xe0>
        {
          /* To update HSE divider, first switch-OFF HSE clock oscillator*/
          return HAL_ERROR;
 800c0c0:	2301      	movs	r3, #1
 800c0c2:	e0e8      	b.n	800c296 <HAL_RCCEx_PeriphCLKConfig+0x2b2>
        }
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    temp_reg = (RCC->CSR & RCC_CSR_RTCSEL);
 800c0c4:	4b76      	ldr	r3, [pc, #472]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c0c6:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800c0c8:	23c0      	movs	r3, #192	; 0xc0
 800c0ca:	029b      	lsls	r3, r3, #10
 800c0cc:	4013      	ands	r3, r2
 800c0ce:	60fb      	str	r3, [r7, #12]

    if((temp_reg != 0x00000000U) && (((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL)) \
 800c0d0:	68fb      	ldr	r3, [r7, #12]
 800c0d2:	2b00      	cmp	r3, #0
 800c0d4:	d049      	beq.n	800c16a <HAL_RCCEx_PeriphCLKConfig+0x186>
 800c0d6:	687b      	ldr	r3, [r7, #4]
 800c0d8:	685a      	ldr	r2, [r3, #4]
 800c0da:	23c0      	movs	r3, #192	; 0xc0
 800c0dc:	029b      	lsls	r3, r3, #10
 800c0de:	4013      	ands	r3, r2
 800c0e0:	68fa      	ldr	r2, [r7, #12]
 800c0e2:	429a      	cmp	r2, r3
 800c0e4:	d004      	beq.n	800c0f0 <HAL_RCCEx_PeriphCLKConfig+0x10c>
      && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 800c0e6:	687b      	ldr	r3, [r7, #4]
 800c0e8:	681b      	ldr	r3, [r3, #0]
 800c0ea:	2220      	movs	r2, #32
 800c0ec:	4013      	ands	r3, r2
 800c0ee:	d10d      	bne.n	800c10c <HAL_RCCEx_PeriphCLKConfig+0x128>
#if defined(LCD)
      || ((temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CSR_RTCSEL)) \
 800c0f0:	687b      	ldr	r3, [r7, #4]
 800c0f2:	689a      	ldr	r2, [r3, #8]
 800c0f4:	23c0      	movs	r3, #192	; 0xc0
 800c0f6:	029b      	lsls	r3, r3, #10
 800c0f8:	4013      	ands	r3, r2
 800c0fa:	68fa      	ldr	r2, [r7, #12]
 800c0fc:	429a      	cmp	r2, r3
 800c0fe:	d034      	beq.n	800c16a <HAL_RCCEx_PeriphCLKConfig+0x186>
       && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD))
 800c100:	687b      	ldr	r3, [r7, #4]
 800c102:	681a      	ldr	r2, [r3, #0]
 800c104:	2380      	movs	r3, #128	; 0x80
 800c106:	011b      	lsls	r3, r3, #4
 800c108:	4013      	ands	r3, r2
 800c10a:	d02e      	beq.n	800c16a <HAL_RCCEx_PeriphCLKConfig+0x186>
#endif /* LCD */
     ))
    {
      /* Store the content of CSR register before the reset of Backup Domain */
      temp_reg = (RCC->CSR & ~(RCC_CSR_RTCSEL));
 800c10c:	4b64      	ldr	r3, [pc, #400]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c10e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800c110:	4a65      	ldr	r2, [pc, #404]	; (800c2a8 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800c112:	4013      	ands	r3, r2
 800c114:	60fb      	str	r3, [r7, #12]

      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 800c116:	4b62      	ldr	r3, [pc, #392]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c118:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800c11a:	4b61      	ldr	r3, [pc, #388]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c11c:	2180      	movs	r1, #128	; 0x80
 800c11e:	0309      	lsls	r1, r1, #12
 800c120:	430a      	orrs	r2, r1
 800c122:	651a      	str	r2, [r3, #80]	; 0x50
      __HAL_RCC_BACKUPRESET_RELEASE();
 800c124:	4b5e      	ldr	r3, [pc, #376]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c126:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800c128:	4b5d      	ldr	r3, [pc, #372]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c12a:	4960      	ldr	r1, [pc, #384]	; (800c2ac <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 800c12c:	400a      	ands	r2, r1
 800c12e:	651a      	str	r2, [r3, #80]	; 0x50

      /* Restore the Content of CSR register */
      RCC->CSR = temp_reg;
 800c130:	4b5b      	ldr	r3, [pc, #364]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c132:	68fa      	ldr	r2, [r7, #12]
 800c134:	651a      	str	r2, [r3, #80]	; 0x50

       /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSEON))
 800c136:	68fa      	ldr	r2, [r7, #12]
 800c138:	2380      	movs	r3, #128	; 0x80
 800c13a:	005b      	lsls	r3, r3, #1
 800c13c:	4013      	ands	r3, r2
 800c13e:	d014      	beq.n	800c16a <HAL_RCCEx_PeriphCLKConfig+0x186>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800c140:	f7fe fc06 	bl	800a950 <HAL_GetTick>
 800c144:	0003      	movs	r3, r0
 800c146:	613b      	str	r3, [r7, #16]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800c148:	e009      	b.n	800c15e <HAL_RCCEx_PeriphCLKConfig+0x17a>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800c14a:	f7fe fc01 	bl	800a950 <HAL_GetTick>
 800c14e:	0002      	movs	r2, r0
 800c150:	693b      	ldr	r3, [r7, #16]
 800c152:	1ad3      	subs	r3, r2, r3
 800c154:	4a56      	ldr	r2, [pc, #344]	; (800c2b0 <HAL_RCCEx_PeriphCLKConfig+0x2cc>)
 800c156:	4293      	cmp	r3, r2
 800c158:	d901      	bls.n	800c15e <HAL_RCCEx_PeriphCLKConfig+0x17a>
          {
            return HAL_TIMEOUT;
 800c15a:	2303      	movs	r3, #3
 800c15c:	e09b      	b.n	800c296 <HAL_RCCEx_PeriphCLKConfig+0x2b2>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800c15e:	4b50      	ldr	r3, [pc, #320]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c160:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800c162:	2380      	movs	r3, #128	; 0x80
 800c164:	009b      	lsls	r3, r3, #2
 800c166:	4013      	ands	r3, r2
 800c168:	d0ef      	beq.n	800c14a <HAL_RCCEx_PeriphCLKConfig+0x166>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800c16a:	687b      	ldr	r3, [r7, #4]
 800c16c:	685a      	ldr	r2, [r3, #4]
 800c16e:	23c0      	movs	r3, #192	; 0xc0
 800c170:	029b      	lsls	r3, r3, #10
 800c172:	401a      	ands	r2, r3
 800c174:	23c0      	movs	r3, #192	; 0xc0
 800c176:	029b      	lsls	r3, r3, #10
 800c178:	429a      	cmp	r2, r3
 800c17a:	d10c      	bne.n	800c196 <HAL_RCCEx_PeriphCLKConfig+0x1b2>
 800c17c:	4b48      	ldr	r3, [pc, #288]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c17e:	681b      	ldr	r3, [r3, #0]
 800c180:	4a4c      	ldr	r2, [pc, #304]	; (800c2b4 <HAL_RCCEx_PeriphCLKConfig+0x2d0>)
 800c182:	4013      	ands	r3, r2
 800c184:	0019      	movs	r1, r3
 800c186:	687b      	ldr	r3, [r7, #4]
 800c188:	685a      	ldr	r2, [r3, #4]
 800c18a:	23c0      	movs	r3, #192	; 0xc0
 800c18c:	039b      	lsls	r3, r3, #14
 800c18e:	401a      	ands	r2, r3
 800c190:	4b43      	ldr	r3, [pc, #268]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c192:	430a      	orrs	r2, r1
 800c194:	601a      	str	r2, [r3, #0]
 800c196:	4b42      	ldr	r3, [pc, #264]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c198:	6d19      	ldr	r1, [r3, #80]	; 0x50
 800c19a:	687b      	ldr	r3, [r7, #4]
 800c19c:	685a      	ldr	r2, [r3, #4]
 800c19e:	23c0      	movs	r3, #192	; 0xc0
 800c1a0:	029b      	lsls	r3, r3, #10
 800c1a2:	401a      	ands	r2, r3
 800c1a4:	4b3e      	ldr	r3, [pc, #248]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c1a6:	430a      	orrs	r2, r1
 800c1a8:	651a      	str	r2, [r3, #80]	; 0x50

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 800c1aa:	2317      	movs	r3, #23
 800c1ac:	18fb      	adds	r3, r7, r3
 800c1ae:	781b      	ldrb	r3, [r3, #0]
 800c1b0:	2b01      	cmp	r3, #1
 800c1b2:	d105      	bne.n	800c1c0 <HAL_RCCEx_PeriphCLKConfig+0x1dc>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800c1b4:	4b3a      	ldr	r3, [pc, #232]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c1b6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800c1b8:	4b39      	ldr	r3, [pc, #228]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c1ba:	493f      	ldr	r1, [pc, #252]	; (800c2b8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 800c1bc:	400a      	ands	r2, r1
 800c1be:	639a      	str	r2, [r3, #56]	; 0x38
    }
  }

#if defined (RCC_CCIPR_USART1SEL)
  /*------------------------------- USART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 800c1c0:	687b      	ldr	r3, [r7, #4]
 800c1c2:	681b      	ldr	r3, [r3, #0]
 800c1c4:	2201      	movs	r2, #1
 800c1c6:	4013      	ands	r3, r2
 800c1c8:	d009      	beq.n	800c1de <HAL_RCCEx_PeriphCLKConfig+0x1fa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800c1ca:	4b35      	ldr	r3, [pc, #212]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c1cc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800c1ce:	2203      	movs	r2, #3
 800c1d0:	4393      	bics	r3, r2
 800c1d2:	0019      	movs	r1, r3
 800c1d4:	687b      	ldr	r3, [r7, #4]
 800c1d6:	68da      	ldr	r2, [r3, #12]
 800c1d8:	4b31      	ldr	r3, [pc, #196]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c1da:	430a      	orrs	r2, r1
 800c1dc:	64da      	str	r2, [r3, #76]	; 0x4c
  }
#endif /* RCC_CCIPR_USART1SEL */

  /*----------------------------- USART2 Configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 800c1de:	687b      	ldr	r3, [r7, #4]
 800c1e0:	681b      	ldr	r3, [r3, #0]
 800c1e2:	2202      	movs	r2, #2
 800c1e4:	4013      	ands	r3, r2
 800c1e6:	d009      	beq.n	800c1fc <HAL_RCCEx_PeriphCLKConfig+0x218>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 800c1e8:	4b2d      	ldr	r3, [pc, #180]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c1ea:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800c1ec:	220c      	movs	r2, #12
 800c1ee:	4393      	bics	r3, r2
 800c1f0:	0019      	movs	r1, r3
 800c1f2:	687b      	ldr	r3, [r7, #4]
 800c1f4:	691a      	ldr	r2, [r3, #16]
 800c1f6:	4b2a      	ldr	r3, [pc, #168]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c1f8:	430a      	orrs	r2, r1
 800c1fa:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  /*------------------------------ LPUART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 800c1fc:	687b      	ldr	r3, [r7, #4]
 800c1fe:	681b      	ldr	r3, [r3, #0]
 800c200:	2204      	movs	r2, #4
 800c202:	4013      	ands	r3, r2
 800c204:	d009      	beq.n	800c21a <HAL_RCCEx_PeriphCLKConfig+0x236>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 800c206:	4b26      	ldr	r3, [pc, #152]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c208:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800c20a:	4a2c      	ldr	r2, [pc, #176]	; (800c2bc <HAL_RCCEx_PeriphCLKConfig+0x2d8>)
 800c20c:	4013      	ands	r3, r2
 800c20e:	0019      	movs	r1, r3
 800c210:	687b      	ldr	r3, [r7, #4]
 800c212:	695a      	ldr	r2, [r3, #20]
 800c214:	4b22      	ldr	r3, [pc, #136]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c216:	430a      	orrs	r2, r1
 800c218:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  /*------------------------------ I2C1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800c21a:	687b      	ldr	r3, [r7, #4]
 800c21c:	681b      	ldr	r3, [r3, #0]
 800c21e:	2208      	movs	r2, #8
 800c220:	4013      	ands	r3, r2
 800c222:	d009      	beq.n	800c238 <HAL_RCCEx_PeriphCLKConfig+0x254>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 800c224:	4b1e      	ldr	r3, [pc, #120]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c226:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800c228:	4a25      	ldr	r2, [pc, #148]	; (800c2c0 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 800c22a:	4013      	ands	r3, r2
 800c22c:	0019      	movs	r1, r3
 800c22e:	687b      	ldr	r3, [r7, #4]
 800c230:	699a      	ldr	r2, [r3, #24]
 800c232:	4b1b      	ldr	r3, [pc, #108]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c234:	430a      	orrs	r2, r1
 800c236:	64da      	str	r2, [r3, #76]	; 0x4c
  }

#if defined (RCC_CCIPR_I2C3SEL)
    /*------------------------------ I2C3 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 800c238:	687b      	ldr	r3, [r7, #4]
 800c23a:	681a      	ldr	r2, [r3, #0]
 800c23c:	2380      	movs	r3, #128	; 0x80
 800c23e:	005b      	lsls	r3, r3, #1
 800c240:	4013      	ands	r3, r2
 800c242:	d009      	beq.n	800c258 <HAL_RCCEx_PeriphCLKConfig+0x274>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 800c244:	4b16      	ldr	r3, [pc, #88]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c246:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800c248:	4a17      	ldr	r2, [pc, #92]	; (800c2a8 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800c24a:	4013      	ands	r3, r2
 800c24c:	0019      	movs	r1, r3
 800c24e:	687b      	ldr	r3, [r7, #4]
 800c250:	69da      	ldr	r2, [r3, #28]
 800c252:	4b13      	ldr	r3, [pc, #76]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c254:	430a      	orrs	r2, r1
 800c256:	64da      	str	r2, [r3, #76]	; 0x4c
  }
#endif /* RCC_CCIPR_I2C3SEL */

#if defined(USB)
 /*---------------------------- USB and RNG configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 800c258:	687b      	ldr	r3, [r7, #4]
 800c25a:	681b      	ldr	r3, [r3, #0]
 800c25c:	2240      	movs	r2, #64	; 0x40
 800c25e:	4013      	ands	r3, r2
 800c260:	d009      	beq.n	800c276 <HAL_RCCEx_PeriphCLKConfig+0x292>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800c262:	4b0f      	ldr	r3, [pc, #60]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c264:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800c266:	4a17      	ldr	r2, [pc, #92]	; (800c2c4 <HAL_RCCEx_PeriphCLKConfig+0x2e0>)
 800c268:	4013      	ands	r3, r2
 800c26a:	0019      	movs	r1, r3
 800c26c:	687b      	ldr	r3, [r7, #4]
 800c26e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800c270:	4b0b      	ldr	r3, [pc, #44]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c272:	430a      	orrs	r2, r1
 800c274:	64da      	str	r2, [r3, #76]	; 0x4c
  }
#endif /* USB */

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 800c276:	687b      	ldr	r3, [r7, #4]
 800c278:	681b      	ldr	r3, [r3, #0]
 800c27a:	2280      	movs	r2, #128	; 0x80
 800c27c:	4013      	ands	r3, r2
 800c27e:	d009      	beq.n	800c294 <HAL_RCCEx_PeriphCLKConfig+0x2b0>
  {
    assert_param(IS_RCC_LPTIMCLK(PeriphClkInit->LptimClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->LptimClockSelection);
 800c280:	4b07      	ldr	r3, [pc, #28]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c282:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800c284:	4a10      	ldr	r2, [pc, #64]	; (800c2c8 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 800c286:	4013      	ands	r3, r2
 800c288:	0019      	movs	r1, r3
 800c28a:	687b      	ldr	r3, [r7, #4]
 800c28c:	6a1a      	ldr	r2, [r3, #32]
 800c28e:	4b04      	ldr	r3, [pc, #16]	; (800c2a0 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 800c290:	430a      	orrs	r2, r1
 800c292:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  return HAL_OK;
 800c294:	2300      	movs	r3, #0
}
 800c296:	0018      	movs	r0, r3
 800c298:	46bd      	mov	sp, r7
 800c29a:	b006      	add	sp, #24
 800c29c:	bd80      	pop	{r7, pc}
 800c29e:	46c0      	nop			; (mov r8, r8)
 800c2a0:	40021000 	.word	0x40021000
 800c2a4:	40007000 	.word	0x40007000
 800c2a8:	fffcffff 	.word	0xfffcffff
 800c2ac:	fff7ffff 	.word	0xfff7ffff
 800c2b0:	00001388 	.word	0x00001388
 800c2b4:	ffcfffff 	.word	0xffcfffff
 800c2b8:	efffffff 	.word	0xefffffff
 800c2bc:	fffff3ff 	.word	0xfffff3ff
 800c2c0:	ffffcfff 	.word	0xffffcfff
 800c2c4:	fbffffff 	.word	0xfbffffff
 800c2c8:	fff3ffff 	.word	0xfff3ffff

0800c2cc <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 800c2cc:	b580      	push	{r7, lr}
 800c2ce:	b082      	sub	sp, #8
 800c2d0:	af00      	add	r7, sp, #0
 800c2d2:	6078      	str	r0, [r7, #4]
  /* Check the SPI handle allocation */
  if (hspi == NULL)
 800c2d4:	687b      	ldr	r3, [r7, #4]
 800c2d6:	2b00      	cmp	r3, #0
 800c2d8:	d101      	bne.n	800c2de <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 800c2da:	2301      	movs	r3, #1
 800c2dc:	e059      	b.n	800c392 <HAL_SPI_Init+0xc6>
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800c2de:	687b      	ldr	r3, [r7, #4]
 800c2e0:	2200      	movs	r2, #0
 800c2e2:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 800c2e4:	687b      	ldr	r3, [r7, #4]
 800c2e6:	2251      	movs	r2, #81	; 0x51
 800c2e8:	5c9b      	ldrb	r3, [r3, r2]
 800c2ea:	b2db      	uxtb	r3, r3
 800c2ec:	2b00      	cmp	r3, #0
 800c2ee:	d107      	bne.n	800c300 <HAL_SPI_Init+0x34>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 800c2f0:	687b      	ldr	r3, [r7, #4]
 800c2f2:	2250      	movs	r2, #80	; 0x50
 800c2f4:	2100      	movs	r1, #0
 800c2f6:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 800c2f8:	687b      	ldr	r3, [r7, #4]
 800c2fa:	0018      	movs	r0, r3
 800c2fc:	f7fe f950 	bl	800a5a0 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 800c300:	687b      	ldr	r3, [r7, #4]
 800c302:	2251      	movs	r2, #81	; 0x51
 800c304:	2102      	movs	r1, #2
 800c306:	5499      	strb	r1, [r3, r2]

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 800c308:	687b      	ldr	r3, [r7, #4]
 800c30a:	681b      	ldr	r3, [r3, #0]
 800c30c:	681a      	ldr	r2, [r3, #0]
 800c30e:	687b      	ldr	r3, [r7, #4]
 800c310:	681b      	ldr	r3, [r3, #0]
 800c312:	2140      	movs	r1, #64	; 0x40
 800c314:	438a      	bics	r2, r1
 800c316:	601a      	str	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 800c318:	687b      	ldr	r3, [r7, #4]
 800c31a:	685a      	ldr	r2, [r3, #4]
 800c31c:	687b      	ldr	r3, [r7, #4]
 800c31e:	689b      	ldr	r3, [r3, #8]
 800c320:	431a      	orrs	r2, r3
 800c322:	687b      	ldr	r3, [r7, #4]
 800c324:	68db      	ldr	r3, [r3, #12]
 800c326:	431a      	orrs	r2, r3
 800c328:	687b      	ldr	r3, [r7, #4]
 800c32a:	691b      	ldr	r3, [r3, #16]
 800c32c:	431a      	orrs	r2, r3
 800c32e:	687b      	ldr	r3, [r7, #4]
 800c330:	695b      	ldr	r3, [r3, #20]
 800c332:	431a      	orrs	r2, r3
 800c334:	687b      	ldr	r3, [r7, #4]
 800c336:	6999      	ldr	r1, [r3, #24]
 800c338:	2380      	movs	r3, #128	; 0x80
 800c33a:	009b      	lsls	r3, r3, #2
 800c33c:	400b      	ands	r3, r1
 800c33e:	431a      	orrs	r2, r3
 800c340:	687b      	ldr	r3, [r7, #4]
 800c342:	69db      	ldr	r3, [r3, #28]
 800c344:	431a      	orrs	r2, r3
 800c346:	687b      	ldr	r3, [r7, #4]
 800c348:	6a1b      	ldr	r3, [r3, #32]
 800c34a:	431a      	orrs	r2, r3
 800c34c:	0011      	movs	r1, r2
 800c34e:	687b      	ldr	r3, [r7, #4]
 800c350:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800c352:	687b      	ldr	r3, [r7, #4]
 800c354:	681b      	ldr	r3, [r3, #0]
 800c356:	430a      	orrs	r2, r1
 800c358:	601a      	str	r2, [r3, #0]
                                  hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                                  hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation));

  /* Configure : NSS management, TI Mode */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
 800c35a:	687b      	ldr	r3, [r7, #4]
 800c35c:	699b      	ldr	r3, [r3, #24]
 800c35e:	0c1b      	lsrs	r3, r3, #16
 800c360:	2204      	movs	r2, #4
 800c362:	4013      	ands	r3, r2
 800c364:	0019      	movs	r1, r3
 800c366:	687b      	ldr	r3, [r7, #4]
 800c368:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800c36a:	687b      	ldr	r3, [r7, #4]
 800c36c:	681b      	ldr	r3, [r3, #0]
 800c36e:	430a      	orrs	r2, r1
 800c370:	605a      	str	r2, [r3, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 800c372:	687b      	ldr	r3, [r7, #4]
 800c374:	681b      	ldr	r3, [r3, #0]
 800c376:	69da      	ldr	r2, [r3, #28]
 800c378:	687b      	ldr	r3, [r7, #4]
 800c37a:	681b      	ldr	r3, [r3, #0]
 800c37c:	4907      	ldr	r1, [pc, #28]	; (800c39c <HAL_SPI_Init+0xd0>)
 800c37e:	400a      	ands	r2, r1
 800c380:	61da      	str	r2, [r3, #28]
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800c382:	687b      	ldr	r3, [r7, #4]
 800c384:	2200      	movs	r2, #0
 800c386:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 800c388:	687b      	ldr	r3, [r7, #4]
 800c38a:	2251      	movs	r2, #81	; 0x51
 800c38c:	2101      	movs	r1, #1
 800c38e:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800c390:	2300      	movs	r3, #0
}
 800c392:	0018      	movs	r0, r3
 800c394:	46bd      	mov	sp, r7
 800c396:	b002      	add	sp, #8
 800c398:	bd80      	pop	{r7, pc}
 800c39a:	46c0      	nop			; (mov r8, r8)
 800c39c:	fffff7ff 	.word	0xfffff7ff

0800c3a0 <HAL_SPI_TransmitReceive>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
                                          uint32_t Timeout)
{
 800c3a0:	b580      	push	{r7, lr}
 800c3a2:	b08c      	sub	sp, #48	; 0x30
 800c3a4:	af00      	add	r7, sp, #0
 800c3a6:	60f8      	str	r0, [r7, #12]
 800c3a8:	60b9      	str	r1, [r7, #8]
 800c3aa:	607a      	str	r2, [r7, #4]
 800c3ac:	001a      	movs	r2, r3
 800c3ae:	1cbb      	adds	r3, r7, #2
 800c3b0:	801a      	strh	r2, [r3, #0]
  uint32_t             tmp_mode;
  HAL_SPI_StateTypeDef tmp_state;
  uint32_t             tickstart;

  /* Variable used to alternate Rx and Tx during transfer */
  uint32_t             txallowed = 1U;
 800c3b2:	2301      	movs	r3, #1
 800c3b4:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_StatusTypeDef    errorcode = HAL_OK;
 800c3b6:	232b      	movs	r3, #43	; 0x2b
 800c3b8:	18fb      	adds	r3, r7, r3
 800c3ba:	2200      	movs	r2, #0
 800c3bc:	701a      	strb	r2, [r3, #0]

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 800c3be:	68fb      	ldr	r3, [r7, #12]
 800c3c0:	2250      	movs	r2, #80	; 0x50
 800c3c2:	5c9b      	ldrb	r3, [r3, r2]
 800c3c4:	2b01      	cmp	r3, #1
 800c3c6:	d101      	bne.n	800c3cc <HAL_SPI_TransmitReceive+0x2c>
 800c3c8:	2302      	movs	r3, #2
 800c3ca:	e1a1      	b.n	800c710 <HAL_SPI_TransmitReceive+0x370>
 800c3cc:	68fb      	ldr	r3, [r7, #12]
 800c3ce:	2250      	movs	r2, #80	; 0x50
 800c3d0:	2101      	movs	r1, #1
 800c3d2:	5499      	strb	r1, [r3, r2]

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 800c3d4:	f7fe fabc 	bl	800a950 <HAL_GetTick>
 800c3d8:	0003      	movs	r3, r0
 800c3da:	627b      	str	r3, [r7, #36]	; 0x24

  /* Init temporary variables */
  tmp_state           = hspi->State;
 800c3dc:	2023      	movs	r0, #35	; 0x23
 800c3de:	183b      	adds	r3, r7, r0
 800c3e0:	68fa      	ldr	r2, [r7, #12]
 800c3e2:	2151      	movs	r1, #81	; 0x51
 800c3e4:	5c52      	ldrb	r2, [r2, r1]
 800c3e6:	701a      	strb	r2, [r3, #0]
  tmp_mode            = hspi->Init.Mode;
 800c3e8:	68fb      	ldr	r3, [r7, #12]
 800c3ea:	685b      	ldr	r3, [r3, #4]
 800c3ec:	61fb      	str	r3, [r7, #28]
  initial_TxXferCount = Size;
 800c3ee:	231a      	movs	r3, #26
 800c3f0:	18fb      	adds	r3, r7, r3
 800c3f2:	1cba      	adds	r2, r7, #2
 800c3f4:	8812      	ldrh	r2, [r2, #0]
 800c3f6:	801a      	strh	r2, [r3, #0]

  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 800c3f8:	183b      	adds	r3, r7, r0
 800c3fa:	781b      	ldrb	r3, [r3, #0]
 800c3fc:	2b01      	cmp	r3, #1
 800c3fe:	d012      	beq.n	800c426 <HAL_SPI_TransmitReceive+0x86>
 800c400:	69fa      	ldr	r2, [r7, #28]
 800c402:	2382      	movs	r3, #130	; 0x82
 800c404:	005b      	lsls	r3, r3, #1
 800c406:	429a      	cmp	r2, r3
 800c408:	d108      	bne.n	800c41c <HAL_SPI_TransmitReceive+0x7c>
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 800c40a:	68fb      	ldr	r3, [r7, #12]
 800c40c:	689b      	ldr	r3, [r3, #8]
 800c40e:	2b00      	cmp	r3, #0
 800c410:	d104      	bne.n	800c41c <HAL_SPI_TransmitReceive+0x7c>
 800c412:	2323      	movs	r3, #35	; 0x23
 800c414:	18fb      	adds	r3, r7, r3
 800c416:	781b      	ldrb	r3, [r3, #0]
 800c418:	2b04      	cmp	r3, #4
 800c41a:	d004      	beq.n	800c426 <HAL_SPI_TransmitReceive+0x86>
  {
    errorcode = HAL_BUSY;
 800c41c:	232b      	movs	r3, #43	; 0x2b
 800c41e:	18fb      	adds	r3, r7, r3
 800c420:	2202      	movs	r2, #2
 800c422:	701a      	strb	r2, [r3, #0]
    goto error;
 800c424:	e169      	b.n	800c6fa <HAL_SPI_TransmitReceive+0x35a>
  }

  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 800c426:	68bb      	ldr	r3, [r7, #8]
 800c428:	2b00      	cmp	r3, #0
 800c42a:	d006      	beq.n	800c43a <HAL_SPI_TransmitReceive+0x9a>
 800c42c:	687b      	ldr	r3, [r7, #4]
 800c42e:	2b00      	cmp	r3, #0
 800c430:	d003      	beq.n	800c43a <HAL_SPI_TransmitReceive+0x9a>
 800c432:	1cbb      	adds	r3, r7, #2
 800c434:	881b      	ldrh	r3, [r3, #0]
 800c436:	2b00      	cmp	r3, #0
 800c438:	d104      	bne.n	800c444 <HAL_SPI_TransmitReceive+0xa4>
  {
    errorcode = HAL_ERROR;
 800c43a:	232b      	movs	r3, #43	; 0x2b
 800c43c:	18fb      	adds	r3, r7, r3
 800c43e:	2201      	movs	r2, #1
 800c440:	701a      	strb	r2, [r3, #0]
    goto error;
 800c442:	e15a      	b.n	800c6fa <HAL_SPI_TransmitReceive+0x35a>
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 800c444:	68fb      	ldr	r3, [r7, #12]
 800c446:	2251      	movs	r2, #81	; 0x51
 800c448:	5c9b      	ldrb	r3, [r3, r2]
 800c44a:	b2db      	uxtb	r3, r3
 800c44c:	2b04      	cmp	r3, #4
 800c44e:	d003      	beq.n	800c458 <HAL_SPI_TransmitReceive+0xb8>
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 800c450:	68fb      	ldr	r3, [r7, #12]
 800c452:	2251      	movs	r2, #81	; 0x51
 800c454:	2105      	movs	r1, #5
 800c456:	5499      	strb	r1, [r3, r2]
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800c458:	68fb      	ldr	r3, [r7, #12]
 800c45a:	2200      	movs	r2, #0
 800c45c:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 800c45e:	68fb      	ldr	r3, [r7, #12]
 800c460:	687a      	ldr	r2, [r7, #4]
 800c462:	639a      	str	r2, [r3, #56]	; 0x38
  hspi->RxXferCount = Size;
 800c464:	68fb      	ldr	r3, [r7, #12]
 800c466:	1cba      	adds	r2, r7, #2
 800c468:	8812      	ldrh	r2, [r2, #0]
 800c46a:	87da      	strh	r2, [r3, #62]	; 0x3e
  hspi->RxXferSize  = Size;
 800c46c:	68fb      	ldr	r3, [r7, #12]
 800c46e:	1cba      	adds	r2, r7, #2
 800c470:	8812      	ldrh	r2, [r2, #0]
 800c472:	879a      	strh	r2, [r3, #60]	; 0x3c
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 800c474:	68fb      	ldr	r3, [r7, #12]
 800c476:	68ba      	ldr	r2, [r7, #8]
 800c478:	631a      	str	r2, [r3, #48]	; 0x30
  hspi->TxXferCount = Size;
 800c47a:	68fb      	ldr	r3, [r7, #12]
 800c47c:	1cba      	adds	r2, r7, #2
 800c47e:	8812      	ldrh	r2, [r2, #0]
 800c480:	86da      	strh	r2, [r3, #54]	; 0x36
  hspi->TxXferSize  = Size;
 800c482:	68fb      	ldr	r3, [r7, #12]
 800c484:	1cba      	adds	r2, r7, #2
 800c486:	8812      	ldrh	r2, [r2, #0]
 800c488:	869a      	strh	r2, [r3, #52]	; 0x34

  /*Init field not used in handle to zero */
  hspi->RxISR       = NULL;
 800c48a:	68fb      	ldr	r3, [r7, #12]
 800c48c:	2200      	movs	r2, #0
 800c48e:	641a      	str	r2, [r3, #64]	; 0x40
  hspi->TxISR       = NULL;
 800c490:	68fb      	ldr	r3, [r7, #12]
 800c492:	2200      	movs	r2, #0
 800c494:	645a      	str	r2, [r3, #68]	; 0x44
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 800c496:	68fb      	ldr	r3, [r7, #12]
 800c498:	681b      	ldr	r3, [r3, #0]
 800c49a:	681b      	ldr	r3, [r3, #0]
 800c49c:	2240      	movs	r2, #64	; 0x40
 800c49e:	4013      	ands	r3, r2
 800c4a0:	2b40      	cmp	r3, #64	; 0x40
 800c4a2:	d007      	beq.n	800c4b4 <HAL_SPI_TransmitReceive+0x114>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 800c4a4:	68fb      	ldr	r3, [r7, #12]
 800c4a6:	681b      	ldr	r3, [r3, #0]
 800c4a8:	681a      	ldr	r2, [r3, #0]
 800c4aa:	68fb      	ldr	r3, [r7, #12]
 800c4ac:	681b      	ldr	r3, [r3, #0]
 800c4ae:	2140      	movs	r1, #64	; 0x40
 800c4b0:	430a      	orrs	r2, r1
 800c4b2:	601a      	str	r2, [r3, #0]
  }

  /* Transmit and Receive data in 16 Bit mode */
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 800c4b4:	68fb      	ldr	r3, [r7, #12]
 800c4b6:	68da      	ldr	r2, [r3, #12]
 800c4b8:	2380      	movs	r3, #128	; 0x80
 800c4ba:	011b      	lsls	r3, r3, #4
 800c4bc:	429a      	cmp	r2, r3
 800c4be:	d000      	beq.n	800c4c2 <HAL_SPI_TransmitReceive+0x122>
 800c4c0:	e07a      	b.n	800c5b8 <HAL_SPI_TransmitReceive+0x218>
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 800c4c2:	68fb      	ldr	r3, [r7, #12]
 800c4c4:	685b      	ldr	r3, [r3, #4]
 800c4c6:	2b00      	cmp	r3, #0
 800c4c8:	d004      	beq.n	800c4d4 <HAL_SPI_TransmitReceive+0x134>
 800c4ca:	231a      	movs	r3, #26
 800c4cc:	18fb      	adds	r3, r7, r3
 800c4ce:	881b      	ldrh	r3, [r3, #0]
 800c4d0:	2b01      	cmp	r3, #1
 800c4d2:	d166      	bne.n	800c5a2 <HAL_SPI_TransmitReceive+0x202>
    {
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800c4d4:	68fb      	ldr	r3, [r7, #12]
 800c4d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c4d8:	881a      	ldrh	r2, [r3, #0]
 800c4da:	68fb      	ldr	r3, [r7, #12]
 800c4dc:	681b      	ldr	r3, [r3, #0]
 800c4de:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 800c4e0:	68fb      	ldr	r3, [r7, #12]
 800c4e2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c4e4:	1c9a      	adds	r2, r3, #2
 800c4e6:	68fb      	ldr	r3, [r7, #12]
 800c4e8:	631a      	str	r2, [r3, #48]	; 0x30
      hspi->TxXferCount--;
 800c4ea:	68fb      	ldr	r3, [r7, #12]
 800c4ec:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800c4ee:	b29b      	uxth	r3, r3
 800c4f0:	3b01      	subs	r3, #1
 800c4f2:	b29a      	uxth	r2, r3
 800c4f4:	68fb      	ldr	r3, [r7, #12]
 800c4f6:	86da      	strh	r2, [r3, #54]	; 0x36
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800c4f8:	e053      	b.n	800c5a2 <HAL_SPI_TransmitReceive+0x202>
    {
      /* Check TXE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 800c4fa:	68fb      	ldr	r3, [r7, #12]
 800c4fc:	681b      	ldr	r3, [r3, #0]
 800c4fe:	689b      	ldr	r3, [r3, #8]
 800c500:	2202      	movs	r2, #2
 800c502:	4013      	ands	r3, r2
 800c504:	2b02      	cmp	r3, #2
 800c506:	d11b      	bne.n	800c540 <HAL_SPI_TransmitReceive+0x1a0>
 800c508:	68fb      	ldr	r3, [r7, #12]
 800c50a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800c50c:	b29b      	uxth	r3, r3
 800c50e:	2b00      	cmp	r3, #0
 800c510:	d016      	beq.n	800c540 <HAL_SPI_TransmitReceive+0x1a0>
 800c512:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c514:	2b01      	cmp	r3, #1
 800c516:	d113      	bne.n	800c540 <HAL_SPI_TransmitReceive+0x1a0>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 800c518:	68fb      	ldr	r3, [r7, #12]
 800c51a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c51c:	881a      	ldrh	r2, [r3, #0]
 800c51e:	68fb      	ldr	r3, [r7, #12]
 800c520:	681b      	ldr	r3, [r3, #0]
 800c522:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 800c524:	68fb      	ldr	r3, [r7, #12]
 800c526:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c528:	1c9a      	adds	r2, r3, #2
 800c52a:	68fb      	ldr	r3, [r7, #12]
 800c52c:	631a      	str	r2, [r3, #48]	; 0x30
        hspi->TxXferCount--;
 800c52e:	68fb      	ldr	r3, [r7, #12]
 800c530:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800c532:	b29b      	uxth	r3, r3
 800c534:	3b01      	subs	r3, #1
 800c536:	b29a      	uxth	r2, r3
 800c538:	68fb      	ldr	r3, [r7, #12]
 800c53a:	86da      	strh	r2, [r3, #54]	; 0x36
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 800c53c:	2300      	movs	r3, #0
 800c53e:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
#endif /* USE_SPI_CRC */
      }

      /* Check RXNE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 800c540:	68fb      	ldr	r3, [r7, #12]
 800c542:	681b      	ldr	r3, [r3, #0]
 800c544:	689b      	ldr	r3, [r3, #8]
 800c546:	2201      	movs	r2, #1
 800c548:	4013      	ands	r3, r2
 800c54a:	2b01      	cmp	r3, #1
 800c54c:	d119      	bne.n	800c582 <HAL_SPI_TransmitReceive+0x1e2>
 800c54e:	68fb      	ldr	r3, [r7, #12]
 800c550:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800c552:	b29b      	uxth	r3, r3
 800c554:	2b00      	cmp	r3, #0
 800c556:	d014      	beq.n	800c582 <HAL_SPI_TransmitReceive+0x1e2>
      {
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 800c558:	68fb      	ldr	r3, [r7, #12]
 800c55a:	681b      	ldr	r3, [r3, #0]
 800c55c:	68da      	ldr	r2, [r3, #12]
 800c55e:	68fb      	ldr	r3, [r7, #12]
 800c560:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800c562:	b292      	uxth	r2, r2
 800c564:	801a      	strh	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint16_t);
 800c566:	68fb      	ldr	r3, [r7, #12]
 800c568:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800c56a:	1c9a      	adds	r2, r3, #2
 800c56c:	68fb      	ldr	r3, [r7, #12]
 800c56e:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->RxXferCount--;
 800c570:	68fb      	ldr	r3, [r7, #12]
 800c572:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800c574:	b29b      	uxth	r3, r3
 800c576:	3b01      	subs	r3, #1
 800c578:	b29a      	uxth	r2, r3
 800c57a:	68fb      	ldr	r3, [r7, #12]
 800c57c:	87da      	strh	r2, [r3, #62]	; 0x3e
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 800c57e:	2301      	movs	r3, #1
 800c580:	62fb      	str	r3, [r7, #44]	; 0x2c
      }
      if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
 800c582:	f7fe f9e5 	bl	800a950 <HAL_GetTick>
 800c586:	0002      	movs	r2, r0
 800c588:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c58a:	1ad3      	subs	r3, r2, r3
 800c58c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800c58e:	429a      	cmp	r2, r3
 800c590:	d807      	bhi.n	800c5a2 <HAL_SPI_TransmitReceive+0x202>
 800c592:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c594:	3301      	adds	r3, #1
 800c596:	d004      	beq.n	800c5a2 <HAL_SPI_TransmitReceive+0x202>
      {
        errorcode = HAL_TIMEOUT;
 800c598:	232b      	movs	r3, #43	; 0x2b
 800c59a:	18fb      	adds	r3, r7, r3
 800c59c:	2203      	movs	r2, #3
 800c59e:	701a      	strb	r2, [r3, #0]
        goto error;
 800c5a0:	e0ab      	b.n	800c6fa <HAL_SPI_TransmitReceive+0x35a>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800c5a2:	68fb      	ldr	r3, [r7, #12]
 800c5a4:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800c5a6:	b29b      	uxth	r3, r3
 800c5a8:	2b00      	cmp	r3, #0
 800c5aa:	d1a6      	bne.n	800c4fa <HAL_SPI_TransmitReceive+0x15a>
 800c5ac:	68fb      	ldr	r3, [r7, #12]
 800c5ae:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800c5b0:	b29b      	uxth	r3, r3
 800c5b2:	2b00      	cmp	r3, #0
 800c5b4:	d1a1      	bne.n	800c4fa <HAL_SPI_TransmitReceive+0x15a>
 800c5b6:	e07f      	b.n	800c6b8 <HAL_SPI_TransmitReceive+0x318>
    }
  }
  /* Transmit and Receive data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 800c5b8:	68fb      	ldr	r3, [r7, #12]
 800c5ba:	685b      	ldr	r3, [r3, #4]
 800c5bc:	2b00      	cmp	r3, #0
 800c5be:	d005      	beq.n	800c5cc <HAL_SPI_TransmitReceive+0x22c>
 800c5c0:	231a      	movs	r3, #26
 800c5c2:	18fb      	adds	r3, r7, r3
 800c5c4:	881b      	ldrh	r3, [r3, #0]
 800c5c6:	2b01      	cmp	r3, #1
 800c5c8:	d000      	beq.n	800c5cc <HAL_SPI_TransmitReceive+0x22c>
 800c5ca:	e06b      	b.n	800c6a4 <HAL_SPI_TransmitReceive+0x304>
    {
      *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 800c5cc:	68fb      	ldr	r3, [r7, #12]
 800c5ce:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800c5d0:	68fb      	ldr	r3, [r7, #12]
 800c5d2:	681b      	ldr	r3, [r3, #0]
 800c5d4:	330c      	adds	r3, #12
 800c5d6:	7812      	ldrb	r2, [r2, #0]
 800c5d8:	701a      	strb	r2, [r3, #0]
      hspi->pTxBuffPtr += sizeof(uint8_t);
 800c5da:	68fb      	ldr	r3, [r7, #12]
 800c5dc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c5de:	1c5a      	adds	r2, r3, #1
 800c5e0:	68fb      	ldr	r3, [r7, #12]
 800c5e2:	631a      	str	r2, [r3, #48]	; 0x30
      hspi->TxXferCount--;
 800c5e4:	68fb      	ldr	r3, [r7, #12]
 800c5e6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800c5e8:	b29b      	uxth	r3, r3
 800c5ea:	3b01      	subs	r3, #1
 800c5ec:	b29a      	uxth	r2, r3
 800c5ee:	68fb      	ldr	r3, [r7, #12]
 800c5f0:	86da      	strh	r2, [r3, #54]	; 0x36
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800c5f2:	e057      	b.n	800c6a4 <HAL_SPI_TransmitReceive+0x304>
    {
      /* Check TXE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 800c5f4:	68fb      	ldr	r3, [r7, #12]
 800c5f6:	681b      	ldr	r3, [r3, #0]
 800c5f8:	689b      	ldr	r3, [r3, #8]
 800c5fa:	2202      	movs	r2, #2
 800c5fc:	4013      	ands	r3, r2
 800c5fe:	2b02      	cmp	r3, #2
 800c600:	d11c      	bne.n	800c63c <HAL_SPI_TransmitReceive+0x29c>
 800c602:	68fb      	ldr	r3, [r7, #12]
 800c604:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800c606:	b29b      	uxth	r3, r3
 800c608:	2b00      	cmp	r3, #0
 800c60a:	d017      	beq.n	800c63c <HAL_SPI_TransmitReceive+0x29c>
 800c60c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c60e:	2b01      	cmp	r3, #1
 800c610:	d114      	bne.n	800c63c <HAL_SPI_TransmitReceive+0x29c>
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 800c612:	68fb      	ldr	r3, [r7, #12]
 800c614:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800c616:	68fb      	ldr	r3, [r7, #12]
 800c618:	681b      	ldr	r3, [r3, #0]
 800c61a:	330c      	adds	r3, #12
 800c61c:	7812      	ldrb	r2, [r2, #0]
 800c61e:	701a      	strb	r2, [r3, #0]
        hspi->pTxBuffPtr++;
 800c620:	68fb      	ldr	r3, [r7, #12]
 800c622:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c624:	1c5a      	adds	r2, r3, #1
 800c626:	68fb      	ldr	r3, [r7, #12]
 800c628:	631a      	str	r2, [r3, #48]	; 0x30
        hspi->TxXferCount--;
 800c62a:	68fb      	ldr	r3, [r7, #12]
 800c62c:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800c62e:	b29b      	uxth	r3, r3
 800c630:	3b01      	subs	r3, #1
 800c632:	b29a      	uxth	r2, r3
 800c634:	68fb      	ldr	r3, [r7, #12]
 800c636:	86da      	strh	r2, [r3, #54]	; 0x36
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 800c638:	2300      	movs	r3, #0
 800c63a:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
#endif /* USE_SPI_CRC */
      }

      /* Wait until RXNE flag is reset */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 800c63c:	68fb      	ldr	r3, [r7, #12]
 800c63e:	681b      	ldr	r3, [r3, #0]
 800c640:	689b      	ldr	r3, [r3, #8]
 800c642:	2201      	movs	r2, #1
 800c644:	4013      	ands	r3, r2
 800c646:	2b01      	cmp	r3, #1
 800c648:	d119      	bne.n	800c67e <HAL_SPI_TransmitReceive+0x2de>
 800c64a:	68fb      	ldr	r3, [r7, #12]
 800c64c:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800c64e:	b29b      	uxth	r3, r3
 800c650:	2b00      	cmp	r3, #0
 800c652:	d014      	beq.n	800c67e <HAL_SPI_TransmitReceive+0x2de>
      {
        (*(uint8_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
 800c654:	68fb      	ldr	r3, [r7, #12]
 800c656:	681b      	ldr	r3, [r3, #0]
 800c658:	68da      	ldr	r2, [r3, #12]
 800c65a:	68fb      	ldr	r3, [r7, #12]
 800c65c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800c65e:	b2d2      	uxtb	r2, r2
 800c660:	701a      	strb	r2, [r3, #0]
        hspi->pRxBuffPtr++;
 800c662:	68fb      	ldr	r3, [r7, #12]
 800c664:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800c666:	1c5a      	adds	r2, r3, #1
 800c668:	68fb      	ldr	r3, [r7, #12]
 800c66a:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->RxXferCount--;
 800c66c:	68fb      	ldr	r3, [r7, #12]
 800c66e:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800c670:	b29b      	uxth	r3, r3
 800c672:	3b01      	subs	r3, #1
 800c674:	b29a      	uxth	r2, r3
 800c676:	68fb      	ldr	r3, [r7, #12]
 800c678:	87da      	strh	r2, [r3, #62]	; 0x3e
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 800c67a:	2301      	movs	r3, #1
 800c67c:	62fb      	str	r3, [r7, #44]	; 0x2c
      }
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 800c67e:	f7fe f967 	bl	800a950 <HAL_GetTick>
 800c682:	0002      	movs	r2, r0
 800c684:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c686:	1ad3      	subs	r3, r2, r3
 800c688:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800c68a:	429a      	cmp	r2, r3
 800c68c:	d802      	bhi.n	800c694 <HAL_SPI_TransmitReceive+0x2f4>
 800c68e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c690:	3301      	adds	r3, #1
 800c692:	d102      	bne.n	800c69a <HAL_SPI_TransmitReceive+0x2fa>
 800c694:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c696:	2b00      	cmp	r3, #0
 800c698:	d104      	bne.n	800c6a4 <HAL_SPI_TransmitReceive+0x304>
      {
        errorcode = HAL_TIMEOUT;
 800c69a:	232b      	movs	r3, #43	; 0x2b
 800c69c:	18fb      	adds	r3, r7, r3
 800c69e:	2203      	movs	r2, #3
 800c6a0:	701a      	strb	r2, [r3, #0]
        goto error;
 800c6a2:	e02a      	b.n	800c6fa <HAL_SPI_TransmitReceive+0x35a>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800c6a4:	68fb      	ldr	r3, [r7, #12]
 800c6a6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800c6a8:	b29b      	uxth	r3, r3
 800c6aa:	2b00      	cmp	r3, #0
 800c6ac:	d1a2      	bne.n	800c5f4 <HAL_SPI_TransmitReceive+0x254>
 800c6ae:	68fb      	ldr	r3, [r7, #12]
 800c6b0:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800c6b2:	b29b      	uxth	r3, r3
 800c6b4:	2b00      	cmp	r3, #0
 800c6b6:	d19d      	bne.n	800c5f4 <HAL_SPI_TransmitReceive+0x254>
    errorcode = HAL_ERROR;
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 800c6b8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800c6ba:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800c6bc:	68fb      	ldr	r3, [r7, #12]
 800c6be:	0018      	movs	r0, r3
 800c6c0:	f000 f89a 	bl	800c7f8 <SPI_EndRxTxTransaction>
 800c6c4:	1e03      	subs	r3, r0, #0
 800c6c6:	d007      	beq.n	800c6d8 <HAL_SPI_TransmitReceive+0x338>
  {
    errorcode = HAL_ERROR;
 800c6c8:	232b      	movs	r3, #43	; 0x2b
 800c6ca:	18fb      	adds	r3, r7, r3
 800c6cc:	2201      	movs	r2, #1
 800c6ce:	701a      	strb	r2, [r3, #0]
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 800c6d0:	68fb      	ldr	r3, [r7, #12]
 800c6d2:	2220      	movs	r2, #32
 800c6d4:	655a      	str	r2, [r3, #84]	; 0x54
    goto error;
 800c6d6:	e010      	b.n	800c6fa <HAL_SPI_TransmitReceive+0x35a>
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 800c6d8:	68fb      	ldr	r3, [r7, #12]
 800c6da:	689b      	ldr	r3, [r3, #8]
 800c6dc:	2b00      	cmp	r3, #0
 800c6de:	d10b      	bne.n	800c6f8 <HAL_SPI_TransmitReceive+0x358>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800c6e0:	2300      	movs	r3, #0
 800c6e2:	617b      	str	r3, [r7, #20]
 800c6e4:	68fb      	ldr	r3, [r7, #12]
 800c6e6:	681b      	ldr	r3, [r3, #0]
 800c6e8:	68db      	ldr	r3, [r3, #12]
 800c6ea:	617b      	str	r3, [r7, #20]
 800c6ec:	68fb      	ldr	r3, [r7, #12]
 800c6ee:	681b      	ldr	r3, [r3, #0]
 800c6f0:	689b      	ldr	r3, [r3, #8]
 800c6f2:	617b      	str	r3, [r7, #20]
 800c6f4:	697b      	ldr	r3, [r7, #20]
 800c6f6:	e000      	b.n	800c6fa <HAL_SPI_TransmitReceive+0x35a>
  }

error :
 800c6f8:	46c0      	nop			; (mov r8, r8)
  hspi->State = HAL_SPI_STATE_READY;
 800c6fa:	68fb      	ldr	r3, [r7, #12]
 800c6fc:	2251      	movs	r2, #81	; 0x51
 800c6fe:	2101      	movs	r1, #1
 800c700:	5499      	strb	r1, [r3, r2]
  __HAL_UNLOCK(hspi);
 800c702:	68fb      	ldr	r3, [r7, #12]
 800c704:	2250      	movs	r2, #80	; 0x50
 800c706:	2100      	movs	r1, #0
 800c708:	5499      	strb	r1, [r3, r2]
  return errorcode;
 800c70a:	232b      	movs	r3, #43	; 0x2b
 800c70c:	18fb      	adds	r3, r7, r3
 800c70e:	781b      	ldrb	r3, [r3, #0]
}
 800c710:	0018      	movs	r0, r3
 800c712:	46bd      	mov	sp, r7
 800c714:	b00c      	add	sp, #48	; 0x30
 800c716:	bd80      	pop	{r7, pc}

0800c718 <SPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 800c718:	b580      	push	{r7, lr}
 800c71a:	b084      	sub	sp, #16
 800c71c:	af00      	add	r7, sp, #0
 800c71e:	60f8      	str	r0, [r7, #12]
 800c720:	60b9      	str	r1, [r7, #8]
 800c722:	603b      	str	r3, [r7, #0]
 800c724:	1dfb      	adds	r3, r7, #7
 800c726:	701a      	strb	r2, [r3, #0]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 800c728:	e050      	b.n	800c7cc <SPI_WaitFlagStateUntilTimeout+0xb4>
  {
    if (Timeout != HAL_MAX_DELAY)
 800c72a:	683b      	ldr	r3, [r7, #0]
 800c72c:	3301      	adds	r3, #1
 800c72e:	d04d      	beq.n	800c7cc <SPI_WaitFlagStateUntilTimeout+0xb4>
    {
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 800c730:	f7fe f90e 	bl	800a950 <HAL_GetTick>
 800c734:	0002      	movs	r2, r0
 800c736:	69bb      	ldr	r3, [r7, #24]
 800c738:	1ad3      	subs	r3, r2, r3
 800c73a:	683a      	ldr	r2, [r7, #0]
 800c73c:	429a      	cmp	r2, r3
 800c73e:	d902      	bls.n	800c746 <SPI_WaitFlagStateUntilTimeout+0x2e>
 800c740:	683b      	ldr	r3, [r7, #0]
 800c742:	2b00      	cmp	r3, #0
 800c744:	d142      	bne.n	800c7cc <SPI_WaitFlagStateUntilTimeout+0xb4>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
        on both master and slave sides in order to resynchronize the master
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 800c746:	68fb      	ldr	r3, [r7, #12]
 800c748:	681b      	ldr	r3, [r3, #0]
 800c74a:	685a      	ldr	r2, [r3, #4]
 800c74c:	68fb      	ldr	r3, [r7, #12]
 800c74e:	681b      	ldr	r3, [r3, #0]
 800c750:	21e0      	movs	r1, #224	; 0xe0
 800c752:	438a      	bics	r2, r1
 800c754:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800c756:	68fb      	ldr	r3, [r7, #12]
 800c758:	685a      	ldr	r2, [r3, #4]
 800c75a:	2382      	movs	r3, #130	; 0x82
 800c75c:	005b      	lsls	r3, r3, #1
 800c75e:	429a      	cmp	r2, r3
 800c760:	d113      	bne.n	800c78a <SPI_WaitFlagStateUntilTimeout+0x72>
 800c762:	68fb      	ldr	r3, [r7, #12]
 800c764:	689a      	ldr	r2, [r3, #8]
 800c766:	2380      	movs	r3, #128	; 0x80
 800c768:	021b      	lsls	r3, r3, #8
 800c76a:	429a      	cmp	r2, r3
 800c76c:	d005      	beq.n	800c77a <SPI_WaitFlagStateUntilTimeout+0x62>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800c76e:	68fb      	ldr	r3, [r7, #12]
 800c770:	689a      	ldr	r2, [r3, #8]
 800c772:	2380      	movs	r3, #128	; 0x80
 800c774:	00db      	lsls	r3, r3, #3
 800c776:	429a      	cmp	r2, r3
 800c778:	d107      	bne.n	800c78a <SPI_WaitFlagStateUntilTimeout+0x72>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 800c77a:	68fb      	ldr	r3, [r7, #12]
 800c77c:	681b      	ldr	r3, [r3, #0]
 800c77e:	681a      	ldr	r2, [r3, #0]
 800c780:	68fb      	ldr	r3, [r7, #12]
 800c782:	681b      	ldr	r3, [r3, #0]
 800c784:	2140      	movs	r1, #64	; 0x40
 800c786:	438a      	bics	r2, r1
 800c788:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800c78a:	68fb      	ldr	r3, [r7, #12]
 800c78c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800c78e:	2380      	movs	r3, #128	; 0x80
 800c790:	019b      	lsls	r3, r3, #6
 800c792:	429a      	cmp	r2, r3
 800c794:	d110      	bne.n	800c7b8 <SPI_WaitFlagStateUntilTimeout+0xa0>
        {
          SPI_RESET_CRC(hspi);
 800c796:	68fb      	ldr	r3, [r7, #12]
 800c798:	681b      	ldr	r3, [r3, #0]
 800c79a:	681a      	ldr	r2, [r3, #0]
 800c79c:	68fb      	ldr	r3, [r7, #12]
 800c79e:	681b      	ldr	r3, [r3, #0]
 800c7a0:	4914      	ldr	r1, [pc, #80]	; (800c7f4 <SPI_WaitFlagStateUntilTimeout+0xdc>)
 800c7a2:	400a      	ands	r2, r1
 800c7a4:	601a      	str	r2, [r3, #0]
 800c7a6:	68fb      	ldr	r3, [r7, #12]
 800c7a8:	681b      	ldr	r3, [r3, #0]
 800c7aa:	681a      	ldr	r2, [r3, #0]
 800c7ac:	68fb      	ldr	r3, [r7, #12]
 800c7ae:	681b      	ldr	r3, [r3, #0]
 800c7b0:	2180      	movs	r1, #128	; 0x80
 800c7b2:	0189      	lsls	r1, r1, #6
 800c7b4:	430a      	orrs	r2, r1
 800c7b6:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 800c7b8:	68fb      	ldr	r3, [r7, #12]
 800c7ba:	2251      	movs	r2, #81	; 0x51
 800c7bc:	2101      	movs	r1, #1
 800c7be:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 800c7c0:	68fb      	ldr	r3, [r7, #12]
 800c7c2:	2250      	movs	r2, #80	; 0x50
 800c7c4:	2100      	movs	r1, #0
 800c7c6:	5499      	strb	r1, [r3, r2]

        return HAL_TIMEOUT;
 800c7c8:	2303      	movs	r3, #3
 800c7ca:	e00f      	b.n	800c7ec <SPI_WaitFlagStateUntilTimeout+0xd4>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 800c7cc:	68fb      	ldr	r3, [r7, #12]
 800c7ce:	681b      	ldr	r3, [r3, #0]
 800c7d0:	689b      	ldr	r3, [r3, #8]
 800c7d2:	68ba      	ldr	r2, [r7, #8]
 800c7d4:	4013      	ands	r3, r2
 800c7d6:	68ba      	ldr	r2, [r7, #8]
 800c7d8:	1ad3      	subs	r3, r2, r3
 800c7da:	425a      	negs	r2, r3
 800c7dc:	4153      	adcs	r3, r2
 800c7de:	b2db      	uxtb	r3, r3
 800c7e0:	001a      	movs	r2, r3
 800c7e2:	1dfb      	adds	r3, r7, #7
 800c7e4:	781b      	ldrb	r3, [r3, #0]
 800c7e6:	429a      	cmp	r2, r3
 800c7e8:	d19f      	bne.n	800c72a <SPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }

  return HAL_OK;
 800c7ea:	2300      	movs	r3, #0
}
 800c7ec:	0018      	movs	r0, r3
 800c7ee:	46bd      	mov	sp, r7
 800c7f0:	b004      	add	sp, #16
 800c7f2:	bd80      	pop	{r7, pc}
 800c7f4:	ffffdfff 	.word	0xffffdfff

0800c7f8 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 800c7f8:	b580      	push	{r7, lr}
 800c7fa:	b086      	sub	sp, #24
 800c7fc:	af02      	add	r7, sp, #8
 800c7fe:	60f8      	str	r0, [r7, #12]
 800c800:	60b9      	str	r1, [r7, #8]
 800c802:	607a      	str	r2, [r7, #4]
  /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 800c804:	68fb      	ldr	r3, [r7, #12]
 800c806:	685a      	ldr	r2, [r3, #4]
 800c808:	2382      	movs	r3, #130	; 0x82
 800c80a:	005b      	lsls	r3, r3, #1
 800c80c:	429a      	cmp	r2, r3
 800c80e:	d112      	bne.n	800c836 <SPI_EndRxTxTransaction+0x3e>
  {
    /* Control the BSY flag */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 800c810:	68ba      	ldr	r2, [r7, #8]
 800c812:	68f8      	ldr	r0, [r7, #12]
 800c814:	687b      	ldr	r3, [r7, #4]
 800c816:	9300      	str	r3, [sp, #0]
 800c818:	0013      	movs	r3, r2
 800c81a:	2200      	movs	r2, #0
 800c81c:	2180      	movs	r1, #128	; 0x80
 800c81e:	f7ff ff7b 	bl	800c718 <SPI_WaitFlagStateUntilTimeout>
 800c822:	1e03      	subs	r3, r0, #0
 800c824:	d020      	beq.n	800c868 <SPI_EndRxTxTransaction+0x70>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800c826:	68fb      	ldr	r3, [r7, #12]
 800c828:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800c82a:	2220      	movs	r2, #32
 800c82c:	431a      	orrs	r2, r3
 800c82e:	68fb      	ldr	r3, [r7, #12]
 800c830:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_TIMEOUT;
 800c832:	2303      	movs	r3, #3
 800c834:	e019      	b.n	800c86a <SPI_EndRxTxTransaction+0x72>
    }
  }
  else
  {
    /* Control RXNE flag in case of Full-Duplex transfer */
    if (hspi->State == HAL_SPI_STATE_BUSY_TX_RX)
 800c836:	68fb      	ldr	r3, [r7, #12]
 800c838:	2251      	movs	r2, #81	; 0x51
 800c83a:	5c9b      	ldrb	r3, [r3, r2]
 800c83c:	b2db      	uxtb	r3, r3
 800c83e:	2b05      	cmp	r3, #5
 800c840:	d112      	bne.n	800c868 <SPI_EndRxTxTransaction+0x70>
    {
      /* Wait the RXNE reset */
      if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
 800c842:	68ba      	ldr	r2, [r7, #8]
 800c844:	68f8      	ldr	r0, [r7, #12]
 800c846:	687b      	ldr	r3, [r7, #4]
 800c848:	9300      	str	r3, [sp, #0]
 800c84a:	0013      	movs	r3, r2
 800c84c:	2200      	movs	r2, #0
 800c84e:	2101      	movs	r1, #1
 800c850:	f7ff ff62 	bl	800c718 <SPI_WaitFlagStateUntilTimeout>
 800c854:	1e03      	subs	r3, r0, #0
 800c856:	d007      	beq.n	800c868 <SPI_EndRxTxTransaction+0x70>
      {
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800c858:	68fb      	ldr	r3, [r7, #12]
 800c85a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800c85c:	2220      	movs	r2, #32
 800c85e:	431a      	orrs	r2, r3
 800c860:	68fb      	ldr	r3, [r7, #12]
 800c862:	655a      	str	r2, [r3, #84]	; 0x54
        return HAL_TIMEOUT;
 800c864:	2303      	movs	r3, #3
 800c866:	e000      	b.n	800c86a <SPI_EndRxTxTransaction+0x72>
      }
    }
  }
  return HAL_OK;
 800c868:	2300      	movs	r3, #0
}
 800c86a:	0018      	movs	r0, r3
 800c86c:	46bd      	mov	sp, r7
 800c86e:	b004      	add	sp, #16
 800c870:	bd80      	pop	{r7, pc}
	...

0800c874 <__errno>:
 800c874:	4b01      	ldr	r3, [pc, #4]	; (800c87c <__errno+0x8>)
 800c876:	6818      	ldr	r0, [r3, #0]
 800c878:	4770      	bx	lr
 800c87a:	46c0      	nop			; (mov r8, r8)
 800c87c:	20000004 	.word	0x20000004

0800c880 <__libc_init_array>:
 800c880:	b570      	push	{r4, r5, r6, lr}
 800c882:	2600      	movs	r6, #0
 800c884:	4d0c      	ldr	r5, [pc, #48]	; (800c8b8 <__libc_init_array+0x38>)
 800c886:	4c0d      	ldr	r4, [pc, #52]	; (800c8bc <__libc_init_array+0x3c>)
 800c888:	1b64      	subs	r4, r4, r5
 800c88a:	10a4      	asrs	r4, r4, #2
 800c88c:	42a6      	cmp	r6, r4
 800c88e:	d109      	bne.n	800c8a4 <__libc_init_array+0x24>
 800c890:	2600      	movs	r6, #0
 800c892:	f001 f80d 	bl	800d8b0 <_init>
 800c896:	4d0a      	ldr	r5, [pc, #40]	; (800c8c0 <__libc_init_array+0x40>)
 800c898:	4c0a      	ldr	r4, [pc, #40]	; (800c8c4 <__libc_init_array+0x44>)
 800c89a:	1b64      	subs	r4, r4, r5
 800c89c:	10a4      	asrs	r4, r4, #2
 800c89e:	42a6      	cmp	r6, r4
 800c8a0:	d105      	bne.n	800c8ae <__libc_init_array+0x2e>
 800c8a2:	bd70      	pop	{r4, r5, r6, pc}
 800c8a4:	00b3      	lsls	r3, r6, #2
 800c8a6:	58eb      	ldr	r3, [r5, r3]
 800c8a8:	4798      	blx	r3
 800c8aa:	3601      	adds	r6, #1
 800c8ac:	e7ee      	b.n	800c88c <__libc_init_array+0xc>
 800c8ae:	00b3      	lsls	r3, r6, #2
 800c8b0:	58eb      	ldr	r3, [r5, r3]
 800c8b2:	4798      	blx	r3
 800c8b4:	3601      	adds	r6, #1
 800c8b6:	e7f2      	b.n	800c89e <__libc_init_array+0x1e>
 800c8b8:	0800e770 	.word	0x0800e770
 800c8bc:	0800e770 	.word	0x0800e770
 800c8c0:	0800e770 	.word	0x0800e770
 800c8c4:	0800e774 	.word	0x0800e774

0800c8c8 <memcpy>:
 800c8c8:	2300      	movs	r3, #0
 800c8ca:	b510      	push	{r4, lr}
 800c8cc:	429a      	cmp	r2, r3
 800c8ce:	d100      	bne.n	800c8d2 <memcpy+0xa>
 800c8d0:	bd10      	pop	{r4, pc}
 800c8d2:	5ccc      	ldrb	r4, [r1, r3]
 800c8d4:	54c4      	strb	r4, [r0, r3]
 800c8d6:	3301      	adds	r3, #1
 800c8d8:	e7f8      	b.n	800c8cc <memcpy+0x4>

0800c8da <memset>:
 800c8da:	0003      	movs	r3, r0
 800c8dc:	1812      	adds	r2, r2, r0
 800c8de:	4293      	cmp	r3, r2
 800c8e0:	d100      	bne.n	800c8e4 <memset+0xa>
 800c8e2:	4770      	bx	lr
 800c8e4:	7019      	strb	r1, [r3, #0]
 800c8e6:	3301      	adds	r3, #1
 800c8e8:	e7f9      	b.n	800c8de <memset+0x4>
	...

0800c8ec <iprintf>:
 800c8ec:	b40f      	push	{r0, r1, r2, r3}
 800c8ee:	4b0b      	ldr	r3, [pc, #44]	; (800c91c <iprintf+0x30>)
 800c8f0:	b513      	push	{r0, r1, r4, lr}
 800c8f2:	681c      	ldr	r4, [r3, #0]
 800c8f4:	2c00      	cmp	r4, #0
 800c8f6:	d005      	beq.n	800c904 <iprintf+0x18>
 800c8f8:	69a3      	ldr	r3, [r4, #24]
 800c8fa:	2b00      	cmp	r3, #0
 800c8fc:	d102      	bne.n	800c904 <iprintf+0x18>
 800c8fe:	0020      	movs	r0, r4
 800c900:	f000 fa92 	bl	800ce28 <__sinit>
 800c904:	ab05      	add	r3, sp, #20
 800c906:	9a04      	ldr	r2, [sp, #16]
 800c908:	68a1      	ldr	r1, [r4, #8]
 800c90a:	0020      	movs	r0, r4
 800c90c:	9301      	str	r3, [sp, #4]
 800c90e:	f000 fc65 	bl	800d1dc <_vfiprintf_r>
 800c912:	bc16      	pop	{r1, r2, r4}
 800c914:	bc08      	pop	{r3}
 800c916:	b004      	add	sp, #16
 800c918:	4718      	bx	r3
 800c91a:	46c0      	nop			; (mov r8, r8)
 800c91c:	20000004 	.word	0x20000004

0800c920 <_puts_r>:
 800c920:	b570      	push	{r4, r5, r6, lr}
 800c922:	0005      	movs	r5, r0
 800c924:	000e      	movs	r6, r1
 800c926:	2800      	cmp	r0, #0
 800c928:	d004      	beq.n	800c934 <_puts_r+0x14>
 800c92a:	6983      	ldr	r3, [r0, #24]
 800c92c:	2b00      	cmp	r3, #0
 800c92e:	d101      	bne.n	800c934 <_puts_r+0x14>
 800c930:	f000 fa7a 	bl	800ce28 <__sinit>
 800c934:	69ab      	ldr	r3, [r5, #24]
 800c936:	68ac      	ldr	r4, [r5, #8]
 800c938:	2b00      	cmp	r3, #0
 800c93a:	d102      	bne.n	800c942 <_puts_r+0x22>
 800c93c:	0028      	movs	r0, r5
 800c93e:	f000 fa73 	bl	800ce28 <__sinit>
 800c942:	4b24      	ldr	r3, [pc, #144]	; (800c9d4 <_puts_r+0xb4>)
 800c944:	429c      	cmp	r4, r3
 800c946:	d10f      	bne.n	800c968 <_puts_r+0x48>
 800c948:	686c      	ldr	r4, [r5, #4]
 800c94a:	89a3      	ldrh	r3, [r4, #12]
 800c94c:	071b      	lsls	r3, r3, #28
 800c94e:	d502      	bpl.n	800c956 <_puts_r+0x36>
 800c950:	6923      	ldr	r3, [r4, #16]
 800c952:	2b00      	cmp	r3, #0
 800c954:	d11f      	bne.n	800c996 <_puts_r+0x76>
 800c956:	0021      	movs	r1, r4
 800c958:	0028      	movs	r0, r5
 800c95a:	f000 f8f7 	bl	800cb4c <__swsetup_r>
 800c95e:	2800      	cmp	r0, #0
 800c960:	d019      	beq.n	800c996 <_puts_r+0x76>
 800c962:	2001      	movs	r0, #1
 800c964:	4240      	negs	r0, r0
 800c966:	bd70      	pop	{r4, r5, r6, pc}
 800c968:	4b1b      	ldr	r3, [pc, #108]	; (800c9d8 <_puts_r+0xb8>)
 800c96a:	429c      	cmp	r4, r3
 800c96c:	d101      	bne.n	800c972 <_puts_r+0x52>
 800c96e:	68ac      	ldr	r4, [r5, #8]
 800c970:	e7eb      	b.n	800c94a <_puts_r+0x2a>
 800c972:	4b1a      	ldr	r3, [pc, #104]	; (800c9dc <_puts_r+0xbc>)
 800c974:	429c      	cmp	r4, r3
 800c976:	d1e8      	bne.n	800c94a <_puts_r+0x2a>
 800c978:	68ec      	ldr	r4, [r5, #12]
 800c97a:	e7e6      	b.n	800c94a <_puts_r+0x2a>
 800c97c:	3601      	adds	r6, #1
 800c97e:	60a3      	str	r3, [r4, #8]
 800c980:	2b00      	cmp	r3, #0
 800c982:	da04      	bge.n	800c98e <_puts_r+0x6e>
 800c984:	69a2      	ldr	r2, [r4, #24]
 800c986:	429a      	cmp	r2, r3
 800c988:	dc16      	bgt.n	800c9b8 <_puts_r+0x98>
 800c98a:	290a      	cmp	r1, #10
 800c98c:	d014      	beq.n	800c9b8 <_puts_r+0x98>
 800c98e:	6823      	ldr	r3, [r4, #0]
 800c990:	1c5a      	adds	r2, r3, #1
 800c992:	6022      	str	r2, [r4, #0]
 800c994:	7019      	strb	r1, [r3, #0]
 800c996:	68a3      	ldr	r3, [r4, #8]
 800c998:	7831      	ldrb	r1, [r6, #0]
 800c99a:	3b01      	subs	r3, #1
 800c99c:	2900      	cmp	r1, #0
 800c99e:	d1ed      	bne.n	800c97c <_puts_r+0x5c>
 800c9a0:	60a3      	str	r3, [r4, #8]
 800c9a2:	2b00      	cmp	r3, #0
 800c9a4:	da0f      	bge.n	800c9c6 <_puts_r+0xa6>
 800c9a6:	0022      	movs	r2, r4
 800c9a8:	310a      	adds	r1, #10
 800c9aa:	0028      	movs	r0, r5
 800c9ac:	f000 f878 	bl	800caa0 <__swbuf_r>
 800c9b0:	1c43      	adds	r3, r0, #1
 800c9b2:	d0d6      	beq.n	800c962 <_puts_r+0x42>
 800c9b4:	200a      	movs	r0, #10
 800c9b6:	e7d6      	b.n	800c966 <_puts_r+0x46>
 800c9b8:	0022      	movs	r2, r4
 800c9ba:	0028      	movs	r0, r5
 800c9bc:	f000 f870 	bl	800caa0 <__swbuf_r>
 800c9c0:	1c43      	adds	r3, r0, #1
 800c9c2:	d1e8      	bne.n	800c996 <_puts_r+0x76>
 800c9c4:	e7cd      	b.n	800c962 <_puts_r+0x42>
 800c9c6:	200a      	movs	r0, #10
 800c9c8:	6823      	ldr	r3, [r4, #0]
 800c9ca:	1c5a      	adds	r2, r3, #1
 800c9cc:	6022      	str	r2, [r4, #0]
 800c9ce:	7018      	strb	r0, [r3, #0]
 800c9d0:	e7c9      	b.n	800c966 <_puts_r+0x46>
 800c9d2:	46c0      	nop			; (mov r8, r8)
 800c9d4:	0800e6f4 	.word	0x0800e6f4
 800c9d8:	0800e714 	.word	0x0800e714
 800c9dc:	0800e6d4 	.word	0x0800e6d4

0800c9e0 <puts>:
 800c9e0:	b510      	push	{r4, lr}
 800c9e2:	4b03      	ldr	r3, [pc, #12]	; (800c9f0 <puts+0x10>)
 800c9e4:	0001      	movs	r1, r0
 800c9e6:	6818      	ldr	r0, [r3, #0]
 800c9e8:	f7ff ff9a 	bl	800c920 <_puts_r>
 800c9ec:	bd10      	pop	{r4, pc}
 800c9ee:	46c0      	nop			; (mov r8, r8)
 800c9f0:	20000004 	.word	0x20000004

0800c9f4 <srand>:
 800c9f4:	4b0d      	ldr	r3, [pc, #52]	; (800ca2c <srand+0x38>)
 800c9f6:	b570      	push	{r4, r5, r6, lr}
 800c9f8:	681c      	ldr	r4, [r3, #0]
 800c9fa:	0005      	movs	r5, r0
 800c9fc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c9fe:	2b00      	cmp	r3, #0
 800ca00:	d10f      	bne.n	800ca22 <srand+0x2e>
 800ca02:	2018      	movs	r0, #24
 800ca04:	f000 fb10 	bl	800d028 <malloc>
 800ca08:	4b09      	ldr	r3, [pc, #36]	; (800ca30 <srand+0x3c>)
 800ca0a:	63a0      	str	r0, [r4, #56]	; 0x38
 800ca0c:	6003      	str	r3, [r0, #0]
 800ca0e:	4b09      	ldr	r3, [pc, #36]	; (800ca34 <srand+0x40>)
 800ca10:	2201      	movs	r2, #1
 800ca12:	6043      	str	r3, [r0, #4]
 800ca14:	4b08      	ldr	r3, [pc, #32]	; (800ca38 <srand+0x44>)
 800ca16:	6083      	str	r3, [r0, #8]
 800ca18:	230b      	movs	r3, #11
 800ca1a:	8183      	strh	r3, [r0, #12]
 800ca1c:	2300      	movs	r3, #0
 800ca1e:	6102      	str	r2, [r0, #16]
 800ca20:	6143      	str	r3, [r0, #20]
 800ca22:	2200      	movs	r2, #0
 800ca24:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800ca26:	611d      	str	r5, [r3, #16]
 800ca28:	615a      	str	r2, [r3, #20]
 800ca2a:	bd70      	pop	{r4, r5, r6, pc}
 800ca2c:	20000004 	.word	0x20000004
 800ca30:	abcd330e 	.word	0xabcd330e
 800ca34:	e66d1234 	.word	0xe66d1234
 800ca38:	0005deec 	.word	0x0005deec

0800ca3c <rand>:
 800ca3c:	4b12      	ldr	r3, [pc, #72]	; (800ca88 <rand+0x4c>)
 800ca3e:	b510      	push	{r4, lr}
 800ca40:	681c      	ldr	r4, [r3, #0]
 800ca42:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800ca44:	2b00      	cmp	r3, #0
 800ca46:	d10f      	bne.n	800ca68 <rand+0x2c>
 800ca48:	2018      	movs	r0, #24
 800ca4a:	f000 faed 	bl	800d028 <malloc>
 800ca4e:	4b0f      	ldr	r3, [pc, #60]	; (800ca8c <rand+0x50>)
 800ca50:	63a0      	str	r0, [r4, #56]	; 0x38
 800ca52:	6003      	str	r3, [r0, #0]
 800ca54:	4b0e      	ldr	r3, [pc, #56]	; (800ca90 <rand+0x54>)
 800ca56:	2201      	movs	r2, #1
 800ca58:	6043      	str	r3, [r0, #4]
 800ca5a:	4b0e      	ldr	r3, [pc, #56]	; (800ca94 <rand+0x58>)
 800ca5c:	6083      	str	r3, [r0, #8]
 800ca5e:	230b      	movs	r3, #11
 800ca60:	8183      	strh	r3, [r0, #12]
 800ca62:	2300      	movs	r3, #0
 800ca64:	6102      	str	r2, [r0, #16]
 800ca66:	6143      	str	r3, [r0, #20]
 800ca68:	6ba4      	ldr	r4, [r4, #56]	; 0x38
 800ca6a:	4a0b      	ldr	r2, [pc, #44]	; (800ca98 <rand+0x5c>)
 800ca6c:	6920      	ldr	r0, [r4, #16]
 800ca6e:	6961      	ldr	r1, [r4, #20]
 800ca70:	4b0a      	ldr	r3, [pc, #40]	; (800ca9c <rand+0x60>)
 800ca72:	f7f3 fcdf 	bl	8000434 <__aeabi_lmul>
 800ca76:	2201      	movs	r2, #1
 800ca78:	2300      	movs	r3, #0
 800ca7a:	1880      	adds	r0, r0, r2
 800ca7c:	4159      	adcs	r1, r3
 800ca7e:	6120      	str	r0, [r4, #16]
 800ca80:	6161      	str	r1, [r4, #20]
 800ca82:	0048      	lsls	r0, r1, #1
 800ca84:	0840      	lsrs	r0, r0, #1
 800ca86:	bd10      	pop	{r4, pc}
 800ca88:	20000004 	.word	0x20000004
 800ca8c:	abcd330e 	.word	0xabcd330e
 800ca90:	e66d1234 	.word	0xe66d1234
 800ca94:	0005deec 	.word	0x0005deec
 800ca98:	4c957f2d 	.word	0x4c957f2d
 800ca9c:	5851f42d 	.word	0x5851f42d

0800caa0 <__swbuf_r>:
 800caa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800caa2:	0005      	movs	r5, r0
 800caa4:	000e      	movs	r6, r1
 800caa6:	0014      	movs	r4, r2
 800caa8:	2800      	cmp	r0, #0
 800caaa:	d004      	beq.n	800cab6 <__swbuf_r+0x16>
 800caac:	6983      	ldr	r3, [r0, #24]
 800caae:	2b00      	cmp	r3, #0
 800cab0:	d101      	bne.n	800cab6 <__swbuf_r+0x16>
 800cab2:	f000 f9b9 	bl	800ce28 <__sinit>
 800cab6:	4b22      	ldr	r3, [pc, #136]	; (800cb40 <__swbuf_r+0xa0>)
 800cab8:	429c      	cmp	r4, r3
 800caba:	d12d      	bne.n	800cb18 <__swbuf_r+0x78>
 800cabc:	686c      	ldr	r4, [r5, #4]
 800cabe:	69a3      	ldr	r3, [r4, #24]
 800cac0:	60a3      	str	r3, [r4, #8]
 800cac2:	89a3      	ldrh	r3, [r4, #12]
 800cac4:	071b      	lsls	r3, r3, #28
 800cac6:	d531      	bpl.n	800cb2c <__swbuf_r+0x8c>
 800cac8:	6923      	ldr	r3, [r4, #16]
 800caca:	2b00      	cmp	r3, #0
 800cacc:	d02e      	beq.n	800cb2c <__swbuf_r+0x8c>
 800cace:	6823      	ldr	r3, [r4, #0]
 800cad0:	6922      	ldr	r2, [r4, #16]
 800cad2:	b2f7      	uxtb	r7, r6
 800cad4:	1a98      	subs	r0, r3, r2
 800cad6:	6963      	ldr	r3, [r4, #20]
 800cad8:	b2f6      	uxtb	r6, r6
 800cada:	4283      	cmp	r3, r0
 800cadc:	dc05      	bgt.n	800caea <__swbuf_r+0x4a>
 800cade:	0021      	movs	r1, r4
 800cae0:	0028      	movs	r0, r5
 800cae2:	f000 f933 	bl	800cd4c <_fflush_r>
 800cae6:	2800      	cmp	r0, #0
 800cae8:	d126      	bne.n	800cb38 <__swbuf_r+0x98>
 800caea:	68a3      	ldr	r3, [r4, #8]
 800caec:	3001      	adds	r0, #1
 800caee:	3b01      	subs	r3, #1
 800caf0:	60a3      	str	r3, [r4, #8]
 800caf2:	6823      	ldr	r3, [r4, #0]
 800caf4:	1c5a      	adds	r2, r3, #1
 800caf6:	6022      	str	r2, [r4, #0]
 800caf8:	701f      	strb	r7, [r3, #0]
 800cafa:	6963      	ldr	r3, [r4, #20]
 800cafc:	4283      	cmp	r3, r0
 800cafe:	d004      	beq.n	800cb0a <__swbuf_r+0x6a>
 800cb00:	89a3      	ldrh	r3, [r4, #12]
 800cb02:	07db      	lsls	r3, r3, #31
 800cb04:	d51a      	bpl.n	800cb3c <__swbuf_r+0x9c>
 800cb06:	2e0a      	cmp	r6, #10
 800cb08:	d118      	bne.n	800cb3c <__swbuf_r+0x9c>
 800cb0a:	0021      	movs	r1, r4
 800cb0c:	0028      	movs	r0, r5
 800cb0e:	f000 f91d 	bl	800cd4c <_fflush_r>
 800cb12:	2800      	cmp	r0, #0
 800cb14:	d012      	beq.n	800cb3c <__swbuf_r+0x9c>
 800cb16:	e00f      	b.n	800cb38 <__swbuf_r+0x98>
 800cb18:	4b0a      	ldr	r3, [pc, #40]	; (800cb44 <__swbuf_r+0xa4>)
 800cb1a:	429c      	cmp	r4, r3
 800cb1c:	d101      	bne.n	800cb22 <__swbuf_r+0x82>
 800cb1e:	68ac      	ldr	r4, [r5, #8]
 800cb20:	e7cd      	b.n	800cabe <__swbuf_r+0x1e>
 800cb22:	4b09      	ldr	r3, [pc, #36]	; (800cb48 <__swbuf_r+0xa8>)
 800cb24:	429c      	cmp	r4, r3
 800cb26:	d1ca      	bne.n	800cabe <__swbuf_r+0x1e>
 800cb28:	68ec      	ldr	r4, [r5, #12]
 800cb2a:	e7c8      	b.n	800cabe <__swbuf_r+0x1e>
 800cb2c:	0021      	movs	r1, r4
 800cb2e:	0028      	movs	r0, r5
 800cb30:	f000 f80c 	bl	800cb4c <__swsetup_r>
 800cb34:	2800      	cmp	r0, #0
 800cb36:	d0ca      	beq.n	800cace <__swbuf_r+0x2e>
 800cb38:	2601      	movs	r6, #1
 800cb3a:	4276      	negs	r6, r6
 800cb3c:	0030      	movs	r0, r6
 800cb3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800cb40:	0800e6f4 	.word	0x0800e6f4
 800cb44:	0800e714 	.word	0x0800e714
 800cb48:	0800e6d4 	.word	0x0800e6d4

0800cb4c <__swsetup_r>:
 800cb4c:	4b36      	ldr	r3, [pc, #216]	; (800cc28 <__swsetup_r+0xdc>)
 800cb4e:	b570      	push	{r4, r5, r6, lr}
 800cb50:	681d      	ldr	r5, [r3, #0]
 800cb52:	0006      	movs	r6, r0
 800cb54:	000c      	movs	r4, r1
 800cb56:	2d00      	cmp	r5, #0
 800cb58:	d005      	beq.n	800cb66 <__swsetup_r+0x1a>
 800cb5a:	69ab      	ldr	r3, [r5, #24]
 800cb5c:	2b00      	cmp	r3, #0
 800cb5e:	d102      	bne.n	800cb66 <__swsetup_r+0x1a>
 800cb60:	0028      	movs	r0, r5
 800cb62:	f000 f961 	bl	800ce28 <__sinit>
 800cb66:	4b31      	ldr	r3, [pc, #196]	; (800cc2c <__swsetup_r+0xe0>)
 800cb68:	429c      	cmp	r4, r3
 800cb6a:	d10f      	bne.n	800cb8c <__swsetup_r+0x40>
 800cb6c:	686c      	ldr	r4, [r5, #4]
 800cb6e:	230c      	movs	r3, #12
 800cb70:	5ee2      	ldrsh	r2, [r4, r3]
 800cb72:	b293      	uxth	r3, r2
 800cb74:	0719      	lsls	r1, r3, #28
 800cb76:	d42d      	bmi.n	800cbd4 <__swsetup_r+0x88>
 800cb78:	06d9      	lsls	r1, r3, #27
 800cb7a:	d411      	bmi.n	800cba0 <__swsetup_r+0x54>
 800cb7c:	2309      	movs	r3, #9
 800cb7e:	2001      	movs	r0, #1
 800cb80:	6033      	str	r3, [r6, #0]
 800cb82:	3337      	adds	r3, #55	; 0x37
 800cb84:	4313      	orrs	r3, r2
 800cb86:	81a3      	strh	r3, [r4, #12]
 800cb88:	4240      	negs	r0, r0
 800cb8a:	bd70      	pop	{r4, r5, r6, pc}
 800cb8c:	4b28      	ldr	r3, [pc, #160]	; (800cc30 <__swsetup_r+0xe4>)
 800cb8e:	429c      	cmp	r4, r3
 800cb90:	d101      	bne.n	800cb96 <__swsetup_r+0x4a>
 800cb92:	68ac      	ldr	r4, [r5, #8]
 800cb94:	e7eb      	b.n	800cb6e <__swsetup_r+0x22>
 800cb96:	4b27      	ldr	r3, [pc, #156]	; (800cc34 <__swsetup_r+0xe8>)
 800cb98:	429c      	cmp	r4, r3
 800cb9a:	d1e8      	bne.n	800cb6e <__swsetup_r+0x22>
 800cb9c:	68ec      	ldr	r4, [r5, #12]
 800cb9e:	e7e6      	b.n	800cb6e <__swsetup_r+0x22>
 800cba0:	075b      	lsls	r3, r3, #29
 800cba2:	d513      	bpl.n	800cbcc <__swsetup_r+0x80>
 800cba4:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800cba6:	2900      	cmp	r1, #0
 800cba8:	d008      	beq.n	800cbbc <__swsetup_r+0x70>
 800cbaa:	0023      	movs	r3, r4
 800cbac:	3344      	adds	r3, #68	; 0x44
 800cbae:	4299      	cmp	r1, r3
 800cbb0:	d002      	beq.n	800cbb8 <__swsetup_r+0x6c>
 800cbb2:	0030      	movs	r0, r6
 800cbb4:	f000 fa42 	bl	800d03c <_free_r>
 800cbb8:	2300      	movs	r3, #0
 800cbba:	6363      	str	r3, [r4, #52]	; 0x34
 800cbbc:	2224      	movs	r2, #36	; 0x24
 800cbbe:	89a3      	ldrh	r3, [r4, #12]
 800cbc0:	4393      	bics	r3, r2
 800cbc2:	81a3      	strh	r3, [r4, #12]
 800cbc4:	2300      	movs	r3, #0
 800cbc6:	6063      	str	r3, [r4, #4]
 800cbc8:	6923      	ldr	r3, [r4, #16]
 800cbca:	6023      	str	r3, [r4, #0]
 800cbcc:	2308      	movs	r3, #8
 800cbce:	89a2      	ldrh	r2, [r4, #12]
 800cbd0:	4313      	orrs	r3, r2
 800cbd2:	81a3      	strh	r3, [r4, #12]
 800cbd4:	6923      	ldr	r3, [r4, #16]
 800cbd6:	2b00      	cmp	r3, #0
 800cbd8:	d10b      	bne.n	800cbf2 <__swsetup_r+0xa6>
 800cbda:	21a0      	movs	r1, #160	; 0xa0
 800cbdc:	2280      	movs	r2, #128	; 0x80
 800cbde:	89a3      	ldrh	r3, [r4, #12]
 800cbe0:	0089      	lsls	r1, r1, #2
 800cbe2:	0092      	lsls	r2, r2, #2
 800cbe4:	400b      	ands	r3, r1
 800cbe6:	4293      	cmp	r3, r2
 800cbe8:	d003      	beq.n	800cbf2 <__swsetup_r+0xa6>
 800cbea:	0021      	movs	r1, r4
 800cbec:	0030      	movs	r0, r6
 800cbee:	f000 f9d7 	bl	800cfa0 <__smakebuf_r>
 800cbf2:	2301      	movs	r3, #1
 800cbf4:	89a2      	ldrh	r2, [r4, #12]
 800cbf6:	4013      	ands	r3, r2
 800cbf8:	d011      	beq.n	800cc1e <__swsetup_r+0xd2>
 800cbfa:	2300      	movs	r3, #0
 800cbfc:	60a3      	str	r3, [r4, #8]
 800cbfe:	6963      	ldr	r3, [r4, #20]
 800cc00:	425b      	negs	r3, r3
 800cc02:	61a3      	str	r3, [r4, #24]
 800cc04:	2000      	movs	r0, #0
 800cc06:	6923      	ldr	r3, [r4, #16]
 800cc08:	4283      	cmp	r3, r0
 800cc0a:	d1be      	bne.n	800cb8a <__swsetup_r+0x3e>
 800cc0c:	230c      	movs	r3, #12
 800cc0e:	5ee2      	ldrsh	r2, [r4, r3]
 800cc10:	0613      	lsls	r3, r2, #24
 800cc12:	d5ba      	bpl.n	800cb8a <__swsetup_r+0x3e>
 800cc14:	2340      	movs	r3, #64	; 0x40
 800cc16:	4313      	orrs	r3, r2
 800cc18:	81a3      	strh	r3, [r4, #12]
 800cc1a:	3801      	subs	r0, #1
 800cc1c:	e7b5      	b.n	800cb8a <__swsetup_r+0x3e>
 800cc1e:	0792      	lsls	r2, r2, #30
 800cc20:	d400      	bmi.n	800cc24 <__swsetup_r+0xd8>
 800cc22:	6963      	ldr	r3, [r4, #20]
 800cc24:	60a3      	str	r3, [r4, #8]
 800cc26:	e7ed      	b.n	800cc04 <__swsetup_r+0xb8>
 800cc28:	20000004 	.word	0x20000004
 800cc2c:	0800e6f4 	.word	0x0800e6f4
 800cc30:	0800e714 	.word	0x0800e714
 800cc34:	0800e6d4 	.word	0x0800e6d4

0800cc38 <__sflush_r>:
 800cc38:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800cc3a:	898a      	ldrh	r2, [r1, #12]
 800cc3c:	0005      	movs	r5, r0
 800cc3e:	000c      	movs	r4, r1
 800cc40:	0713      	lsls	r3, r2, #28
 800cc42:	d460      	bmi.n	800cd06 <__sflush_r+0xce>
 800cc44:	684b      	ldr	r3, [r1, #4]
 800cc46:	2b00      	cmp	r3, #0
 800cc48:	dc04      	bgt.n	800cc54 <__sflush_r+0x1c>
 800cc4a:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 800cc4c:	2b00      	cmp	r3, #0
 800cc4e:	dc01      	bgt.n	800cc54 <__sflush_r+0x1c>
 800cc50:	2000      	movs	r0, #0
 800cc52:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800cc54:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 800cc56:	2f00      	cmp	r7, #0
 800cc58:	d0fa      	beq.n	800cc50 <__sflush_r+0x18>
 800cc5a:	2300      	movs	r3, #0
 800cc5c:	682e      	ldr	r6, [r5, #0]
 800cc5e:	602b      	str	r3, [r5, #0]
 800cc60:	2380      	movs	r3, #128	; 0x80
 800cc62:	015b      	lsls	r3, r3, #5
 800cc64:	6a21      	ldr	r1, [r4, #32]
 800cc66:	401a      	ands	r2, r3
 800cc68:	d034      	beq.n	800ccd4 <__sflush_r+0x9c>
 800cc6a:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800cc6c:	89a3      	ldrh	r3, [r4, #12]
 800cc6e:	075b      	lsls	r3, r3, #29
 800cc70:	d506      	bpl.n	800cc80 <__sflush_r+0x48>
 800cc72:	6863      	ldr	r3, [r4, #4]
 800cc74:	1ac0      	subs	r0, r0, r3
 800cc76:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800cc78:	2b00      	cmp	r3, #0
 800cc7a:	d001      	beq.n	800cc80 <__sflush_r+0x48>
 800cc7c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800cc7e:	1ac0      	subs	r0, r0, r3
 800cc80:	0002      	movs	r2, r0
 800cc82:	6a21      	ldr	r1, [r4, #32]
 800cc84:	2300      	movs	r3, #0
 800cc86:	0028      	movs	r0, r5
 800cc88:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 800cc8a:	47b8      	blx	r7
 800cc8c:	89a1      	ldrh	r1, [r4, #12]
 800cc8e:	1c43      	adds	r3, r0, #1
 800cc90:	d106      	bne.n	800cca0 <__sflush_r+0x68>
 800cc92:	682b      	ldr	r3, [r5, #0]
 800cc94:	2b1d      	cmp	r3, #29
 800cc96:	d830      	bhi.n	800ccfa <__sflush_r+0xc2>
 800cc98:	4a2b      	ldr	r2, [pc, #172]	; (800cd48 <__sflush_r+0x110>)
 800cc9a:	40da      	lsrs	r2, r3
 800cc9c:	07d3      	lsls	r3, r2, #31
 800cc9e:	d52c      	bpl.n	800ccfa <__sflush_r+0xc2>
 800cca0:	2300      	movs	r3, #0
 800cca2:	6063      	str	r3, [r4, #4]
 800cca4:	6923      	ldr	r3, [r4, #16]
 800cca6:	6023      	str	r3, [r4, #0]
 800cca8:	04cb      	lsls	r3, r1, #19
 800ccaa:	d505      	bpl.n	800ccb8 <__sflush_r+0x80>
 800ccac:	1c43      	adds	r3, r0, #1
 800ccae:	d102      	bne.n	800ccb6 <__sflush_r+0x7e>
 800ccb0:	682b      	ldr	r3, [r5, #0]
 800ccb2:	2b00      	cmp	r3, #0
 800ccb4:	d100      	bne.n	800ccb8 <__sflush_r+0x80>
 800ccb6:	6560      	str	r0, [r4, #84]	; 0x54
 800ccb8:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800ccba:	602e      	str	r6, [r5, #0]
 800ccbc:	2900      	cmp	r1, #0
 800ccbe:	d0c7      	beq.n	800cc50 <__sflush_r+0x18>
 800ccc0:	0023      	movs	r3, r4
 800ccc2:	3344      	adds	r3, #68	; 0x44
 800ccc4:	4299      	cmp	r1, r3
 800ccc6:	d002      	beq.n	800ccce <__sflush_r+0x96>
 800ccc8:	0028      	movs	r0, r5
 800ccca:	f000 f9b7 	bl	800d03c <_free_r>
 800ccce:	2000      	movs	r0, #0
 800ccd0:	6360      	str	r0, [r4, #52]	; 0x34
 800ccd2:	e7be      	b.n	800cc52 <__sflush_r+0x1a>
 800ccd4:	2301      	movs	r3, #1
 800ccd6:	0028      	movs	r0, r5
 800ccd8:	47b8      	blx	r7
 800ccda:	1c43      	adds	r3, r0, #1
 800ccdc:	d1c6      	bne.n	800cc6c <__sflush_r+0x34>
 800ccde:	682b      	ldr	r3, [r5, #0]
 800cce0:	2b00      	cmp	r3, #0
 800cce2:	d0c3      	beq.n	800cc6c <__sflush_r+0x34>
 800cce4:	2b1d      	cmp	r3, #29
 800cce6:	d001      	beq.n	800ccec <__sflush_r+0xb4>
 800cce8:	2b16      	cmp	r3, #22
 800ccea:	d101      	bne.n	800ccf0 <__sflush_r+0xb8>
 800ccec:	602e      	str	r6, [r5, #0]
 800ccee:	e7af      	b.n	800cc50 <__sflush_r+0x18>
 800ccf0:	2340      	movs	r3, #64	; 0x40
 800ccf2:	89a2      	ldrh	r2, [r4, #12]
 800ccf4:	4313      	orrs	r3, r2
 800ccf6:	81a3      	strh	r3, [r4, #12]
 800ccf8:	e7ab      	b.n	800cc52 <__sflush_r+0x1a>
 800ccfa:	2340      	movs	r3, #64	; 0x40
 800ccfc:	430b      	orrs	r3, r1
 800ccfe:	2001      	movs	r0, #1
 800cd00:	81a3      	strh	r3, [r4, #12]
 800cd02:	4240      	negs	r0, r0
 800cd04:	e7a5      	b.n	800cc52 <__sflush_r+0x1a>
 800cd06:	690f      	ldr	r7, [r1, #16]
 800cd08:	2f00      	cmp	r7, #0
 800cd0a:	d0a1      	beq.n	800cc50 <__sflush_r+0x18>
 800cd0c:	680b      	ldr	r3, [r1, #0]
 800cd0e:	600f      	str	r7, [r1, #0]
 800cd10:	1bdb      	subs	r3, r3, r7
 800cd12:	9301      	str	r3, [sp, #4]
 800cd14:	2300      	movs	r3, #0
 800cd16:	0792      	lsls	r2, r2, #30
 800cd18:	d100      	bne.n	800cd1c <__sflush_r+0xe4>
 800cd1a:	694b      	ldr	r3, [r1, #20]
 800cd1c:	60a3      	str	r3, [r4, #8]
 800cd1e:	9b01      	ldr	r3, [sp, #4]
 800cd20:	2b00      	cmp	r3, #0
 800cd22:	dc00      	bgt.n	800cd26 <__sflush_r+0xee>
 800cd24:	e794      	b.n	800cc50 <__sflush_r+0x18>
 800cd26:	9b01      	ldr	r3, [sp, #4]
 800cd28:	003a      	movs	r2, r7
 800cd2a:	6a21      	ldr	r1, [r4, #32]
 800cd2c:	0028      	movs	r0, r5
 800cd2e:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 800cd30:	47b0      	blx	r6
 800cd32:	2800      	cmp	r0, #0
 800cd34:	dc03      	bgt.n	800cd3e <__sflush_r+0x106>
 800cd36:	2340      	movs	r3, #64	; 0x40
 800cd38:	89a2      	ldrh	r2, [r4, #12]
 800cd3a:	4313      	orrs	r3, r2
 800cd3c:	e7df      	b.n	800ccfe <__sflush_r+0xc6>
 800cd3e:	9b01      	ldr	r3, [sp, #4]
 800cd40:	183f      	adds	r7, r7, r0
 800cd42:	1a1b      	subs	r3, r3, r0
 800cd44:	9301      	str	r3, [sp, #4]
 800cd46:	e7ea      	b.n	800cd1e <__sflush_r+0xe6>
 800cd48:	20400001 	.word	0x20400001

0800cd4c <_fflush_r>:
 800cd4c:	690b      	ldr	r3, [r1, #16]
 800cd4e:	b570      	push	{r4, r5, r6, lr}
 800cd50:	0005      	movs	r5, r0
 800cd52:	000c      	movs	r4, r1
 800cd54:	2b00      	cmp	r3, #0
 800cd56:	d101      	bne.n	800cd5c <_fflush_r+0x10>
 800cd58:	2000      	movs	r0, #0
 800cd5a:	bd70      	pop	{r4, r5, r6, pc}
 800cd5c:	2800      	cmp	r0, #0
 800cd5e:	d004      	beq.n	800cd6a <_fflush_r+0x1e>
 800cd60:	6983      	ldr	r3, [r0, #24]
 800cd62:	2b00      	cmp	r3, #0
 800cd64:	d101      	bne.n	800cd6a <_fflush_r+0x1e>
 800cd66:	f000 f85f 	bl	800ce28 <__sinit>
 800cd6a:	4b0b      	ldr	r3, [pc, #44]	; (800cd98 <_fflush_r+0x4c>)
 800cd6c:	429c      	cmp	r4, r3
 800cd6e:	d109      	bne.n	800cd84 <_fflush_r+0x38>
 800cd70:	686c      	ldr	r4, [r5, #4]
 800cd72:	220c      	movs	r2, #12
 800cd74:	5ea3      	ldrsh	r3, [r4, r2]
 800cd76:	2b00      	cmp	r3, #0
 800cd78:	d0ee      	beq.n	800cd58 <_fflush_r+0xc>
 800cd7a:	0021      	movs	r1, r4
 800cd7c:	0028      	movs	r0, r5
 800cd7e:	f7ff ff5b 	bl	800cc38 <__sflush_r>
 800cd82:	e7ea      	b.n	800cd5a <_fflush_r+0xe>
 800cd84:	4b05      	ldr	r3, [pc, #20]	; (800cd9c <_fflush_r+0x50>)
 800cd86:	429c      	cmp	r4, r3
 800cd88:	d101      	bne.n	800cd8e <_fflush_r+0x42>
 800cd8a:	68ac      	ldr	r4, [r5, #8]
 800cd8c:	e7f1      	b.n	800cd72 <_fflush_r+0x26>
 800cd8e:	4b04      	ldr	r3, [pc, #16]	; (800cda0 <_fflush_r+0x54>)
 800cd90:	429c      	cmp	r4, r3
 800cd92:	d1ee      	bne.n	800cd72 <_fflush_r+0x26>
 800cd94:	68ec      	ldr	r4, [r5, #12]
 800cd96:	e7ec      	b.n	800cd72 <_fflush_r+0x26>
 800cd98:	0800e6f4 	.word	0x0800e6f4
 800cd9c:	0800e714 	.word	0x0800e714
 800cda0:	0800e6d4 	.word	0x0800e6d4

0800cda4 <std>:
 800cda4:	2300      	movs	r3, #0
 800cda6:	b510      	push	{r4, lr}
 800cda8:	0004      	movs	r4, r0
 800cdaa:	6003      	str	r3, [r0, #0]
 800cdac:	6043      	str	r3, [r0, #4]
 800cdae:	6083      	str	r3, [r0, #8]
 800cdb0:	8181      	strh	r1, [r0, #12]
 800cdb2:	6643      	str	r3, [r0, #100]	; 0x64
 800cdb4:	81c2      	strh	r2, [r0, #14]
 800cdb6:	6103      	str	r3, [r0, #16]
 800cdb8:	6143      	str	r3, [r0, #20]
 800cdba:	6183      	str	r3, [r0, #24]
 800cdbc:	0019      	movs	r1, r3
 800cdbe:	2208      	movs	r2, #8
 800cdc0:	305c      	adds	r0, #92	; 0x5c
 800cdc2:	f7ff fd8a 	bl	800c8da <memset>
 800cdc6:	4b05      	ldr	r3, [pc, #20]	; (800cddc <std+0x38>)
 800cdc8:	6224      	str	r4, [r4, #32]
 800cdca:	6263      	str	r3, [r4, #36]	; 0x24
 800cdcc:	4b04      	ldr	r3, [pc, #16]	; (800cde0 <std+0x3c>)
 800cdce:	62a3      	str	r3, [r4, #40]	; 0x28
 800cdd0:	4b04      	ldr	r3, [pc, #16]	; (800cde4 <std+0x40>)
 800cdd2:	62e3      	str	r3, [r4, #44]	; 0x2c
 800cdd4:	4b04      	ldr	r3, [pc, #16]	; (800cde8 <std+0x44>)
 800cdd6:	6323      	str	r3, [r4, #48]	; 0x30
 800cdd8:	bd10      	pop	{r4, pc}
 800cdda:	46c0      	nop			; (mov r8, r8)
 800cddc:	0800d719 	.word	0x0800d719
 800cde0:	0800d741 	.word	0x0800d741
 800cde4:	0800d779 	.word	0x0800d779
 800cde8:	0800d7a5 	.word	0x0800d7a5

0800cdec <_cleanup_r>:
 800cdec:	b510      	push	{r4, lr}
 800cdee:	4902      	ldr	r1, [pc, #8]	; (800cdf8 <_cleanup_r+0xc>)
 800cdf0:	f000 f88c 	bl	800cf0c <_fwalk_reent>
 800cdf4:	bd10      	pop	{r4, pc}
 800cdf6:	46c0      	nop			; (mov r8, r8)
 800cdf8:	0800cd4d 	.word	0x0800cd4d

0800cdfc <__sfmoreglue>:
 800cdfc:	b570      	push	{r4, r5, r6, lr}
 800cdfe:	2568      	movs	r5, #104	; 0x68
 800ce00:	1e4a      	subs	r2, r1, #1
 800ce02:	4355      	muls	r5, r2
 800ce04:	000e      	movs	r6, r1
 800ce06:	0029      	movs	r1, r5
 800ce08:	3174      	adds	r1, #116	; 0x74
 800ce0a:	f000 f961 	bl	800d0d0 <_malloc_r>
 800ce0e:	1e04      	subs	r4, r0, #0
 800ce10:	d008      	beq.n	800ce24 <__sfmoreglue+0x28>
 800ce12:	2100      	movs	r1, #0
 800ce14:	002a      	movs	r2, r5
 800ce16:	6001      	str	r1, [r0, #0]
 800ce18:	6046      	str	r6, [r0, #4]
 800ce1a:	300c      	adds	r0, #12
 800ce1c:	60a0      	str	r0, [r4, #8]
 800ce1e:	3268      	adds	r2, #104	; 0x68
 800ce20:	f7ff fd5b 	bl	800c8da <memset>
 800ce24:	0020      	movs	r0, r4
 800ce26:	bd70      	pop	{r4, r5, r6, pc}

0800ce28 <__sinit>:
 800ce28:	6983      	ldr	r3, [r0, #24]
 800ce2a:	b513      	push	{r0, r1, r4, lr}
 800ce2c:	0004      	movs	r4, r0
 800ce2e:	2b00      	cmp	r3, #0
 800ce30:	d128      	bne.n	800ce84 <__sinit+0x5c>
 800ce32:	6483      	str	r3, [r0, #72]	; 0x48
 800ce34:	64c3      	str	r3, [r0, #76]	; 0x4c
 800ce36:	6503      	str	r3, [r0, #80]	; 0x50
 800ce38:	4b13      	ldr	r3, [pc, #76]	; (800ce88 <__sinit+0x60>)
 800ce3a:	4a14      	ldr	r2, [pc, #80]	; (800ce8c <__sinit+0x64>)
 800ce3c:	681b      	ldr	r3, [r3, #0]
 800ce3e:	6282      	str	r2, [r0, #40]	; 0x28
 800ce40:	9301      	str	r3, [sp, #4]
 800ce42:	4298      	cmp	r0, r3
 800ce44:	d101      	bne.n	800ce4a <__sinit+0x22>
 800ce46:	2301      	movs	r3, #1
 800ce48:	6183      	str	r3, [r0, #24]
 800ce4a:	0020      	movs	r0, r4
 800ce4c:	f000 f820 	bl	800ce90 <__sfp>
 800ce50:	6060      	str	r0, [r4, #4]
 800ce52:	0020      	movs	r0, r4
 800ce54:	f000 f81c 	bl	800ce90 <__sfp>
 800ce58:	60a0      	str	r0, [r4, #8]
 800ce5a:	0020      	movs	r0, r4
 800ce5c:	f000 f818 	bl	800ce90 <__sfp>
 800ce60:	2200      	movs	r2, #0
 800ce62:	60e0      	str	r0, [r4, #12]
 800ce64:	2104      	movs	r1, #4
 800ce66:	6860      	ldr	r0, [r4, #4]
 800ce68:	f7ff ff9c 	bl	800cda4 <std>
 800ce6c:	2201      	movs	r2, #1
 800ce6e:	2109      	movs	r1, #9
 800ce70:	68a0      	ldr	r0, [r4, #8]
 800ce72:	f7ff ff97 	bl	800cda4 <std>
 800ce76:	2202      	movs	r2, #2
 800ce78:	2112      	movs	r1, #18
 800ce7a:	68e0      	ldr	r0, [r4, #12]
 800ce7c:	f7ff ff92 	bl	800cda4 <std>
 800ce80:	2301      	movs	r3, #1
 800ce82:	61a3      	str	r3, [r4, #24]
 800ce84:	bd13      	pop	{r0, r1, r4, pc}
 800ce86:	46c0      	nop			; (mov r8, r8)
 800ce88:	0800e6d0 	.word	0x0800e6d0
 800ce8c:	0800cded 	.word	0x0800cded

0800ce90 <__sfp>:
 800ce90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ce92:	4b1c      	ldr	r3, [pc, #112]	; (800cf04 <__sfp+0x74>)
 800ce94:	0007      	movs	r7, r0
 800ce96:	681e      	ldr	r6, [r3, #0]
 800ce98:	69b3      	ldr	r3, [r6, #24]
 800ce9a:	2b00      	cmp	r3, #0
 800ce9c:	d102      	bne.n	800cea4 <__sfp+0x14>
 800ce9e:	0030      	movs	r0, r6
 800cea0:	f7ff ffc2 	bl	800ce28 <__sinit>
 800cea4:	3648      	adds	r6, #72	; 0x48
 800cea6:	68b4      	ldr	r4, [r6, #8]
 800cea8:	6873      	ldr	r3, [r6, #4]
 800ceaa:	3b01      	subs	r3, #1
 800ceac:	d504      	bpl.n	800ceb8 <__sfp+0x28>
 800ceae:	6833      	ldr	r3, [r6, #0]
 800ceb0:	2b00      	cmp	r3, #0
 800ceb2:	d007      	beq.n	800cec4 <__sfp+0x34>
 800ceb4:	6836      	ldr	r6, [r6, #0]
 800ceb6:	e7f6      	b.n	800cea6 <__sfp+0x16>
 800ceb8:	220c      	movs	r2, #12
 800ceba:	5ea5      	ldrsh	r5, [r4, r2]
 800cebc:	2d00      	cmp	r5, #0
 800cebe:	d00d      	beq.n	800cedc <__sfp+0x4c>
 800cec0:	3468      	adds	r4, #104	; 0x68
 800cec2:	e7f2      	b.n	800ceaa <__sfp+0x1a>
 800cec4:	2104      	movs	r1, #4
 800cec6:	0038      	movs	r0, r7
 800cec8:	f7ff ff98 	bl	800cdfc <__sfmoreglue>
 800cecc:	6030      	str	r0, [r6, #0]
 800cece:	2800      	cmp	r0, #0
 800ced0:	d1f0      	bne.n	800ceb4 <__sfp+0x24>
 800ced2:	230c      	movs	r3, #12
 800ced4:	0004      	movs	r4, r0
 800ced6:	603b      	str	r3, [r7, #0]
 800ced8:	0020      	movs	r0, r4
 800ceda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800cedc:	0020      	movs	r0, r4
 800cede:	4b0a      	ldr	r3, [pc, #40]	; (800cf08 <__sfp+0x78>)
 800cee0:	6665      	str	r5, [r4, #100]	; 0x64
 800cee2:	6025      	str	r5, [r4, #0]
 800cee4:	6065      	str	r5, [r4, #4]
 800cee6:	60a5      	str	r5, [r4, #8]
 800cee8:	60e3      	str	r3, [r4, #12]
 800ceea:	6125      	str	r5, [r4, #16]
 800ceec:	6165      	str	r5, [r4, #20]
 800ceee:	61a5      	str	r5, [r4, #24]
 800cef0:	2208      	movs	r2, #8
 800cef2:	0029      	movs	r1, r5
 800cef4:	305c      	adds	r0, #92	; 0x5c
 800cef6:	f7ff fcf0 	bl	800c8da <memset>
 800cefa:	6365      	str	r5, [r4, #52]	; 0x34
 800cefc:	63a5      	str	r5, [r4, #56]	; 0x38
 800cefe:	64a5      	str	r5, [r4, #72]	; 0x48
 800cf00:	64e5      	str	r5, [r4, #76]	; 0x4c
 800cf02:	e7e9      	b.n	800ced8 <__sfp+0x48>
 800cf04:	0800e6d0 	.word	0x0800e6d0
 800cf08:	ffff0001 	.word	0xffff0001

0800cf0c <_fwalk_reent>:
 800cf0c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800cf0e:	0004      	movs	r4, r0
 800cf10:	0007      	movs	r7, r0
 800cf12:	2600      	movs	r6, #0
 800cf14:	9101      	str	r1, [sp, #4]
 800cf16:	3448      	adds	r4, #72	; 0x48
 800cf18:	2c00      	cmp	r4, #0
 800cf1a:	d101      	bne.n	800cf20 <_fwalk_reent+0x14>
 800cf1c:	0030      	movs	r0, r6
 800cf1e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800cf20:	6863      	ldr	r3, [r4, #4]
 800cf22:	68a5      	ldr	r5, [r4, #8]
 800cf24:	9300      	str	r3, [sp, #0]
 800cf26:	9b00      	ldr	r3, [sp, #0]
 800cf28:	3b01      	subs	r3, #1
 800cf2a:	9300      	str	r3, [sp, #0]
 800cf2c:	d501      	bpl.n	800cf32 <_fwalk_reent+0x26>
 800cf2e:	6824      	ldr	r4, [r4, #0]
 800cf30:	e7f2      	b.n	800cf18 <_fwalk_reent+0xc>
 800cf32:	89ab      	ldrh	r3, [r5, #12]
 800cf34:	2b01      	cmp	r3, #1
 800cf36:	d908      	bls.n	800cf4a <_fwalk_reent+0x3e>
 800cf38:	220e      	movs	r2, #14
 800cf3a:	5eab      	ldrsh	r3, [r5, r2]
 800cf3c:	3301      	adds	r3, #1
 800cf3e:	d004      	beq.n	800cf4a <_fwalk_reent+0x3e>
 800cf40:	0029      	movs	r1, r5
 800cf42:	0038      	movs	r0, r7
 800cf44:	9b01      	ldr	r3, [sp, #4]
 800cf46:	4798      	blx	r3
 800cf48:	4306      	orrs	r6, r0
 800cf4a:	3568      	adds	r5, #104	; 0x68
 800cf4c:	e7eb      	b.n	800cf26 <_fwalk_reent+0x1a>
	...

0800cf50 <__swhatbuf_r>:
 800cf50:	b570      	push	{r4, r5, r6, lr}
 800cf52:	000e      	movs	r6, r1
 800cf54:	001d      	movs	r5, r3
 800cf56:	230e      	movs	r3, #14
 800cf58:	5ec9      	ldrsh	r1, [r1, r3]
 800cf5a:	b096      	sub	sp, #88	; 0x58
 800cf5c:	0014      	movs	r4, r2
 800cf5e:	2900      	cmp	r1, #0
 800cf60:	da07      	bge.n	800cf72 <__swhatbuf_r+0x22>
 800cf62:	2300      	movs	r3, #0
 800cf64:	602b      	str	r3, [r5, #0]
 800cf66:	89b3      	ldrh	r3, [r6, #12]
 800cf68:	061b      	lsls	r3, r3, #24
 800cf6a:	d411      	bmi.n	800cf90 <__swhatbuf_r+0x40>
 800cf6c:	2380      	movs	r3, #128	; 0x80
 800cf6e:	00db      	lsls	r3, r3, #3
 800cf70:	e00f      	b.n	800cf92 <__swhatbuf_r+0x42>
 800cf72:	466a      	mov	r2, sp
 800cf74:	f000 fc42 	bl	800d7fc <_fstat_r>
 800cf78:	2800      	cmp	r0, #0
 800cf7a:	dbf2      	blt.n	800cf62 <__swhatbuf_r+0x12>
 800cf7c:	22f0      	movs	r2, #240	; 0xf0
 800cf7e:	9b01      	ldr	r3, [sp, #4]
 800cf80:	0212      	lsls	r2, r2, #8
 800cf82:	4013      	ands	r3, r2
 800cf84:	4a05      	ldr	r2, [pc, #20]	; (800cf9c <__swhatbuf_r+0x4c>)
 800cf86:	189b      	adds	r3, r3, r2
 800cf88:	425a      	negs	r2, r3
 800cf8a:	4153      	adcs	r3, r2
 800cf8c:	602b      	str	r3, [r5, #0]
 800cf8e:	e7ed      	b.n	800cf6c <__swhatbuf_r+0x1c>
 800cf90:	2340      	movs	r3, #64	; 0x40
 800cf92:	2000      	movs	r0, #0
 800cf94:	6023      	str	r3, [r4, #0]
 800cf96:	b016      	add	sp, #88	; 0x58
 800cf98:	bd70      	pop	{r4, r5, r6, pc}
 800cf9a:	46c0      	nop			; (mov r8, r8)
 800cf9c:	ffffe000 	.word	0xffffe000

0800cfa0 <__smakebuf_r>:
 800cfa0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800cfa2:	2602      	movs	r6, #2
 800cfa4:	898b      	ldrh	r3, [r1, #12]
 800cfa6:	0005      	movs	r5, r0
 800cfa8:	000c      	movs	r4, r1
 800cfaa:	4233      	tst	r3, r6
 800cfac:	d006      	beq.n	800cfbc <__smakebuf_r+0x1c>
 800cfae:	0023      	movs	r3, r4
 800cfb0:	3347      	adds	r3, #71	; 0x47
 800cfb2:	6023      	str	r3, [r4, #0]
 800cfb4:	6123      	str	r3, [r4, #16]
 800cfb6:	2301      	movs	r3, #1
 800cfb8:	6163      	str	r3, [r4, #20]
 800cfba:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800cfbc:	ab01      	add	r3, sp, #4
 800cfbe:	466a      	mov	r2, sp
 800cfc0:	f7ff ffc6 	bl	800cf50 <__swhatbuf_r>
 800cfc4:	9900      	ldr	r1, [sp, #0]
 800cfc6:	0007      	movs	r7, r0
 800cfc8:	0028      	movs	r0, r5
 800cfca:	f000 f881 	bl	800d0d0 <_malloc_r>
 800cfce:	2800      	cmp	r0, #0
 800cfd0:	d108      	bne.n	800cfe4 <__smakebuf_r+0x44>
 800cfd2:	220c      	movs	r2, #12
 800cfd4:	5ea3      	ldrsh	r3, [r4, r2]
 800cfd6:	059a      	lsls	r2, r3, #22
 800cfd8:	d4ef      	bmi.n	800cfba <__smakebuf_r+0x1a>
 800cfda:	2203      	movs	r2, #3
 800cfdc:	4393      	bics	r3, r2
 800cfde:	431e      	orrs	r6, r3
 800cfe0:	81a6      	strh	r6, [r4, #12]
 800cfe2:	e7e4      	b.n	800cfae <__smakebuf_r+0xe>
 800cfe4:	4b0f      	ldr	r3, [pc, #60]	; (800d024 <__smakebuf_r+0x84>)
 800cfe6:	62ab      	str	r3, [r5, #40]	; 0x28
 800cfe8:	2380      	movs	r3, #128	; 0x80
 800cfea:	89a2      	ldrh	r2, [r4, #12]
 800cfec:	6020      	str	r0, [r4, #0]
 800cfee:	4313      	orrs	r3, r2
 800cff0:	81a3      	strh	r3, [r4, #12]
 800cff2:	9b00      	ldr	r3, [sp, #0]
 800cff4:	6120      	str	r0, [r4, #16]
 800cff6:	6163      	str	r3, [r4, #20]
 800cff8:	9b01      	ldr	r3, [sp, #4]
 800cffa:	2b00      	cmp	r3, #0
 800cffc:	d00d      	beq.n	800d01a <__smakebuf_r+0x7a>
 800cffe:	230e      	movs	r3, #14
 800d000:	5ee1      	ldrsh	r1, [r4, r3]
 800d002:	0028      	movs	r0, r5
 800d004:	f000 fc0c 	bl	800d820 <_isatty_r>
 800d008:	2800      	cmp	r0, #0
 800d00a:	d006      	beq.n	800d01a <__smakebuf_r+0x7a>
 800d00c:	2203      	movs	r2, #3
 800d00e:	89a3      	ldrh	r3, [r4, #12]
 800d010:	4393      	bics	r3, r2
 800d012:	001a      	movs	r2, r3
 800d014:	2301      	movs	r3, #1
 800d016:	4313      	orrs	r3, r2
 800d018:	81a3      	strh	r3, [r4, #12]
 800d01a:	89a0      	ldrh	r0, [r4, #12]
 800d01c:	4338      	orrs	r0, r7
 800d01e:	81a0      	strh	r0, [r4, #12]
 800d020:	e7cb      	b.n	800cfba <__smakebuf_r+0x1a>
 800d022:	46c0      	nop			; (mov r8, r8)
 800d024:	0800cded 	.word	0x0800cded

0800d028 <malloc>:
 800d028:	b510      	push	{r4, lr}
 800d02a:	4b03      	ldr	r3, [pc, #12]	; (800d038 <malloc+0x10>)
 800d02c:	0001      	movs	r1, r0
 800d02e:	6818      	ldr	r0, [r3, #0]
 800d030:	f000 f84e 	bl	800d0d0 <_malloc_r>
 800d034:	bd10      	pop	{r4, pc}
 800d036:	46c0      	nop			; (mov r8, r8)
 800d038:	20000004 	.word	0x20000004

0800d03c <_free_r>:
 800d03c:	b570      	push	{r4, r5, r6, lr}
 800d03e:	0005      	movs	r5, r0
 800d040:	2900      	cmp	r1, #0
 800d042:	d010      	beq.n	800d066 <_free_r+0x2a>
 800d044:	1f0c      	subs	r4, r1, #4
 800d046:	6823      	ldr	r3, [r4, #0]
 800d048:	2b00      	cmp	r3, #0
 800d04a:	da00      	bge.n	800d04e <_free_r+0x12>
 800d04c:	18e4      	adds	r4, r4, r3
 800d04e:	0028      	movs	r0, r5
 800d050:	f000 fc17 	bl	800d882 <__malloc_lock>
 800d054:	4a1d      	ldr	r2, [pc, #116]	; (800d0cc <_free_r+0x90>)
 800d056:	6813      	ldr	r3, [r2, #0]
 800d058:	2b00      	cmp	r3, #0
 800d05a:	d105      	bne.n	800d068 <_free_r+0x2c>
 800d05c:	6063      	str	r3, [r4, #4]
 800d05e:	6014      	str	r4, [r2, #0]
 800d060:	0028      	movs	r0, r5
 800d062:	f000 fc0f 	bl	800d884 <__malloc_unlock>
 800d066:	bd70      	pop	{r4, r5, r6, pc}
 800d068:	42a3      	cmp	r3, r4
 800d06a:	d909      	bls.n	800d080 <_free_r+0x44>
 800d06c:	6821      	ldr	r1, [r4, #0]
 800d06e:	1860      	adds	r0, r4, r1
 800d070:	4283      	cmp	r3, r0
 800d072:	d1f3      	bne.n	800d05c <_free_r+0x20>
 800d074:	6818      	ldr	r0, [r3, #0]
 800d076:	685b      	ldr	r3, [r3, #4]
 800d078:	1841      	adds	r1, r0, r1
 800d07a:	6021      	str	r1, [r4, #0]
 800d07c:	e7ee      	b.n	800d05c <_free_r+0x20>
 800d07e:	0013      	movs	r3, r2
 800d080:	685a      	ldr	r2, [r3, #4]
 800d082:	2a00      	cmp	r2, #0
 800d084:	d001      	beq.n	800d08a <_free_r+0x4e>
 800d086:	42a2      	cmp	r2, r4
 800d088:	d9f9      	bls.n	800d07e <_free_r+0x42>
 800d08a:	6819      	ldr	r1, [r3, #0]
 800d08c:	1858      	adds	r0, r3, r1
 800d08e:	42a0      	cmp	r0, r4
 800d090:	d10b      	bne.n	800d0aa <_free_r+0x6e>
 800d092:	6820      	ldr	r0, [r4, #0]
 800d094:	1809      	adds	r1, r1, r0
 800d096:	1858      	adds	r0, r3, r1
 800d098:	6019      	str	r1, [r3, #0]
 800d09a:	4282      	cmp	r2, r0
 800d09c:	d1e0      	bne.n	800d060 <_free_r+0x24>
 800d09e:	6810      	ldr	r0, [r2, #0]
 800d0a0:	6852      	ldr	r2, [r2, #4]
 800d0a2:	1841      	adds	r1, r0, r1
 800d0a4:	6019      	str	r1, [r3, #0]
 800d0a6:	605a      	str	r2, [r3, #4]
 800d0a8:	e7da      	b.n	800d060 <_free_r+0x24>
 800d0aa:	42a0      	cmp	r0, r4
 800d0ac:	d902      	bls.n	800d0b4 <_free_r+0x78>
 800d0ae:	230c      	movs	r3, #12
 800d0b0:	602b      	str	r3, [r5, #0]
 800d0b2:	e7d5      	b.n	800d060 <_free_r+0x24>
 800d0b4:	6821      	ldr	r1, [r4, #0]
 800d0b6:	1860      	adds	r0, r4, r1
 800d0b8:	4282      	cmp	r2, r0
 800d0ba:	d103      	bne.n	800d0c4 <_free_r+0x88>
 800d0bc:	6810      	ldr	r0, [r2, #0]
 800d0be:	6852      	ldr	r2, [r2, #4]
 800d0c0:	1841      	adds	r1, r0, r1
 800d0c2:	6021      	str	r1, [r4, #0]
 800d0c4:	6062      	str	r2, [r4, #4]
 800d0c6:	605c      	str	r4, [r3, #4]
 800d0c8:	e7ca      	b.n	800d060 <_free_r+0x24>
 800d0ca:	46c0      	nop			; (mov r8, r8)
 800d0cc:	20000088 	.word	0x20000088

0800d0d0 <_malloc_r>:
 800d0d0:	2303      	movs	r3, #3
 800d0d2:	b570      	push	{r4, r5, r6, lr}
 800d0d4:	1ccd      	adds	r5, r1, #3
 800d0d6:	439d      	bics	r5, r3
 800d0d8:	3508      	adds	r5, #8
 800d0da:	0006      	movs	r6, r0
 800d0dc:	2d0c      	cmp	r5, #12
 800d0de:	d21e      	bcs.n	800d11e <_malloc_r+0x4e>
 800d0e0:	250c      	movs	r5, #12
 800d0e2:	42a9      	cmp	r1, r5
 800d0e4:	d81d      	bhi.n	800d122 <_malloc_r+0x52>
 800d0e6:	0030      	movs	r0, r6
 800d0e8:	f000 fbcb 	bl	800d882 <__malloc_lock>
 800d0ec:	4a25      	ldr	r2, [pc, #148]	; (800d184 <_malloc_r+0xb4>)
 800d0ee:	6814      	ldr	r4, [r2, #0]
 800d0f0:	0021      	movs	r1, r4
 800d0f2:	2900      	cmp	r1, #0
 800d0f4:	d119      	bne.n	800d12a <_malloc_r+0x5a>
 800d0f6:	4c24      	ldr	r4, [pc, #144]	; (800d188 <_malloc_r+0xb8>)
 800d0f8:	6823      	ldr	r3, [r4, #0]
 800d0fa:	2b00      	cmp	r3, #0
 800d0fc:	d103      	bne.n	800d106 <_malloc_r+0x36>
 800d0fe:	0030      	movs	r0, r6
 800d100:	f000 faf8 	bl	800d6f4 <_sbrk_r>
 800d104:	6020      	str	r0, [r4, #0]
 800d106:	0029      	movs	r1, r5
 800d108:	0030      	movs	r0, r6
 800d10a:	f000 faf3 	bl	800d6f4 <_sbrk_r>
 800d10e:	1c43      	adds	r3, r0, #1
 800d110:	d12b      	bne.n	800d16a <_malloc_r+0x9a>
 800d112:	230c      	movs	r3, #12
 800d114:	0030      	movs	r0, r6
 800d116:	6033      	str	r3, [r6, #0]
 800d118:	f000 fbb4 	bl	800d884 <__malloc_unlock>
 800d11c:	e003      	b.n	800d126 <_malloc_r+0x56>
 800d11e:	2d00      	cmp	r5, #0
 800d120:	dadf      	bge.n	800d0e2 <_malloc_r+0x12>
 800d122:	230c      	movs	r3, #12
 800d124:	6033      	str	r3, [r6, #0]
 800d126:	2000      	movs	r0, #0
 800d128:	bd70      	pop	{r4, r5, r6, pc}
 800d12a:	680b      	ldr	r3, [r1, #0]
 800d12c:	1b5b      	subs	r3, r3, r5
 800d12e:	d419      	bmi.n	800d164 <_malloc_r+0x94>
 800d130:	2b0b      	cmp	r3, #11
 800d132:	d903      	bls.n	800d13c <_malloc_r+0x6c>
 800d134:	600b      	str	r3, [r1, #0]
 800d136:	18cc      	adds	r4, r1, r3
 800d138:	6025      	str	r5, [r4, #0]
 800d13a:	e003      	b.n	800d144 <_malloc_r+0x74>
 800d13c:	684b      	ldr	r3, [r1, #4]
 800d13e:	428c      	cmp	r4, r1
 800d140:	d10d      	bne.n	800d15e <_malloc_r+0x8e>
 800d142:	6013      	str	r3, [r2, #0]
 800d144:	0030      	movs	r0, r6
 800d146:	f000 fb9d 	bl	800d884 <__malloc_unlock>
 800d14a:	0020      	movs	r0, r4
 800d14c:	2207      	movs	r2, #7
 800d14e:	300b      	adds	r0, #11
 800d150:	1d23      	adds	r3, r4, #4
 800d152:	4390      	bics	r0, r2
 800d154:	1ac3      	subs	r3, r0, r3
 800d156:	d0e7      	beq.n	800d128 <_malloc_r+0x58>
 800d158:	425a      	negs	r2, r3
 800d15a:	50e2      	str	r2, [r4, r3]
 800d15c:	e7e4      	b.n	800d128 <_malloc_r+0x58>
 800d15e:	6063      	str	r3, [r4, #4]
 800d160:	000c      	movs	r4, r1
 800d162:	e7ef      	b.n	800d144 <_malloc_r+0x74>
 800d164:	000c      	movs	r4, r1
 800d166:	6849      	ldr	r1, [r1, #4]
 800d168:	e7c3      	b.n	800d0f2 <_malloc_r+0x22>
 800d16a:	2303      	movs	r3, #3
 800d16c:	1cc4      	adds	r4, r0, #3
 800d16e:	439c      	bics	r4, r3
 800d170:	42a0      	cmp	r0, r4
 800d172:	d0e1      	beq.n	800d138 <_malloc_r+0x68>
 800d174:	1a21      	subs	r1, r4, r0
 800d176:	0030      	movs	r0, r6
 800d178:	f000 fabc 	bl	800d6f4 <_sbrk_r>
 800d17c:	1c43      	adds	r3, r0, #1
 800d17e:	d1db      	bne.n	800d138 <_malloc_r+0x68>
 800d180:	e7c7      	b.n	800d112 <_malloc_r+0x42>
 800d182:	46c0      	nop			; (mov r8, r8)
 800d184:	20000088 	.word	0x20000088
 800d188:	2000008c 	.word	0x2000008c

0800d18c <__sfputc_r>:
 800d18c:	6893      	ldr	r3, [r2, #8]
 800d18e:	b510      	push	{r4, lr}
 800d190:	3b01      	subs	r3, #1
 800d192:	6093      	str	r3, [r2, #8]
 800d194:	2b00      	cmp	r3, #0
 800d196:	da04      	bge.n	800d1a2 <__sfputc_r+0x16>
 800d198:	6994      	ldr	r4, [r2, #24]
 800d19a:	42a3      	cmp	r3, r4
 800d19c:	db07      	blt.n	800d1ae <__sfputc_r+0x22>
 800d19e:	290a      	cmp	r1, #10
 800d1a0:	d005      	beq.n	800d1ae <__sfputc_r+0x22>
 800d1a2:	6813      	ldr	r3, [r2, #0]
 800d1a4:	1c58      	adds	r0, r3, #1
 800d1a6:	6010      	str	r0, [r2, #0]
 800d1a8:	7019      	strb	r1, [r3, #0]
 800d1aa:	0008      	movs	r0, r1
 800d1ac:	bd10      	pop	{r4, pc}
 800d1ae:	f7ff fc77 	bl	800caa0 <__swbuf_r>
 800d1b2:	0001      	movs	r1, r0
 800d1b4:	e7f9      	b.n	800d1aa <__sfputc_r+0x1e>

0800d1b6 <__sfputs_r>:
 800d1b6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d1b8:	0006      	movs	r6, r0
 800d1ba:	000f      	movs	r7, r1
 800d1bc:	0014      	movs	r4, r2
 800d1be:	18d5      	adds	r5, r2, r3
 800d1c0:	42ac      	cmp	r4, r5
 800d1c2:	d101      	bne.n	800d1c8 <__sfputs_r+0x12>
 800d1c4:	2000      	movs	r0, #0
 800d1c6:	e007      	b.n	800d1d8 <__sfputs_r+0x22>
 800d1c8:	7821      	ldrb	r1, [r4, #0]
 800d1ca:	003a      	movs	r2, r7
 800d1cc:	0030      	movs	r0, r6
 800d1ce:	f7ff ffdd 	bl	800d18c <__sfputc_r>
 800d1d2:	3401      	adds	r4, #1
 800d1d4:	1c43      	adds	r3, r0, #1
 800d1d6:	d1f3      	bne.n	800d1c0 <__sfputs_r+0xa>
 800d1d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0800d1dc <_vfiprintf_r>:
 800d1dc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d1de:	b0a1      	sub	sp, #132	; 0x84
 800d1e0:	9003      	str	r0, [sp, #12]
 800d1e2:	000f      	movs	r7, r1
 800d1e4:	0016      	movs	r6, r2
 800d1e6:	001d      	movs	r5, r3
 800d1e8:	2800      	cmp	r0, #0
 800d1ea:	d005      	beq.n	800d1f8 <_vfiprintf_r+0x1c>
 800d1ec:	6983      	ldr	r3, [r0, #24]
 800d1ee:	9305      	str	r3, [sp, #20]
 800d1f0:	2b00      	cmp	r3, #0
 800d1f2:	d101      	bne.n	800d1f8 <_vfiprintf_r+0x1c>
 800d1f4:	f7ff fe18 	bl	800ce28 <__sinit>
 800d1f8:	4b7b      	ldr	r3, [pc, #492]	; (800d3e8 <_vfiprintf_r+0x20c>)
 800d1fa:	429f      	cmp	r7, r3
 800d1fc:	d15c      	bne.n	800d2b8 <_vfiprintf_r+0xdc>
 800d1fe:	9b03      	ldr	r3, [sp, #12]
 800d200:	685f      	ldr	r7, [r3, #4]
 800d202:	89bb      	ldrh	r3, [r7, #12]
 800d204:	071b      	lsls	r3, r3, #28
 800d206:	d563      	bpl.n	800d2d0 <_vfiprintf_r+0xf4>
 800d208:	693b      	ldr	r3, [r7, #16]
 800d20a:	2b00      	cmp	r3, #0
 800d20c:	d060      	beq.n	800d2d0 <_vfiprintf_r+0xf4>
 800d20e:	2300      	movs	r3, #0
 800d210:	ac08      	add	r4, sp, #32
 800d212:	6163      	str	r3, [r4, #20]
 800d214:	3320      	adds	r3, #32
 800d216:	7663      	strb	r3, [r4, #25]
 800d218:	3310      	adds	r3, #16
 800d21a:	76a3      	strb	r3, [r4, #26]
 800d21c:	9507      	str	r5, [sp, #28]
 800d21e:	0035      	movs	r5, r6
 800d220:	782b      	ldrb	r3, [r5, #0]
 800d222:	2b00      	cmp	r3, #0
 800d224:	d001      	beq.n	800d22a <_vfiprintf_r+0x4e>
 800d226:	2b25      	cmp	r3, #37	; 0x25
 800d228:	d15c      	bne.n	800d2e4 <_vfiprintf_r+0x108>
 800d22a:	1bab      	subs	r3, r5, r6
 800d22c:	9305      	str	r3, [sp, #20]
 800d22e:	d00c      	beq.n	800d24a <_vfiprintf_r+0x6e>
 800d230:	0032      	movs	r2, r6
 800d232:	0039      	movs	r1, r7
 800d234:	9803      	ldr	r0, [sp, #12]
 800d236:	f7ff ffbe 	bl	800d1b6 <__sfputs_r>
 800d23a:	1c43      	adds	r3, r0, #1
 800d23c:	d100      	bne.n	800d240 <_vfiprintf_r+0x64>
 800d23e:	e0c4      	b.n	800d3ca <_vfiprintf_r+0x1ee>
 800d240:	6962      	ldr	r2, [r4, #20]
 800d242:	9b05      	ldr	r3, [sp, #20]
 800d244:	4694      	mov	ip, r2
 800d246:	4463      	add	r3, ip
 800d248:	6163      	str	r3, [r4, #20]
 800d24a:	782b      	ldrb	r3, [r5, #0]
 800d24c:	2b00      	cmp	r3, #0
 800d24e:	d100      	bne.n	800d252 <_vfiprintf_r+0x76>
 800d250:	e0bb      	b.n	800d3ca <_vfiprintf_r+0x1ee>
 800d252:	2201      	movs	r2, #1
 800d254:	2300      	movs	r3, #0
 800d256:	4252      	negs	r2, r2
 800d258:	6062      	str	r2, [r4, #4]
 800d25a:	a904      	add	r1, sp, #16
 800d25c:	3254      	adds	r2, #84	; 0x54
 800d25e:	1852      	adds	r2, r2, r1
 800d260:	1c6e      	adds	r6, r5, #1
 800d262:	6023      	str	r3, [r4, #0]
 800d264:	60e3      	str	r3, [r4, #12]
 800d266:	60a3      	str	r3, [r4, #8]
 800d268:	7013      	strb	r3, [r2, #0]
 800d26a:	65a3      	str	r3, [r4, #88]	; 0x58
 800d26c:	7831      	ldrb	r1, [r6, #0]
 800d26e:	2205      	movs	r2, #5
 800d270:	485e      	ldr	r0, [pc, #376]	; (800d3ec <_vfiprintf_r+0x210>)
 800d272:	f000 fafb 	bl	800d86c <memchr>
 800d276:	1c75      	adds	r5, r6, #1
 800d278:	2800      	cmp	r0, #0
 800d27a:	d135      	bne.n	800d2e8 <_vfiprintf_r+0x10c>
 800d27c:	6822      	ldr	r2, [r4, #0]
 800d27e:	06d3      	lsls	r3, r2, #27
 800d280:	d504      	bpl.n	800d28c <_vfiprintf_r+0xb0>
 800d282:	2353      	movs	r3, #83	; 0x53
 800d284:	a904      	add	r1, sp, #16
 800d286:	185b      	adds	r3, r3, r1
 800d288:	2120      	movs	r1, #32
 800d28a:	7019      	strb	r1, [r3, #0]
 800d28c:	0713      	lsls	r3, r2, #28
 800d28e:	d504      	bpl.n	800d29a <_vfiprintf_r+0xbe>
 800d290:	2353      	movs	r3, #83	; 0x53
 800d292:	a904      	add	r1, sp, #16
 800d294:	185b      	adds	r3, r3, r1
 800d296:	212b      	movs	r1, #43	; 0x2b
 800d298:	7019      	strb	r1, [r3, #0]
 800d29a:	7833      	ldrb	r3, [r6, #0]
 800d29c:	2b2a      	cmp	r3, #42	; 0x2a
 800d29e:	d02c      	beq.n	800d2fa <_vfiprintf_r+0x11e>
 800d2a0:	0035      	movs	r5, r6
 800d2a2:	2100      	movs	r1, #0
 800d2a4:	200a      	movs	r0, #10
 800d2a6:	68e3      	ldr	r3, [r4, #12]
 800d2a8:	782a      	ldrb	r2, [r5, #0]
 800d2aa:	1c6e      	adds	r6, r5, #1
 800d2ac:	3a30      	subs	r2, #48	; 0x30
 800d2ae:	2a09      	cmp	r2, #9
 800d2b0:	d964      	bls.n	800d37c <_vfiprintf_r+0x1a0>
 800d2b2:	2900      	cmp	r1, #0
 800d2b4:	d02e      	beq.n	800d314 <_vfiprintf_r+0x138>
 800d2b6:	e026      	b.n	800d306 <_vfiprintf_r+0x12a>
 800d2b8:	4b4d      	ldr	r3, [pc, #308]	; (800d3f0 <_vfiprintf_r+0x214>)
 800d2ba:	429f      	cmp	r7, r3
 800d2bc:	d102      	bne.n	800d2c4 <_vfiprintf_r+0xe8>
 800d2be:	9b03      	ldr	r3, [sp, #12]
 800d2c0:	689f      	ldr	r7, [r3, #8]
 800d2c2:	e79e      	b.n	800d202 <_vfiprintf_r+0x26>
 800d2c4:	4b4b      	ldr	r3, [pc, #300]	; (800d3f4 <_vfiprintf_r+0x218>)
 800d2c6:	429f      	cmp	r7, r3
 800d2c8:	d19b      	bne.n	800d202 <_vfiprintf_r+0x26>
 800d2ca:	9b03      	ldr	r3, [sp, #12]
 800d2cc:	68df      	ldr	r7, [r3, #12]
 800d2ce:	e798      	b.n	800d202 <_vfiprintf_r+0x26>
 800d2d0:	0039      	movs	r1, r7
 800d2d2:	9803      	ldr	r0, [sp, #12]
 800d2d4:	f7ff fc3a 	bl	800cb4c <__swsetup_r>
 800d2d8:	2800      	cmp	r0, #0
 800d2da:	d098      	beq.n	800d20e <_vfiprintf_r+0x32>
 800d2dc:	2001      	movs	r0, #1
 800d2de:	4240      	negs	r0, r0
 800d2e0:	b021      	add	sp, #132	; 0x84
 800d2e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d2e4:	3501      	adds	r5, #1
 800d2e6:	e79b      	b.n	800d220 <_vfiprintf_r+0x44>
 800d2e8:	4b40      	ldr	r3, [pc, #256]	; (800d3ec <_vfiprintf_r+0x210>)
 800d2ea:	6822      	ldr	r2, [r4, #0]
 800d2ec:	1ac0      	subs	r0, r0, r3
 800d2ee:	2301      	movs	r3, #1
 800d2f0:	4083      	lsls	r3, r0
 800d2f2:	4313      	orrs	r3, r2
 800d2f4:	6023      	str	r3, [r4, #0]
 800d2f6:	002e      	movs	r6, r5
 800d2f8:	e7b8      	b.n	800d26c <_vfiprintf_r+0x90>
 800d2fa:	9b07      	ldr	r3, [sp, #28]
 800d2fc:	1d19      	adds	r1, r3, #4
 800d2fe:	681b      	ldr	r3, [r3, #0]
 800d300:	9107      	str	r1, [sp, #28]
 800d302:	2b00      	cmp	r3, #0
 800d304:	db01      	blt.n	800d30a <_vfiprintf_r+0x12e>
 800d306:	930b      	str	r3, [sp, #44]	; 0x2c
 800d308:	e004      	b.n	800d314 <_vfiprintf_r+0x138>
 800d30a:	425b      	negs	r3, r3
 800d30c:	60e3      	str	r3, [r4, #12]
 800d30e:	2302      	movs	r3, #2
 800d310:	4313      	orrs	r3, r2
 800d312:	6023      	str	r3, [r4, #0]
 800d314:	782b      	ldrb	r3, [r5, #0]
 800d316:	2b2e      	cmp	r3, #46	; 0x2e
 800d318:	d10a      	bne.n	800d330 <_vfiprintf_r+0x154>
 800d31a:	786b      	ldrb	r3, [r5, #1]
 800d31c:	2b2a      	cmp	r3, #42	; 0x2a
 800d31e:	d135      	bne.n	800d38c <_vfiprintf_r+0x1b0>
 800d320:	9b07      	ldr	r3, [sp, #28]
 800d322:	3502      	adds	r5, #2
 800d324:	1d1a      	adds	r2, r3, #4
 800d326:	681b      	ldr	r3, [r3, #0]
 800d328:	9207      	str	r2, [sp, #28]
 800d32a:	2b00      	cmp	r3, #0
 800d32c:	db2b      	blt.n	800d386 <_vfiprintf_r+0x1aa>
 800d32e:	9309      	str	r3, [sp, #36]	; 0x24
 800d330:	4e31      	ldr	r6, [pc, #196]	; (800d3f8 <_vfiprintf_r+0x21c>)
 800d332:	7829      	ldrb	r1, [r5, #0]
 800d334:	2203      	movs	r2, #3
 800d336:	0030      	movs	r0, r6
 800d338:	f000 fa98 	bl	800d86c <memchr>
 800d33c:	2800      	cmp	r0, #0
 800d33e:	d006      	beq.n	800d34e <_vfiprintf_r+0x172>
 800d340:	2340      	movs	r3, #64	; 0x40
 800d342:	1b80      	subs	r0, r0, r6
 800d344:	4083      	lsls	r3, r0
 800d346:	6822      	ldr	r2, [r4, #0]
 800d348:	3501      	adds	r5, #1
 800d34a:	4313      	orrs	r3, r2
 800d34c:	6023      	str	r3, [r4, #0]
 800d34e:	7829      	ldrb	r1, [r5, #0]
 800d350:	2206      	movs	r2, #6
 800d352:	482a      	ldr	r0, [pc, #168]	; (800d3fc <_vfiprintf_r+0x220>)
 800d354:	1c6e      	adds	r6, r5, #1
 800d356:	7621      	strb	r1, [r4, #24]
 800d358:	f000 fa88 	bl	800d86c <memchr>
 800d35c:	2800      	cmp	r0, #0
 800d35e:	d03a      	beq.n	800d3d6 <_vfiprintf_r+0x1fa>
 800d360:	4b27      	ldr	r3, [pc, #156]	; (800d400 <_vfiprintf_r+0x224>)
 800d362:	2b00      	cmp	r3, #0
 800d364:	d125      	bne.n	800d3b2 <_vfiprintf_r+0x1d6>
 800d366:	2207      	movs	r2, #7
 800d368:	9b07      	ldr	r3, [sp, #28]
 800d36a:	3307      	adds	r3, #7
 800d36c:	4393      	bics	r3, r2
 800d36e:	3308      	adds	r3, #8
 800d370:	9307      	str	r3, [sp, #28]
 800d372:	6963      	ldr	r3, [r4, #20]
 800d374:	9a04      	ldr	r2, [sp, #16]
 800d376:	189b      	adds	r3, r3, r2
 800d378:	6163      	str	r3, [r4, #20]
 800d37a:	e750      	b.n	800d21e <_vfiprintf_r+0x42>
 800d37c:	4343      	muls	r3, r0
 800d37e:	2101      	movs	r1, #1
 800d380:	189b      	adds	r3, r3, r2
 800d382:	0035      	movs	r5, r6
 800d384:	e790      	b.n	800d2a8 <_vfiprintf_r+0xcc>
 800d386:	2301      	movs	r3, #1
 800d388:	425b      	negs	r3, r3
 800d38a:	e7d0      	b.n	800d32e <_vfiprintf_r+0x152>
 800d38c:	2300      	movs	r3, #0
 800d38e:	200a      	movs	r0, #10
 800d390:	001a      	movs	r2, r3
 800d392:	3501      	adds	r5, #1
 800d394:	6063      	str	r3, [r4, #4]
 800d396:	7829      	ldrb	r1, [r5, #0]
 800d398:	1c6e      	adds	r6, r5, #1
 800d39a:	3930      	subs	r1, #48	; 0x30
 800d39c:	2909      	cmp	r1, #9
 800d39e:	d903      	bls.n	800d3a8 <_vfiprintf_r+0x1cc>
 800d3a0:	2b00      	cmp	r3, #0
 800d3a2:	d0c5      	beq.n	800d330 <_vfiprintf_r+0x154>
 800d3a4:	9209      	str	r2, [sp, #36]	; 0x24
 800d3a6:	e7c3      	b.n	800d330 <_vfiprintf_r+0x154>
 800d3a8:	4342      	muls	r2, r0
 800d3aa:	2301      	movs	r3, #1
 800d3ac:	1852      	adds	r2, r2, r1
 800d3ae:	0035      	movs	r5, r6
 800d3b0:	e7f1      	b.n	800d396 <_vfiprintf_r+0x1ba>
 800d3b2:	ab07      	add	r3, sp, #28
 800d3b4:	9300      	str	r3, [sp, #0]
 800d3b6:	003a      	movs	r2, r7
 800d3b8:	4b12      	ldr	r3, [pc, #72]	; (800d404 <_vfiprintf_r+0x228>)
 800d3ba:	0021      	movs	r1, r4
 800d3bc:	9803      	ldr	r0, [sp, #12]
 800d3be:	e000      	b.n	800d3c2 <_vfiprintf_r+0x1e6>
 800d3c0:	bf00      	nop
 800d3c2:	9004      	str	r0, [sp, #16]
 800d3c4:	9b04      	ldr	r3, [sp, #16]
 800d3c6:	3301      	adds	r3, #1
 800d3c8:	d1d3      	bne.n	800d372 <_vfiprintf_r+0x196>
 800d3ca:	89bb      	ldrh	r3, [r7, #12]
 800d3cc:	065b      	lsls	r3, r3, #25
 800d3ce:	d500      	bpl.n	800d3d2 <_vfiprintf_r+0x1f6>
 800d3d0:	e784      	b.n	800d2dc <_vfiprintf_r+0x100>
 800d3d2:	980d      	ldr	r0, [sp, #52]	; 0x34
 800d3d4:	e784      	b.n	800d2e0 <_vfiprintf_r+0x104>
 800d3d6:	ab07      	add	r3, sp, #28
 800d3d8:	9300      	str	r3, [sp, #0]
 800d3da:	003a      	movs	r2, r7
 800d3dc:	4b09      	ldr	r3, [pc, #36]	; (800d404 <_vfiprintf_r+0x228>)
 800d3de:	0021      	movs	r1, r4
 800d3e0:	9803      	ldr	r0, [sp, #12]
 800d3e2:	f000 f87f 	bl	800d4e4 <_printf_i>
 800d3e6:	e7ec      	b.n	800d3c2 <_vfiprintf_r+0x1e6>
 800d3e8:	0800e6f4 	.word	0x0800e6f4
 800d3ec:	0800e734 	.word	0x0800e734
 800d3f0:	0800e714 	.word	0x0800e714
 800d3f4:	0800e6d4 	.word	0x0800e6d4
 800d3f8:	0800e73a 	.word	0x0800e73a
 800d3fc:	0800e73e 	.word	0x0800e73e
 800d400:	00000000 	.word	0x00000000
 800d404:	0800d1b7 	.word	0x0800d1b7

0800d408 <_printf_common>:
 800d408:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800d40a:	0015      	movs	r5, r2
 800d40c:	9301      	str	r3, [sp, #4]
 800d40e:	688a      	ldr	r2, [r1, #8]
 800d410:	690b      	ldr	r3, [r1, #16]
 800d412:	9000      	str	r0, [sp, #0]
 800d414:	000c      	movs	r4, r1
 800d416:	4293      	cmp	r3, r2
 800d418:	da00      	bge.n	800d41c <_printf_common+0x14>
 800d41a:	0013      	movs	r3, r2
 800d41c:	0022      	movs	r2, r4
 800d41e:	602b      	str	r3, [r5, #0]
 800d420:	3243      	adds	r2, #67	; 0x43
 800d422:	7812      	ldrb	r2, [r2, #0]
 800d424:	2a00      	cmp	r2, #0
 800d426:	d001      	beq.n	800d42c <_printf_common+0x24>
 800d428:	3301      	adds	r3, #1
 800d42a:	602b      	str	r3, [r5, #0]
 800d42c:	6823      	ldr	r3, [r4, #0]
 800d42e:	069b      	lsls	r3, r3, #26
 800d430:	d502      	bpl.n	800d438 <_printf_common+0x30>
 800d432:	682b      	ldr	r3, [r5, #0]
 800d434:	3302      	adds	r3, #2
 800d436:	602b      	str	r3, [r5, #0]
 800d438:	2706      	movs	r7, #6
 800d43a:	6823      	ldr	r3, [r4, #0]
 800d43c:	401f      	ands	r7, r3
 800d43e:	d027      	beq.n	800d490 <_printf_common+0x88>
 800d440:	0023      	movs	r3, r4
 800d442:	3343      	adds	r3, #67	; 0x43
 800d444:	781b      	ldrb	r3, [r3, #0]
 800d446:	1e5a      	subs	r2, r3, #1
 800d448:	4193      	sbcs	r3, r2
 800d44a:	6822      	ldr	r2, [r4, #0]
 800d44c:	0692      	lsls	r2, r2, #26
 800d44e:	d430      	bmi.n	800d4b2 <_printf_common+0xaa>
 800d450:	0022      	movs	r2, r4
 800d452:	9901      	ldr	r1, [sp, #4]
 800d454:	3243      	adds	r2, #67	; 0x43
 800d456:	9800      	ldr	r0, [sp, #0]
 800d458:	9e08      	ldr	r6, [sp, #32]
 800d45a:	47b0      	blx	r6
 800d45c:	1c43      	adds	r3, r0, #1
 800d45e:	d025      	beq.n	800d4ac <_printf_common+0xa4>
 800d460:	2306      	movs	r3, #6
 800d462:	6820      	ldr	r0, [r4, #0]
 800d464:	682a      	ldr	r2, [r5, #0]
 800d466:	68e1      	ldr	r1, [r4, #12]
 800d468:	4003      	ands	r3, r0
 800d46a:	2500      	movs	r5, #0
 800d46c:	2b04      	cmp	r3, #4
 800d46e:	d103      	bne.n	800d478 <_printf_common+0x70>
 800d470:	1a8d      	subs	r5, r1, r2
 800d472:	43eb      	mvns	r3, r5
 800d474:	17db      	asrs	r3, r3, #31
 800d476:	401d      	ands	r5, r3
 800d478:	68a3      	ldr	r3, [r4, #8]
 800d47a:	6922      	ldr	r2, [r4, #16]
 800d47c:	4293      	cmp	r3, r2
 800d47e:	dd01      	ble.n	800d484 <_printf_common+0x7c>
 800d480:	1a9b      	subs	r3, r3, r2
 800d482:	18ed      	adds	r5, r5, r3
 800d484:	2700      	movs	r7, #0
 800d486:	42bd      	cmp	r5, r7
 800d488:	d120      	bne.n	800d4cc <_printf_common+0xc4>
 800d48a:	2000      	movs	r0, #0
 800d48c:	e010      	b.n	800d4b0 <_printf_common+0xa8>
 800d48e:	3701      	adds	r7, #1
 800d490:	68e3      	ldr	r3, [r4, #12]
 800d492:	682a      	ldr	r2, [r5, #0]
 800d494:	1a9b      	subs	r3, r3, r2
 800d496:	42bb      	cmp	r3, r7
 800d498:	ddd2      	ble.n	800d440 <_printf_common+0x38>
 800d49a:	0022      	movs	r2, r4
 800d49c:	2301      	movs	r3, #1
 800d49e:	3219      	adds	r2, #25
 800d4a0:	9901      	ldr	r1, [sp, #4]
 800d4a2:	9800      	ldr	r0, [sp, #0]
 800d4a4:	9e08      	ldr	r6, [sp, #32]
 800d4a6:	47b0      	blx	r6
 800d4a8:	1c43      	adds	r3, r0, #1
 800d4aa:	d1f0      	bne.n	800d48e <_printf_common+0x86>
 800d4ac:	2001      	movs	r0, #1
 800d4ae:	4240      	negs	r0, r0
 800d4b0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800d4b2:	2030      	movs	r0, #48	; 0x30
 800d4b4:	18e1      	adds	r1, r4, r3
 800d4b6:	3143      	adds	r1, #67	; 0x43
 800d4b8:	7008      	strb	r0, [r1, #0]
 800d4ba:	0021      	movs	r1, r4
 800d4bc:	1c5a      	adds	r2, r3, #1
 800d4be:	3145      	adds	r1, #69	; 0x45
 800d4c0:	7809      	ldrb	r1, [r1, #0]
 800d4c2:	18a2      	adds	r2, r4, r2
 800d4c4:	3243      	adds	r2, #67	; 0x43
 800d4c6:	3302      	adds	r3, #2
 800d4c8:	7011      	strb	r1, [r2, #0]
 800d4ca:	e7c1      	b.n	800d450 <_printf_common+0x48>
 800d4cc:	0022      	movs	r2, r4
 800d4ce:	2301      	movs	r3, #1
 800d4d0:	321a      	adds	r2, #26
 800d4d2:	9901      	ldr	r1, [sp, #4]
 800d4d4:	9800      	ldr	r0, [sp, #0]
 800d4d6:	9e08      	ldr	r6, [sp, #32]
 800d4d8:	47b0      	blx	r6
 800d4da:	1c43      	adds	r3, r0, #1
 800d4dc:	d0e6      	beq.n	800d4ac <_printf_common+0xa4>
 800d4de:	3701      	adds	r7, #1
 800d4e0:	e7d1      	b.n	800d486 <_printf_common+0x7e>
	...

0800d4e4 <_printf_i>:
 800d4e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d4e6:	b089      	sub	sp, #36	; 0x24
 800d4e8:	9204      	str	r2, [sp, #16]
 800d4ea:	000a      	movs	r2, r1
 800d4ec:	3243      	adds	r2, #67	; 0x43
 800d4ee:	9305      	str	r3, [sp, #20]
 800d4f0:	9003      	str	r0, [sp, #12]
 800d4f2:	9202      	str	r2, [sp, #8]
 800d4f4:	7e0a      	ldrb	r2, [r1, #24]
 800d4f6:	000c      	movs	r4, r1
 800d4f8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800d4fa:	2a6e      	cmp	r2, #110	; 0x6e
 800d4fc:	d100      	bne.n	800d500 <_printf_i+0x1c>
 800d4fe:	e086      	b.n	800d60e <_printf_i+0x12a>
 800d500:	d81f      	bhi.n	800d542 <_printf_i+0x5e>
 800d502:	2a63      	cmp	r2, #99	; 0x63
 800d504:	d033      	beq.n	800d56e <_printf_i+0x8a>
 800d506:	d808      	bhi.n	800d51a <_printf_i+0x36>
 800d508:	2a00      	cmp	r2, #0
 800d50a:	d100      	bne.n	800d50e <_printf_i+0x2a>
 800d50c:	e08c      	b.n	800d628 <_printf_i+0x144>
 800d50e:	2a58      	cmp	r2, #88	; 0x58
 800d510:	d04d      	beq.n	800d5ae <_printf_i+0xca>
 800d512:	0025      	movs	r5, r4
 800d514:	3542      	adds	r5, #66	; 0x42
 800d516:	702a      	strb	r2, [r5, #0]
 800d518:	e030      	b.n	800d57c <_printf_i+0x98>
 800d51a:	2a64      	cmp	r2, #100	; 0x64
 800d51c:	d001      	beq.n	800d522 <_printf_i+0x3e>
 800d51e:	2a69      	cmp	r2, #105	; 0x69
 800d520:	d1f7      	bne.n	800d512 <_printf_i+0x2e>
 800d522:	6819      	ldr	r1, [r3, #0]
 800d524:	6825      	ldr	r5, [r4, #0]
 800d526:	1d0a      	adds	r2, r1, #4
 800d528:	0628      	lsls	r0, r5, #24
 800d52a:	d529      	bpl.n	800d580 <_printf_i+0x9c>
 800d52c:	6808      	ldr	r0, [r1, #0]
 800d52e:	601a      	str	r2, [r3, #0]
 800d530:	2800      	cmp	r0, #0
 800d532:	da03      	bge.n	800d53c <_printf_i+0x58>
 800d534:	232d      	movs	r3, #45	; 0x2d
 800d536:	9a02      	ldr	r2, [sp, #8]
 800d538:	4240      	negs	r0, r0
 800d53a:	7013      	strb	r3, [r2, #0]
 800d53c:	4e6b      	ldr	r6, [pc, #428]	; (800d6ec <_printf_i+0x208>)
 800d53e:	270a      	movs	r7, #10
 800d540:	e04f      	b.n	800d5e2 <_printf_i+0xfe>
 800d542:	2a73      	cmp	r2, #115	; 0x73
 800d544:	d074      	beq.n	800d630 <_printf_i+0x14c>
 800d546:	d808      	bhi.n	800d55a <_printf_i+0x76>
 800d548:	2a6f      	cmp	r2, #111	; 0x6f
 800d54a:	d01f      	beq.n	800d58c <_printf_i+0xa8>
 800d54c:	2a70      	cmp	r2, #112	; 0x70
 800d54e:	d1e0      	bne.n	800d512 <_printf_i+0x2e>
 800d550:	2220      	movs	r2, #32
 800d552:	6809      	ldr	r1, [r1, #0]
 800d554:	430a      	orrs	r2, r1
 800d556:	6022      	str	r2, [r4, #0]
 800d558:	e003      	b.n	800d562 <_printf_i+0x7e>
 800d55a:	2a75      	cmp	r2, #117	; 0x75
 800d55c:	d016      	beq.n	800d58c <_printf_i+0xa8>
 800d55e:	2a78      	cmp	r2, #120	; 0x78
 800d560:	d1d7      	bne.n	800d512 <_printf_i+0x2e>
 800d562:	0022      	movs	r2, r4
 800d564:	2178      	movs	r1, #120	; 0x78
 800d566:	3245      	adds	r2, #69	; 0x45
 800d568:	7011      	strb	r1, [r2, #0]
 800d56a:	4e61      	ldr	r6, [pc, #388]	; (800d6f0 <_printf_i+0x20c>)
 800d56c:	e022      	b.n	800d5b4 <_printf_i+0xd0>
 800d56e:	0025      	movs	r5, r4
 800d570:	681a      	ldr	r2, [r3, #0]
 800d572:	3542      	adds	r5, #66	; 0x42
 800d574:	1d11      	adds	r1, r2, #4
 800d576:	6019      	str	r1, [r3, #0]
 800d578:	6813      	ldr	r3, [r2, #0]
 800d57a:	702b      	strb	r3, [r5, #0]
 800d57c:	2301      	movs	r3, #1
 800d57e:	e065      	b.n	800d64c <_printf_i+0x168>
 800d580:	6808      	ldr	r0, [r1, #0]
 800d582:	601a      	str	r2, [r3, #0]
 800d584:	0669      	lsls	r1, r5, #25
 800d586:	d5d3      	bpl.n	800d530 <_printf_i+0x4c>
 800d588:	b200      	sxth	r0, r0
 800d58a:	e7d1      	b.n	800d530 <_printf_i+0x4c>
 800d58c:	6819      	ldr	r1, [r3, #0]
 800d58e:	6825      	ldr	r5, [r4, #0]
 800d590:	1d08      	adds	r0, r1, #4
 800d592:	6018      	str	r0, [r3, #0]
 800d594:	6808      	ldr	r0, [r1, #0]
 800d596:	062e      	lsls	r6, r5, #24
 800d598:	d505      	bpl.n	800d5a6 <_printf_i+0xc2>
 800d59a:	4e54      	ldr	r6, [pc, #336]	; (800d6ec <_printf_i+0x208>)
 800d59c:	2708      	movs	r7, #8
 800d59e:	2a6f      	cmp	r2, #111	; 0x6f
 800d5a0:	d01b      	beq.n	800d5da <_printf_i+0xf6>
 800d5a2:	270a      	movs	r7, #10
 800d5a4:	e019      	b.n	800d5da <_printf_i+0xf6>
 800d5a6:	066d      	lsls	r5, r5, #25
 800d5a8:	d5f7      	bpl.n	800d59a <_printf_i+0xb6>
 800d5aa:	b280      	uxth	r0, r0
 800d5ac:	e7f5      	b.n	800d59a <_printf_i+0xb6>
 800d5ae:	3145      	adds	r1, #69	; 0x45
 800d5b0:	4e4e      	ldr	r6, [pc, #312]	; (800d6ec <_printf_i+0x208>)
 800d5b2:	700a      	strb	r2, [r1, #0]
 800d5b4:	6818      	ldr	r0, [r3, #0]
 800d5b6:	6822      	ldr	r2, [r4, #0]
 800d5b8:	1d01      	adds	r1, r0, #4
 800d5ba:	6800      	ldr	r0, [r0, #0]
 800d5bc:	6019      	str	r1, [r3, #0]
 800d5be:	0615      	lsls	r5, r2, #24
 800d5c0:	d521      	bpl.n	800d606 <_printf_i+0x122>
 800d5c2:	07d3      	lsls	r3, r2, #31
 800d5c4:	d502      	bpl.n	800d5cc <_printf_i+0xe8>
 800d5c6:	2320      	movs	r3, #32
 800d5c8:	431a      	orrs	r2, r3
 800d5ca:	6022      	str	r2, [r4, #0]
 800d5cc:	2710      	movs	r7, #16
 800d5ce:	2800      	cmp	r0, #0
 800d5d0:	d103      	bne.n	800d5da <_printf_i+0xf6>
 800d5d2:	2320      	movs	r3, #32
 800d5d4:	6822      	ldr	r2, [r4, #0]
 800d5d6:	439a      	bics	r2, r3
 800d5d8:	6022      	str	r2, [r4, #0]
 800d5da:	0023      	movs	r3, r4
 800d5dc:	2200      	movs	r2, #0
 800d5de:	3343      	adds	r3, #67	; 0x43
 800d5e0:	701a      	strb	r2, [r3, #0]
 800d5e2:	6863      	ldr	r3, [r4, #4]
 800d5e4:	60a3      	str	r3, [r4, #8]
 800d5e6:	2b00      	cmp	r3, #0
 800d5e8:	db58      	blt.n	800d69c <_printf_i+0x1b8>
 800d5ea:	2204      	movs	r2, #4
 800d5ec:	6821      	ldr	r1, [r4, #0]
 800d5ee:	4391      	bics	r1, r2
 800d5f0:	6021      	str	r1, [r4, #0]
 800d5f2:	2800      	cmp	r0, #0
 800d5f4:	d154      	bne.n	800d6a0 <_printf_i+0x1bc>
 800d5f6:	9d02      	ldr	r5, [sp, #8]
 800d5f8:	2b00      	cmp	r3, #0
 800d5fa:	d05a      	beq.n	800d6b2 <_printf_i+0x1ce>
 800d5fc:	0025      	movs	r5, r4
 800d5fe:	7833      	ldrb	r3, [r6, #0]
 800d600:	3542      	adds	r5, #66	; 0x42
 800d602:	702b      	strb	r3, [r5, #0]
 800d604:	e055      	b.n	800d6b2 <_printf_i+0x1ce>
 800d606:	0655      	lsls	r5, r2, #25
 800d608:	d5db      	bpl.n	800d5c2 <_printf_i+0xde>
 800d60a:	b280      	uxth	r0, r0
 800d60c:	e7d9      	b.n	800d5c2 <_printf_i+0xde>
 800d60e:	681a      	ldr	r2, [r3, #0]
 800d610:	680d      	ldr	r5, [r1, #0]
 800d612:	1d10      	adds	r0, r2, #4
 800d614:	6949      	ldr	r1, [r1, #20]
 800d616:	6018      	str	r0, [r3, #0]
 800d618:	6813      	ldr	r3, [r2, #0]
 800d61a:	062e      	lsls	r6, r5, #24
 800d61c:	d501      	bpl.n	800d622 <_printf_i+0x13e>
 800d61e:	6019      	str	r1, [r3, #0]
 800d620:	e002      	b.n	800d628 <_printf_i+0x144>
 800d622:	066d      	lsls	r5, r5, #25
 800d624:	d5fb      	bpl.n	800d61e <_printf_i+0x13a>
 800d626:	8019      	strh	r1, [r3, #0]
 800d628:	2300      	movs	r3, #0
 800d62a:	9d02      	ldr	r5, [sp, #8]
 800d62c:	6123      	str	r3, [r4, #16]
 800d62e:	e04f      	b.n	800d6d0 <_printf_i+0x1ec>
 800d630:	681a      	ldr	r2, [r3, #0]
 800d632:	1d11      	adds	r1, r2, #4
 800d634:	6019      	str	r1, [r3, #0]
 800d636:	6815      	ldr	r5, [r2, #0]
 800d638:	2100      	movs	r1, #0
 800d63a:	6862      	ldr	r2, [r4, #4]
 800d63c:	0028      	movs	r0, r5
 800d63e:	f000 f915 	bl	800d86c <memchr>
 800d642:	2800      	cmp	r0, #0
 800d644:	d001      	beq.n	800d64a <_printf_i+0x166>
 800d646:	1b40      	subs	r0, r0, r5
 800d648:	6060      	str	r0, [r4, #4]
 800d64a:	6863      	ldr	r3, [r4, #4]
 800d64c:	6123      	str	r3, [r4, #16]
 800d64e:	2300      	movs	r3, #0
 800d650:	9a02      	ldr	r2, [sp, #8]
 800d652:	7013      	strb	r3, [r2, #0]
 800d654:	e03c      	b.n	800d6d0 <_printf_i+0x1ec>
 800d656:	6923      	ldr	r3, [r4, #16]
 800d658:	002a      	movs	r2, r5
 800d65a:	9904      	ldr	r1, [sp, #16]
 800d65c:	9803      	ldr	r0, [sp, #12]
 800d65e:	9d05      	ldr	r5, [sp, #20]
 800d660:	47a8      	blx	r5
 800d662:	1c43      	adds	r3, r0, #1
 800d664:	d03e      	beq.n	800d6e4 <_printf_i+0x200>
 800d666:	6823      	ldr	r3, [r4, #0]
 800d668:	079b      	lsls	r3, r3, #30
 800d66a:	d415      	bmi.n	800d698 <_printf_i+0x1b4>
 800d66c:	9b07      	ldr	r3, [sp, #28]
 800d66e:	68e0      	ldr	r0, [r4, #12]
 800d670:	4298      	cmp	r0, r3
 800d672:	da39      	bge.n	800d6e8 <_printf_i+0x204>
 800d674:	0018      	movs	r0, r3
 800d676:	e037      	b.n	800d6e8 <_printf_i+0x204>
 800d678:	0022      	movs	r2, r4
 800d67a:	2301      	movs	r3, #1
 800d67c:	3219      	adds	r2, #25
 800d67e:	9904      	ldr	r1, [sp, #16]
 800d680:	9803      	ldr	r0, [sp, #12]
 800d682:	9e05      	ldr	r6, [sp, #20]
 800d684:	47b0      	blx	r6
 800d686:	1c43      	adds	r3, r0, #1
 800d688:	d02c      	beq.n	800d6e4 <_printf_i+0x200>
 800d68a:	3501      	adds	r5, #1
 800d68c:	68e3      	ldr	r3, [r4, #12]
 800d68e:	9a07      	ldr	r2, [sp, #28]
 800d690:	1a9b      	subs	r3, r3, r2
 800d692:	42ab      	cmp	r3, r5
 800d694:	dcf0      	bgt.n	800d678 <_printf_i+0x194>
 800d696:	e7e9      	b.n	800d66c <_printf_i+0x188>
 800d698:	2500      	movs	r5, #0
 800d69a:	e7f7      	b.n	800d68c <_printf_i+0x1a8>
 800d69c:	2800      	cmp	r0, #0
 800d69e:	d0ad      	beq.n	800d5fc <_printf_i+0x118>
 800d6a0:	9d02      	ldr	r5, [sp, #8]
 800d6a2:	0039      	movs	r1, r7
 800d6a4:	f7f2 fdb6 	bl	8000214 <__aeabi_uidivmod>
 800d6a8:	5c73      	ldrb	r3, [r6, r1]
 800d6aa:	3d01      	subs	r5, #1
 800d6ac:	702b      	strb	r3, [r5, #0]
 800d6ae:	2800      	cmp	r0, #0
 800d6b0:	d1f7      	bne.n	800d6a2 <_printf_i+0x1be>
 800d6b2:	2f08      	cmp	r7, #8
 800d6b4:	d109      	bne.n	800d6ca <_printf_i+0x1e6>
 800d6b6:	6823      	ldr	r3, [r4, #0]
 800d6b8:	07db      	lsls	r3, r3, #31
 800d6ba:	d506      	bpl.n	800d6ca <_printf_i+0x1e6>
 800d6bc:	6863      	ldr	r3, [r4, #4]
 800d6be:	6922      	ldr	r2, [r4, #16]
 800d6c0:	4293      	cmp	r3, r2
 800d6c2:	dc02      	bgt.n	800d6ca <_printf_i+0x1e6>
 800d6c4:	2330      	movs	r3, #48	; 0x30
 800d6c6:	3d01      	subs	r5, #1
 800d6c8:	702b      	strb	r3, [r5, #0]
 800d6ca:	9b02      	ldr	r3, [sp, #8]
 800d6cc:	1b5b      	subs	r3, r3, r5
 800d6ce:	6123      	str	r3, [r4, #16]
 800d6d0:	9b05      	ldr	r3, [sp, #20]
 800d6d2:	aa07      	add	r2, sp, #28
 800d6d4:	9300      	str	r3, [sp, #0]
 800d6d6:	0021      	movs	r1, r4
 800d6d8:	9b04      	ldr	r3, [sp, #16]
 800d6da:	9803      	ldr	r0, [sp, #12]
 800d6dc:	f7ff fe94 	bl	800d408 <_printf_common>
 800d6e0:	1c43      	adds	r3, r0, #1
 800d6e2:	d1b8      	bne.n	800d656 <_printf_i+0x172>
 800d6e4:	2001      	movs	r0, #1
 800d6e6:	4240      	negs	r0, r0
 800d6e8:	b009      	add	sp, #36	; 0x24
 800d6ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d6ec:	0800e745 	.word	0x0800e745
 800d6f0:	0800e756 	.word	0x0800e756

0800d6f4 <_sbrk_r>:
 800d6f4:	2300      	movs	r3, #0
 800d6f6:	b570      	push	{r4, r5, r6, lr}
 800d6f8:	4c06      	ldr	r4, [pc, #24]	; (800d714 <_sbrk_r+0x20>)
 800d6fa:	0005      	movs	r5, r0
 800d6fc:	0008      	movs	r0, r1
 800d6fe:	6023      	str	r3, [r4, #0]
 800d700:	f7fd f83c 	bl	800a77c <_sbrk>
 800d704:	1c43      	adds	r3, r0, #1
 800d706:	d103      	bne.n	800d710 <_sbrk_r+0x1c>
 800d708:	6823      	ldr	r3, [r4, #0]
 800d70a:	2b00      	cmp	r3, #0
 800d70c:	d000      	beq.n	800d710 <_sbrk_r+0x1c>
 800d70e:	602b      	str	r3, [r5, #0]
 800d710:	bd70      	pop	{r4, r5, r6, pc}
 800d712:	46c0      	nop			; (mov r8, r8)
 800d714:	200005bc 	.word	0x200005bc

0800d718 <__sread>:
 800d718:	b570      	push	{r4, r5, r6, lr}
 800d71a:	000c      	movs	r4, r1
 800d71c:	250e      	movs	r5, #14
 800d71e:	5f49      	ldrsh	r1, [r1, r5]
 800d720:	f000 f8b2 	bl	800d888 <_read_r>
 800d724:	2800      	cmp	r0, #0
 800d726:	db03      	blt.n	800d730 <__sread+0x18>
 800d728:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800d72a:	181b      	adds	r3, r3, r0
 800d72c:	6563      	str	r3, [r4, #84]	; 0x54
 800d72e:	bd70      	pop	{r4, r5, r6, pc}
 800d730:	89a3      	ldrh	r3, [r4, #12]
 800d732:	4a02      	ldr	r2, [pc, #8]	; (800d73c <__sread+0x24>)
 800d734:	4013      	ands	r3, r2
 800d736:	81a3      	strh	r3, [r4, #12]
 800d738:	e7f9      	b.n	800d72e <__sread+0x16>
 800d73a:	46c0      	nop			; (mov r8, r8)
 800d73c:	ffffefff 	.word	0xffffefff

0800d740 <__swrite>:
 800d740:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d742:	001f      	movs	r7, r3
 800d744:	898b      	ldrh	r3, [r1, #12]
 800d746:	0005      	movs	r5, r0
 800d748:	000c      	movs	r4, r1
 800d74a:	0016      	movs	r6, r2
 800d74c:	05db      	lsls	r3, r3, #23
 800d74e:	d505      	bpl.n	800d75c <__swrite+0x1c>
 800d750:	230e      	movs	r3, #14
 800d752:	5ec9      	ldrsh	r1, [r1, r3]
 800d754:	2200      	movs	r2, #0
 800d756:	2302      	movs	r3, #2
 800d758:	f000 f874 	bl	800d844 <_lseek_r>
 800d75c:	89a3      	ldrh	r3, [r4, #12]
 800d75e:	4a05      	ldr	r2, [pc, #20]	; (800d774 <__swrite+0x34>)
 800d760:	0028      	movs	r0, r5
 800d762:	4013      	ands	r3, r2
 800d764:	81a3      	strh	r3, [r4, #12]
 800d766:	0032      	movs	r2, r6
 800d768:	230e      	movs	r3, #14
 800d76a:	5ee1      	ldrsh	r1, [r4, r3]
 800d76c:	003b      	movs	r3, r7
 800d76e:	f000 f81f 	bl	800d7b0 <_write_r>
 800d772:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800d774:	ffffefff 	.word	0xffffefff

0800d778 <__sseek>:
 800d778:	b570      	push	{r4, r5, r6, lr}
 800d77a:	000c      	movs	r4, r1
 800d77c:	250e      	movs	r5, #14
 800d77e:	5f49      	ldrsh	r1, [r1, r5]
 800d780:	f000 f860 	bl	800d844 <_lseek_r>
 800d784:	89a3      	ldrh	r3, [r4, #12]
 800d786:	1c42      	adds	r2, r0, #1
 800d788:	d103      	bne.n	800d792 <__sseek+0x1a>
 800d78a:	4a05      	ldr	r2, [pc, #20]	; (800d7a0 <__sseek+0x28>)
 800d78c:	4013      	ands	r3, r2
 800d78e:	81a3      	strh	r3, [r4, #12]
 800d790:	bd70      	pop	{r4, r5, r6, pc}
 800d792:	2280      	movs	r2, #128	; 0x80
 800d794:	0152      	lsls	r2, r2, #5
 800d796:	4313      	orrs	r3, r2
 800d798:	81a3      	strh	r3, [r4, #12]
 800d79a:	6560      	str	r0, [r4, #84]	; 0x54
 800d79c:	e7f8      	b.n	800d790 <__sseek+0x18>
 800d79e:	46c0      	nop			; (mov r8, r8)
 800d7a0:	ffffefff 	.word	0xffffefff

0800d7a4 <__sclose>:
 800d7a4:	b510      	push	{r4, lr}
 800d7a6:	230e      	movs	r3, #14
 800d7a8:	5ec9      	ldrsh	r1, [r1, r3]
 800d7aa:	f000 f815 	bl	800d7d8 <_close_r>
 800d7ae:	bd10      	pop	{r4, pc}

0800d7b0 <_write_r>:
 800d7b0:	b570      	push	{r4, r5, r6, lr}
 800d7b2:	0005      	movs	r5, r0
 800d7b4:	0008      	movs	r0, r1
 800d7b6:	0011      	movs	r1, r2
 800d7b8:	2200      	movs	r2, #0
 800d7ba:	4c06      	ldr	r4, [pc, #24]	; (800d7d4 <_write_r+0x24>)
 800d7bc:	6022      	str	r2, [r4, #0]
 800d7be:	001a      	movs	r2, r3
 800d7c0:	f7fc ff93 	bl	800a6ea <_write>
 800d7c4:	1c43      	adds	r3, r0, #1
 800d7c6:	d103      	bne.n	800d7d0 <_write_r+0x20>
 800d7c8:	6823      	ldr	r3, [r4, #0]
 800d7ca:	2b00      	cmp	r3, #0
 800d7cc:	d000      	beq.n	800d7d0 <_write_r+0x20>
 800d7ce:	602b      	str	r3, [r5, #0]
 800d7d0:	bd70      	pop	{r4, r5, r6, pc}
 800d7d2:	46c0      	nop			; (mov r8, r8)
 800d7d4:	200005bc 	.word	0x200005bc

0800d7d8 <_close_r>:
 800d7d8:	2300      	movs	r3, #0
 800d7da:	b570      	push	{r4, r5, r6, lr}
 800d7dc:	4c06      	ldr	r4, [pc, #24]	; (800d7f8 <_close_r+0x20>)
 800d7de:	0005      	movs	r5, r0
 800d7e0:	0008      	movs	r0, r1
 800d7e2:	6023      	str	r3, [r4, #0]
 800d7e4:	f7fc ff9d 	bl	800a722 <_close>
 800d7e8:	1c43      	adds	r3, r0, #1
 800d7ea:	d103      	bne.n	800d7f4 <_close_r+0x1c>
 800d7ec:	6823      	ldr	r3, [r4, #0]
 800d7ee:	2b00      	cmp	r3, #0
 800d7f0:	d000      	beq.n	800d7f4 <_close_r+0x1c>
 800d7f2:	602b      	str	r3, [r5, #0]
 800d7f4:	bd70      	pop	{r4, r5, r6, pc}
 800d7f6:	46c0      	nop			; (mov r8, r8)
 800d7f8:	200005bc 	.word	0x200005bc

0800d7fc <_fstat_r>:
 800d7fc:	2300      	movs	r3, #0
 800d7fe:	b570      	push	{r4, r5, r6, lr}
 800d800:	4c06      	ldr	r4, [pc, #24]	; (800d81c <_fstat_r+0x20>)
 800d802:	0005      	movs	r5, r0
 800d804:	0008      	movs	r0, r1
 800d806:	0011      	movs	r1, r2
 800d808:	6023      	str	r3, [r4, #0]
 800d80a:	f7fc ff94 	bl	800a736 <_fstat>
 800d80e:	1c43      	adds	r3, r0, #1
 800d810:	d103      	bne.n	800d81a <_fstat_r+0x1e>
 800d812:	6823      	ldr	r3, [r4, #0]
 800d814:	2b00      	cmp	r3, #0
 800d816:	d000      	beq.n	800d81a <_fstat_r+0x1e>
 800d818:	602b      	str	r3, [r5, #0]
 800d81a:	bd70      	pop	{r4, r5, r6, pc}
 800d81c:	200005bc 	.word	0x200005bc

0800d820 <_isatty_r>:
 800d820:	2300      	movs	r3, #0
 800d822:	b570      	push	{r4, r5, r6, lr}
 800d824:	4c06      	ldr	r4, [pc, #24]	; (800d840 <_isatty_r+0x20>)
 800d826:	0005      	movs	r5, r0
 800d828:	0008      	movs	r0, r1
 800d82a:	6023      	str	r3, [r4, #0]
 800d82c:	f7fc ff91 	bl	800a752 <_isatty>
 800d830:	1c43      	adds	r3, r0, #1
 800d832:	d103      	bne.n	800d83c <_isatty_r+0x1c>
 800d834:	6823      	ldr	r3, [r4, #0]
 800d836:	2b00      	cmp	r3, #0
 800d838:	d000      	beq.n	800d83c <_isatty_r+0x1c>
 800d83a:	602b      	str	r3, [r5, #0]
 800d83c:	bd70      	pop	{r4, r5, r6, pc}
 800d83e:	46c0      	nop			; (mov r8, r8)
 800d840:	200005bc 	.word	0x200005bc

0800d844 <_lseek_r>:
 800d844:	b570      	push	{r4, r5, r6, lr}
 800d846:	0005      	movs	r5, r0
 800d848:	0008      	movs	r0, r1
 800d84a:	0011      	movs	r1, r2
 800d84c:	2200      	movs	r2, #0
 800d84e:	4c06      	ldr	r4, [pc, #24]	; (800d868 <_lseek_r+0x24>)
 800d850:	6022      	str	r2, [r4, #0]
 800d852:	001a      	movs	r2, r3
 800d854:	f7fc ff86 	bl	800a764 <_lseek>
 800d858:	1c43      	adds	r3, r0, #1
 800d85a:	d103      	bne.n	800d864 <_lseek_r+0x20>
 800d85c:	6823      	ldr	r3, [r4, #0]
 800d85e:	2b00      	cmp	r3, #0
 800d860:	d000      	beq.n	800d864 <_lseek_r+0x20>
 800d862:	602b      	str	r3, [r5, #0]
 800d864:	bd70      	pop	{r4, r5, r6, pc}
 800d866:	46c0      	nop			; (mov r8, r8)
 800d868:	200005bc 	.word	0x200005bc

0800d86c <memchr>:
 800d86c:	b2c9      	uxtb	r1, r1
 800d86e:	1882      	adds	r2, r0, r2
 800d870:	4290      	cmp	r0, r2
 800d872:	d101      	bne.n	800d878 <memchr+0xc>
 800d874:	2000      	movs	r0, #0
 800d876:	4770      	bx	lr
 800d878:	7803      	ldrb	r3, [r0, #0]
 800d87a:	428b      	cmp	r3, r1
 800d87c:	d0fb      	beq.n	800d876 <memchr+0xa>
 800d87e:	3001      	adds	r0, #1
 800d880:	e7f6      	b.n	800d870 <memchr+0x4>

0800d882 <__malloc_lock>:
 800d882:	4770      	bx	lr

0800d884 <__malloc_unlock>:
 800d884:	4770      	bx	lr
	...

0800d888 <_read_r>:
 800d888:	b570      	push	{r4, r5, r6, lr}
 800d88a:	0005      	movs	r5, r0
 800d88c:	0008      	movs	r0, r1
 800d88e:	0011      	movs	r1, r2
 800d890:	2200      	movs	r2, #0
 800d892:	4c06      	ldr	r4, [pc, #24]	; (800d8ac <_read_r+0x24>)
 800d894:	6022      	str	r2, [r4, #0]
 800d896:	001a      	movs	r2, r3
 800d898:	f7fc ff0a 	bl	800a6b0 <_read>
 800d89c:	1c43      	adds	r3, r0, #1
 800d89e:	d103      	bne.n	800d8a8 <_read_r+0x20>
 800d8a0:	6823      	ldr	r3, [r4, #0]
 800d8a2:	2b00      	cmp	r3, #0
 800d8a4:	d000      	beq.n	800d8a8 <_read_r+0x20>
 800d8a6:	602b      	str	r3, [r5, #0]
 800d8a8:	bd70      	pop	{r4, r5, r6, pc}
 800d8aa:	46c0      	nop			; (mov r8, r8)
 800d8ac:	200005bc 	.word	0x200005bc

0800d8b0 <_init>:
 800d8b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d8b2:	46c0      	nop			; (mov r8, r8)
 800d8b4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800d8b6:	bc08      	pop	{r3}
 800d8b8:	469e      	mov	lr, r3
 800d8ba:	4770      	bx	lr

0800d8bc <_fini>:
 800d8bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d8be:	46c0      	nop			; (mov r8, r8)
 800d8c0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800d8c2:	bc08      	pop	{r3}
 800d8c4:	469e      	mov	lr, r3
 800d8c6:	4770      	bx	lr
